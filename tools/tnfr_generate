#!/usr/bin/env python3
"""CLI tool for TNFR sequence generation.

This command-line tool provides access to the context-guided sequence
generator, allowing users to generate, validate, and improve TNFR operator
sequences from the terminal.

Usage Examples
--------------
# Generate for specific domain and objective
$ tnfr-generate --domain therapeutic --objective crisis_intervention --min-health 0.8

# Generate for a specific pattern
$ tnfr-generate --pattern BOOTSTRAP --max-length 4

# Improve an existing sequence
$ tnfr-generate --improve "emission,coherence,silence" --target-health 0.8

# List available domains and objectives
$ tnfr-generate --list-domains
$ tnfr-generate --list-objectives therapeutic
"""

from __future__ import annotations

import argparse
import sys
from typing import TYPE_CHECKING, NoReturn

if TYPE_CHECKING:
    from tnfr.tools.sequence_generator import GenerationResult


def main() -> int | NoReturn:
    """Main entry point for tnfr-generate CLI tool."""
    parser = argparse.ArgumentParser(
        description="TNFR Context-Guided Sequence Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate for therapeutic crisis intervention
  %(prog)s --domain therapeutic --objective crisis_intervention

  # Generate for BOOTSTRAP pattern with constraints
  %(prog)s --pattern BOOTSTRAP --max-length 5 --min-health 0.70

  # Improve existing sequence
  %(prog)s --improve "emission,coherence,silence" --target-health 0.80

  # List available domains
  %(prog)s --list-domains

  # List objectives for a domain
  %(prog)s --list-objectives therapeutic
        """,
    )

    # Listing options
    list_group = parser.add_argument_group("listing options")
    list_group.add_argument(
        "--list-domains",
        action="store_true",
        help="List all available application domains",
    )
    list_group.add_argument(
        "--list-objectives",
        metavar="DOMAIN",
        help="List all objectives for a specific domain",
    )

    # Generation mode selection
    mode_group = parser.add_argument_group("generation modes")
    mode_group.add_argument(
        "--domain",
        metavar="DOMAIN",
        help="Application domain (therapeutic, educational, organizational, creative)",
    )
    mode_group.add_argument(
        "--objective",
        metavar="OBJECTIVE",
        help="Specific objective within domain",
    )
    mode_group.add_argument(
        "--pattern",
        metavar="PATTERN",
        help="Target structural pattern (BOOTSTRAP, THERAPEUTIC, STABILIZE, etc.)",
    )
    mode_group.add_argument(
        "--improve",
        metavar="SEQUENCE",
        help="Comma-separated sequence to improve (e.g., 'emission,coherence,silence')",
    )

    # Constraints
    constraint_group = parser.add_argument_group("constraints")
    constraint_group.add_argument(
        "--max-length",
        type=int,
        default=10,
        metavar="N",
        help="Maximum sequence length (default: 10)",
    )
    constraint_group.add_argument(
        "--min-health",
        type=float,
        default=0.70,
        metavar="SCORE",
        help="Minimum required health score 0.0-1.0 (default: 0.70)",
    )
    constraint_group.add_argument(
        "--target-health",
        type=float,
        metavar="SCORE",
        help="Target health for improvement (default: current + 0.15)",
    )

    # Output options
    output_group = parser.add_argument_group("output options")
    output_group.add_argument(
        "--format",
        choices=["compact", "detailed", "json"],
        default="compact",
        help="Output format (default: compact)",
    )
    output_group.add_argument(
        "--seed",
        type=int,
        metavar="N",
        help="Random seed for deterministic generation",
    )
    output_group.add_argument(
        "--quiet",
        action="store_true",
        help="Only output the sequence, no metadata",
    )

    args = parser.parse_args()

    # Import here to avoid loading if just showing help
    from tnfr.tools.domain_templates import list_domains, list_objectives
    from tnfr.tools.sequence_generator import ContextualSequenceGenerator

    # Handle listing options
    if args.list_domains:
        domains = list_domains()
        print("Available domains:")
        for domain in domains:
            print(f"  - {domain}")
        return 0

    if args.list_objectives:
        try:
            objectives = list_objectives(args.list_objectives)
            print(f"Objectives for '{args.list_objectives}':")
            for objective in objectives:
                print(f"  - {objective}")
            return 0
        except KeyError as e:
            print(f"Error: {e}", file=sys.stderr)
            return 1

    # Validate generation mode
    if not any([args.domain, args.pattern, args.improve]):
        parser.error(
            "Must specify one of: --domain, --pattern, or --improve\n"
            "Use --help for usage information"
        )

    # Initialize generator
    generator = ContextualSequenceGenerator(seed=args.seed)

    try:
        # Generate based on mode
        if args.domain:
            result = generator.generate_for_context(
                domain=args.domain,
                objective=args.objective,
                max_length=args.max_length,
                min_health=args.min_health,
            )
            _print_result(result, args)

        elif args.pattern:
            result = generator.generate_for_pattern(
                target_pattern=args.pattern,
                max_length=args.max_length,
                min_health=args.min_health,
            )
            _print_result(result, args)

        elif args.improve:
            current = _parse_sequence(args.improve)
            improved, recommendations = generator.improve_sequence(
                current,
                target_health=args.target_health,
                max_length=args.max_length,
            )
            _print_improvement(current, improved, recommendations, args)

        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def _parse_sequence(sequence_str: str) -> list[str]:
    """Parse comma-separated sequence string."""
    return [op.strip() for op in sequence_str.split(",")]


def _print_result(result: GenerationResult, args: argparse.Namespace) -> None:  # type: ignore[name-defined]
    """Print generation result based on format option."""
    if args.quiet:
        print(",".join(result.sequence))
        return

    if args.format == "json":
        import json

        output = {
            "sequence": result.sequence,
            "health_score": result.health_score,
            "detected_pattern": result.detected_pattern,
            "domain": result.domain,
            "objective": result.objective,
            "method": result.method,
            "recommendations": result.recommendations,
            "metadata": result.metadata,
        }
        print(json.dumps(output, indent=2))

    elif args.format == "detailed":
        print("=" * 70)
        print("GENERATED SEQUENCE")
        print("=" * 70)
        print(f"Sequence: {' → '.join(result.sequence)}")
        print(f"Health Score: {result.health_score:.2f}")
        print(f"Detected Pattern: {result.detected_pattern}")
        if result.domain:
            print(f"Domain: {result.domain}")
        if result.objective:
            print(f"Objective: {result.objective}")
        print(f"Method: {result.method}")

        if result.recommendations:
            print("\nRecommendations:")
            for i, rec in enumerate(result.recommendations, 1):
                print(f"  {i}. {rec}")

        if result.metadata:
            print("\nMetadata:")
            for key, value in result.metadata.items():
                print(f"  {key}: {value}")

    else:  # compact
        print(f"Sequence: {','.join(result.sequence)}")
        print(f"Health: {result.health_score:.2f}, Pattern: {result.detected_pattern}")
        if result.recommendations:
            print(f"Recommendations: {len(result.recommendations)} suggestion(s)")


def _print_improvement(
    current: list[str],
    improved: list[str],
    recommendations: list[str],
    args: argparse.Namespace,
) -> None:
    """Print improvement result."""
    if args.quiet:
        print(",".join(improved))
        return

    from tnfr.operators.health_analyzer import SequenceHealthAnalyzer

    analyzer = SequenceHealthAnalyzer()
    current_health = analyzer.analyze_health(current)
    improved_health = analyzer.analyze_health(improved)

    if args.format == "json":
        import json

        output = {
            "original": {
                "sequence": current,
                "health_score": current_health.overall_health,
            },
            "improved": {
                "sequence": improved,
                "health_score": improved_health.overall_health,
            },
            "recommendations": recommendations,
        }
        print(json.dumps(output, indent=2))

    elif args.format == "detailed":
        print("=" * 70)
        print("SEQUENCE IMPROVEMENT")
        print("=" * 70)
        print(f"Original:  {' → '.join(current)}")
        print(f"  Health: {current_health.overall_health:.2f}")
        print(f"\nImproved:  {' → '.join(improved)}")
        print(f"  Health: {improved_health.overall_health:.2f}")
        delta = improved_health.overall_health - current_health.overall_health
        print(f"  Delta: {delta:+.2f}")

        if recommendations:
            print("\nImprovements:")
            for i, rec in enumerate(recommendations, 1):
                print(f"  {i}. {rec}")

    else:  # compact
        print(f"Original:  {','.join(current)} (health: {current_health.overall_health:.2f})")
        print(f"Improved:  {','.join(improved)} (health: {improved_health.overall_health:.2f})")
        delta = improved_health.overall_health - current_health.overall_health
        print(f"Improvement: {delta:+.2f}")


if __name__ == "__main__":
    sys.exit(main())
