"""Mathematical spaces supporting TNFR structural reasoning."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Sequence

import numpy as np


@dataclass(frozen=True)
class HilbertSpace:
    """Canonical Hilbert space for TNFR spectral vectors.

    In the TNFR engine a Hilbert space represents the linearized view of an
    EPI's vibrational substrate.  Vectors correspond to resonant spectral
    samples expressed on the canonical orthonormal basis (identity matrix).
    The space therefore provides sesquilinear inner products and projections
    that respect TNFR's emphasis on phase-preserving coherence.
    """

    dimension: int
    dtype: np.dtype = np.complex128

    def __post_init__(self) -> None:
        if self.dimension <= 0:
            raise ValueError("Hilbert spaces require a positive dimension.")

    @property
    def basis(self) -> np.ndarray:
        """Return the canonical orthonormal basis as identity vectors."""

        return np.eye(self.dimension, dtype=self.dtype)

    def _as_vector(self, value: Sequence[complex] | np.ndarray) -> np.ndarray:
        vector = np.asarray(value, dtype=self.dtype)
        if vector.shape != (self.dimension,):
            raise ValueError(
                f"Vector must have shape ({self.dimension},), got {vector.shape!r}."
            )
        return vector

    def inner_product(
        self, vector_a: Sequence[complex] | np.ndarray, vector_b: Sequence[complex] | np.ndarray
    ) -> complex:
        """Compute the sesquilinear inner product ``⟨a, b⟩``.

        NumPy's :func:`numpy.vdot` is used to ensure conjugate linearity in the
        first argument which matches the TNFR requirement of preserving phase
        parity during coherence calculations.
        """

        vec_a = self._as_vector(vector_a)
        vec_b = self._as_vector(vector_b)
        return np.vdot(vec_a, vec_b)

    def norm(self, vector: Sequence[complex] | np.ndarray) -> float:
        """Return the Hilbert norm induced by the inner product."""

        value = self.inner_product(vector, vector)
        magnitude = max(value.real, 0.0)
        return float(np.sqrt(magnitude))

    def is_normalized(
        self, vector: Sequence[complex] | np.ndarray, *, atol: float = 1e-9
    ) -> bool:
        """Check whether a vector has unit norm within a tolerance."""

        return np.isclose(self.norm(vector), 1.0, atol=atol)

    def project(
        self,
        vector: Sequence[complex] | np.ndarray,
        onto: Sequence[complex] | np.ndarray | int,
    ) -> np.ndarray:
        """Project ``vector`` onto the subspace generated by ``onto``.

        The ``onto`` argument may be either a vector in the same space or the
        index of a canonical basis vector.  The result encodes the coherent
        component that remains phase-aligned with the chosen direction.
        """

        vec = self._as_vector(vector)
        if isinstance(onto, int):
            if not 0 <= onto < self.dimension:
                raise IndexError("Basis index out of range.")
            basis_vec = self.basis[onto]
        else:
            basis_vec = self._as_vector(onto)

        denominator = self.inner_product(basis_vec, basis_vec)
        if np.isclose(denominator, 0.0):
            raise ValueError("Cannot project onto a null vector.")
        coefficient = self.inner_product(vec, basis_vec) / denominator
        return coefficient * basis_vec


class BanachSpaceEPI:
    """Banach space describing TNFR EPIs on discretized domains.

    The domain grid tracks the structural coordinates where an EPI is sampled,
    while the weighting factors modulate the contribution of amplitude and
    derivative terms to the coherence functional.  The resulting norm reflects
    how stable the EPI is against TNFR operator perturbations.
    """

    def __init__(
        self,
        domain: Iterable[float],
        *,
        amplitude_weight: float = 1.0,
        derivative_weight: float = 1.0,
    ) -> None:
        self.domain = np.asarray(tuple(domain), dtype=float)
        self.amplitude_weight = float(amplitude_weight)
        self.derivative_weight = float(derivative_weight)
        if self.amplitude_weight < 0 or self.derivative_weight < 0:
            raise ValueError("Weighting factors must be non-negative.")
        self.validate_domain()

    def validate_domain(self) -> None:
        """Validate the domain grid used to sample EPIs.

        The grid must be strictly increasing and contain at least two points so
        that derivative-based coherence metrics are meaningful.
        """

        if self.domain.ndim != 1:
            raise ValueError("Domain grid must be one-dimensional.")
        if self.domain.size < 2:
            raise ValueError("Domain grid must contain at least two points.")
        differences = np.diff(self.domain)
        if np.any(differences <= 0):
            raise ValueError("Domain grid must be strictly increasing.")

    def compute_coherence_functional(self, epi_field: Sequence[complex] | np.ndarray) -> np.ndarray:
        """Compute the coherence functional over the EPI samples.

        The functional combines amplitude and first-order derivative terms to
        capture both the stability of the form (amplitude) and its structural
        frequency (derivative) in TNFR terminology.
        """

        epi = np.asarray(epi_field, dtype=np.complex128)
        if epi.shape != (self.domain.size,):
            raise ValueError(
                "EPI samples must match the domain grid length."
            )
        amplitude_term = self.amplitude_weight * np.abs(epi) ** 2
        edge_order = 2 if self.domain.size > 2 else 1
        derivative = np.gradient(epi, self.domain, edge_order=edge_order)
        derivative_term = self.derivative_weight * np.abs(derivative) ** 2
        return amplitude_term + derivative_term

    def coherence_norm(self, epi_field: Sequence[complex] | np.ndarray) -> float:
        """Return the L²-like norm induced by the coherence functional."""

        functional_values = self.compute_coherence_functional(epi_field)
        integral = np.trapz(functional_values, self.domain)
        if integral < 0:
            raise ValueError("Coherence integral must be non-negative.")
        return float(np.sqrt(integral))
