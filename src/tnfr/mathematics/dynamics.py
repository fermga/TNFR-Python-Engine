"""Spectral dynamics helpers driven by Hermitian ΔNFR generators."""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Sequence

import numpy as np

from .spaces import HilbertSpace

try:  # pragma: no cover - optional SciPy dependency
    from scipy.linalg import expm as _scipy_expm  # type: ignore
except Exception:  # pragma: no cover - SciPy not installed
    _scipy_expm = None

__all__ = ["MathematicalDynamicsEngine"]


def _as_matrix(matrix: Sequence[Sequence[complex]] | np.ndarray) -> np.ndarray:
    arr = np.asarray(matrix, dtype=np.complex128)
    if arr.ndim != 2 or arr.shape[0] != arr.shape[1]:
        raise ValueError("Generator matrix must be square.")
    return arr


def _is_hermitian(matrix: np.ndarray, *, atol: float = 1e-9) -> bool:
    return bool(np.allclose(matrix, matrix.conj().T, atol=atol))


@dataclass(slots=True)
class MathematicalDynamicsEngine:
    """Unitary evolution generated by Hermitian ΔNFR operators."""

    generator: np.ndarray
    hilbert_space: HilbertSpace
    atol: float = 1e-9
    _use_scipy: bool = False
    _eigenvalues: np.ndarray = field(init=False, repr=False)
    _eigenvectors: np.ndarray = field(init=False, repr=False)

    def __init__(
        self,
        generator: Sequence[Sequence[complex]] | np.ndarray,
        hilbert_space: HilbertSpace,
        *,
        atol: float = 1e-9,
        use_scipy: bool | None = None,
    ) -> None:
        matrix = _as_matrix(generator)
        if matrix.shape != (hilbert_space.dimension, hilbert_space.dimension):
            raise ValueError("Generator dimension must match the Hilbert space.")
        if not _is_hermitian(matrix, atol=atol):
            raise ValueError("Dynamics generator must be Hermitian.")
        self.generator = matrix
        self.hilbert_space = hilbert_space
        self.atol = float(atol)
        if use_scipy is None:
            self._use_scipy = bool(_scipy_expm is not None)
        else:
            if use_scipy and _scipy_expm is None:
                raise RuntimeError("SciPy expm requested but SciPy is not available.")
            self._use_scipy = bool(use_scipy and _scipy_expm is not None)
        self._eigenvalues, self._eigenvectors = np.linalg.eigh(self.generator)

    def _unitary(self, dt: float) -> np.ndarray:
        if self._use_scipy and _scipy_expm is not None:
            return _scipy_expm(-1j * dt * self.generator)
        phases = np.exp(-1j * dt * self._eigenvalues)
        return (self._eigenvectors * phases) @ self._eigenvectors.conj().T

    def step(
        self,
        state: Sequence[complex] | np.ndarray,
        *,
        dt: float = 1.0,
        normalize: bool = True,
    ) -> np.ndarray:
        """Evolve ``state`` by ``dt`` using the unitary ``exp(-i·Δ·dt)``."""

        vector = np.asarray(state, dtype=np.complex128)
        if vector.shape != (self.hilbert_space.dimension,):
            raise ValueError(
                "State dimension mismatch: "
                f"expected ({self.hilbert_space.dimension},), received {vector.shape!r}."
            )
        unitary = self._unitary(dt)
        evolved = unitary @ vector
        if normalize:
            norm = self.hilbert_space.norm(evolved)
            if np.isclose(norm, 0.0, atol=self.atol):
                raise ValueError("Cannot normalise a null state vector.")
            evolved = evolved / norm
        return evolved

    def evolve(
        self,
        state: Sequence[complex] | np.ndarray,
        *,
        steps: int,
        dt: float = 1.0,
        normalize: bool = True,
    ) -> np.ndarray:
        """Return trajectory of length ``steps + 1`` starting from ``state``."""

        if steps < 0:
            raise ValueError("steps must be non-negative.")
        current = np.asarray(state, dtype=np.complex128)
        if current.shape != (self.hilbert_space.dimension,):
            raise ValueError(
                "State dimension mismatch: "
                f"expected ({self.hilbert_space.dimension},), received {current.shape!r}."
            )
        trajectory = [current.copy()]
        for _ in range(steps):
            current = self.step(current, dt=dt, normalize=normalize)
            trajectory.append(current)
        return np.vstack(trajectory)
