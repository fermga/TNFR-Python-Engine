<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TNFR API Contracts and Structural Invariants â€” TNFR Python Engine</title>
  <meta name="description" content="TNFR documentation: TNFR API Contracts and Structural Invariants">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap"
    >
  <style>
    :root {
      color-scheme: dark;
      --bg: #0e0f11;
      --panel: rgba(24, 25, 27, 0.9);
      --border: rgba(90, 92, 95, 0.4);
      --text: #e4e6eb;
      --muted: #9ea4b3;
      --accent: #6aa0ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.6;
      background: radial-gradient(circle at 20% 20%, #1a1c20, var(--bg));
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
        .page {
            max-width: 960px;
            margin: 0 auto;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 18px;
            padding: 2.5rem 3rem 3rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }
        header {
            border-bottom: 1px solid var(--border);
            padding-bottom: 1.5rem;
            margin-bottom: 2rem;
        }
    .home-link { font-weight: 600; color: var(--text); }
        .doc-title {
            display: block;
            font-size: 2.2rem;
            font-weight: 600;
            margin-top: 0.4rem;
        }
        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            margin-top: 1rem;
            font-size: 0.95rem;
            color: var(--muted);
        }
    main { font-size: 1rem; }
    main h1 { font-size: 2rem; margin-top: 2.5rem; }
        main h2 {
            font-size: 1.5rem;
            margin-top: 2rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.3rem;
        }
    main h3 { font-size: 1.2rem; margin-top: 1.5rem; }
    main p { margin: 1rem 0; }
        pre {
            background: #0a0b0d;
            padding: 1rem;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
    code { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; }
    table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; }
        th, td {
            border: 1px solid var(--border);
            padding: 0.6rem 0.8rem;
            text-align: left;
        }
        blockquote {
            border-left: 4px solid var(--accent);
            margin: 1.5rem 0;
            padding: 0.2rem 1rem;
            color: var(--muted);
            background: rgba(255, 255, 255, 0.02);
        }
        footer {
            border-top: 1px solid var(--border);
            margin-top: 2.5rem;
            padding-top: 1.5rem;
            font-size: 0.9rem;
            color: var(--muted);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: space-between;
        }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <a class="home-link" href="/TNFR-Python-Engine/">TNFR Python Engine</a>
      <span class="doc-title">TNFR API Contracts and Structural Invariants</span>
      <div class="meta">
        <span>Version 0.0.2 Â· DOI <a href="https://doi.org/10.5281/zenodo.17764207" target="_blank" rel="noopener">10.5281/zenodo.17764207</a> Â· Updated 2025-11-29</span>
                <span>
                    Source
                    <a
                        href="https://github.com/fermga/TNFR-Python-Engine/blob/main/docs/API_CONTRACTS.md"
                        target="_blank"
                        rel="noopener"
                    >
                        docs/API_CONTRACTS.md
                    </a>
                </span>
      </div>
    </header>
    <main>
      <h1 id="tnfr-api-contracts-and-structural-invariants">TNFR API Contracts and Structural Invariants</h1>
<p><strong>Status</strong>: âœ… <strong>ACTIVE</strong> - Complete operator specifications<br>
<strong>Version</strong>: 2.1.0 (Enhanced with optimization patterns)<br>
<strong>Last Updated</strong>: November 29, 2025  </p>
<h2 id="purpose">Purpose</h2>
<p>This document formalizes the <strong>structural invariants</strong> and <strong>API contracts</strong> for key TNFR functions, inspired by the 13 canonical structural operators. Each contract specifies preconditions, postconditions, and the structural effects on the Primary Information Structure (EPI), structural frequency (Î½f), phase (Î¸), and internal reorganization operator (Î”NFR).</p>
<h3 id="what-this-document-provides">ðŸŽ¯ What This Document Provides</h3>
<ol>
<li><strong>Formal Operator Specifications</strong>: Mathematical contracts for all 13 canonical operators</li>
<li><strong>Implementation Guidelines</strong>: How to implement operators while preserving TNFR physics</li>
<li><strong>Optimization Patterns</strong>: Common patterns for improving operator sequences</li>
<li><strong>Debugging Reference</strong>: Contract violations and how to fix them</li>
<li><strong>Extension Framework</strong>: How to add new operators while maintaining canonicity</li>
</ol>
<hr>
<h2 id="module-organization">Module Organization</h2>
<h3 id="core-modules">Core Modules</h3>
<ul>
<li><strong><code>tnfr.operators</code></strong>: Structural operators implementing TNFR canonical grammar</li>
<li><strong><code>tnfr.utils</code></strong>: Utility functions for caching, graph operations, and data normalization</li>
<li><strong><code>tnfr.dynamics</code></strong>: Evolution and dynamics computation</li>
<li><strong><code>tnfr.structural</code></strong>: Node creation and network initialization</li>
</ul>
<hr>
<h2 id="structural-operators">Structural Operators</h2>
<h3 id="1-emission-al-tnfroperatorsdefinitionsemission">1. Emission (AL) â€” <code>tnfr.operators.definitions.Emission</code></h3>
<p><strong>Structural Function</strong>: Seeds coherence by projecting the emission pattern.</p>
<p><strong>Operator</strong>: AL (Glyph.AL)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has valid EPI, Î½f, Î¸, Î”NFR attributes
  - EPI is finite and real-valued
- <strong>Postconditions</strong>:
  - <code>EPI_new = EPI_old + AL_boost</code> where <code>AL_boost &gt; 0</code>
  - <code>Î½f</code>, <code>Î¸</code>, <code>Î”NFR</code> remain unchanged
  - Node coherence <code>C(t)</code> increases or remains stable
- <strong>Structural Effect</strong>: Increases Primary Information Structure without altering temporal cadence
- <strong>TNFR Invariants</strong>:
  - âœ“ Preserves operator closure: Emission â†’ valid TNFR state
  - âœ“ Maintains phase coherence: <code>Î¸</code> unchanged
  - âœ“ Conserves structural frequency: <code>Î½f</code> unchanged</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_AL</code></p>
<hr>
<h3 id="2-reception-en-tnfroperatorsdefinitionsreception">2. Reception (EN) â€” <code>tnfr.operators.definitions.Reception</code></h3>
<p><strong>Structural Function</strong>: Stabilizes inbound energy to strengthen receptivity.</p>
<p><strong>Operator</strong>: EN (Glyph.EN)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has neighbors accessible via <code>neighbors()</code> method
  - Each neighbor has valid EPI attribute
- <strong>Postconditions</strong>:
  - <code>EPI_new = (1 - EN_mix) * EPI_old + EN_mix * EPI_bar</code> where <code>EPI_bar</code> is neighbor mean
  - <code>0 â‰¤ EN_mix â‰¤ 1</code> (default: 0.25)
  - <code>epi_kind</code> updated to dominant neighbor kind if <code>|EPI_neighbor| &gt; |EPI_node|</code>
  - <code>Î½f</code>, <code>Î¸</code>, <code>Î”NFR</code> remain unchanged
- <strong>Structural Effect</strong>: Harmonizes node EPI with neighborhood field
- <strong>TNFR Invariants</strong>:
  - âœ“ Coupling requires phase verification (implicit in neighbor mean)
  - âœ“ Propagates EPI without identity loss
  - âœ“ Preserves structural frequency</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_EN</code></p>
<hr>
<h3 id="3-coherence-il-tnfroperatorsdefinitionscoherence">3. Coherence (IL) â€” <code>tnfr.operators.definitions.Coherence</code></h3>
<p><strong>Structural Function</strong>: Reinforces structural alignment by compressing Î”NFR drift.</p>
<p><strong>Operator</strong>: IL (Glyph.IL)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î”NFR attribute (default: 0.0 if missing)
- <strong>Postconditions</strong>:
  - <code>Î”NFR_new = IL_dnfr_factor * Î”NFR_old</code> where <code>0 &lt; IL_dnfr_factor &lt; 1</code> (default: 0.7)
  - <code>|Î”NFR_new| â‰¤ |Î”NFR_old|</code> (monotonic decrease unless factor &gt; 1)
  - Sign of Î”NFR preserved: <code>sign(Î”NFR_new) = sign(Î”NFR_old)</code>
  - <code>EPI</code>, <code>Î½f</code>, <code>Î¸</code> remain unchanged
  - Total coherence <code>C(t)</code> increases or remains stable
- <strong>Structural Effect</strong>: Dampens internal reorganization, increasing stability
- <strong>TNFR Invariants</strong>:
  - âœ“ Coherence application must not reduce <code>C(t)</code> (unless in controlled dissonance test)
  - âœ“ Preserves operator closure
  - âœ“ Maintains phase and frequency integrity</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_IL</code></p>
<hr>
<h3 id="4-dissonance-oz-tnfroperatorsdefinitionsdissonance">4. Dissonance (OZ) â€” <code>tnfr.operators.definitions.Dissonance</code></h3>
<p><strong>Structural Function</strong>: Injects controlled dissonance to probe structural robustness.</p>
<p><strong>Operator</strong>: OZ (Glyph.OZ)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î”NFR attribute
  - Node has access to graph metadata for noise mode configuration
- <strong>Postconditions</strong>:
  - <strong>Noise mode</strong> (<code>OZ_NOISE_MODE=True</code>): <code>Î”NFR_new = Î”NFR_old + jitter</code> where <code>jitter ~ N(0, OZ_SIGMAÂ²)</code>
  - <strong>Amplification mode</strong> (<code>OZ_NOISE_MODE=False</code>): <code>Î”NFR_new = OZ_dnfr_factor * Î”NFR_old</code> where <code>OZ_dnfr_factor &gt; 1</code> (default: 1.3)
  - <code>|Î”NFR_new| &gt; |Î”NFR_old|</code> (typically, increases internal reorganization)
  - <code>EPI</code>, <code>Î½f</code>, <code>Î¸</code> remain unchanged
  - May trigger bifurcation if <code>âˆ‚Â²EPI/âˆ‚tÂ² &gt; Ï„</code>
- <strong>Structural Effect</strong>: Increases Î”NFR to test bifurcation thresholds
- <strong>TNFR Invariants</strong>:
  - âœ“ Dissonance increases <code>|Î”NFR|</code>
  - âœ“ May trigger bifurcation at configurable threshold
  - âœ“ Preserves EPI, Î½f, Î¸</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_OZ</code></p>
<hr>
<h3 id="5-coupling-um-tnfroperatorsdefinitionscoupling">5. Coupling (UM) â€” <code>tnfr.operators.definitions.Coupling</code></h3>
<p><strong>Structural Function</strong>: Synchronizes phase and optionally creates functional links.</p>
<p><strong>Operator</strong>: UM (Glyph.UM)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î¸ (phase) attribute
  - Node has neighbors accessible via <code>neighbors()</code> method
  - Each neighbor has Î¸ attribute
- <strong>Postconditions</strong>:
  - <code>Î¸_new = Î¸_old + UM_theta_push * angle_diff(Î¸_neighbor_mean, Î¸_old)</code>
  - <code>0 â‰¤ UM_theta_push â‰¤ 1</code> (default: 0.25)
  - By default (<code>UM_FUNCTIONAL_LINKS=True</code>), may add edges based on:
    - Phase similarity: <code>1 - |Î”Î¸|/Ï€</code>
    - EPI similarity: <code>1 - |EPI_i - EPI_j| / (|EPI_i| + |EPI_j| + Îµ)</code>
    - Sense index similarity: <code>1 - |Si_i - Si_j|</code>
    - Edge added if <code>compatibility â‰¥ UM_COMPAT_THRESHOLD</code> (default: 0.75)
  - Set <code>UM_FUNCTIONAL_LINKS=False</code> to disable link creation (edge case: phase-only sync)
  - <code>EPI</code>, <code>Î½f</code>, <code>Î”NFR</code> remain unchanged
- <strong>Structural Effect</strong>: Aligns node phase with neighbor mean, enables structural coupling
- <strong>TNFR Invariants</strong>:
  - âœ“ No coupling without explicit phase verification
  - âœ“ Phase synchrony increases effective coupling
  - âœ“ Preserves structural frequency and EPI</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_UM</code></p>
<hr>
<h3 id="6-resonance-ra-tnfroperatorsdefinitionsresonance">6. Resonance (RA) â€” <code>tnfr.operators.definitions.Resonance</code></h3>
<p><strong>Structural Function</strong>: Propagates coherent energy through the network.</p>
<p><strong>Operator</strong>: RA (Glyph.RA)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has EPI, epi_kind attributes
  - Node has neighbors with EPI attributes
- <strong>Postconditions</strong>:
  - <code>EPI_new = (1 - RA_epi_diff) * EPI_old + RA_epi_diff * EPI_bar</code>
  - <code>0 â‰¤ RA_epi_diff â‰¤ 1</code> (default: 0.15)
  - <code>epi_kind</code> updated to dominant neighbor kind if applicable
  - <code>Î½f</code>, <code>Î¸</code>, <code>Î”NFR</code> remain unchanged
- <strong>Structural Effect</strong>: Diffuses EPI along existing couplings
- <strong>TNFR Invariants</strong>:
  - âœ“ Resonance increases effective connectivity (measured via phase)
  - âœ“ Propagates EPI without altering identity
  - âœ“ Preserves Î½f and phase</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_RA</code></p>
<hr>
<h3 id="7-silence-sha-tnfroperatorsdefinitionssilence">7. Silence (SHA) â€” <code>tnfr.operators.definitions.Silence</code></h3>
<p><strong>Structural Function</strong>: Temporarily suspends structural evolution by reducing Î½f.</p>
<p><strong>Operator</strong>: SHA (Glyph.SHA)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î½f (structural frequency) attribute
- <strong>Postconditions</strong>:
  - <code>Î½f_new = SHA_vf_factor * Î½f_old</code> where <code>0 &lt; SHA_vf_factor &lt; 1</code> (default: 0.85)
  - <code>Î½f_new &lt; Î½f_old</code> (monotonic decrease)
  - <code>EPI</code>, <code>Î¸</code>, <code>Î”NFR</code> remain unchanged
  - Node enters reduced evolution state (<code>Î½f â‰ˆ 0</code> limit)
- <strong>Structural Effect</strong>: Decelerates temporal cadence without structural change
- <strong>TNFR Invariants</strong>:
  - âœ“ Silence freezes evolution (<code>Î½f â†’ 0</code>) without EPI loss
  - âœ“ Latency: EPI remains invariant over <code>t + Î”t</code>
  - âœ“ Preserves phase and Î”NFR</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_SHA</code></p>
<hr>
<h3 id="8-expansion-val-tnfroperatorsdefinitionsexpansion">8. Expansion (VAL) â€” <code>tnfr.operators.definitions.Expansion</code></h3>
<p><strong>Structural Function</strong>: Accelerates structural frequency to expand temporal cadence.</p>
<p><strong>Operator</strong>: VAL (Glyph.VAL)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î½f attribute
- <strong>Postconditions</strong>:
  - <code>Î½f_new = VAL_scale * Î½f_old</code> where <code>VAL_scale &gt; 1</code> (default: 1.15)
  - <code>Î½f_new &gt; Î½f_old</code> (monotonic increase)
  - <code>EPI</code>, <code>Î¸</code>, <code>Î”NFR</code> remain unchanged
- <strong>Structural Effect</strong>: Increases reorganization rate
- <strong>TNFR Invariants</strong>:
  - âœ“ Expansion increases Î½f
  - âœ“ Preserves EPI, phase, Î”NFR</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_scale</code> via <code>_make_scale_op(Glyph.VAL)</code></p>
<hr>
<h3 id="9-contraction-nul-tnfroperatorsdefinitionscontraction">9. Contraction (NUL) â€” <code>tnfr.operators.definitions.Contraction</code></h3>
<p><strong>Structural Function</strong>: Decelerates structural frequency to contract temporal cadence.</p>
<p><strong>Operator</strong>: NUL (Glyph.NUL)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î½f attribute
- <strong>Postconditions</strong>:
  - <code>Î½f_new = NUL_scale * Î½f_old</code> where <code>0 &lt; NUL_scale &lt; 1</code> (default: 0.85)
  - <code>Î½f_new &lt; Î½f_old</code> (monotonic decrease)
  - <code>EPI</code>, <code>Î¸</code>, <code>Î”NFR</code> remain unchanged
- <strong>Structural Effect</strong>: Decreases reorganization rate
- <strong>TNFR Invariants</strong>:
  - âœ“ Contraction decreases Î½f
  - âœ“ Preserves EPI, phase, Î”NFR</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_scale</code> via <code>_make_scale_op(Glyph.NUL)</code></p>
<hr>
<h3 id="10-self-organization-thol-tnfroperatorsdefinitionsselforganization">10. Self-Organization (THOL) â€” <code>tnfr.operators.definitions.SelfOrganization</code></h3>
<p><strong>Structural Function</strong>: Injects EPI curvature into Î”NFR to trigger self-organization.</p>
<p><strong>Operator</strong>: THOL (Glyph.THOL)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î”NFR attribute
  - Node has d2EPI (second derivative of EPI) attribute
- <strong>Postconditions</strong>:
  - <code>Î”NFR_new = Î”NFR_old + THOL_accel * d2EPI</code>
  - <code>THOL_accel &gt; 0</code> (default: 0.10)
  - <code>EPI</code>, <code>Î½f</code>, <code>Î¸</code> remain unchanged
  - May create sub-EPIs while preserving global form (operational fractality)
- <strong>Structural Effect</strong>: Accelerates structural rearrangement via curvature
- <strong>TNFR Invariants</strong>:
  - âœ“ Self-organization may create sub-EPIs
  - âœ“ Preserves global form (operational fractality)
  - âœ“ Bifurcation triggered if <code>âˆ‚Â²EPI/âˆ‚tÂ² &gt; Ï„</code></p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_THOL</code></p>
<hr>
<h3 id="11-mutation-zhir-tnfroperatorsdefinitionsmutation">11. Mutation (ZHIR) â€” <code>tnfr.operators.definitions.Mutation</code></h3>
<p><strong>Structural Function</strong>: Enacts discrete structural transition via phase shift.</p>
<p><strong>Operator</strong>: ZHIR (Glyph.ZHIR)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î¸ (phase) attribute
- <strong>Postconditions</strong>:
  - <code>Î¸_new = Î¸_old + ZHIR_theta_shift</code>
  - <code>ZHIR_theta_shift</code> configurable (default: Ï€/2)
  - Phase change occurs if <code>Î”EPI/Î”t &gt; Î¾</code> (limits configurable)
  - <code>EPI</code>, <code>Î½f</code>, <code>Î”NFR</code> remain unchanged
- <strong>Structural Effect</strong>: Rotates phase to encode state transition
- <strong>TNFR Invariants</strong>:
  - âœ“ Mutation changes Î¸ respecting threshold Î¾
  - âœ“ Preserves EPI, Î½f, Î”NFR</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_ZHIR</code></p>
<hr>
<h3 id="12-transition-nav-tnfroperatorsdefinitionstransition">12. Transition (NAV) â€” <code>tnfr.operators.definitions.Transition</code></h3>
<p><strong>Structural Function</strong>: Rebalances Î”NFR towards Î½f-aligned target.</p>
<p><strong>Operator</strong>: NAV (Glyph.NAV)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has Î”NFR, Î½f attributes
- <strong>Postconditions</strong>:
  - <strong>Strict mode</strong> (<code>NAV_STRICT=True</code>): <code>Î”NFR_new = vf + jitter</code>
  - <strong>Default mode</strong>: <code>Î”NFR_new = (1-Î·)*Î”NFR_old + Î·*sign(Î”NFR_old)*vf + jitter</code>
  - <code>0 â‰¤ Î· â‰¤ 1</code> (default: 0.5)
  - Jitter configurable via <code>NAV_jitter</code> (default: 0.05)
  - <code>EPI</code>, <code>Î¸</code> remain unchanged; <code>Î½f</code> used as reference
- <strong>Structural Effect</strong>: Redirects Î”NFR with optional exploration
- <strong>TNFR Invariants</strong>:
  - âœ“ Preserves EPI and phase
  - âœ“ Uses Î½f as reference without direct modification</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_NAV</code></p>
<hr>
<h3 id="13-recursivity-remesh">13. Recursivity (REMESH)</h3>
<p><strong>Structural Function</strong>: Advisory for network-scale remeshing.</p>
<p><strong>Operator</strong>: REMESH (Glyph.REMESH)</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - Node has access to graph metadata
  - Glyph history tracking enabled
- <strong>Postconditions</strong>:
  - Node-level <code>EPI</code>, <code>Î½f</code>, <code>Î¸</code>, <code>Î”NFR</code> unchanged
  - Advisory recorded in glyph history
  - <code>_remesh_warn_step</code> updated to current step
- <strong>Structural Effect</strong>: Signals orchestrator for global remesh when stability conditions met
- <strong>TNFR Invariants</strong>:
  - âœ“ Operational fractality: EPIs nest without losing identity
  - âœ“ No direct node mutation</p>
<p><strong>Implementation</strong>: <code>tnfr.operators._op_REMESH</code></p>
<hr>
<h2 id="utility-functions-contracts">Utility Functions Contracts</h2>
<h3 id="tnfrutilscachecached_node_list"><code>tnfr.utils.cache.cached_node_list</code></h3>
<p><strong>Purpose</strong>: Return cached node list with version tracking.</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - <code>G</code> implements GraphLike protocol
  - Graph has version tracking enabled
- <strong>Postconditions</strong>:
  - Returns list of nodes consistent with graph version
  - Cache invalidated on graph mutation (version increment)
  - Thread-safe access via locking
- <strong>Invariants</strong>:
  - âœ“ Deterministic: same graph version â†’ same node list
  - âœ“ Cache hit improves performance without semantic change</p>
<hr>
<h3 id="tnfrutilsgraphmark_dnfr_prep_dirty"><code>tnfr.utils.graph.mark_dnfr_prep_dirty</code></h3>
<p><strong>Purpose</strong>: Invalidate Î”NFR preparation cache.</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - <code>G</code> has graph metadata accessible
- <strong>Postconditions</strong>:
  - <code>G.graph["_dnfr_prep_dirty"] = True</code>
  - Next Î”NFR computation will rebuild cache
- <strong>Invariants</strong>:
  - âœ“ Structural consistency: dirty flag triggers recomputation
  - âœ“ No data loss on invalidation</p>
<hr>
<h3 id="tnfrutilsnumericclamp"><code>tnfr.utils.numeric.clamp</code></h3>
<p><strong>Purpose</strong>: Constrain value within bounds.</p>
<p><strong>Contract</strong>:
- <strong>Preconditions</strong>:
  - <code>value</code>, <code>min_val</code>, <code>max_val</code> are comparable
  - <code>min_val â‰¤ max_val</code>
- <strong>Postconditions</strong>:
  - <code>result = max(min_val, min(value, max_val))</code>
  - <code>min_val â‰¤ result â‰¤ max_val</code>
- <strong>Invariants</strong>:
  - âœ“ Idempotent: <code>clamp(clamp(x, a, b), a, b) = clamp(x, a, b)</code>
  - âœ“ Deterministic</p>
<hr>
<h2 id="canonical-invariants-global">Canonical Invariants (Global)</h2>
<p>These invariants apply across all TNFR operations:</p>
<ol>
<li><strong>EPI as coherent form</strong>: EPI changes only via structural operators; no ad-hoc mutations</li>
<li><strong>Structural units</strong>: Î½f expressed in Hz_str (structural hertz)</li>
<li><strong>Î”NFR semantics</strong>: Sign and magnitude modulate reorganization rate</li>
<li><strong>Operator closure</strong>: Composition yields valid TNFR states</li>
<li><strong>Phase check</strong>: Coupling requires explicit phase verification</li>
<li><strong>Node birth/collapse</strong>: Minimal conditions (sufficient Î½f, coupling, reduced Î”NFR)</li>
<li><strong>Operational fractality</strong>: EPIs nest without losing functional identity</li>
<li><strong>Controlled determinism</strong>: Reproducible with seeds, traceable with structural logs</li>
<li><strong>Structural metrics</strong>: Expose C(t), Si, phase, Î½f in telemetry</li>
<li><strong>Domain neutrality</strong>: Trans-scale, trans-domain engine</li>
</ol>
<hr>
<h2 id="usage-example">Usage Example</h2>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">tnfr.operators.definitions</span> <span class="kn">import</span> <span class="n">Emission</span><span class="p">,</span> <span class="n">Coherence</span><span class="p">,</span> <span class="n">Coupling</span>
<span class="kn">from</span> <span class="nn">tnfr.structural</span> <span class="kn">import</span> <span class="n">create_nfr</span><span class="p">,</span> <span class="n">run_sequence</span>

<span class="c1"># Create a node with initial conditions</span>
<span class="n">G</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">create_nfr</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">,</span> <span class="n">epi</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">vf</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<span class="c1"># Apply operators respecting structural invariants</span>
<span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Emission</span><span class="p">(),</span>    <span class="c1"># âœ“ Increases EPI, preserves Î½f, Î¸, Î”NFR</span>
    <span class="n">Coherence</span><span class="p">(),</span>   <span class="c1"># âœ“ Dampens Î”NFR, increases C(t)</span>
    <span class="n">Coupling</span><span class="p">(),</span>    <span class="c1"># âœ“ Synchronizes phase with neighbors</span>
<span class="p">]</span>

<span class="n">run_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>

<span class="c1"># Verify invariants</span>
<span class="k">assert</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;epi&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.1</span>  <span class="c1"># Emission increased EPI</span>
<span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;dnfr&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1.0</span>  <span class="c1"># Coherence dampened Î”NFR</span>
</code></pre></div>

<hr>
<h2 id="testing-contracts">Testing Contracts</h2>
<p>All contracts should be validated by:
1. <strong>Unit tests</strong>: Verify pre/postconditions for each operator
2. <strong>Integration tests</strong>: Ensure operator closure and composition
3. <strong>Property tests</strong>: Use Hypothesis to check invariants across parameter spaces
4. <strong>Regression tests</strong>: Prevent contract violations on refactoring</p>
<p>See <code>tests/integration/test_additional_critical_paths.py</code> for examples.</p>
<hr>
<h2 id="module-dependency-analysis-and-coupling-assessment">Module Dependency Analysis and Coupling Assessment</h2>
<h3 id="utils-package-dependency-graph">Utils Package Dependency Graph</h3>
<p>The <code>tnfr.utils</code> package exhibits a well-structured dependency hierarchy with no circular runtime dependencies:</p>
<div class="codehilite"><pre><span></span><code><span class="n">init</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">foundational</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">logging</span><span class="p">,</span><span class="w"> </span><span class="n">lazy</span><span class="w"> </span><span class="n">imports</span><span class="p">)</span>
<span class="w">  </span><span class="err">â†“</span>
<span class="n">numeric</span><span class="o">.</span><span class="n">py</span><span class="p">,</span><span class="w"> </span><span class="n">chunks</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">pure</span><span class="w"> </span><span class="n">mathematical</span><span class="w"> </span><span class="n">functions</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">TNFR</span><span class="w"> </span><span class="n">imports</span><span class="p">)</span>
<span class="w">  </span><span class="err">â†“</span>
<span class="n">data</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">depends</span><span class="w"> </span><span class="n">on</span><span class="p">:</span><span class="w"> </span><span class="n">numeric</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="w">  </span><span class="err">â†“</span>
<span class="n">graph</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">depends</span><span class="w"> </span><span class="n">on</span><span class="p">:</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">only</span><span class="p">)</span>
<span class="w">  </span><span class="err">â†“</span>
<span class="n">io</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">depends</span><span class="w"> </span><span class="n">on</span><span class="p">:</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="w">  </span><span class="err">â†“</span>
<span class="n">cache</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">depends</span><span class="w"> </span><span class="n">on</span><span class="p">:</span><span class="w"> </span><span class="n">locking</span><span class="p">,</span><span class="w"> </span><span class="n">types</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">)</span>
<span class="w">  </span><span class="err">â†“</span>
<span class="n">callbacks</span><span class="o">.</span><span class="n">py</span><span class="w"> </span><span class="p">(</span><span class="n">depends</span><span class="w"> </span><span class="n">on</span><span class="p">:</span><span class="w"> </span><span class="n">constants</span><span class="p">,</span><span class="w"> </span><span class="n">locking</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">types</span><span class="p">)</span>
</code></pre></div>

<h3 id="cross-module-import-analysis">Cross-Module Import Analysis</h3>
<p><strong>Verified No Circular Imports</strong>: Analysis confirmed no runtime circular dependencies. The apparent bidirectional reference between <code>init.py</code> and <code>cache.py</code> uses <code>TYPE_CHECKING</code> guards, preventing runtime circular import issues.</p>
<h4 id="legitimate-cross-dependencies">Legitimate Cross-Dependencies</h4>
<ol>
<li><strong><code>cache.py</code> â†’ <code>graph.py</code></strong>: </li>
<li>Purpose: Î”NFR preparation state management</li>
<li>Functions: <code>get_graph()</code>, <code>mark_dnfr_prep_dirty()</code></li>
<li>
<p>Justification: Cache invalidation must coordinate with graph mutation tracking</p>
</li>
<li>
<p><strong><code>cache.py</code> â†’ <code>init.py</code></strong>:</p>
</li>
<li>Purpose: Logging and lazy numpy backend loading</li>
<li>Functions: <code>get_logger()</code>, <code>get_numpy()</code></li>
<li>
<p>Justification: Domain-neutral backend selection (INVARIANT #10)</p>
</li>
<li>
<p><strong><code>cache.py</code> â†’ <code>io.py</code></strong>:</p>
</li>
<li>Purpose: Deterministic serialization for cache keys</li>
<li>Functions: <code>json_dumps()</code></li>
<li>
<p>Justification: Reproducible cache key generation (INVARIANT #8)</p>
</li>
<li>
<p><strong><code>data.py</code> â†’ <code>numeric.py</code></strong>:</p>
</li>
<li>Purpose: Compensated summation for coherence calculations</li>
<li>Functions: <code>kahan_sum_nd()</code></li>
<li>
<p>Justification: Numerical stability for C(t) computation</p>
</li>
<li>
<p><strong><code>callbacks.py</code> â†’ <code>data.py</code></strong>:</p>
</li>
<li>Purpose: Callback argument validation</li>
<li>Functions: <code>is_non_string_sequence()</code></li>
<li>Justification: Type checking for structural event data</li>
</ol>
<p><strong>Assessment</strong>: All cross-module imports serve specific structural purposes aligned with TNFR invariants. No unnecessary coupling detected.</p>
<h3 id="compatibility-shims">Compatibility Shims</h3>
<p><strong><code>callback_utils.py</code></strong>: Deprecated compatibility shim that redirects to <code>utils.callbacks</code>. This module:
- Emits <code>DeprecationWarning</code> on import
- Provides backward compatibility during migration period
- Documented for future removal
- <strong>Recommendation</strong>: Remove in next major version after migration period</p>
<h3 id="module-coupling-metrics">Module Coupling Metrics</h3>
<table>
<thead>
<tr>
<th>Module</th>
<th>Internal Imports</th>
<th>External TNFR Imports</th>
<th>Coupling Score</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>numeric.py</code></td>
<td>0</td>
<td>0</td>
<td><strong>Low</strong> âœ“</td>
</tr>
<tr>
<td><code>chunks.py</code></td>
<td>0</td>
<td>0</td>
<td><strong>Low</strong> âœ“</td>
</tr>
<tr>
<td><code>init.py</code></td>
<td>1 (cache - TYPE_CHECKING only)</td>
<td>0</td>
<td><strong>Low</strong> âœ“</td>
</tr>
<tr>
<td><code>graph.py</code></td>
<td>0</td>
<td>2 (types)</td>
<td><strong>Low</strong> âœ“</td>
</tr>
<tr>
<td><code>io.py</code></td>
<td>4 (init)</td>
<td>0</td>
<td><strong>Low</strong> âœ“</td>
</tr>
<tr>
<td><code>data.py</code></td>
<td>3 (numeric, init)</td>
<td>0</td>
<td><strong>Moderate</strong> âœ“</td>
</tr>
<tr>
<td><code>callbacks.py</code></td>
<td>2 (init, data)</td>
<td>3 (constants, locking, types)</td>
<td><strong>Moderate</strong> âœ“</td>
</tr>
<tr>
<td><code>cache.py</code></td>
<td>5 (graph, init, io)</td>
<td>2 (locking, types)</td>
<td><strong>Moderate</strong> âœ“</td>
</tr>
</tbody>
</table>
<p><strong>âœ“ All coupling levels are appropriate for module responsibilities.</strong></p>
<h3 id="linting-results-summary">Linting Results Summary</h3>
<p>Flake8 analysis identified only minor style issues:
- Blank lines with whitespace (W293)
- Module imports not at top (E402) - intentional for lazy loading
- Unused TYPE_CHECKING imports (F401) - required for type hints
- Minor spacing issues (E302, E305)</p>
<p><strong>No structural anti-patterns, circular imports, or dangerous coupling detected.</strong></p>
<h3 id="recommendations">Recommendations</h3>
<ol>
<li><strong>Keep Current Structure</strong>: The dependency hierarchy is clean and well-organized</li>
<li><strong>Remove <code>callback_utils.py</code></strong>: After deprecation period expires</li>
<li><strong>Document Import Rationale</strong>: Comments added where non-obvious</li>
</ol>
<hr>
<h2 id="advanced-optimization-patterns">ðŸš€ Advanced Optimization Patterns</h2>
<h3 id="pattern-1-therapeutic-transformation-cycle">Pattern 1: Therapeutic Transformation Cycle</h3>
<p><strong>Purpose</strong>: Transform unstable or problematic sequences into stable therapeutic patterns.</p>
<p><strong>Template</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Before: Unstable transformation (health â‰ˆ 0.60)</span>
<span class="n">unstable</span> <span class="o">=</span> <span class="p">[</span><span class="n">EMISSION</span><span class="p">,</span> <span class="n">DISSONANCE</span><span class="p">,</span> <span class="n">MUTATION</span><span class="p">,</span> <span class="n">COHERENCE</span><span class="p">]</span>

<span class="c1"># After: Full therapeutic cycle (health â‰ˆ 0.89)</span>
<span class="n">therapeutic</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">EMISSION</span><span class="p">,</span>           <span class="c1"># AL: Initialize therapeutic space</span>
    <span class="n">RECEPTION</span><span class="p">,</span>          <span class="c1"># EN: Gather contextual information</span>
    <span class="n">COHERENCE</span><span class="p">,</span>          <span class="c1"># IL: Establish baseline stability</span>
    <span class="n">DISSONANCE</span><span class="p">,</span>         <span class="c1"># OZ: Controlled destabilization</span>
    <span class="n">SELF_ORGANIZATION</span><span class="p">,</span>  <span class="c1"># THOL: Emergent reorganization</span>
    <span class="n">COHERENCE</span><span class="p">,</span>          <span class="c1"># IL: Consolidate transformation</span>
    <span class="n">SILENCE</span>             <span class="c1"># SHA: Integration period</span>
<span class="p">]</span>
</code></pre></div>

<p><strong>Key Improvements</strong>:
- <strong>+0.29 health improvement</strong> through proper stabilization
- <strong>Grammar compliance</strong>: U2 (destabilizer + stabilizer), U1b (proper closure)
- <strong>Pattern recognition</strong>: Canonical therapeutic sequence</p>
<h3 id="pattern-2-enhanced-activation-with-amplification">Pattern 2: Enhanced Activation with Amplification</h3>
<p><strong>Purpose</strong>: Upgrade basic activation patterns with resonant amplification.</p>
<p><strong>Template</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Before: Basic activation (health â‰ˆ 0.66)</span>
<span class="n">basic</span> <span class="o">=</span> <span class="p">[</span><span class="n">EMISSION</span><span class="p">,</span> <span class="n">RECEPTION</span><span class="p">,</span> <span class="n">COHERENCE</span><span class="p">,</span> <span class="n">SILENCE</span><span class="p">]</span>

<span class="c1"># After: Enhanced with resonance (health â‰ˆ 0.85)</span>
<span class="n">enhanced</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">EMISSION</span><span class="p">,</span>    <span class="c1"># AL: Seed activation</span>
    <span class="n">RECEPTION</span><span class="p">,</span>   <span class="c1"># EN: Information gathering</span>
    <span class="n">COHERENCE</span><span class="p">,</span>   <span class="c1"># IL: Baseline stability</span>
    <span class="n">RESONANCE</span><span class="p">,</span>   <span class="c1"># RA: Amplify coherent patterns</span>
    <span class="n">SILENCE</span>      <span class="c1"># SHA: Preserve amplified state</span>
<span class="p">]</span>
</code></pre></div>

<p><strong>Key Improvements</strong>:
- <strong>+0.19 health improvement</strong> through resonant amplification
- <strong>Enhanced pattern</strong>: Basic activation â†’ Activation with amplification
- <strong>Preserved simplicity</strong>: Minimal operator addition</p>
<h3 id="pattern-3-exploration-with-controlled-bifurcation">Pattern 3: Exploration with Controlled Bifurcation</h3>
<p><strong>Purpose</strong>: Enable safe exploration through controlled destabilization and recovery.</p>
<p><strong>Template</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">controlled_exploration</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">EMISSION</span><span class="p">,</span>           <span class="c1"># AL: Initialize exploration space</span>
    <span class="n">RECEPTION</span><span class="p">,</span>          <span class="c1"># EN: Gather environmental context</span>
    <span class="n">COHERENCE</span><span class="p">,</span>          <span class="c1"># IL: Establish safety baseline</span>
    <span class="n">EXPANSION</span><span class="p">,</span>          <span class="c1"># VAL: Increase exploration volume</span>
    <span class="n">COHERENCE</span><span class="p">,</span>          <span class="c1"># IL: Stabilize expansion (U2)</span>
    <span class="n">DISSONANCE</span><span class="p">,</span>         <span class="c1"># OZ: First exploration wave</span>
    <span class="n">MUTATION</span><span class="p">,</span>           <span class="c1"># ZHIR: Alternative trajectory (U4b)</span>
    <span class="n">COHERENCE</span><span class="p">,</span>          <span class="c1"># IL: Checkpoint stability</span>
    <span class="n">DISSONANCE</span><span class="p">,</span>         <span class="c1"># OZ: Second exploration wave</span>
    <span class="n">SELF_ORGANIZATION</span><span class="p">,</span>  <span class="c1"># THOL: Emergent structure (U4a)</span>
    <span class="n">COHERENCE</span><span class="p">,</span>          <span class="c1"># IL: Final consolidation</span>
    <span class="n">SILENCE</span>             <span class="c1"># SHA: Integration</span>
<span class="p">]</span>
</code></pre></div>

<p><strong>Key Features</strong>:
- <strong>Multi-wave exploration</strong>: Two destabilization cycles
- <strong>Safety checkpoints</strong>: Coherence after each major operation
- <strong>Grammar compliance</strong>: U2, U4a, U4b all satisfied
- <strong>Health target</strong>: &gt; 0.68 (moderate due to exploration complexity)</p>
<h3 id="pattern-4-network-synchronization-protocol">Pattern 4: Network Synchronization Protocol</h3>
<p><strong>Purpose</strong>: Establish coherent coupling across network nodes with phase verification.</p>
<p><strong>Template</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">network_sync</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">EMISSION</span><span class="p">,</span>     <span class="c1"># AL: Initialize local coherence</span>
    <span class="n">RECEPTION</span><span class="p">,</span>    <span class="c1"># EN: Sense network state</span>
    <span class="n">COHERENCE</span><span class="p">,</span>    <span class="c1"># IL: Local stabilization</span>
    <span class="n">COUPLING</span><span class="p">,</span>     <span class="c1"># UM: Form phase-verified links (U3)</span>
    <span class="n">RESONANCE</span><span class="p">,</span>    <span class="c1"># RA: Network-wide amplification</span>
    <span class="n">COUPLING</span><span class="p">,</span>     <span class="c1"># UM: Strengthen synchronization</span>
    <span class="n">RESONANCE</span><span class="p">,</span>    <span class="c1"># RA: Reinforce coherent patterns</span>
    <span class="n">COHERENCE</span><span class="p">,</span>    <span class="c1"># IL: Network consolidation</span>
    <span class="n">SILENCE</span>       <span class="c1"># SHA: Maintain synchrony</span>
<span class="p">]</span>
</code></pre></div>

<p><strong>Critical Requirements</strong>:
- <strong>Phase verification</strong>: Each COUPLING must satisfy |Ï†áµ¢ - Ï†â±¼| â‰¤ Î”Ï†_max (U3)
- <strong>Network topology</strong>: Requires connected network with multiple nodes
- <strong>Health target</strong>: &gt; 0.80 for strong network coherence</p>
<h3 id="pattern-5-compression-and-essence-extraction">Pattern 5: Compression and Essence Extraction</h3>
<p><strong>Purpose</strong>: Simplify complex structures while preserving essential information.</p>
<p><strong>Template</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">compression</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">EMISSION</span><span class="p">,</span>      <span class="c1"># AL: Initialize from complex state</span>
    <span class="n">RECEPTION</span><span class="p">,</span>     <span class="c1"># EN: Understand full complexity</span>
    <span class="n">COHERENCE</span><span class="p">,</span>     <span class="c1"># IL: Baseline stability</span>
    <span class="n">EXPANSION</span><span class="p">,</span>     <span class="c1"># VAL: Temporarily increase complexity</span>
    <span class="n">COHERENCE</span><span class="p">,</span>     <span class="c1"># IL: Stabilize expansion (U2)</span>
    <span class="n">CONTRACTION</span><span class="p">,</span>   <span class="c1"># NUL: First compression wave</span>
    <span class="n">COHERENCE</span><span class="p">,</span>     <span class="c1"># IL: Stabilize compression</span>
    <span class="n">CONTRACTION</span><span class="p">,</span>   <span class="c1"># NUL: Second compression wave</span>
    <span class="n">COHERENCE</span><span class="p">,</span>     <span class="c1"># IL: Final consolidation</span>
    <span class="n">SILENCE</span>        <span class="c1"># SHA: Preserve essence</span>
<span class="p">]</span>
</code></pre></div>

<p><strong>Key Features</strong>:
- <strong>Expand then compress</strong>: Counter-intuitive but effective pattern
- <strong>Multiple compression waves</strong>: Progressive simplification
- <strong>Essence preservation</strong>: Each contraction followed by stabilization</p>
<hr>
<h2 id="optimization-strategies">ðŸ”¬ Optimization Strategies</h2>
<h3 id="strategy-1-health-driven-optimization">Strategy 1: Health-Driven Optimization</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">optimize_by_health</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">target_health</span><span class="o">=</span><span class="mf">0.80</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterative health improvement strategy.&quot;&quot;&quot;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">compute_health</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">target_health</span><span class="p">:</span>
        <span class="c1"># 1. Check grammar violations</span>
        <span class="n">violations</span> <span class="o">=</span> <span class="n">validate_grammar</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">violations</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">fix_grammar_violations</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">violations</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># 2. Apply common improvements</span>
        <span class="k">if</span> <span class="n">needs_stabilization</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">add_stabilizers</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lacks_amplification</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">add_resonance</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">missing_closure</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">fix_closure</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># No obvious improvements</span>

    <span class="k">return</span> <span class="n">current</span>
</code></pre></div>

<h3 id="strategy-2-pattern-based-enhancement">Strategy 2: Pattern-Based Enhancement</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">enhance_with_patterns</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Upgrade sequences using canonical patterns.&quot;&quot;&quot;</span>
    <span class="n">pattern_type</span> <span class="o">=</span> <span class="n">classify_sequence</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pattern_type</span> <span class="o">==</span> <span class="s2">&quot;basic_activation&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">upgrade_to_enhanced_activation</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pattern_type</span> <span class="o">==</span> <span class="s2">&quot;unstable_transformation&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convert_to_therapeutic</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pattern_type</span> <span class="o">==</span> <span class="s2">&quot;incomplete_exploration&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">complete_exploration_cycle</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">apply_generic_improvements</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
</code></pre></div>

<h3 id="strategy-3-grammar-first-optimization">Strategy 3: Grammar-First Optimization</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">grammar_compliant_optimization</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure grammar compliance while optimizing.&quot;&quot;&quot;</span>
    <span class="c1"># 1. Fix U1 violations (initiation/closure)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">starts_with_generator</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">EMISSION</span><span class="p">]</span> <span class="o">+</span> <span class="n">sequence</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ends_with_closure</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span> <span class="o">+</span> <span class="p">[</span><span class="n">SILENCE</span><span class="p">]</span>

    <span class="c1"># 2. Fix U2 violations (convergence/boundedness)</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">balance_destabilizers</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

    <span class="c1"># 3. Fix U3 violations (resonant coupling)</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">verify_phase_compatibility</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

    <span class="c1"># 4. Fix U4 violations (bifurcation dynamics)</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">handle_bifurcation_triggers</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sequence</span>
</code></pre></div>

<hr>
<h2 id="performance-optimization-guidelines">ðŸ“Š Performance Optimization Guidelines</h2>
<h3 id="memory-optimization">Memory Optimization</h3>
<ol>
<li><strong>Use inplace operations</strong> when possible: <code>compute_si(G, inplace=True)</code></li>
<li><strong>Enable node caching</strong> for repeated calculations: <code>TNFR_CACHE_ENABLED=1</code></li>
<li><strong>Batch operations</strong> on multiple nodes to amortize overhead</li>
<li><strong>Profile memory usage</strong> with <code>OperatorMetrics</code> collection</li>
</ol>
<h3 id="computational-optimization">Computational Optimization</h3>
<ol>
<li><strong>Backend selection</strong>: Choose appropriate backend for network size</li>
<li><strong>Numpy</strong>: Networks &lt; 100 nodes</li>
<li><strong>Numba</strong>: Networks 100-1000 nodes  </li>
<li>
<p><strong>GPU</strong>: Networks &gt; 1000 nodes</p>
</li>
<li>
<p><strong>Operator composition</strong>: Combine compatible operators to reduce overhead</p>
</li>
<li>
<p><strong>Sequence caching</strong>: Cache validated sequences to avoid re-validation</p>
</li>
</ol>
<h3 id="network-architecture-optimization">Network Architecture Optimization</h3>
<ol>
<li><strong>Topology awareness</strong>: Choose operators based on network topology</li>
<li><strong>Dense networks</strong>: Favor coupling and resonance</li>
<li><strong>Sparse networks</strong>: Use expansion carefully</li>
<li>
<p><strong>Scale-free</strong>: Focus on hub stabilization</p>
</li>
<li>
<p><strong>Load balancing</strong>: Distribute operations across high-degree nodes</p>
</li>
<li>
<p><strong>Hierarchical processing</strong>: Use operational fractality for multi-scale networks</p>
</li>
</ol>
<hr>
<h2 id="extension-framework">ðŸ› ï¸ Extension Framework</h2>
<h3 id="adding-custom-operators">Adding Custom Operators</h3>
<p>To add new operators while maintaining canonicity:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">tnfr.operators</span> <span class="kn">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">tnfr.operators.glyphs</span> <span class="kn">import</span> <span class="n">Glyph</span>

<span class="k">class</span> <span class="nc">CustomOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Custom operator following TNFR physics.&quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;custom_name&quot;</span>
    <span class="n">glyph</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Glyph</span><span class="p">]</span> <span class="o">=</span> <span class="n">Glyph</span><span class="o">.</span><span class="n">CUSTOM</span>  <span class="c1"># Define new glyph</span>

    <span class="k">def</span> <span class="nf">_validate_preconditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate custom preconditions.&quot;&quot;&quot;</span>
        <span class="c1"># Implement physics-based validation</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_apply_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply custom structural transformation.&quot;&quot;&quot;</span>
        <span class="c1"># Must preserve nodal equation: âˆ‚EPI/âˆ‚t = Î½f Â· Î”NFR</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_collect_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state_before</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collect custom metrics.&quot;&quot;&quot;</span>
        <span class="c1"># Return metrics dict</span>
        <span class="k">pass</span>
</code></pre></div>

<h3 id="grammar-integration">Grammar Integration</h3>
<p>New operators must be classified in grammar rules:</p>
<ul>
<li><strong>Generators</strong> (U1a): Can start sequences from EPI=0</li>
<li><strong>Closures</strong> (U1b): Can end sequences safely</li>
<li><strong>Stabilizers</strong> (U2): Reduce Î”NFR, increase C(t)</li>
<li><strong>Destabilizers</strong> (U2): Increase Î”NFR, require stabilizers</li>
<li><strong>Coupling-based</strong> (U3): Require phase verification</li>
<li><strong>Bifurcation triggers</strong> (U4): Need careful handling</li>
</ul>
<h3 id="testing-requirements">Testing Requirements</h3>
<p>All new operators must pass:</p>
<ol>
<li><strong>Physics compliance</strong>: Preserve nodal equation</li>
<li><strong>Grammar validation</strong>: Follow U1-U6 rules</li>
<li><strong>Invariant preservation</strong>: Maintain 10 canonical invariants</li>
<li><strong>Health metrics</strong>: Provide predictable health impact</li>
<li><strong>Multi-topology testing</strong>: Work across different network topologies</li>
</ol>
<hr>
<h2 id="related-documentation">ðŸ“š Related Documentation</h2>
<ul>
<li><strong><a href="/TNFR-Python-Engine/AGENTS/">AGENTS.md</a></strong>: Complete TNFR theory and canonical invariants</li>
<li><strong><a href="/TNFR-Python-Engine/TROUBLESHOOTING/">TROUBLESHOOTING.md</a></strong>: Grammar validation error solutions</li>
<li><strong><a href="/TNFR-Python-Engine/CANONICAL_OZ_SEQUENCES/">CANONICAL_OZ_SEQUENCES.md</a></strong>: Dissonance-based patterns</li>
<li><strong><a href="https://github.com/fermga/TNFR-Python-Engine/blob/main/examples/04_operator_sequences.py">examples/04_operator_sequences.py</a></strong>: Live operator examples</li>
<li><strong><a href="https://github.com/fermga/TNFR-Python-Engine/blob/main/src/tnfr/operators">src/tnfr/operators/</a></strong>: Implementation source code</li>
<li><strong>Maintain TYPE_CHECKING Guards</strong>: For forward references without runtime cycles</li>
<li><strong>Continue Modular Design</strong>: New utilities should follow same layered approach</li>
</ul>
<hr>
<h2 id="references">References</h2>
<ul>
<li><code>AGENTS.md</code>: Agent instructions for maintaining TNFR fidelity</li>
<li><code>TNFR.pdf</code>: Base paradigm document</li>
<li><code>tnfr.operators</code>: Operator implementations</li>
<li><code>tnfr.validation</code>: Grammar and precondition checking</li>
</ul>
    </main>
    <footer>
            <span>
                &copy; 2025
                TNFR Python Engine â€” Licensed under MIT.
            </span>
            <span>
                Feedback?
                <a
                    href="https://github.com/fermga/TNFR-Python-Engine"
                    target="_blank"
                    rel="noopener"
                >
                    Open an issue
                </a>.
            </span>
    </footer>
  </div>
</body>
</html>
