{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TNFR Documentation Index (Phase 3 scaffold)","text":"<p>Welcome to the canonical reference for the TNFR Python Engine. This page orients you to the major documentation areas so you can quickly find the right level of detail\u2014whether you are bootstrapping an environment, validating operator semantics, or diving into the underlying theory.</p>"},{"location":"#quick-references-for-new-contributors","title":"Quick References for New Contributors","text":"<ul> <li>TNFR Fundamental Concepts \u2013 START HERE if you're new to TNFR! Understand the paradigm in 10 minutes with accessible explanations, visual analogies, and practical examples.</li> <li>README.md \u2013 Accessible introduction to TNFR with quick installation and first steps.</li> <li>GLOSSARY.md \u2013 Unified glossary of TNFR variables, operators, and   canonical concepts. Essential reference for understanding EPI, \u03bdf, \u0394NFR, and structural operators.</li> <li>GLYPH_SEQUENCES_GUIDE.md \u2013 Examples of common structural   operator sequences with expected behaviors and metrics.</li> </ul>"},{"location":"#documentation-map","title":"Documentation map","text":"<ul> <li>Getting started \u2013 NEW: Read the TNFR Fundamental Concepts guide first to understand the paradigm! Then follow the practical Quickstart to   spin up a TNFR node, or review the migrating guide   if you are coming from Remesh Window.</li> <li>API reference \u2013 consult the overview plus the focused guides on   structural operators and telemetry utilities when you need   concrete call signatures or examples.</li> <li>Mathematical Foundations \u2013 the notebooks under <code>theory/</code> connect the canonical equations with   implementation choices. Use them when you must align derivations with code paths.</li> <li>Examples \u2013 cloneable scenarios in examples/README.md that demonstrate   cross-scale coherence checks.</li> <li>Security \u2013 operational guidance for monitoring and supply-chain hygiene in   security/.</li> <li>Releases \u2013 version-by-version summaries in the release notes.</li> </ul> <p>Mathematical Foundations</p> <p>The Mathematical Foundations document is the single source of truth for the canonical nodal equation and structural operators. It includes complete derivations, operator formalism, and spectral theory. Interactive notebooks (structural frequency, phase synchrony, \u0394NFR gradient fields, coherence metrics, sense index, and recursivity cascades) provide hands-on exploration with visualizations. Refer to the unified foundations document whenever you need to validate analytical assumptions or reproduce the derivations behind telemetry outputs.</p> <p>Quick-start pathways</p> <ul> <li>New to TNFR? Read the TNFR Fundamental Concepts guide to understand the paradigm first (10 minutes).</li> <li>For implementers: follow the Quickstart to configure   dependencies, initialize a seed, and run your first coherence sweep.</li> <li>For theorists: the Mathematical Quick Start bridges the primer notebooks with   the code-level abstractions.</li> </ul>"},{"location":"#release-cadence","title":"Release cadence","text":"<p>Stable builds, bug fixes, and structural operator updates are catalogued in the Release notes. Use that page to confirm which operators, telemetry fields, and notebook revisions shipped in a given version before you align experiments or migrations.</p>"},{"location":"#need-a-different-entry-point","title":"Need a different entry point?","text":"<p>Use the navigation sidebar (Material theme) to jump directly into operators, notebooks, or example bundles. Each section cross-links back to this index so you can maintain orientation while exploring deeper content.</p>"},{"location":"conf/","title":"Conf","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Sphinx configuration for the TNFR Python Engine documentation.\"\"\"\nfrom __future__ import annotations\n</pre> \"\"\"Sphinx configuration for the TNFR Python Engine documentation.\"\"\" from __future__ import annotations In\u00a0[\u00a0]: Copied! <pre>import os\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\n</pre> import os import sys from datetime import datetime from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>try:\n    import pypandoc\nexcept ImportError:\n    pypandoc = None\n</pre> try:     import pypandoc except ImportError:     pypandoc = None In\u00a0[\u00a0]: Copied! <pre>REPO_ROOT = Path(__file__).resolve().parents[2]\nSRC_PATH = REPO_ROOT / \"src\"\nos.environ.setdefault(\"SPHINX_APIDOC_OPTIONS\", \"members,special-members,show-inheritance\")\nsys.path.insert(0, str(SRC_PATH))\n</pre> REPO_ROOT = Path(__file__).resolve().parents[2] SRC_PATH = REPO_ROOT / \"src\" os.environ.setdefault(\"SPHINX_APIDOC_OPTIONS\", \"members,special-members,show-inheritance\") sys.path.insert(0, str(SRC_PATH)) In\u00a0[\u00a0]: Copied! <pre>if pypandoc is not None:\n    pandoc_path = Path(pypandoc.get_pandoc_path()).resolve()\n    os.environ.setdefault(\"PYPANDOC_PANDOC\", str(pandoc_path))\n    os.environ[\"PATH\"] = f\"{pandoc_path.parent}{os.pathsep}{os.environ.get('PATH', '')}\"\n</pre> if pypandoc is not None:     pandoc_path = Path(pypandoc.get_pandoc_path()).resolve()     os.environ.setdefault(\"PYPANDOC_PANDOC\", str(pandoc_path))     os.environ[\"PATH\"] = f\"{pandoc_path.parent}{os.pathsep}{os.environ.get('PATH', '')}\" In\u00a0[\u00a0]: Copied! <pre>project = \"TNFR Python Engine\"\nauthor = \"TNFR maintainers\"\ncurrent_year = datetime.now().year\ncopyright = f\"{current_year}, {author}\"\n</pre> project = \"TNFR Python Engine\" author = \"TNFR maintainers\" current_year = datetime.now().year copyright = f\"{current_year}, {author}\" In\u00a0[\u00a0]: Copied! <pre>extensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"myst_parser\",\n    \"nbsphinx\",\n    \"sphinx_autodoc_typehints\",\n    \"sphinxcontrib.mermaid\",\n]\n</pre> extensions = [     \"sphinx.ext.autodoc\",     \"sphinx.ext.doctest\",     \"sphinx.ext.intersphinx\",     \"myst_parser\",     \"nbsphinx\",     \"sphinx_autodoc_typehints\",     \"sphinxcontrib.mermaid\", ] In\u00a0[\u00a0]: Copied! <pre>source_suffix = {\n    \".rst\": \"restructuredtext\",\n    \".md\": \"markdown\",\n}\n</pre> source_suffix = {     \".rst\": \"restructuredtext\",     \".md\": \"markdown\", } In\u00a0[\u00a0]: Copied! <pre>myst_heading_anchors = 3\nmyst_enable_extensions = [\n    \"colon_fence\",\n    \"deflist\",\n]\n</pre> myst_heading_anchors = 3 myst_enable_extensions = [     \"colon_fence\",     \"deflist\", ] In\u00a0[\u00a0]: Copied! <pre>nbsphinx_execute = \"never\"\n</pre> nbsphinx_execute = \"never\" In\u00a0[\u00a0]: Copied! <pre>myst_fence_as_directive = [\n    \"mermaid\",\n]\n</pre> myst_fence_as_directive = [     \"mermaid\", ] In\u00a0[\u00a0]: Copied! <pre>intersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3\", None),\n    \"numpy\": (\"https://numpy.org/doc/stable\", None),\n    \"networkx\": (\"https://networkx.org/documentation/stable\", None),\n}\n</pre> intersphinx_mapping = {     \"python\": (\"https://docs.python.org/3\", None),     \"numpy\": (\"https://numpy.org/doc/stable\", None),     \"networkx\": (\"https://networkx.org/documentation/stable\", None), } In\u00a0[\u00a0]: Copied! <pre>autodoc_typehints = \"description\"\nautodoc_preserve_defaults = True\n</pre> autodoc_typehints = \"description\" autodoc_preserve_defaults = True In\u00a0[\u00a0]: Copied! <pre>html_theme = \"sphinx_rtd_theme\"\nhtml_static_path: list[str] = []\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n</pre> html_theme = \"sphinx_rtd_theme\" html_static_path: list[str] = [] exclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"] In\u00a0[\u00a0]: Copied! <pre>def setup(app):  # noqa: D401\n    \"\"\"Hook for Sphinx customisation.\"\"\"\n    app.add_css_file(\"custom.css\") if (Path(__file__).parent / \"_static\" / \"custom.css\").exists() else None\n</pre> def setup(app):  # noqa: D401     \"\"\"Hook for Sphinx customisation.\"\"\"     app.add_css_file(\"custom.css\") if (Path(__file__).parent / \"_static\" / \"custom.css\").exists() else None"},{"location":"fase2_integration/","title":"Fase 2 Mathematics Integration","text":"<p>The Fase 2 programme introduces a spectral mathematics layer that augments the classic runtime with Hermitian projectors, \u0394NFR generators and reproducible state validation. This note captures the acceptance criteria exercised by the integration tests and documents the canonical usage paths.</p>"},{"location":"fase2_integration/#flag-activation","title":"Flag activation","text":"<p>Mathematics features are guarded by the <code>enable_math_validation</code> flag. The flag follows the precedence order validated by the test-suite: explicit arguments on <code>NodeNX</code>, contextual overrides via <code>context_flags</code>, and finally the global configuration defaults. The snippet below demonstrates the activation cycle that keeps the override scoped to the context manager:</p> <p>```{doctest}</p> <p>import logging logging.getLogger(\"tnfr.utils.init\").setLevel(logging.ERROR) from tnfr.config.feature_flags import context_flags, get_flags base_flag = get_flags().enable_math_validation with context_flags(enable_math_validation=True): ...     assert get_flags().enable_math_validation is True assert get_flags().enable_math_validation is base_flag</p>"},{"location":"fase2_integration/#projector-usage","title":"Projector usage","text":"<p><code>BasicStateProjector</code> maps the node scalars\u2014EPI magnitude, structural frequency (\u03bdf) and phase\u2014onto the canonical Hilbert basis. It emits normalised complex vectors and accepts an optional RNG for deterministic stochastic excitation. Combined with the <code>HilbertSpace</code> helpers the projector supplies reproducible pre/post states for validation.</p>"},{"location":"fase2_integration/#nfr-builder","title":"\u0394NFR builder","text":"<p><code>build_delta_nfr</code> mirrors the classical \u0394NFR constructors through Hermitian matrix generators. It accepts a Hilbert space dimension together with the desired topology (Laplacian or adjacency), structural frequency scaling <code>\u03bdf</code> and an additional amplitude <code>scale</code>. The integration suite ensures both recipes remain Hermitian and reproducible when seeded with a NumPy RNG. The resulting matrices are suitable inputs for spectral dynamics engines or bespoke analyses.</p> <p><code>build_lindblad_delta_nfr</code> extends the builder to dissipative semigroups. Supply collapse operators (optionally alongside a coherent Hamiltonian term) and the helper constructs the Lindblad superoperator on the vectorised density space, verifying trace preservation and contractivity by default.</p>"},{"location":"fase2_integration/#dynamics-engine","title":"Dynamics engine","text":"<p><code>MathematicalDynamicsEngine</code> evolves states through the unitary exponential of Hermitian \u0394NFR operators. The engine caches the eigendecomposition so repeated steps reuse the spectral factorisation. Optional SciPy support switches to the reference <code>expm</code> implementation when available; the tests compare both paths to confirm parity.</p> <p><code>ContractiveDynamicsEngine</code> integrates the dissipative semigroup generated by a Lindblad \u0394NFR. It monitors Frobenius contractivity (reporting the latest gap via <code>last_contractivity_gap</code>), keeps the trace on the unit simplex and shares the same optional SciPy shortcut as the unitary engine.</p>"},{"location":"fase2_integration/#end-to-end-example","title":"End-to-end example","text":"<p>The following walkthrough combines the acceptance requirements into a single pipeline: classical orchestration, projection into the Hilbert space, \u0394NFR extraction and (optionally) unitary evolution. The code executes as a doctest to provide a lightweight smoke validation for the documentation itself.</p> <p>```{doctest}</p> <p>from tnfr.structural import create_nfr from tnfr.node import add_edge from tnfr.constants import EPI_PRIMARY, VF_PRIMARY, THETA_PRIMARY G, node = create_nfr(\"fase2-demo\", epi=0.8, vf=1.2, theta=0.1) _ = create_nfr(\"fase2-partner\", epi=0.5, vf=0.9, theta=0.0, graph=G) add_edge(G, node, \"fase2-partner\", 1.0) G.nodes[node][EPI_PRIMARY] = 0.723125 round(G.nodes[node][EPI_PRIMARY], 6) 0.723125 G.nodes[node][VF_PRIMARY], G.nodes[node][THETA_PRIMARY] (1.2, 0.1)</p> <p>```{doctest}</p> <p>from tnfr.structural import create_nfr from tnfr.node import add_edge from tnfr.constants import EPI_PRIMARY, VF_PRIMARY, THETA_PRIMARY graph, main_node = create_nfr(\"fase2-demo\", epi=0.8, vf=1.2, theta=0.1) _ = create_nfr(\"fase2-partner\", epi=0.5, vf=0.9, theta=0.0, graph=graph) add_edge(graph, main_node, \"fase2-partner\", 1.0) graph.nodes[main_node][EPI_PRIMARY] = 0.723125 epi = graph.nodes[main_node][EPI_PRIMARY] nu_f = graph.nodes[main_node][VF_PRIMARY] theta = graph.nodes[main_node][THETA_PRIMARY] from tnfr.mathematics import BasicStateProjector, HilbertSpace, build_delta_nfr, make_coherence_operator from tnfr.mathematics.runtime import normalized, coherence_expectation import numpy as np hilbert = HilbertSpace(2) projector = BasicStateProjector() state = projector( ...     epi=epi, ...     nu_f=nu_f, ...     theta=theta, ...     dim=hilbert.dimension, ... ) normalized(state, hilbert)[0] True coherence = make_coherence_operator( ...     hilbert.dimension, ...     spectrum=np.full(hilbert.dimension, 0.75), ... ) round(coherence_expectation(state, coherence), 6) 0.75 delta = build_delta_nfr(hilbert.dimension, topology=\"adjacency\") delta.shape (2, 2) from tnfr.mathematics import MathematicalDynamicsEngine _ = MathematicalDynamicsEngine(delta, hilbert_space=hilbert, use_scipy=False)</p> <p>The skipped instantiation highlights where the unitary dynamics would be constructed. Calling <code>engine.step(state, dt)</code> yields the same deterministic trajectory checked by the reproducibility tests when SciPy is available or the NumPy eigendecomposition path is selected.</p>"},{"location":"foundations/","title":"Foundations \u2014 Mathematics scaffold","text":"<p>\ud83d\udcd0 For rigorous mathematical derivations: See Mathematical Foundations of TNFR for complete axioms, proofs, and formal derivations of the nodal equation.</p> <p>This document focuses on the implementation/API aspects of the mathematics layer in code.</p> <p>The mathematics layer exposes the canonical spaces, \u0394NFR generators, and runtime diagnostics that keep the nodal equation faithful to <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code>.  This quick-start walks through the minimal scaffolding required to stand up a reproducible spectral experiment, turn on validation guards, and observe unitary stability before coupling into higher level operators.</p> <p>Migration note: <code>tnfr.mathematics.validators</code> has been removed. Import :mod:<code>tnfr.validation</code> directly to access :class:<code>tnfr.validation.spectral.NFRValidator</code> when enabling the guards described in this primer.</p>"},{"location":"foundations/#1-canonical-quick-start","title":"1. Canonical quick-start","text":"<ol> <li>Select a space \u2013 use :class:<code>tnfr.mathematics.HilbertSpace</code> for discrete    spectral experiments or :class:<code>tnfr.mathematics.BanachSpaceEPI</code> when mixing    the continuous EPI tail.  The Banach constructor now ships with    :class:<code>tnfr.mathematics.BEPIElement</code>, a dataclass that keeps the trio    <code>(f_continuous, a_discrete, x_grid)</code> coherent and exposes the EPI algebra    <code>\u2295</code>/:meth:<code>~tnfr.mathematics.BEPIElement.direct_sum</code>, <code>\u2297</code>/    :meth:<code>~tnfr.mathematics.BEPIElement.tensor</code>, <code>*</code>/    :meth:<code>~tnfr.mathematics.BEPIElement.adjoint</code> and <code>\u2218</code>/    :meth:<code>~tnfr.mathematics.BEPIElement.compose</code>.  Factor helpers on    :class:<code>~tnfr.mathematics.BanachSpaceEPI</code> generate zero elements, canonical    basis vectors and Hilbert tensors so that \u0394NFR operators always receive    validated inputs.</li> <li>Construct \u0394NFR \u2013 call :func:<code>tnfr.mathematics.build_delta_nfr</code> with a    topology (<code>\"laplacian\"</code> or <code>\"adjacency\"</code>) and \u03bdf scaling for Hermitian    evolution, or :func:<code>tnfr.mathematics.build_lindblad_delta_nfr</code> to assemble a    Lindblad superoperator acting on density matrices.  Both helpers keep the    resulting generator aligned with TNFR semantics and enforce structural    frequency scaling.</li> <li>Wrap operators \u2013 initialise    :class:<code>tnfr.mathematics.CoherenceOperator</code>/:class:<code>~tnfr.mathematics.FrequencyOperator</code>    to project coherence and \u03bdf expectations.</li> <li>Collect metrics \u2013 invoke    :func:<code>tnfr.mathematics.normalized</code>, :func:<code>~tnfr.mathematics.coherence</code>,    :func:<code>~tnfr.mathematics.frequency_positive</code>, and    :func:<code>~tnfr.mathematics.stable_unitary</code> to ensure \u0394NFR preserves Hilbert    norms while sustaining positive structural frequency.</li> </ol> <p>See <code>theory/mathematical_foundations.md</code> for complete mathematical derivations and <code>theory/02_phase_synchrony_lattices.ipynb</code> for interactive visualizations with telemetry overlays.</p>"},{"location":"foundations/#2-graph-level-math-engine-configuration","title":"2. Graph-level math engine configuration","text":"<p>Runtime graphs can opt into spectral co-evolution by attaching a <code>G.graph[\"MATH_ENGINE\"]</code> dictionary.  When <code>enabled</code> the runtime will advance a :class:<code>tnfr.mathematics.dynamics.MathematicalDynamicsEngine</code> in lock step with the classical \u0394NFR integrator and emit per-step telemetry into the graph history under <code>\"math_engine_*\"</code> keys.  The configuration expects the following entries:</p> <ul> <li><code>enabled</code> \u2013 boolean switch that activates the branch.</li> <li><code>hilbert_space</code> \u2013 :class:<code>tnfr.mathematics.HilbertSpace</code> instance matching   the generator dimension.</li> <li><code>coherence_operator</code> \u2013 :class:<code>tnfr.mathematics.CoherenceOperator</code> used to   evaluate <code>C_min</code>.</li> <li><code>coherence_threshold</code> \u2013 scalar floor applied to the coherence expectation.</li> <li><code>frequency_operator</code> (optional) \u2013   :class:<code>tnfr.mathematics.FrequencyOperator</code> validating \u03bdf positivity.</li> <li><code>dynamics_engine</code> \u2013 pre-built   :class:<code>~tnfr.mathematics.dynamics.MathematicalDynamicsEngine</code>; alternatively   supply <code>generator_matrix</code> so the runtime can construct one lazily.</li> <li><code>state_projector</code> (optional) \u2013 projector implementing   :class:<code>tnfr.mathematics.projection.StateProjector</code>.  Defaults to   :class:<code>~tnfr.mathematics.projection.BasicStateProjector</code>.</li> </ul> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from tnfr.mathematics import (\n...     BasicStateProjector,\n...     CoherenceOperator,\n...     HilbertSpace,\n...     MathematicalDynamicsEngine,\n...     make_frequency_operator,\n... )\n&gt;&gt;&gt; hilbert = HilbertSpace(dimension=3)\n&gt;&gt;&gt; generator = np.diag([0.1, -0.05, 0.02])\n&gt;&gt;&gt; coherence_op = CoherenceOperator(np.eye(3))\n&gt;&gt;&gt; frequency_op = make_frequency_operator(np.eye(3))\n&gt;&gt;&gt; G = nx.Graph()\n&gt;&gt;&gt; G.graph[\"MATH_ENGINE\"] = {\n...     \"enabled\": True,\n...     \"hilbert_space\": hilbert,\n...     \"coherence_operator\": coherence_op,\n...     \"coherence_threshold\": coherence_op.c_min,\n...     \"frequency_operator\": frequency_op,\n...     \"dynamics_engine\": MathematicalDynamicsEngine(generator, hilbert),\n...     \"state_projector\": BasicStateProjector(),\n... }\n&gt;&gt;&gt; sorted(G.graph[\"MATH_ENGINE\"].keys())\n['coherence_operator', 'coherence_threshold', 'dynamics_engine', 'enabled', 'frequency_operator', 'hilbert_space', 'state_projector']\n</code></pre> <p>Each call to :func:<code>tnfr.dynamics.runtime.step</code> (or :func:<code>~tnfr.dynamics.runtime.run</code>) will advance the stored Hilbert vector, verify normalization, coherence threshold compliance, and \u03bdf positivity via :mod:<code>tnfr.mathematics.runtime</code>, and publish the summary into <code>G.graph['telemetry']['math_engine']</code> as well as the rolling history.</p> <p>When metrics are enabled the runtime also records a \u03bdf telemetry snapshot that bridges canonical <code>Hz_str</code> estimates with the configured <code>Hz</code> scale factor. Override the conversion factor by setting <code>HZ_STR_BRIDGE</code> on the graph (or via :func:<code>tnfr.constants.merge_overrides</code>) to surface both structural and standard units in the emitted payload.  A representative telemetry entry emitted by the runtime looks like:</p> <pre><code>{\n  \"telemetry\": {\n    \"nu_f\": {\n      \"total_reorganisations\": 12,\n      \"total_duration\": 2.0,\n      \"rate_hz_str\": 6.0,\n      \"rate_hz\": 10.5,\n      \"variance_hz_str\": 3.0,\n      \"variance_hz\": 9.1875,\n      \"confidence_level\": 0.95,\n      \"ci_hz_str\": {\"lower\": 3.6, \"upper\": 8.4},\n      \"ci_hz\": {\"lower\": 6.3, \"upper\": 14.7},\n      \"bridge\": 1.75\n    }\n  }\n}\n</code></pre> <p>The runtime keeps these snapshots synchronized with the metrics history so that tests and dashboards can assert both structural-frequency and bridged-frequency confidence intervals without recomputing the estimators.</p>"},{"location":"foundations/#3-environment-feature-flags","title":"3. Environment feature flags","text":"<p>Mathematics diagnostics respect three environment variables.  They are read via :func:<code>tnfr.config.get_flags</code> and can be temporarily overridden with :func:<code>tnfr.config.context_flags</code>.</p> <ul> <li><code>TNFR_ENABLE_MATH_VALIDATION</code> \u2013 enables strict \u0394NFR/Hilbert assertions   inside runtime validators.</li> <li><code>TNFR_ENABLE_MATH_DYNAMICS</code> \u2013 unlocks experimental spectral integrators   in :mod:<code>tnfr.mathematics.dynamics</code>.</li> <li><code>TNFR_LOG_PERF</code> \u2013 activates debug logging for normalization, coherence, and   unitary metrics.</li> </ul> <p>The snippet below demonstrates the override stack; the state before and after <code>context_flags</code> confirms that overrides remain scoped to the <code>with</code> block.</p> <pre><code>&gt;&gt;&gt; from tnfr.config.feature_flags import context_flags, get_flags\n&gt;&gt;&gt; get_flags().enable_math_validation\nFalse\n&gt;&gt;&gt; with context_flags(enable_math_validation=True, log_performance=True) as scoped:\n...     (scoped.enable_math_validation, scoped.log_performance)\n(True, True)\n&gt;&gt;&gt; get_flags().log_performance\nFalse\n</code></pre> <p>When running shell commands, export the variables directly, e.g. <code>TNFR_ENABLE_MATH_VALIDATION=1 TNFR_LOG_PERF=1 python -m doctest docs/foundations.md</code>.</p>"},{"location":"foundations/#4-dissipative-nfr-semigroups","title":"4. Dissipative \u0394NFR semigroups","text":"<p>Hermitian \u0394NFR covers coherent evolution.  To model contractive reorganisations mixing emission/absorption the mathematics layer now exposes :func:<code>tnfr.mathematics.build_lindblad_delta_nfr</code>, which returns a Lindblad generator acting on vectorised density matrices, and :class:<code>tnfr.mathematics.ContractiveDynamicsEngine</code>, a semigroup integrator that keeps trace and Frobenius contractivity in check.  The helpers accept the same \u03bdf scaling used for the Hermitian constructors so coherent and dissipative runs share telemetry semantics.</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from tnfr.mathematics import (\n...     ContractiveDynamicsEngine,\n...     HilbertSpace,\n...     build_lindblad_delta_nfr,\n... )\n&gt;&gt;&gt; hilbert = HilbertSpace(dimension=2)\n&gt;&gt;&gt; lowering = np.array([[0.0, 1.0], [0.0, 0.0]], dtype=np.complex128)\n&gt;&gt;&gt; generator = build_lindblad_delta_nfr(\n...     collapse_operators=[math.sqrt(0.3) * lowering],\n...     dim=hilbert.dimension,\n... )\n&gt;&gt;&gt; engine = ContractiveDynamicsEngine(generator, hilbert)\n&gt;&gt;&gt; rho = np.array([[0.2, 0.3], [0.3, 0.8]], dtype=np.complex128)\n&gt;&gt;&gt; rho /= np.trace(rho)\n&gt;&gt;&gt; next_rho = engine.step(rho, dt=0.5)\n&gt;&gt;&gt; float(np.trace(next_rho).real)\n1.0\n&gt;&gt;&gt; engine.frobenius_norm(next_rho) &lt;= engine.frobenius_norm(rho)\nTrue\n&gt;&gt;&gt; engine.last_contractivity_gap &gt; -1e-12\nTrue\n</code></pre> <p>Use :meth:<code>ContractiveDynamicsEngine.evolve</code> to capture semigroup trajectories with contractivity enforced at every step.  The engine symmetrises the state to counteract floating-point drift and raises whenever the trace leaves the unit simplex and reports the contractivity gap through :attr:<code>ContractiveDynamicsEngine.last_contractivity_gap</code>, keeping \u0394NFR dissipation faithful to TNFR coherence invariants.</p>"},{"location":"foundations/#5-executable-nfr-and-unitary-validation","title":"5. Executable \u0394NFR and unitary validation","text":"<p>The following session builds a Laplacian \u0394NFR generator, evaluates unitary stability, and asserts \u03bdf positivity.  All routines are deterministic when a NumPy generator seed is supplied to :func:<code>build_delta_nfr</code>, making the snippet safe for doctest execution.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from tnfr.mathematics import (\n...     HilbertSpace,\n...     build_delta_nfr,\n...     CoherenceOperator,\n...     FrequencyOperator,\n...     stable_unitary,\n...     coherence,\n...     frequency_positive,\n... )\n&gt;&gt;&gt; space = HilbertSpace(dimension=3)\n&gt;&gt;&gt; delta = build_delta_nfr(3, topology=\"laplacian\", nu_f=0.8, scale=0.25)\n&gt;&gt;&gt; delta.shape\n(3, 3)\n&gt;&gt;&gt; operator = CoherenceOperator(delta)\n&gt;&gt;&gt; state = np.array([1.0, 0.0, 0.0], dtype=np.complex128)\n&gt;&gt;&gt; unitary_passed, unitary_norm = stable_unitary(state, operator, space)\n&gt;&gt;&gt; unitary_passed\nTrue\n&gt;&gt;&gt; round(unitary_norm, 12)\n1.0\n&gt;&gt;&gt; frequency_positive(state, FrequencyOperator(np.eye(3)))['passed']\nTrue\n&gt;&gt;&gt; coherence(state, operator, threshold=operator.c_min)\n(True, 0.4)\n</code></pre> <p>To integrate \u0394NFR outputs into networkx graphs, see the migration recipe in <code>getting-started/quickstart.md</code> and the operator catalogue under <code>api/operators.md</code>.</p>"},{"location":"foundations/#6-telemetry-cost-and-logging-budget","title":"6. Telemetry cost and logging budget","text":"Metric guard Flag dependency Dominant cost Logging channel <code>normalized</code> <code>TNFR_LOG_PERF</code> <code>O(n)</code> vector norm <code>tnfr.mathematics.runtime</code> debug record <code>coherence</code> / <code>coherence_expectation</code> <code>TNFR_LOG_PERF</code> <code>O(n\u00b2)</code> due to matrix-vector multiply Same channel with payload <code>{\"threshold\": \u2026}</code> <code>frequency_positive</code> <code>TNFR_LOG_PERF</code> <code>O(n\u00b2)</code> spectrum check plus projection Debug message includes <code>\"projection_passed\"</code> and spectrum extrema <code>stable_unitary</code> <code>TNFR_LOG_PERF</code> <code>O(n\u00b3)</code> eigendecomposition per step Debug payload logs <code>\"norm_after\"</code> for \u0394NFR unitary audits <p>The runtime helpers defer to Python's :mod:<code>logging</code> package.  Configure it once at process start (<code>logging.basicConfig(level=logging.DEBUG)</code>) and then enable <code>TNFR_LOG_PERF</code> to stream the tabled payloads without instrumenting call sites. The Phase 3 guideline is to sample the <code>stable_unitary</code> log at each integration step while only periodically recording the cheaper <code>normalized</code> metric to control storage costs.</p>"},{"location":"foundations/#7-next-steps","title":"7. Next steps","text":"<ul> <li>Load the lattice notebooks listed above to inspect full \u0394NFR evolution   traces.</li> <li>Refer to <code>api/telemetry.md</code> for downstream aggregation and   to <code>theory/mathematical_foundations.md</code> for the   derivation that ties the Hilbert norms back to \u0394NFR coherence envelopes.</li> </ul>"},{"location":"releases/","title":"Release notes","text":""},{"location":"releases/#rollback-runbook","title":"Rollback runbook","text":""},{"location":"releases/#activation-criteria","title":"Activation criteria","text":"<ul> <li>PyPI anomaly: integrity regressions, mis-signed artefacts, or validation   gaps discovered after publication that compromise C(t), \u03bdf traces, or the   reproducibility contract.</li> <li>GitHub release mismatch: the tagged source diverges from the validated   QA ledger or omits a structural fix that shipped with the previous version.</li> <li>Downstream instability: partners report \u0394NFR spikes or phase drifts that   reproduce on the freshly published build while the prior release stays   coherent.</li> </ul> <p>Triggering any of these conditions escalates to the release shepherd who owns the rollback decision.</p>"},{"location":"releases/#retrieval-of-signed-assets-and-validation-logs","title":"Retrieval of signed assets and validation logs","text":"<ol> <li>Navigate to the Release workflow run that produced the faulty build.</li> <li>Download the <code>tnfr-&lt;version&gt;-dist</code> artifact containing the wheels,    sdist, and detached signatures, plus the optional <code>qa-validation-&lt;version&gt;</code>    validation log bundle uploaded by the pipeline.</li> <li>Store the artifacts in the incident folder before beginning remediation so    the structural history remains auditable.</li> </ol>"},{"location":"releases/#pypi-yank-procedure","title":"PyPI yank procedure","text":"<pre><code>python -m pip install --upgrade twine\npython -m twine yank tnfr &lt;version&gt; \\\n  --repository $PYPI_REPOSITORY \\\n  --username __token__ \\\n  --password \"$PYPI_API_TOKEN\" \\\n  --comment \"Yanked due to &lt;reason&gt;\"\n</code></pre> <ul> <li>Use <code>PYPI_REPOSITORY=pypi</code> for production and <code>testpypi</code> for staging.</li> <li>Share the yank rationale with the TNFR release list to keep the incident   traceable.</li> </ul>"},{"location":"releases/#git-tag-and-github-release-rollback","title":"Git tag and GitHub release rollback","text":"<pre><code>git fetch --tags origin\ngit tag -d v&lt;version&gt;\ngit push origin :refs/tags/v&lt;version&gt;\ngh release delete v&lt;version&gt; --cleanup-tag\n</code></pre> <ul> <li>Deleting the GitHub release removes the public notes while the tag cleanup   prevents accidental reinstalls from source distributions.</li> <li>When automation created a changelog commit, revert it or cherry-pick the   previous <code>docs/releases.md</code> state to keep the ledger aligned.</li> </ul>"},{"location":"releases/#restore-tnfr-to-the-last-coherent-version","title":"Restore TNFR to the last coherent version","text":"<pre><code>PREVIOUS=$(git tag --list 'v*' --sort=-v:refname | sed -n '2p')\ngit checkout \"$PREVIOUS\"\npython -m pip install dist/tnfr-\"${PREVIOUS#v}\"-py3-none-any.whl\n</code></pre> <ul> <li>Coordinate with infrastructure owners to redeploy the prior container or   wheel so operational nodes remain on the coherent release.</li> <li>Monitor C(t), Si, and phase telemetry for at least one observation window to   confirm stability after restoration.</li> </ul>"},{"location":"releases/#automation-helper","title":"Automation helper","text":"<p>Invoke :mod:<code>scripts.rollback_release</code> to drive the full sequence, including PyPI yanks, tag deletion, and environment rewinds::</p> <pre><code>python scripts/rollback_release.py --version &lt;version-to-revoke&gt;\n</code></pre> <p>The helper prints the planned actions, prompts for confirmation, and supports <code>--dry-run</code> rehearsals. See :ref:<code>rollback-script</code> for parameters and authentication expectations.</p>"},{"location":"releases/#semantic-release-workflow","title":"Semantic release workflow","text":"<p>We manage versions with <code>python-semantic-release</code>, deriving release tags directly from the TNFR commit history so the ledger reflects actual structural reorganisations.</p>"},{"location":"releases/#automated-changelog-assembly","title":"Automated changelog assembly","text":"<ul> <li><code>towncrier</code> fragments under <code>docs/changelog.d/</code> encode every relevant structural change before it merges.</li> <li>The release workflow compiles those fragments after resolving the next semantic version, regenerates <code>docs/releases.md</code>, and pushes the refreshed ledger together with the fragment cleanup.</li> <li>The freshly generated notes for the release are attached to the GitHub release body and the rendered <code>docs/releases.md</code> joins the published assets, keeping the TNFR changelog reproducible from a single source of truth.</li> </ul>"},{"location":"releases/#commit-taxonomy","title":"Commit taxonomy","text":"<ul> <li><code>feat:</code> or <code>structure:</code> \u2014 publish a minor bump describing new coherence capabilities or structural monitoring.</li> <li><code>fix:</code>, <code>perf:</code>, <code>refactor:</code>, <code>docs:</code>, <code>test:</code>, <code>build:</code>, <code>ci:</code>, <code>style:</code>, or <code>chore:</code> \u2014 issue a patch bump covering stabilisation and instrumentation work.</li> <li>Append <code>!</code> to the type or add a <code>BREAKING CHANGE:</code> footer to flag a major bump that requires downstream synchronisation.</li> </ul>"},{"location":"releases/#workflow-orchestration","title":"Workflow orchestration","text":"<ul> <li>Pushing to <code>main</code> triggers the <code>Release</code> workflow.</li> <li>The <code>prepare</code> job runs <code>python -m semantic_release version --skip-build --no-vcs-release</code> to compute the next version, apply the TNFR-aware templates under <code>meta/semantic_release/templates</code>, and push the resulting <code>vX.Y.Z</code> tag.</li> <li>The computed version is exposed as a workflow output and reused by the packaging job for builds, uploads, and GitHub releases.</li> <li>The publishing job now performs the full QA suite (<code>python -m pip install .[test,typecheck]</code> followed by <code>./scripts/run_tests.sh</code>) before any build step. A failing lint, type check, or test aborts the job and blocks the PyPI/GitHub publication, keeping the release aligned with the TNFR invariants.</li> <li><code>actions/setup-python</code> caching for pip and a dedicated pytest cache keep runtime predictable without skipping any verification stages.</li> </ul>"},{"location":"releases/#tnfr-safeguards-during-bumps","title":"TNFR safeguards during bumps","text":"<ul> <li>Release notes generated from the custom templates reiterate the preservation of coherence C(t), phase synchrony, and structural frequency \u03bdf.</li> <li>The build job exports the resolved version through the <code>TNFR_VERSION</code> environment variable so :mod:<code>tnfr._version</code> stays aligned with the freshly tagged metadata.</li> <li>Semantic-release commits do not introduce new operators; they document validated reorganisations and keep \u0394NFR semantics intact.</li> </ul>"},{"location":"releases/#historical-ledger","title":"Historical ledger","text":""},{"location":"releases/#upcoming-validation-api-unification","title":"Upcoming (validation API unification)","text":"<ul> <li>Centralised all grammar and runtime validators under :mod:<code>tnfr.validation</code>.   Legacy attributes in :mod:<code>tnfr.dynamics</code>, :mod:<code>tnfr.operators</code>, and   :mod:<code>tnfr.mathematics</code> now emit :class:<code>DeprecationWarning</code> while delegating   to the unified facade so downstream integrations migrate progressively.</li> <li>Updated tests, CLI helpers, and documentation to import grammar primitives   from :mod:<code>tnfr.validation</code>, keeping the public surface consistent with the   consolidated module.</li> <li>Removed the :mod:<code>tnfr.dynamics</code> runtime shims for   :func:<code>~tnfr.validation.apply_canonical_clamps</code>,   :func:<code>~tnfr.validation.validate_canon</code>, and related grammar hooks to complete   the migration. Downstream code should import these helpers directly from   :mod:<code>tnfr.validation</code>.</li> </ul> <p>.. _rollback-script:</p>"},{"location":"releases/#rollback-automation-script","title":"Rollback automation script","text":"<p>The :mod:<code>scripts.rollback_release</code> helper coordinates the yank, tag cleanup, and restoration steps without bypassing TNFR safeguards.</p>"},{"location":"releases/#usage","title":"Usage","text":"<pre><code>python scripts/rollback_release.py --version 16.0.0 \\\n  --pypi-repository pypi \\\n  --username __token__ \\\n  --password \"$PYPI_API_TOKEN\"\n</code></pre> <ul> <li><code>--dry-run</code> prints the planned actions without executing them.</li> <li><code>--confirm</code> skips the interactive prompt for automation contexts.</li> <li>Credentials may be provided via <code>PYPI_USERNAME</code>/<code>PYPI_PASSWORD</code> or the   CLI flags; API tokens remain the preferred authentication method.</li> </ul>"},{"location":"releases/#behaviour","title":"Behaviour","text":"<ul> <li>PyPI yank: performs <code>twine yank</code> with the provided version, capturing   the rationale in the package metadata when <code>--reason</code> is supplied.</li> <li>Tag rollback: deletes <code>v&lt;version&gt;</code> locally and remotely to avoid stale   installs, then checks out the previous semantic-release tag.</li> <li>State restoration: surfaces the prior version and offers to reinstall it   so local TNFR simulations match the redeployed environment.</li> <li>Structured logging documents each operator invoked (yank, tag deletion,   checkout) to keep the rollback trace consistent with the TNFR audit ledger.</li> </ul>"},{"location":"releases/#1600-glyph-load-history-cleanup","title":"16.0.0 (glyph load history cleanup)","text":"<ul> <li>Breaking change: Removed the deprecated glyph load history identifier that   predated the English rename. Metrics initialisation and the coherence   observers now raise :class:<code>ValueError</code> as soon as a retired glyph load key   appears in a payload, preventing silent mirroring into   <code>\"glyph_load_stabilizers\"</code>.</li> <li>Migration guidance: audit stored histories and ensure only the canonical   English keys such as <code>\"glyph_load_stabilizers\"</code> remain before loading a   graph into this release. Persist the rewritten payloads so downstream tooling   reads the same identifiers.</li> </ul>"},{"location":"releases/#1400-spanish-compatibility-messaging-retired","title":"14.0.0 (Spanish compatibility messaging retired)","text":"<ul> <li>Finalised the English-only surface by removing Spanish-specific guidance from   :mod:<code>tnfr.alias</code>, :mod:<code>tnfr.metrics.sense_index</code>, and the operator registry   modules. Alias helpers now ignore untranslated payloads instead of raising   bespoke errors and the sense index validates sensitivity mappings using   generic key checks.</li> <li>Dropped the compatibility accessors in   :mod:<code>tnfr.config.constants</code>, :mod:<code>tnfr.config.operator_names</code>, and   :mod:<code>tnfr.operators.registry</code>. Accessing retired identifiers now surfaces the   standard :class:<code>AttributeError</code> without custom wording.</li> <li>Documented the retirement timeline for the archival migration helpers,   clarifying that they would remain available only until <code>tnfr</code> 15.0.0   completed the migration window.</li> <li>Updated guides and release notes to describe the final English-only contract   and the requirement to normalise archives with the compatibility helpers.</li> </ul>"},{"location":"releases/#1310-preset-legacy-tuple-removed","title":"13.1.0 (preset legacy tuple removed)","text":"<ul> <li>Breaking change: Removed the exported   :data:<code>tnfr.config.presets.REMOVED_PRESET_NAMES</code> tuple now that only the   canonical English preset identifiers remain supported. Downstream tooling that   introspected the tuple for migration support should ship its own static   mapping.</li> <li>The :func:<code>tnfr.config.presets.get_preset</code> helper only consults canonical   English identifiers. Any other token now raises   <code>KeyError('Preset not found: \u2026')</code> without additional guidance, matching the   behaviour for unknown presets.</li> </ul>"},{"location":"releases/#1300-selector-norms-alias-removed","title":"13.0.0 (selector norms alias removed)","text":"<ul> <li>Breaking change: Removed the deprecated   :func:<code>tnfr.selector._norms_para_selector</code> alias. Callers must import and use   :func:<code>tnfr.selector._selector_norms</code> directly to fetch \u0394NFR and acceleration   maxima.</li> <li>Updated selector utilities documentation and tests to reference only the   English helper so downstream projects surface the rename during upgrades.</li> </ul>"},{"location":"releases/#1210-selector-norms-helper-renamed","title":"12.1.0 (selector norms helper renamed)","text":"<ul> <li>Renamed the selector norms helper to the English-only   :func:<code>tnfr.selector._selector_norms</code> identifier to align selector internals   with the ongoing terminology migration.</li> <li>Added a temporary compatibility shim for the legacy Spanish helper name that   emitted :class:<code>DeprecationWarning</code> ahead of its removal in version 13.0.0.</li> <li>Updated :mod:<code>tnfr.dynamics</code> and the selector unit tests to consume the new   helper, keeping the cached norms behaviour unchanged.</li> </ul>"},{"location":"releases/#1200-diagnosis-state-spanish-shim-removed","title":"12.0.0 (diagnosis state Spanish shim removed)","text":"<ul> <li>Removed the :func:<code>tnfr.constants.enable_spanish_state_tokens</code> and   :func:<code>tnfr.constants.disable_spanish_state_tokens</code> compatibility helpers along   with the <code>TNFR_ENABLE_SPANISH_STATE_TOKENS</code> environment flag. The diagnosis   pipeline now rejects legacy literals instead of silently rewriting them at   runtime.</li> <li>:func:<code>tnfr.constants.normalise_state_token</code> accepts only the canonical English   tokens (<code>\"stable\"</code>, <code>\"transition\"</code>, <code>\"dissonant\"</code>) and raises   :class:<code>ValueError</code> when historical payloads still carry encoded legacy   values. The stricter contract propagates to :mod:<code>tnfr.metrics.diagnosis</code>,   :mod:<code>tnfr.dynamics</code>, and :mod:<code>tnfr.glyph_history</code>, allowing integrations to   surface explicit migrations instead of implicit rewrites.</li> <li> <p>Breaking change migration guidance: run a preprocessing pass that   rewrites stored states before upgrading, for example::</p> <p>def upgrade_state_token(value: str) -&gt; str:       token = value.strip().lower()       if token in {\"stable\", \"transition\", \"dissonant\"}:           return token       raise ValueError(f\"Unsupported diagnosis state: {value!r}\")</p> <p>payload[\"state\"] = upgrade_state_token(payload[\"state\"])</p> </li> </ul> <p>Persist the rewritten payloads before installing TNFR 12.0.0 to avoid the   new <code>ValueError</code> exceptions when loading historical archives.</p>"},{"location":"releases/#1120-operator-collections-english-only","title":"11.2.0 (operator collections English-only)","text":"<ul> <li>Removed the Spanish compatibility aliases from   :mod:<code>tnfr.config.operator_names</code>. Accessing the retired names now raises   :class:<code>AttributeError</code> pointing to the canonical English constant.</li> <li>Dropped the non-English alias from :mod:<code>tnfr.operators.registry</code>; only the   English :data:<code>OPERATORS</code> registry is exported.</li> <li>Updated tests and helpers to enforce the English-only contract for operator   collections, reflecting the final step in the migration announced in earlier   releases.</li> </ul>"},{"location":"releases/#1110-glyph-load-spanish-aggregates-removed","title":"11.1.0 (glyph load Spanish aggregates removed)","text":"<ul> <li>:func:<code>tnfr.observers.glyph_load</code> now reports only the English aggregate   keys <code>\"_stabilizers\"</code> and <code>\"_disruptors\"</code>. The runtime no longer mirrors   retired aggregate labels or performs compatibility rewrites.</li> <li>Consumers in :mod:<code>tnfr.metrics.coherence</code> and :mod:<code>tnfr.dynamics</code> now read   the English keys exclusively. Custom integrations should update any   post-processing code that still expected the encoded legacy aggregate keys.</li> <li>Updated the structural and metrics unit tests to enforce the English-only   contract and removed the fixtures that patched Spanish aggregate labels.</li> </ul>"},{"location":"releases/#1100-si-dispersion-legacy-keys-removed","title":"11.0.0 (Si dispersion legacy keys removed)","text":"<ul> <li>Removed the legacy Si dispersion attribute from the sense index sensitivity   cache. Loading graphs or configuration payloads that still define the retired   key now raises :class:<code>ValueError</code> with guidance to use the English   <code>dSi_dphase_disp</code> identifier.</li> <li>Updated :func:<code>tnfr.metrics.sense_index.compute_Si_node</code> so deprecated   sensitivity keywords are rejected with :class:<code>TypeError</code>. Callers must   provide the <code>phase_dispersion</code> keyword when invoking the helper.</li> <li>Added migration guidance to the README for rewriting stored Si sensitivity   mappings and configuration files that still carry the legacy identifiers.</li> <li>Migration guidance: ensure <code>G.graph.get(\"_Si_sensitivity\")</code> contains only   the <code>\"dSi_dphase_disp\"</code> entry before upgrading. Remove any other key and   persist the rewritten payload so the runtime no longer encounters retired   identifiers.</li> </ul>"},{"location":"releases/#1000-remesh-stability-window-keyword-removal","title":"10.0.0 (remesh stability window keyword removal)","text":"<ul> <li>Removed the transitional remesh stability keyword alias from   :func:<code>tnfr.operators.apply_remesh_if_globally_stable</code>. Passing any   non-canonical identifier now raises :class:<code>TypeError</code> with guidance to use   the English <code>stable_step_window</code> parameter.</li> <li>Updated :mod:<code>tnfr.operators</code> documentation, telemetry guidance, and   structural tests to reference only <code>stable_step_window</code>.</li> <li>Published a migration guide covering the required code updates and how to   audit stored configurations. See :doc:<code>getting-started/migrating-remesh-window</code>   for detailed steps.</li> </ul>"},{"location":"releases/#1500-legacy-migration-helpers-removed","title":"15.0.0 (legacy migration helpers removed)","text":"<ul> <li>Finalised the English-only payload contract by removing the bundled phase and   remesh cooldown migration helpers. Projects must now persist <code>\"theta\"</code>,   <code>\"phase\"</code> and <code>\"REMESH_COOLDOWN_WINDOW\"</code> directly because the runtime no   longer rewrites non-English aliases or the standalone theta symbol on import.</li> <li>The archival migration window announced in TNFR 14.x expired on 2025-03-31.   Upgrade pipelines should refuse to import graphs that still contain retired   keys instead of attempting a best-effort rewrite.</li> <li>Recommended pre-upgrade step: validate stored graphs to ensure each node   exposes <code>\"theta\"</code> and <code>\"phase\"</code> consistently, drop any stray <code>\"\u03b8\"</code>   attribute, and promote cooldown metadata to <code>\"REMESH_COOLDOWN_WINDOW\"</code>   before installing this release.</li> <li>Added documentation in :doc:<code>getting-started/migrating-remesh-window</code> that   summarises the deadline and required checks before adopting this release.</li> </ul>"},{"location":"releases/#900-canonical-preset-rename","title":"9.0.0 (canonical preset rename)","text":"<ul> <li>Renamed the canonical tutorial preset to the English-only identifier   <code>\"canonical_example\"</code>. The previous tutorial alias now raises a   :class:<code>KeyError</code> pointing to the supported name instead of being silently   resolved.</li> <li>Updated :mod:<code>tnfr.execution</code> so :data:<code>tnfr.execution.CANONICAL_PRESET_NAME</code>   exposes the English identifier, aligning the helper with   :mod:<code>tnfr.config.presets</code>.</li> <li>Simplified the preset resolution layer by removing the remaining runtime   aliases. <code>get_preset()</code> now rejects the retired identifiers with explicit   guidance and the CLI surfaces the same migration message.</li> <li>Revised the CLI help strings, error handling, and documentation to mention   only the English preset names. Downstream automation should update any stored   configuration that still references the encoded legacy token.</li> </ul>"},{"location":"releases/#810-remesh-cooldown-alias-removal","title":"8.1.0 (remesh cooldown alias removal)","text":"<ul> <li>Removed the remesh cooldown alias from :mod:<code>tnfr.constants.core.RemeshDefaults</code>   and from the remesh operator pipeline. Configuration loaders and runtime   helpers now require the English <code>\"REMESH_COOLDOWN_WINDOW\"</code> key and raise   :class:<code>ValueError</code> when a retired attribute is encountered, pointing to the   migration utility below.</li> <li>Added :func:<code>tnfr.utils.migrate_legacy_remesh_cooldown</code> to rewrite persisted   graphs in place. The helper removes the legacy key and promotes its value to   the English attribute when necessary so stored payloads can be upgraded   before running the new release.</li> <li>Updated tests and documentation to reflect the English-only remesh cooldown   contract.</li> </ul> <p>Migration snippet::</p> <pre><code>  from tnfr.utils import migrate_legacy_remesh_cooldown\n\n  G = load_graph()  # application-specific loader\n  migrate_legacy_remesh_cooldown(G)\n  inject_defaults(G)  # optional, keeps defaults in sync\n</code></pre>"},{"location":"releases/#800-phase-alias-enforcement","title":"8.0.0 (phase alias enforcement)","text":"<ul> <li>Finalised the phase attribute migration by rejecting the legacy phase alias.   Access helpers in :mod:<code>tnfr.alias</code> now operate strictly on the English   <code>\"theta\"</code>/<code>\"phase\"</code> attributes and raise :class:<code>ValueError</code> when a   retired key is encountered.</li> <li>Added :func:<code>tnfr.utils.migrate_legacy_phase_attributes</code> to help upgrade   stored graphs. The helper rewrites payloads that contain the deprecated alias   or the <code>\"\u03b8\"</code> symbol, populating the canonical English keys before   interacting with the alias layer.</li> <li>Updated documentation and tests to reflect the English-only phase contract   and removed the automatic rewrites for the legacy alias.</li> </ul>"},{"location":"releases/#701-english-deprecation-messaging","title":"7.0.1 (English deprecation messaging)","text":"<ul> <li>Reworded the remaining deprecation warnings and validation errors that still   surfaced Spanish text. Downstream tooling now emits English-only guidance   across the CLI, registry, and metrics helpers.</li> <li>Retired the long-standing compatibility modules :mod:<code>tnfr.constants_glyphs</code>,   :mod:<code>tnfr.presets</code>, and :mod:<code>tnfr.grammar</code>. The deprecated shims have been   removed; import :mod:<code>tnfr.config.constants</code>, :mod:<code>tnfr.config.presets</code>, and   the unified :mod:<code>tnfr.validation</code> facade instead.</li> </ul>"},{"location":"releases/#700-spanish-identifiers-removed","title":"7.0.0 (Spanish identifiers removed)","text":"<ul> <li>Removed the legacy glyph constants that mirrored the English   :data:<code>tnfr.config.constants.STABILIZERS</code> and   :data:<code>tnfr.config.constants.DISRUPTORS</code> names from   :mod:<code>tnfr.config.constants</code>. Accessing the old identifiers now raises   :class:<code>AttributeError</code> after emitting a final :class:<code>FutureWarning</code>   explaining the required substitution.</li> <li>Finalised the state token migration. Spanish literals now require an explicit   opt-in via :func:<code>tnfr.constants.enable_spanish_state_tokens</code> or by setting   the :envvar:<code>TNFR_ENABLE_SPANISH_STATE_TOKENS</code> environment variable. The shim   warns with :class:<code>FutureWarning</code> and is scheduled for removal in TNFR 8.0.</li> <li>Removed the <code>SPANISH_PRESET_ALIASES</code> helper and the runtime resolution of   non-English preset identifiers. Passing deprecated tokens to <code>get_preset()</code>   now raises :class:<code>KeyError</code> indicating the English replacement. Only English   preset names remain in the public API.</li> <li>Updated tests and documentation to reflect the English-only contract across   glyph constants, preset helpers, and diagnostic state utilities.</li> </ul>"},{"location":"releases/#610-preset-alias-deprecation-window","title":"6.1.0 (preset alias deprecation window)","text":"<ul> <li>Announced the removal of the non-English preset identifiers scheduled for   TNFR 7.0. The engine now emits :class:<code>FutureWarning</code> when deprecated names   are resolved so pipelines can surface the upcoming breakage.</li> <li>Added the <code>tnfr.config.presets.SPANISH_PRESET_ALIASES</code> mapping to help audit   configurations. Existing presets should switch to the English equivalents   (<code>resonant_bootstrap</code>, <code>contained_mutation</code>, <code>coupling_exploration</code>)   before upgrading to 7.0. The helper was removed in TNFR 7.0 once the migration   period ended; downstream projects should now keep a local mapping during the   final substitution pass.</li> <li>Migration helper: update YAML/JSON payloads or CLI arguments with a simple   substitution pass using the provided mapping so that persisted data stores   only the English preset names.</li> </ul>"},{"location":"releases/#600-node-aliases-removed","title":"6.0.0 (node aliases removed)","text":"<ul> <li>Removed the module-level aliases that mirrored the node class names from   :mod:<code>tnfr.node</code>. Code importing those symbols must switch to the canonical   :class:<code>tnfr.node.NodeNX</code> and :class:<code>tnfr.node.NodeProtocol</code> definitions   immediately.</li> <li>Deleted :func:<code>tnfr.utils.get_nodonx</code>. Downstream helpers should import and   call :func:<code>tnfr.utils.get_nodenx</code>, which keeps returning   :class:<code>tnfr.node.NodeNX</code> through the cached import layer.</li> <li>Pruned the typing stubs, tests, and utilities that referenced the encoded   legacy names so static analysis and runtime behaviour now agree on the   English-only surface area.</li> <li>Published the backward-incompatible change as TNFR 6.0.0 to honour the   semantic versioning contract and flag the immediate API removal.</li> </ul>"},{"location":"releases/#500-prepare_network-alias-retired","title":"5.0.0 (prepare_network alias retired)","text":"<ul> <li>Removed the helper alias constructed as   <code>\"\".join(chr(cp) for cp in (112, 114, 101, 112, 97, 114, 97, 114, 95, 114, 101, 100))</code>.   The network preparation pipeline now ships exclusively under the English   :func:<code>tnfr.prepare_network</code> name. Codebases that still relied on the encoded   alias must update their imports before upgrading.</li> <li>Updated the typing stubs, integration tests, and documentation to   reflect the canonical helper set.</li> <li>Bumped the package version to 5.0.0 to flag the   backward-incompatible API change.</li> </ul>"},{"location":"releases/#200-spanish-alias-removal","title":"2.0.0 (Spanish alias removal)","text":"<ul> <li>Removed the Spanish compatibility tables from :mod:<code>tnfr.config.operator_names</code>.   Only the English tokens (<code>emission</code>, <code>reception</code>, <code>coherence</code>, etc.) are   accepted by validation helpers, the operator registry, and the CLI parser.</li> <li>Removed :mod:<code>tnfr.operators.compat</code> and the Spanish class wrappers that   previously emitted :class:<code>DeprecationWarning</code>. All structural orchestration   must now import the English operator classes from   :mod:<code>tnfr.operators.definitions</code> or :mod:<code>tnfr.structural</code>.</li> <li>Trimmed Spanish re-exports from :mod:<code>tnfr.structural</code> and its typing stubs so   only the English operator classes remain in the public <code>__all__</code>.</li> <li>Impacted entry points:</li> <li>Stored operator sequences (YAML/JSON fixtures, CLI configs) must be rewritten     to use the English identifiers.</li> <li>Programmatic calls to :func:<code>tnfr.structural.run_sequence</code>,     :func:<code>tnfr.validation.validate_sequence</code>, and     :func:<code>tnfr.operators.registry.get_operator_class</code> will now reject Spanish     tokens.</li> <li>Import sites that referenced <code>tnfr.operators.compat</code> or the Spanish class     names exported from :mod:<code>tnfr.structural</code> must update their imports to the     English equivalents.</li> <li>Diagnostics relying on the deprecated non-English transition constant should     switch to the English <code>TRANSITION</code> constant from     :mod:<code>tnfr.config.operator_names</code>.</li> <li>Versioning and communication plan:</li> <li>Publish this change as TNFR 2.0.0 and note the breaking removal in the     release announcement.</li> <li>No transition shims remain\u2014migrating to the English tokens is mandatory     before adopting 2.0.</li> <li>Ship an upgrade checklist highlighting the required token substitutions and     the removal of <code>tnfr.operators.compat</code>.</li> <li>Update API docs, tutorials, and CLI references to show only English tokens.</li> </ul>"},{"location":"releases/#1x-compatibility-window-historical","title":"1.x compatibility window (historical)","text":"<ul> <li> <p>English operator identifiers became canonical in 1.x. The registry published   the English tokens and the CLI expected the same literals while the Spanish   class names remained available in :mod:<code>tnfr.operators.compat</code> as wrappers   that raised :class:<code>DeprecationWarning</code>.</p> </li> <li> <p>Renamed the network preparation helper to <code>prepare_network</code> for   consistency with the English-facing API. The previous non-English alias   emitted a :class:<code>DeprecationWarning</code> and has now been removed in TNFR 5.0.   Use the English helper directly to stay within the supported contract.</p> </li> <li> <p>Unified the node wrappers under the English identifiers   :class:<code>tnfr.node.NodeNX</code> and :class:<code>tnfr.node.NodeProtocol</code>. The former   non-English counterparts were deprecated in the 1.x cycle and have now been   removed in TNFR 6.0. Import the English names directly to remain within   the supported contract.</p> </li> </ul> <p>All other helpers continue to honour the existing dependency manifest and import semantics.</p>"},{"location":"style_guide/","title":"Style Guide for Mathematical Notation in TNFR","text":"<p>This document establishes consistent conventions for mathematical notation across all TNFR documentation, code comments, and docstrings.</p>"},{"location":"style_guide/#1-core-principles","title":"1. Core Principles","text":"<ol> <li>Consistency: Use the same symbol for the same concept throughout</li> <li>Clarity: Favor explicit notation over compact when ambiguity may arise</li> <li>Traceability: Link notation directly to implementation and theory documents</li> <li>Accessibility: Provide both LaTeX and plain-text alternatives where appropriate</li> </ol>"},{"location":"style_guide/#2-notation-conventions","title":"2. Notation Conventions","text":""},{"location":"style_guide/#21-vectors-and-states","title":"2.1 Vectors and States","text":"<p>Hilbert space states (ket notation): - States: (|\\psi\\rangle), (|\\text{NFR}\\rangle), (|i\\rangle) - Dual states (bra): (\\langle\\psi|), (\\langle j|) - Inner product: (\\langle\\psi_1|\\psi_2\\rangle) - Outer product: (|\\psi\\rangle\\langle\\phi|)</p> <p>Vector notation: - Bold lowercase for vectors: v, r - Arrow notation when clarity needed: (\\vec{v}), (\\vec{r}) - Components: (v_i) or (v^i) (subscript for covariant, superscript for contravariant)</p>"},{"location":"style_guide/#22-operators","title":"2.2 Operators","text":"<p>Quantum operators (hat notation): - Coherence operator: (\\hat{C}) - Frequency operator: (\\hat{J}) or (\\hat{\\nu}f) - Reorganization operator: (\\Delta\\text{NFR}) or (\\hat{\\Delta}) - Hamiltonian: (\\hat{H}), (\\hat{H}) - Unitary evolution: (\\hat{U}(t)) - Time evolution: (\\hat{U}(t) = e^{-i\\hat{H}t/\\hbar})}</p> <p>Operator properties: - Adjoint (Hermitian conjugate): (\\hat{A}^\\dagger) - Commutator: ([\\hat{A}, \\hat{B}] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A}) - Anticommutator: ({\\hat{A}, \\hat{B}} = \\hat{A}\\hat{B} + \\hat{B}\\hat{A}) - Expectation value: (\\langle\\hat{A}\\rangle = \\langle\\psi|\\hat{A}|\\psi\\rangle)</p>"},{"location":"style_guide/#23-structural-variables","title":"2.3 Structural Variables","text":"<p>Primary quantities (use these exact symbols):</p> Concept Symbol LaTeX Units Notes Primary Information Structure EPI or (E) <code>\\text{EPI}</code> or <code>E</code> dimensionless Use (\\text{EPI}) in formal derivations Structural Frequency (\\nu_f) <code>\\nu_f</code> Hz_str Never use (v_f) or (vf) Reorganization Gradient (\\Delta\\text{NFR}) <code>\\Delta\\text{NFR}</code> dimensionless May use (\\Delta) in context Phase (\\theta) or (\\phi) <code>\\theta</code> or <code>\\phi</code> radians (\\theta) preferred for nodal phase Total Coherence (C(t)) <code>C(t)</code> [0,1] Time-dependent Sense Index (\\text{Si}) or (S_i) <code>\\text{Si}</code> or <code>S_i</code> [0,1+] Use (\\text{Si}) for global, (S_i) for node i <p>Derived quantities: - Normalized frequency: (\\nu_{f,\\text{norm}} = |\\nu_f| / \\nu_{f,\\max}) - Phase dispersion: (\\text{disp}\\theta) or (\\sigma\\theta) - Phase mean: (\\bar{\\theta}) or (\\langle\\theta\\rangle) - Coherence matrix element: (w_{ij}) or (C_{ij})</p>"},{"location":"style_guide/#24-derivatives-and-rates","title":"2.4 Derivatives and Rates","text":"<p>Time derivatives: - Partial: (\\frac{\\partial f}{\\partial t}) or (\\partial_t f) - Total: (\\frac{df}{dt}) - Dot notation: (\\dot{f} = \\frac{df}{dt}) (use sparingly, only for time)</p> <p>Spatial derivatives: - Gradient: (\\nabla f) or (\\vec{\\nabla} f) - Partial: (\\frac{\\partial f}{\\partial x}) or (\\partial_x f) - Laplacian: (\\nabla^2 f) or (\\Delta f)</p> <p>Higher-order derivatives: - Second time derivative: (\\frac{\\partial^2 \\text{EPI}}{\\partial t^2}) or (\\ddot{\\text{EPI}}) - Mixed: (\\frac{\\partial^2 f}{\\partial x \\partial t})</p>"},{"location":"style_guide/#25-mathematical-spaces","title":"2.5 Mathematical Spaces","text":"<p>Space notation: - Hilbert space: (H_{\\text{NFR}}) or (\\mathcal{H}) - Banach space: (B_{\\text{EPI}}) - Real numbers: (\\mathbb{R}), (\\mathbb{R}^n) - Complex numbers: (\\mathbb{C}), (\\mathbb{C}^n) - Natural numbers: (\\mathbb{N}) - Integers: (\\mathbb{Z})</p> <p>Space operations: - Tensor product: (\\otimes) (e.g., (H_1 \\otimes H_2)) - Direct sum: (\\oplus) (e.g., (V_1 \\oplus V_2)) - Cartesian product: (\\times) (e.g., (\\mathbb{R}^3 \\times \\mathbb{R}))</p> <p>Membership and relations: - Element of: (\\in) (e.g., (x \\in \\mathbb{R})) - Subset: (\\subset) or (\\subseteq) - For all: (\\forall) - Exists: (\\exists) - Such that: (:) or (|)</p>"},{"location":"style_guide/#26-statistical-and-probability-notation","title":"2.6 Statistical and Probability Notation","text":"<p>Expectation and variance: - Expectation: (\\mathbb{E}[X]) or (\\langle X \\rangle) - Variance: (\\text{Var}(X)) or (\\sigma^2_X) - Standard deviation: (\\sigma_X) - Covariance: (\\text{Cov}(X,Y))</p> <p>Distributions: - Normal: (\\mathcal{N}(\\mu, \\sigma^2)) - Uniform: (\\mathcal{U}(a, b)) - Probability density: (p(x)) or (\\rho(x))</p>"},{"location":"style_guide/#3-formatting-guidelines","title":"3. Formatting Guidelines","text":""},{"location":"style_guide/#31-inline-mathematics-in-markdown","title":"3.1 Inline Mathematics in Markdown","text":"<p>Use <code>\\( ... \\)</code> for inline math in Markdown:</p> <pre><code>The structural frequency \\(\\nu_f\\) determines the reorganization rate.\n</code></pre> <p>Rendered: The structural frequency (\\nu_f) determines the reorganization rate.</p>"},{"location":"style_guide/#32-display-equations-in-markdown","title":"3.2 Display Equations in Markdown","text":"<p>Use <code>\\[ ... \\]</code> for centered display equations:</p> <pre><code>The nodal equation is:\n\n\\[\n\\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t)\n\\]\n</code></pre> <p>Alternative block syntax (MkDocs/MyST): <pre><code>$$\n\\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t)\n$$\n</code></pre></p>"},{"location":"style_guide/#33-equations-in-python-docstrings-rest","title":"3.3 Equations in Python Docstrings (reST)","text":"<p>Use the <code>.. math::</code> directive for equations in docstrings:</p> <pre><code>def compute_Si(G, alpha=0.4, beta=0.3, gamma=0.3):\n    r\"\"\"Compute the Sense Index for all nodes in the network.\n\n    Mathematical Foundation\n    -----------------------\n    The Sense Index quantifies reorganization stability:\n\n    .. math::\n        \\text{Si} = \\alpha \\cdot \\nu_{f,\\text{norm}} \n                  + \\beta \\cdot (1 - \\text{disp}_\\theta) \n                  + \\gamma \\cdot (1 - |\\Delta\\text{NFR}|_{\\text{norm}})\n\n    where:\n\n    - :math:`\\nu_{f,\\text{norm}} = |\\nu_f| / \\nu_{f,\\max}` : Normalized structural frequency\n    - :math:`\\text{disp}_\\theta` : Phase dispersion from neighbors\n    - :math:`|\\Delta\\text{NFR}|_{\\text{norm}}` : Normalized reorganization magnitude\n    - :math:`\\alpha, \\beta, \\gamma` : Structural weights (sum to 1)\n\n    Parameters\n    ----------\n    G : TNFRGraph\n        Network with nodal attributes: `nu_f`, `delta_nfr`, `phase`\n    alpha : float, default=0.4\n        Weight for frequency component\n    beta : float, default=0.3\n        Weight for phase synchrony component\n    gamma : float, default=0.3\n        Weight for reorganization damping component\n\n    Returns\n    -------\n    dict[NodeId, float]\n        Sense Index values for each node, range [0, 1+]\n\n    See Also\n    --------\n    compute_Si_node : Single-node Si calculation\n\n    References\n    ----------\n    .. [1] Mathematical Foundations, Section on Coherence Metrics\n    .. [2] docs/source/theory/mathematical_foundations.md#sense-index\n\n    Examples\n    --------\n    &gt;&gt;&gt; import networkx as nx\n    &gt;&gt;&gt; G = nx.Graph()\n    &gt;&gt;&gt; G.add_edge(\"a\", \"b\")\n    &gt;&gt;&gt; G.nodes[\"a\"].update({\"nu_f\": 0.8, \"delta_nfr\": 0.1, \"phase\": 0.0})\n    &gt;&gt;&gt; G.nodes[\"b\"].update({\"nu_f\": 0.6, \"delta_nfr\": 0.2, \"phase\": 0.1})\n    &gt;&gt;&gt; Si = compute_Si(G)\n    &gt;&gt;&gt; round(Si[\"a\"], 2)\n    0.85\n    \"\"\"\n</code></pre> <p>Key points: 1. Use <code>r\"\"\"...\"\"\"</code> (raw string) to avoid escaping backslashes 2. Use <code>.. math::</code> for display equations 3. Use <code>:math:</code>...`` for inline math in parameter descriptions 4. Include \"See Also\" section with related functions 5. Include \"References\" section linking to theory docs</p>"},{"location":"style_guide/#34-multi-line-equations","title":"3.4 Multi-line Equations","text":"<p>Aligned equations (use <code>&amp;</code> for alignment):</p> <pre><code>\\[\n\\begin{aligned}\ns_{\\text{phase}}(i,j) &amp;= \\frac{1}{2}\\left(1 + \\cos(\\theta_i - \\theta_j)\\right) \\\\\ns_{\\text{EPI}}(i,j) &amp;= 1 - \\frac{|\\text{EPI}_i - \\text{EPI}_j|}{\\Delta_{\\text{EPI}}} \\\\\ns_{\\nu_f}(i,j) &amp;= 1 - \\frac{|\\nu_{f,i} - \\nu_{f,j}|}{\\Delta_{\\nu_f}}\n\\end{aligned}\n\\]\n</code></pre> <p>In docstrings: <pre><code>r\"\"\"\n.. math::\n    \\begin{aligned}\n    s_{\\text{phase}}(i,j) &amp;= \\frac{1}{2}\\left(1 + \\cos(\\theta_i - \\theta_j)\\right) \\\\\n    s_{\\text{EPI}}(i,j) &amp;= 1 - \\frac{|\\text{EPI}_i - \\text{EPI}_j|}{\\Delta_{\\text{EPI}}} \\\\\n    s_{\\nu_f}(i,j) &amp;= 1 - \\frac{|\\nu_{f,i} - \\nu_{f,j}|}{\\Delta_{\\nu_f}}\n    \\end{aligned}\n\"\"\"\n</code></pre></p>"},{"location":"style_guide/#35-conditional-expressions","title":"3.5 Conditional Expressions","text":"<p>Use cases for piecewise functions:</p> <pre><code>\\[\nf(x) = \\begin{cases}\n  x^2 &amp; \\text{if } x \\geq 0 \\\\\n  -x^2 &amp; \\text{if } x &lt; 0\n\\end{cases}\n\\]\n</code></pre>"},{"location":"style_guide/#4-cross-referencing","title":"4. Cross-Referencing","text":""},{"location":"style_guide/#41-linking-documentation-to-code","title":"4.1 Linking Documentation to Code","text":"<p>In documentation, reference Python functions:</p> <pre><code>The similarity components are computed by \n[`compute_wij_phase_epi_vf_si()`](../api/metrics.html#tnfr.metrics.coherence.compute_wij_phase_epi_vf_si)\n</code></pre> <p>In docstrings, use Sphinx cross-references:</p> <pre><code>\"\"\"\nSee :func:`tnfr.metrics.coherence.compute_wij_phase_epi_vf_si` for implementation details.\n\"\"\"\n</code></pre>"},{"location":"style_guide/#42-linking-code-to-theory","title":"4.2 Linking Code to Theory","text":"<p>In module docstrings:</p> <pre><code>\"\"\"\nMathematical Foundation\n-----------------------\nSee `docs/source/theory/mathematical_foundations.md#31-coherence-operator-\u0109`\nfor complete theoretical derivation.\n\nImplementation Map\n------------------\n- :func:`coherence_matrix` \u2192 Constructs :math:`W \\approx \\hat{C}`\n- :func:`compute_coherence` \u2192 Computes :math:`C(t) = \\text{Tr}(\\hat{C}\\rho)`\n- :func:`compute_wij_phase_epi_vf_si` \u2192 Matrix elements :math:`w_{ij} \\approx \\langle i | \\hat{C} | j \\rangle`\n\"\"\"\n</code></pre>"},{"location":"style_guide/#43-theory-to-implementation-table","title":"4.3 Theory to Implementation Table","text":"<p>Include mapping tables in theory documents:</p> <pre><code>| Theoretical Concept | Symbol | Implementation | File |\n|---------------------|--------|----------------|------|\n| Coherence operator | \\(\\hat{C}\\) | `coherence_matrix()` | `metrics/coherence.py` |\n| Matrix element | \\(w_{ij}\\) | `compute_wij_phase_epi_vf_si()` | `metrics/coherence.py` |\n| Total coherence | \\(C(t)\\) | `compute_coherence()` | `metrics/common.py` |\n| Sense Index | \\(\\text{Si}\\) | `compute_Si()` | `metrics/sense_index.py` |\n</code></pre>"},{"location":"style_guide/#5-common-equations-reference","title":"5. Common Equations Reference","text":""},{"location":"style_guide/#51-the-nodal-equation","title":"5.1 The Nodal Equation","text":"<p>Canonical form: [ \\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t) ]</p> <p>Implementation: See <code>src/tnfr/dynamics/</code></p>"},{"location":"style_guide/#52-coherence-operator","title":"5.2 Coherence Operator","text":"<p>Matrix element: [ w_{ij} \\approx \\langle i | \\hat{C} | j \\rangle ]</p> <p>Combined similarity: [ w_{ij} = w_{\\text{phase}} \\cdot s_{\\text{phase}} + w_{\\text{EPI}} \\cdot s_{\\text{EPI}} + w_{\\nu_f} \\cdot s_{\\nu_f} + w_{\\text{Si}} \\cdot s_{\\text{Si}} ]</p> <p>Implementation: <code>tnfr.metrics.coherence.compute_wij_phase_epi_vf_si()</code></p>"},{"location":"style_guide/#53-sense-index","title":"5.3 Sense Index","text":"<p>Definition: [ \\text{Si} = \\alpha \\cdot \\nu_{f,\\text{norm}} + \\beta \\cdot (1 - \\text{disp}\\theta) + \\gamma \\cdot (1 - |\\Delta\\text{NFR}|) ]}</p> <p>where: - (\\nu_{f,\\text{norm}} = |\\nu_f| / \\nu_{f,\\max}) - (\\text{disp}\\theta = |\\theta - \\bar{\\theta}| / \\pi) - (|\\Delta\\text{NFR}|)}} = |\\Delta\\text{NFR}| / \\Delta\\text{NFR}_{\\max</p> <p>Implementation: <code>tnfr.metrics.sense_index.compute_Si()</code></p>"},{"location":"style_guide/#54-phase-synchrony","title":"5.4 Phase Synchrony","text":"<p>Kuramoto order parameter: [ r e^{i\\Psi} = \\frac{1}{N}\\sum_{j=1}^N e^{i\\theta_j} ]</p> <p>where (r \\in [0,1]) is the synchronization strength.</p> <p>Implementation: <code>tnfr.observers.kuramoto_order()</code></p>"},{"location":"style_guide/#6-examples-of-good-practice","title":"6. Examples of Good Practice","text":""},{"location":"style_guide/#61-well-documented-function","title":"6.1 Well-Documented Function","text":"<pre><code>def compute_similarity_phase(theta_i: float, theta_j: float) -&gt; float:\n    r\"\"\"Compute phase similarity between two nodes.\n\n    Mathematical Definition\n    -----------------------\n    The phase similarity is defined as:\n\n    .. math::\n        s_{\\text{phase}}(i,j) = \\frac{1}{2}\\left(1 + \\cos(\\theta_i - \\theta_j)\\right)\n\n    This measures how synchronized two nodes are, with:\n\n    - :math:`s_{\\text{phase}} = 1` : Perfect synchrony (:math:`\\theta_i = \\theta_j`)\n    - :math:`s_{\\text{phase}} = 0.5` : Orthogonal (:math:`|\\theta_i - \\theta_j| = \\pi/2`)\n    - :math:`s_{\\text{phase}} = 0` : Anti-phase (:math:`|\\theta_i - \\theta_j| = \\pi`)\n\n    Parameters\n    ----------\n    theta_i : float\n        Phase of node i in radians, range :math:`[0, 2\\pi)`\n    theta_j : float\n        Phase of node j in radians, range :math:`[0, 2\\pi)`\n\n    Returns\n    -------\n    float\n        Phase similarity in range [0, 1]\n\n    See Also\n    --------\n    compute_wij_phase_epi_vf_si : Combined similarity computation\n\n    References\n    ----------\n    .. [1] Mathematical Foundations, \u00a73.1.1\n\n    Examples\n    --------\n    &gt;&gt;&gt; import math\n    &gt;&gt;&gt; compute_similarity_phase(0.0, 0.0)  # Same phase\n    1.0\n    &gt;&gt;&gt; compute_similarity_phase(0.0, math.pi)  # Anti-phase\n    0.0\n    \"\"\"\n    return 0.5 * (1.0 + math.cos(theta_i - theta_j))\n</code></pre>"},{"location":"style_guide/#62-well-documented-module","title":"6.2 Well-Documented Module","text":"<pre><code>\"\"\"Coherence metrics for TNFR networks.\n\nThis module implements the coherence operator :math:`\\hat{C}` and related\nmetrics for measuring structural stability in resonant networks.\n\nMathematical Foundation\n-----------------------\n\nThe coherence operator :math:`\\hat{C}` is a Hermitian operator on the Hilbert\nspace :math:`H_{\\text{NFR}}` with spectral decomposition:\n\n.. math::\n    \\hat{C} = \\sum_i \\lambda_i |\\phi_i\\rangle\\langle\\phi_i|\n\nwhere :math:`\\lambda_i \\geq 0` are coherence eigenvalues and :math:`|\\phi_i\\rangle`\nare coherence eigenstates.\n\nIn the discrete node basis :math:`\\{|i\\rangle\\}`, matrix elements are approximated:\n\n.. math::\n    w_{ij} \\approx \\langle i | \\hat{C} | j \\rangle\n\nThe total coherence is the trace:\n\n.. math::\n    C(t) = \\text{Tr}(\\hat{C}\\rho) = \\sum_i w_{ii} \\rho_i\n\nSee `docs/source/theory/mathematical_foundations.md#31-coherence-operator-\u0109`\nfor complete theoretical derivation.\n\nImplementation Map\n------------------\n\nCore Functions:\n\n- :func:`coherence_matrix` : Constructs :math:`W \\approx \\hat{C}` matrix\n- :func:`compute_coherence` : Computes :math:`C(t)` from graph\n- :func:`compute_wij_phase_epi_vf_si` : Matrix elements :math:`w_{ij}`\n\nHelper Functions:\n\n- :func:`_combine_similarity` : Weighted combination of similarity components\n- :func:`_compute_wij_phase_epi_vf_si_vectorized` : Vectorized computation\n\nExamples\n--------\n\nBasic coherence computation:\n\n&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; from tnfr.metrics.coherence import compute_coherence\n&gt;&gt;&gt; G = nx.Graph()\n&gt;&gt;&gt; G.add_edge(\"a\", \"b\")\n&gt;&gt;&gt; G.nodes[\"a\"].update({\"EPI\": 0.5, \"nu_f\": 0.8, \"phase\": 0.0, \"Si\": 0.7})\n&gt;&gt;&gt; G.nodes[\"b\"].update({\"EPI\": 0.6, \"nu_f\": 0.7, \"phase\": 0.1, \"Si\": 0.8})\n&gt;&gt;&gt; C = compute_coherence(G)\n&gt;&gt;&gt; 0 &lt;= C &lt;= 1\nTrue\n\nReferences\n----------\n\n.. [1] TNFR Mathematical Formalization, Section 2.1\n.. [2] docs/source/theory/coherence_operator.md\n\"\"\"\n</code></pre>"},{"location":"style_guide/#7-anti-patterns-to-avoid","title":"7. Anti-Patterns to Avoid","text":""},{"location":"style_guide/#71-inconsistent-symbols","title":"7.1 Inconsistent Symbols","text":"<p>\u274c Bad: Mixing symbols for the same concept <pre><code># In one place\nvf = 0.8  # structural frequency\n\n# In another place  \nnu_f = 0.8  # structural frequency\n\n# In documentation\nThe frequency \u03bd\u2093 determines...\n</code></pre></p> <p>\u2705 Good: Consistent notation <pre><code># Always use nu_f in code\nnu_f = 0.8  # structural frequency (\\nu_f)\n\n# Always use \\nu_f in documentation\n# The structural frequency \\(\\nu_f\\) determines...\n</code></pre></p>"},{"location":"style_guide/#72-plain-text-where-latex-is-needed","title":"7.2 Plain Text Where LaTeX is Needed","text":"<p>\u274c Bad: Ambiguous plain text <pre><code>The equation is: dEPI/dt = vf * DELTA_NFR\n</code></pre></p> <p>\u2705 Good: Clear LaTeX <pre><code>The nodal equation is:\n\n\\[\n\\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t)\n\\]\n</code></pre></p>"},{"location":"style_guide/#73-missing-units","title":"7.3 Missing Units","text":"<p>\u274c Bad: No units specified <pre><code>nu_f: float  # Structural frequency\n</code></pre></p> <p>\u2705 Good: Units explicitly stated <pre><code>nu_f: float  # Structural frequency in Hz_str (structural hertz)\n</code></pre></p>"},{"location":"style_guide/#74-broken-cross-references","title":"7.4 Broken Cross-References","text":"<p>\u274c Bad: Hard-coded links that break <pre><code>\"\"\"See coherence_operator.md for details.\"\"\"\n</code></pre></p> <p>\u2705 Good: Relative or Sphinx references <pre><code>\"\"\"\nSee :doc:`../theory/mathematical_foundations` Section 3.1 for details.\n\"\"\"\n</code></pre></p>"},{"location":"style_guide/#8-validation-checklist","title":"8. Validation Checklist","text":"<p>Before committing documentation changes, verify:</p> <ul> <li>[ ] All equations use consistent symbol conventions from Section 2</li> <li>[ ] Inline math uses <code>\\( ... \\)</code> or <code>:math:</code>...`` appropriately</li> <li>[ ] Display equations use <code>\\[ ... \\]</code> or <code>.. math::</code> appropriately</li> <li>[ ] All variables have units specified where applicable</li> <li>[ ] Cross-references use relative paths or Sphinx directives</li> <li>[ ] Docstrings use raw strings (<code>r\"\"\"...\"\"\"</code>) when containing LaTeX</li> <li>[ ] Examples include expected output or assertions</li> <li>[ ] \"See Also\" sections link to related functions</li> <li>[ ] \"References\" sections link to theory documents</li> </ul>"},{"location":"style_guide/#9-tools-and-resources","title":"9. Tools and Resources","text":""},{"location":"style_guide/#91-latex-testing","title":"9.1 LaTeX Testing","text":"<p>Test LaTeX rendering online: - KaTeX Playground - MathJax Demo</p>"},{"location":"style_guide/#92-sphinx-documentation","title":"9.2 Sphinx Documentation","text":"<ul> <li>Sphinx Math Extension</li> <li>NumPy Docstring Standard</li> <li>Sphinx Cross-Referencing</li> </ul>"},{"location":"style_guide/#93-building-documentation-locally","title":"9.3 Building Documentation Locally","text":"<pre><code># Install dependencies\npip install -e \".[docs]\"\n\n# Build HTML documentation\nmake docs\n\n# Or directly with Sphinx\nsphinx-build -b html docs/source docs/_build/html\n</code></pre>"},{"location":"style_guide/#summary","title":"Summary","text":"<p>This style guide ensures that TNFR documentation maintains:</p> <ol> <li>Consistent notation across all documents and code</li> <li>Clear mathematical presentation using LaTeX where appropriate</li> <li>Bidirectional traceability between theory and implementation</li> <li>Accessible examples that demonstrate calculations step-by-step</li> </ol> <p>When in doubt, prioritize clarity and consistency over brevity.</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/","title":"TNFR Architecture Guide: Patterns and Dependencies","text":"<p>Comprehensive guide to TNFR factory patterns, type safety, and module dependencies</p> <p>This guide consolidates architectural knowledge about the TNFR Python Engine's structural organization, factory patterns, type system, and dependency management.</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Factory Patterns</li> <li>Core Principles</li> <li>Naming Conventions</li> <li>Factory Templates</li> <li>Validation and Testing</li> <li>Type Stub Automation</li> <li>Workflow</li> <li>Commands</li> <li>Troubleshooting</li> <li>Module Dependencies</li> <li>Dependency Hierarchy</li> <li>API Contracts</li> <li>Coupling Analysis</li> <li>System Invariants</li> <li>Quick References</li> </ol>"},{"location":"advanced/ARCHITECTURE_GUIDE/#factory-patterns","title":"Factory Patterns","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#core-principles","title":"Core Principles","text":"<p>Factory functions in TNFR follow strict principles to preserve structural coherence:</p> <ol> <li>TNFR Fidelity First: Factory functions must preserve structural invariants (coherence, phase, \u03bdf, \u0394NFR)</li> <li>Explicit Validation: All inputs validated before construction</li> <li>Self-Documenting: Clear naming conventions that reveal intent</li> <li>Type Safety: Full type annotations with corresponding <code>.pyi</code> stubs</li> <li>Reproducibility: Support for deterministic construction (seeds, explicit parameters)</li> </ol>"},{"location":"advanced/ARCHITECTURE_GUIDE/#naming-conventions","title":"Naming Conventions","text":"<p>TNFR uses three distinct factory patterns based on what they return:</p> Prefix Returns Purpose Example <code>make_*</code> Objects Create validated operator instances with structural guarantees <code>make_coherence_operator</code> <code>build_*</code> Arrays/Data Construct \u0394NFR generators and raw mathematical structures <code>build_delta_nfr</code> <code>create_*</code> Nodes/Factories Create TNFR nodes or return other factory functions <code>create_nfr</code> <p>Rationale: - <code>make_*</code>: Emphasizes creation of validated, ready-to-use objects - <code>build_*</code>: Suggests construction of raw, flexible data structures - <code>create_*</code>: Reserved for higher-order abstractions (nodes, factory generators)</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#factory-templates","title":"Factory Templates","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#operator-factory-template-make_","title":"Operator Factory Template (<code>make_*</code>)","text":"<pre><code>def make_operator_name(\n    dim: int,\n    *,\n    param1: Type1 = default1,\n    param2: Type2 = default2,\n) -&gt; OperatorType:\n    \"\"\"Return a validated operator with structural guarantees.\n\n    Parameters\n    ----------\n    dim : int\n        Dimensionality of the operator's Hilbert space.\n    param1 : Type1, optional\n        Description (default: default1).\n    param2 : Type2, optional\n        Description (default: default2).\n\n    Returns\n    -------\n    OperatorType\n        Validated operator instance.\n\n    Raises\n    ------\n    ValueError\n        If validation fails or structural invariants violated.\n\n    Examples\n    --------\n    &gt;&gt;&gt; op = make_operator_name(dim=5, param1=custom_value)\n    &gt;&gt;&gt; assert op.is_hermitian()\n    \"\"\"\n    # 1. Validate inputs\n    if dim &lt;= 0:\n        raise ValueError(f\"Dimension must be positive, got {dim}\")\n\n    # 2. Get backend for array operations\n    backend = get_backend()\n\n    # 3. Construct operator\n    data = backend.zeros((dim, dim), dtype=backend.complex128)\n    # ... construction logic ...\n    operator = OperatorType(data, backend=backend)\n\n    # 4. Verify structural invariants\n    if not operator.is_hermitian(atol=1e-9):\n        raise ValueError(\"Operator must be Hermitian\")\n\n    if not operator.is_positive_semidefinite():\n        raise ValueError(\"Operator must be positive semidefinite\")\n\n    return operator\n</code></pre> <p>Key characteristics: - Keyword-only arguments (after <code>*</code>) for options - Comprehensive input validation with descriptive errors - Backend integration for math operations - Post-construction verification of structural properties - Complete NumPy-style docstring</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#generator-factory-template-build_","title":"Generator Factory Template (<code>build_*</code>)","text":"<pre><code>def build_generator_name(\n    dim: int,\n    *,\n    nu_f: float = 1.0,\n    scale: float = 1.0,\n    rng: Generator | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Construct a Hermitian generator for \u0394NFR evolution.\n\n    Parameters\n    ----------\n    dim : int\n        Dimensionality of the Hilbert space.\n    nu_f : float, optional\n        Structural frequency scaling (Hz_str) (default: 1.0).\n    scale : float, optional\n        Additional uniform scaling factor (default: 1.0).\n    rng : Generator | None, optional\n        NumPy RNG for reproducible noise injection.\n        If None, generates deterministic structure only.\n\n    Returns\n    -------\n    np.ndarray\n        Hermitian generator matrix of shape (dim, dim).\n\n    Raises\n    ------\n    ValueError\n        If dimension is invalid or parameters out of range.\n\n    Notes\n    -----\n    The \u03bdf parameter represents structural frequency in Hz_str units,\n    modulating the rate of reorganization as per the nodal equation:\n\n    .. math::\n        \\\\frac{\u2202EPI}{\u2202t} = \u03bdf \u00b7 \u0394NFR(t)\n\n    Examples\n    --------\n    &gt;&gt;&gt; rng = np.random.default_rng(42)\n    &gt;&gt;&gt; gen = build_generator_name(dim=5, nu_f=2.0, rng=rng)\n    &gt;&gt;&gt; assert gen.shape == (5, 5)\n    &gt;&gt;&gt; assert np.allclose(gen, gen.conj().T)  # Hermitian\n    \"\"\"\n    # 1. Validate inputs\n    if dim &lt;= 0:\n        raise ValueError(f\"Dimension must be positive, got {dim}\")\n    if nu_f &lt; 0:\n        raise ValueError(f\"Structural frequency must be non-negative, got {nu_f}\")\n\n    # 2. Get backend\n    backend = get_backend()\n\n    # 3. Build base structure\n    matrix = backend.zeros((dim, dim), dtype=backend.complex128)\n    # ... construction logic with nu_f scaling ...\n\n    # 4. Add reproducible noise if requested\n    if rng is not None:\n        noise = rng.standard_normal((dim, dim)) + 1j * rng.standard_normal((dim, dim))\n        noise = (noise + noise.conj().T) / 2  # Hermitianize\n        matrix = matrix + 0.1 * scale * noise\n\n    # 5. Ensure Hermiticity\n    matrix = (matrix + matrix.conj().T) / 2\n\n    return matrix\n</code></pre> <p>Key characteristics: - Returns raw numpy array (not wrapped object) - Includes <code>nu_f</code> parameter for structural frequency scaling - Supports reproducible noise via explicit RNG - Ensures Hermiticity before returning - Documents structural semantics in Notes section</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#node-factory-template-create_","title":"Node Factory Template (<code>create_*</code>)","text":"<pre><code>def create_nfr(\n    G: TNFRGraph,\n    *,\n    nu_f: float = 1.0,\n    phase: float = 0.0,\n    epi_dim: int = 2,\n    seed: int | None = None,\n) -&gt; tuple[TNFRGraph, str]:\n    \"\"\"Create a new resonant fractal node (NFR) in the network.\n\n    Parameters\n    ----------\n    G : TNFRGraph\n        Target network graph.\n    nu_f : float, optional\n        Initial structural frequency in Hz_str (default: 1.0).\n    phase : float, optional\n        Initial phase in radians, range [0, 2\u03c0] (default: 0.0).\n    epi_dim : int, optional\n        EPI dimensionality (default: 2).\n    seed : int | None, optional\n        Random seed for deterministic node creation.\n\n    Returns\n    -------\n    G : TNFRGraph\n        Updated graph with new node.\n    node_id : str\n        Identifier of created node.\n\n    Raises\n    ------\n    ValueError\n        If parameters violate structural constraints.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import networkx as nx\n    &gt;&gt;&gt; G = nx.Graph()\n    &gt;&gt;&gt; G, node = create_nfr(G, nu_f=2.0, phase=0.5, seed=42)\n    &gt;&gt;&gt; assert node in G.nodes\n    &gt;&gt;&gt; assert G.nodes[node]['nu_f'] == 2.0\n    \"\"\"\n    # 1. Validate inputs\n    if nu_f &lt; 0:\n        raise ValueError(f\"Structural frequency must be non-negative, got {nu_f}\")\n    if not 0 &lt;= phase &lt;= 2 * np.pi:\n        raise ValueError(f\"Phase must be in [0, 2\u03c0], got {phase}\")\n    if epi_dim &lt;= 0:\n        raise ValueError(f\"EPI dimension must be positive, got {epi_dim}\")\n\n    # 2. Generate deterministic node ID\n    rng = np.random.default_rng(seed) if seed is not None else np.random.default_rng()\n    node_id = f\"NFR_{rng.integers(0, 1000000):06d}\"\n\n    # 3. Initialize EPI structure\n    epi = build_delta_nfr(dim=epi_dim, nu_f=nu_f, rng=rng)\n\n    # 4. Add node to graph\n    G.add_node(\n        node_id,\n        nu_f=nu_f,\n        phase=phase,\n        epi=epi,\n        coherence=1.0,  # Initial perfect coherence\n        dnfr=0.0,       # No reorganization pressure initially\n    )\n\n    return G, node_id\n</code></pre> <p>Key characteristics: - Returns composite structures (graph + identifier) - Creates complete TNFR nodes with all required attributes - Uses other factories internally (<code>build_delta_nfr</code>) - Comprehensive examples showing typical usage - May call other factory functions</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#testing-template-for-factory-functions","title":"Testing Template for Factory Functions","text":"<p>Every factory function should have tests covering:</p> <pre><code>import pytest\nimport numpy as np\nfrom tnfr.mathematics.operators_factory import make_coherence_operator\n\nclass TestMakeCoherenceOperator:\n    \"\"\"Test suite for coherence operator factory.\"\"\"\n\n    def test_valid_construction_defaults(self):\n        \"\"\"Test construction with default parameters.\"\"\"\n        op = make_coherence_operator(dim=5)\n        assert op.shape == (5, 5)\n        assert op.is_hermitian()\n        assert op.is_positive_semidefinite()\n\n    def test_valid_construction_custom_spectrum(self):\n        \"\"\"Test construction with custom eigenvalue spectrum.\"\"\"\n        spectrum = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\n        op = make_coherence_operator(dim=5, spectrum=spectrum)\n        assert np.allclose(np.sort(np.linalg.eigvals(op)), spectrum, atol=1e-9)\n\n    def test_invalid_dimension(self):\n        \"\"\"Test that invalid dimensions raise ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Dimension must be positive\"):\n            make_coherence_operator(dim=0)\n        with pytest.raises(ValueError, match=\"Dimension must be positive\"):\n            make_coherence_operator(dim=-5)\n\n    def test_invalid_spectrum_shape(self):\n        \"\"\"Test that mismatched spectrum shape raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"shape\"):\n            make_coherence_operator(dim=5, spectrum=np.array([0.1, 0.2]))  # Wrong size\n\n    def test_structural_invariant_hermiticity(self):\n        \"\"\"Test that Hermiticity is guaranteed.\"\"\"\n        op = make_coherence_operator(dim=10)\n        matrix = op.to_array()\n        assert np.allclose(matrix, matrix.conj().T, atol=1e-9)\n\n    def test_structural_invariant_psd(self):\n        \"\"\"Test that positive semidefiniteness is guaranteed.\"\"\"\n        op = make_coherence_operator(dim=10)\n        eigenvalues = np.linalg.eigvalsh(op.to_array())\n        assert np.all(eigenvalues &gt;= -1e-9)  # Allow numerical tolerance\n\n    def test_reproducibility(self):\n        \"\"\"Test that same inputs produce same outputs.\"\"\"\n        op1 = make_coherence_operator(dim=5, spectrum=np.linspace(0.1, 0.5, 5))\n        op2 = make_coherence_operator(dim=5, spectrum=np.linspace(0.1, 0.5, 5))\n        assert np.allclose(op1.to_array(), op2.to_array())\n\n    def test_backend_compatibility(self):\n        \"\"\"Test that factory works with different backends.\"\"\"\n        # This test would cycle through available backends\n        op = make_coherence_operator(dim=5)\n        assert hasattr(op, 'backend')\n        assert op.backend is not None\n</code></pre> <p>Test coverage checklist: - \u2713 Valid construction with defaults - \u2713 Valid construction with custom parameters - \u2713 Invalid dimension handling - \u2713 Invalid parameter handling - \u2713 Structural invariants (Hermiticity, PSD, norm preservation) - \u2713 Reproducibility (deterministic output) - \u2713 Backend compatibility - \u2713 Edge cases (boundary values)</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#type-stub-automation","title":"Type Stub Automation","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#type-stub-workflow","title":"Type Stub Workflow","text":"<p>TNFR uses automated <code>.pyi</code> stub generation to maintain type safety and prevent drift between implementations and type hints.</p> <p>Why type stubs? - Separate type information from implementation - Faster type checking (no need to parse implementations) - Explicit API contracts - IDE autocomplete support</p> <p>Automation layers: <pre><code>Pre-commit Hook \u2192 CI Check (missing) \u2192 CI Check (sync) \u2192 Mypy Validation\n     (local)           (GitHub)             (GitHub)         (local/CI)\n</code></pre></p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#stub-commands","title":"Stub Commands","text":"<pre><code># Display all available commands\nmake help\n\n# Generate missing stub files\nmake stubs\n\n# Check for missing stubs (exit code 1 if any missing)\nmake stubs-check\n\n# Check if stubs are synchronized (exit code 1 if outdated)\nmake stubs-check-sync\n\n# Regenerate outdated stub files\nmake stubs-sync\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#stub-workflow-scenarios","title":"Stub Workflow Scenarios","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#scenario-1-creating-a-new-module","title":"Scenario 1: Creating a New Module","text":"<pre><code># 1. Create your Python module\ntouch src/tnfr/new_module.py\n\n# 2. Implement your functions with type hints\n# src/tnfr/new_module.py\ndef my_function(x: int, y: float) -&gt; str:\n    return f\"{x} + {y}\"\n\n# 3. Generate stub file\nmake stubs\n# Creates: src/tnfr/new_module.pyi\n\n# 4. Verify stub was created\nmake stubs-check\n# Output: All modules have stub files \u2713\n\n# 5. Commit both files together\ngit add src/tnfr/new_module.py src/tnfr/new_module.pyi\ngit commit -m \"Add new_module with type stubs\"\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#scenario-2-modifying-an-existing-module","title":"Scenario 2: Modifying an Existing Module","text":"<pre><code># 1. Make changes to implementation\n# Edit: src/tnfr/existing_module.py\n\n# 2. Check if stub needs update\nmake stubs-check-sync\n# Output: Stub file outdated: src/tnfr/existing_module.pyi\n\n# 3. Regenerate stub\nmake stubs-sync\n# Updates: src/tnfr/existing_module.pyi\n\n# 4. Review changes\ngit diff src/tnfr/existing_module.pyi\n\n# 5. Commit both files together\ngit add src/tnfr/existing_module.py src/tnfr/existing_module.pyi\ngit commit -m \"Update existing_module and regenerate stub\"\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#scenario-3-pre-commit-hook-catches-missing-stub","title":"Scenario 3: Pre-commit Hook Catches Missing Stub","text":"<pre><code># 1. Create new module\ntouch src/tnfr/another_module.py\n# ... add code ...\n\n# 2. Try to commit without generating stub\ngit add src/tnfr/another_module.py\ngit commit -m \"Add another_module\"\n\n# Pre-commit hook runs and fails:\n# ERROR: Missing stub files detected:\n#   - src/tnfr/another_module.pyi\n# Run 'make stubs' to generate them\n\n# 3. Generate stub as instructed\nmake stubs\n\n# 4. Add stub and commit\ngit add src/tnfr/another_module.pyi\ngit commit -m \"Add another_module with type stub\"\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#stub-troubleshooting","title":"Stub Troubleshooting","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#issue-stub-generation-fails","title":"Issue: Stub generation fails","text":"<p>Symptoms: <code>make stubs</code> returns errors</p> <p>Solutions: 1. Ensure mypy is installed: <code>pip install -e .[typecheck]</code> 2. Check for syntax errors in <code>.py</code> files 3. Run <code>python scripts/generate_stubs.py --dry-run</code> to see what would be generated 4. Check script output for specific module errors</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#issue-stub-file-appears-outdated","title":"Issue: Stub file appears outdated","text":"<p>Symptoms: <code>make stubs-check-sync</code> fails but <code>make stubs-sync</code> doesn't update</p> <p>Solutions: 1. Check if <code>.py</code> file was actually modified 2. Manually inspect <code>.pyi</code> file for correctness 3. Delete <code>.pyi</code> file and regenerate: <code>rm src/tnfr/module.pyi &amp;&amp; make stubs</code> 4. Verify file permissions allow writing</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#issue-ci-fails-on-stub-check","title":"Issue: CI fails on stub check","text":"<p>Symptoms: GitHub Actions fails with \"stub files outdated\"</p> <p>Solutions: 1. Run <code>make stubs-check-sync</code> locally before pushing 2. Run <code>make stubs-sync</code> to regenerate all outdated stubs 3. Commit and push both <code>.py</code> and <code>.pyi</code> files together 4. If persistent, check that CI uses same mypy version as local</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#module-dependencies","title":"Module Dependencies","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#dependency-hierarchy","title":"Dependency Hierarchy","text":"<p>The TNFR codebase follows a clean layered architecture to prevent circular dependencies:</p> <pre><code>Layer 0 (Types &amp; Constants):\n  - types.py: Core type definitions (TNFRGraph, GraphLike, EPI)\n  - constants/: Default parameters, limits, structural constants\n\nLayer 1 (Foundation):\n  - utils/init.py: Logging, lazy imports, backend loading\n  - utils/numeric.py: Pure mathematical functions (clamping, angles)\n  - utils/chunks.py: Parallelism utilities\n\nLayer 2 (Data Operations):\n  - utils/data.py: Type conversion, normalization\n    Depends on: numeric (L1), init (L1)\n\nLayer 3 (Graph &amp; State):\n  - utils/graph.py: Graph metadata, \u0394NFR state management\n    Depends on: types (L0)\n\nLayer 4 (I/O):\n  - utils/io.py: JSON/YAML parsing, file operations\n    Depends on: init (L1)\n\nLayer 5 (Caching):\n  - utils/cache.py: Cache infrastructure, versioning\n    Depends on: graph (L3), init (L1), io (L4)\n\nLayer 6 (Callbacks):\n  - utils/callbacks.py: Event system for observations\n    Depends on: init (L1), data (L2)\n\nLayer 7 (High-Level Modules):\n  - structural.py: NFR creation (create_nfr)\n  - operators/: Structural operators (Emission, Reception, etc.)\n  - mathematics/: Factories for operators and generators\n    Depends on: All lower layers as needed\n</code></pre> <p>Dependency rules: 1. Downward only: Modules only import from lower layers 2. No cycles: Circular imports are forbidden and tested in CI 3. Minimal coupling: Each layer has minimal dependencies on others 4. Clear boundaries: Layer transitions are explicit and documented</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#api-contracts","title":"API Contracts","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#contract-graph-state-management-utilsgraphpy","title":"Contract: Graph State Management (<code>utils/graph.py</code>)","text":"<p>Functions: <code>get_graph()</code>, <code>mark_dnfr_prep_dirty()</code>, <code>node_set_checksum()</code></p> <p>Structural Operators Supported: All operators that modify graph state</p> <p>Invariants: - <code>get_graph()</code> never modifies the graph - <code>mark_dnfr_prep_dirty()</code> only sets a flag, doesn't compute \u0394NFR - Checksums are deterministic for same node set</p> <p>Pre-conditions: - Graph must be a valid NetworkX graph or TNFRGraph - Node attributes must exist if accessed</p> <p>Post-conditions: - Graph structure unchanged (for read operations) - Dirty flags correctly set (for write operations) - Checksums stable across Python sessions</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#contract-cache-management-utilscachepy","title":"Contract: Cache Management (<code>utils/cache.py</code>)","text":"<p>Classes: <code>CacheManager</code>, <code>cached_node_list()</code>, <code>edge_version_cache()</code></p> <p>Structural Operators Supported: All operators (caching is transparent)</p> <p>Invariants: - Cache hits are bitwise identical to cache misses - Cache invalidation maintains structural consistency - Maximum cache sizes are respected</p> <p>Pre-conditions: - Cache keys are hashable - Cached objects are pickleable (if using disk cache)</p> <p>Post-conditions: - Cache state consistent with graph version - Memory usage bounded by configured limits - No stale data returned</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#contract-validation-validation","title":"Contract: Validation (<code>validation/</code>)","text":"<p>Functions: <code>validate_frequency()</code>, <code>validate_phase()</code>, <code>validate_coherence()</code></p> <p>Structural Operators Supported: All operators that modify node attributes</p> <p>Invariants: - \u03bdf \u2265 0 (structural frequency non-negative) - 0 \u2264 phase &lt; 2\u03c0 (phase in valid range) - 0 \u2264 C(t) \u2264 1 (coherence normalized) - \u0394NFR is Hermitian (if matrix)</p> <p>Pre-conditions: - Input values have correct types - Graph exists and is valid</p> <p>Post-conditions: - ValueError raised if validation fails - No modifications to inputs - Error messages clearly describe violation</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#coupling-analysis","title":"Coupling Analysis","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#low-coupling-desirable","title":"Low Coupling (Desirable)","text":"<p>Example: <code>utils/numeric.py</code> \u2192 No internal TNFR dependencies - Pure mathematical functions - Zero coupling to graph or node state - Easily testable and reusable</p> <p>Example: <code>utils/chunks.py</code> \u2192 Depends only on standard library - Computes chunk sizes for parallelism - No TNFR-specific dependencies - Could be extracted as standalone module</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#moderate-coupling-justified","title":"Moderate Coupling (Justified)","text":"<p>Example: <code>utils/data.py</code> \u2192 Depends on <code>utils/numeric.py</code> - Needs clamping and normalization functions - Justified: Data operations naturally need numeric utilities - Still testable in isolation with mocked dependencies</p> <p>Example: <code>utils/cache.py</code> \u2192 Depends on <code>utils/graph.py</code> - Needs graph versioning to invalidate caches - Justified: Caching must be aware of graph changes - Interface is minimal (only <code>edge_version_cache</code> used)</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#high-coupling-requires-justification","title":"High Coupling (Requires Justification)","text":"<p>Example: <code>structural.py</code> \u2192 Depends on many layers - Uses operators, mathematics, utils, validation - Justified: High-level orchestration module - Coupling is necessary to coordinate subsystems - Well-tested despite complexity</p> <p>Red flag pattern (not present in TNFR): - Two modules both import each other (circular) - Utils module depending on high-level modules - Core types importing from specific implementations</p>"},{"location":"advanced/ARCHITECTURE_GUIDE/#system-invariants","title":"System Invariants","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#tnfr-structural-invariants","title":"TNFR Structural Invariants","text":"<p>These invariants must be preserved by all factory functions and module operations:</p> <ol> <li>EPI as Coherent Form</li> <li>EPI only changes via structural operators</li> <li>No ad-hoc mutations allowed</li> <li> <p>Changes are traceable and logged</p> </li> <li> <p>Structural Units</p> </li> <li>\u03bdf expressed in Hz_str (structural hertz)</li> <li>Do not mix with physical frequencies</li> <li> <p>Always use dimensionally correct scaling</p> </li> <li> <p>\u0394NFR Semantics</p> </li> <li>Sign and magnitude modulate reorganization rate</li> <li>Not a classic ML \"error\" or \"loss gradient\"</li> <li> <p>Hermitian matrix if in operator form</p> </li> <li> <p>Operator Closure</p> </li> <li>Operator composition yields valid TNFR states</li> <li> <p>New functions must map to existing operators or be defined as one</p> </li> <li> <p>Phase Verification</p> </li> <li>No coupling valid without explicit phase check</li> <li>Phase must be in [0, 2\u03c0] range</li> <li> <p>Phase synchrony computed via Kuramoto order parameter</p> </li> <li> <p>Node Birth/Collapse Conditions</p> </li> <li>Birth requires: sufficient \u03bdf, coupling, reduced \u0394NFR</li> <li> <p>Collapse causes: extreme dissonance, decoupling, frequency failure</p> </li> <li> <p>Operational Fractality</p> </li> <li>EPIs can nest without losing functional identity</li> <li>Avoid flattening that breaks recursivity</li> <li> <p>Sub-EPIs maintain coherence independently</p> </li> <li> <p>Controlled Determinism</p> </li> <li>Simulations may be stochastic but must be reproducible</li> <li>Use explicit seeds for RNG</li> <li> <p>Log all structural events with timestamps</p> </li> <li> <p>Structural Metrics</p> </li> <li>Expose C(t), Si, phase, \u03bdf in telemetry</li> <li>Avoid alien metrics that dilute TNFR semantics</li> <li> <p>Metrics must be computable from structural state</p> </li> <li> <p>Domain Neutrality</p> <ul> <li>Engine is trans-scale and trans-domain</li> <li>No hard-wired assumptions from specific fields</li> <li>Keep core abstractions general</li> </ul> </li> </ol>"},{"location":"advanced/ARCHITECTURE_GUIDE/#factory-specific-invariants","title":"Factory-Specific Invariants","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#operator-factories-make_","title":"Operator Factories (<code>make_*</code>)","text":"<ul> <li>Hermiticity: All operators must be Hermitian (within tolerance)</li> <li>Positive Semidefiniteness: Coherence and frequency operators must be PSD</li> <li>Backend Compatibility: Must work with all supported backends (NumPy, JAX, PyTorch)</li> <li>Idempotence: Same inputs always produce equivalent outputs</li> </ul>"},{"location":"advanced/ARCHITECTURE_GUIDE/#generator-factories-build_","title":"Generator Factories (<code>build_*</code>)","text":"<ul> <li>Hermiticity: Generators must be Hermitian matrices</li> <li>Trace Preservation: Lindblad generators must preserve trace</li> <li>Scaling Consistency: \u03bdf scaling must be dimensionally correct</li> <li>Reproducibility: Same RNG seed must produce identical output</li> </ul>"},{"location":"advanced/ARCHITECTURE_GUIDE/#node-factories-create_","title":"Node Factories (<code>create_*</code>)","text":"<ul> <li>Attribute Completeness: All required node attributes must be set</li> <li>Valid Initial State: Initial C(t) = 1, \u0394NFR = 0, 0 \u2264 phase &lt; 2\u03c0</li> <li>Unique Identifiers: Node IDs must be unique within graph</li> <li>Graph Consistency: Graph metadata must be updated correctly</li> </ul>"},{"location":"advanced/ARCHITECTURE_GUIDE/#quick-references","title":"Quick References","text":""},{"location":"advanced/ARCHITECTURE_GUIDE/#factory-naming-cheatsheet","title":"Factory Naming Cheatsheet","text":"<pre><code># Create operator instances\nop = make_coherence_operator(dim=5)\nop = make_frequency_operator(matrix=H)\nrng = make_rng(seed=42, key=1)\n\n# Build data structures\ngen = build_delta_nfr(dim=10, nu_f=2.0)\nlind = build_lindblad_delta_nfr(dim=5, gamma=0.1)\niso = build_isometry_factory(input_dim=3, output_dim=5)\n\n# Create nodes\nG, node = create_nfr(G, nu_f=1.5, phase=0.5)\nG, node = create_math_nfr(G, dim=10)\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#type-stub-commands","title":"Type Stub Commands","text":"<pre><code>make help                  # Show all commands\nmake stubs                 # Generate missing stubs\nmake stubs-check           # Check for missing (CI)\nmake stubs-check-sync      # Check if outdated (CI)\nmake stubs-sync            # Regenerate outdated\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#module-import-rules","title":"Module Import Rules","text":"<pre><code># \u2713 Good: Import from public API\nfrom tnfr import create_nfr, Coherence\nfrom tnfr.utils import CacheManager, clamp\n\n# \u2713 Good: Import specific backend utilities\nfrom tnfr.backends import get_backend\n\n# \u2713 Good: Import validation functions\nfrom tnfr.validation import validate_frequency\n\n# \u2717 Bad: Import private modules\nfrom tnfr.utils._internal import something  # Private!\n\n# \u2717 Bad: Import from higher layers in lower layers\n# (e.g., utils/ importing from operators/)\n\n# \u2717 Bad: Circular imports\n# module_a.py imports module_b\n# module_b.py imports module_a\n</code></pre>"},{"location":"advanced/ARCHITECTURE_GUIDE/#validation-checklist","title":"Validation Checklist","text":"<p>Before creating a PR with factory changes:</p> <ul> <li>[ ] Factory follows naming convention (<code>make_*</code>, <code>build_*</code>, <code>create_*</code>)</li> <li>[ ] All parameters have type annotations</li> <li>[ ] Keyword-only arguments for options (after <code>*</code>)</li> <li>[ ] Input validation with descriptive error messages</li> <li>[ ] Structural invariants verified (Hermiticity, PSD, etc.)</li> <li>[ ] Complete NumPy-style docstring</li> <li>[ ] Backend integration if manipulating arrays</li> <li>[ ] Tests cover: valid cases, invalid inputs, edge cases</li> <li>[ ] Reproducibility tested (if using RNG)</li> <li>[ ] Stub file generated: <code>make stubs</code></li> <li>[ ] Stub file synchronized: <code>make stubs-check-sync</code></li> <li>[ ] No circular import dependencies introduced</li> <li>[ ] All tests pass: <code>pytest tests/</code></li> </ul>"},{"location":"advanced/ARCHITECTURE_GUIDE/#references","title":"References","text":"<ul> <li>AGENTS.md - TNFR paradigm fundamentals</li> <li>CONTRIBUTING.md - General contribution guidelines</li> <li>ARCHITECTURE.md - Overall project structure</li> <li>Performance Optimization - Caching and optimization patterns</li> <li>Testing Strategies - Test patterns and coverage requirements</li> <li>Foundations - Mathematical foundations</li> <li>API Reference - Complete API documentation</li> </ul> <p>Last Updated: 2025-11-06 Status: Active - consolidates FACTORY_, DEPENDENCY_, MODULE_ docs Maintenance*: Update when patterns change, review quarterly</p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/","title":"TNFR Development Workflow","text":"<p>Complete guide for contributors: workflows, best practices, and CI/CD integration</p> <p>This guide provides a comprehensive overview of development workflows for TNFR Python Engine contributors, from initial setup through PR submission.</p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Getting Started</li> <li>Development Environment</li> <li>Workflow Patterns</li> <li>Code Quality</li> <li>Documentation</li> <li>CI/CD Pipeline</li> <li>Release Process</li> <li>Troubleshooting</li> </ol>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#getting-started","title":"Getting Started","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#prerequisites","title":"Prerequisites","text":"<pre><code># Required\n- Python 3.9, 3.10, 3.11, 3.12, or 3.13\n- git\n- pip\n\n# Recommended\n- pyenv (for managing Python versions)\n- direnv (for managing environment variables)\n- pre-commit (installed automatically with dev dependencies)\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#initial-setup","title":"Initial Setup","text":"<pre><code># 1. Clone the repository\ngit clone https://github.com/fermga/TNFR-Python-Engine.git\ncd TNFR-Python-Engine\n\n# 2. Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# 3. Install in editable mode with all dev dependencies\npip install -e .[dev-full]\n\n# 4. Install pre-commit hooks\npre-commit install\n\n# 5. Verify installation\npython -c \"import tnfr; print(tnfr.__version__)\"\npytest tests/ -k \"test_basic\" --collect-only\nmake help\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#repository-structure","title":"Repository Structure","text":"<pre><code>TNFR-Python-Engine/\n\u251c\u2500\u2500 src/tnfr/               # Source code\n\u2502   \u251c\u2500\u2500 operators/          # Structural operators (Emission, Reception, etc.)\n\u2502   \u251c\u2500\u2500 mathematics/        # Factory functions, generators\n\u2502   \u251c\u2500\u2500 metrics/            # C(t), Si, phase calculations\n\u2502   \u251c\u2500\u2500 dynamics/           # \u0394NFR computation\n\u2502   \u251c\u2500\u2500 utils/              # Utilities (cache, validation, etc.)\n\u2502   \u251c\u2500\u2500 backends/           # Math backends (NumPy, JAX, PyTorch)\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 tests/                  # Test suite\n\u2502   \u251c\u2500\u2500 unit/               # Unit tests\n\u2502   \u251c\u2500\u2500 integration/        # Integration tests\n\u2502   \u2514\u2500\u2500 ci/                 # CI-specific tests\n\u251c\u2500\u2500 docs/                   # Documentation\n\u2502   \u251c\u2500\u2500 source/             # Sphinx/MkDocs source\n\u2502   \u2502   \u251c\u2500\u2500 getting-started/\n\u2502   \u2502   \u251c\u2500\u2500 user-guide/\n\u2502   \u2502   \u251c\u2500\u2500 advanced/       # \u2190 Your consolidated guides live here\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 scripts/                # Development scripts\n\u2502   \u251c\u2500\u2500 generate_stubs.py   # Type stub generation\n\u2502   \u251c\u2500\u2500 verify_internal_references.py\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .github/                # GitHub Actions workflows\n\u251c\u2500\u2500 pyproject.toml          # Project configuration\n\u251c\u2500\u2500 Makefile                # Common tasks\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#development-environment","title":"Development Environment","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#development-dependencies","title":"Development Dependencies","text":"<pre><code># Core development tools\npip install -e .[dev-core]\n\n# Full development suite (recommended)\npip install -e .[dev-full]\n\n# Specific tool groups\npip install -e .[typecheck]    # mypy, type stubs\npip install -e .[test-all]     # pytest and all plugins\npip install -e .[docs]         # Sphinx, MkDocs\npip install -e .[lint]         # Linters and formatters\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#environment-variables","title":"Environment Variables","text":"<p>Create <code>.env</code> file for local configuration:</p> <pre><code># .env (copy from .env.example)\nTNFR_BACKEND=numpy          # or jax, torch\nTNFR_CACHE_SIZE=128         # Cache entries\nTNFR_LOG_LEVEL=INFO         # DEBUG, INFO, WARNING, ERROR\nTNFR_PROFILE=false          # Enable profiling\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#editor-configuration","title":"Editor Configuration","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#vs-code","title":"VS Code","text":"<pre><code>// .vscode/settings.json\n{\n  \"python.defaultInterpreterPath\": \"${workspaceFolder}/venv/bin/python\",\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\"tests\"],\n  \"python.linting.enabled\": true,\n  \"python.linting.mypyEnabled\": true,\n  \"python.formatting.provider\": \"black\",\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#pycharm","title":"PyCharm","text":"<ol> <li>Open Settings \u2192 Project \u2192 Python Interpreter</li> <li>Add interpreter from <code>venv/bin/python</code></li> <li>Enable pytest as test runner</li> <li>Configure mypy as external tool</li> </ol>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#workflow-patterns","title":"Workflow Patterns","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#feature-development-workflow","title":"Feature Development Workflow","text":"<pre><code># 1. Create feature branch\ngit checkout -b feature/my-new-feature\n\n# 2. Make changes\n# Edit files...\n\n# 3. Run tests frequently\npytest tests/ -n auto\n\n# 4. Generate/update stubs if you modified .py files\nmake stubs-sync\n\n# 5. Check code quality\nmake stubs-check-sync    # Verify stubs\nmypy src/tnfr            # Type check\npytest tests/ --cov=tnfr # Test with coverage\n\n# 6. Commit changes\ngit add .\ngit commit -m \"Add feature: description\"\n# Pre-commit hooks run automatically\n\n# 7. Push and create PR\ngit push origin feature/my-new-feature\n# Create PR on GitHub\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#bug-fix-workflow","title":"Bug Fix Workflow","text":"<pre><code># 1. Create bug fix branch\ngit checkout -b fix/issue-123\n\n# 2. Write failing test first (TDD)\n# Edit tests/unit/test_operators.py\ndef test_bug_123():\n    \"\"\"Reproduce bug #123.\"\"\"\n    # Code that demonstrates the bug\n    assert False, \"Bug not fixed yet\"\n\n# 3. Verify test fails\npytest tests/unit/test_operators.py::test_bug_123\n\n# 4. Fix the bug\n# Edit src/tnfr/operators/coherence.py\n\n# 5. Verify test passes\npytest tests/unit/test_operators.py::test_bug_123\n\n# 6. Run full test suite\npytest tests/ -n auto\n\n# 7. Commit and push\ngit add .\ngit commit -m \"Fix #123: description of fix\"\ngit push origin fix/issue-123\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#documentation-workflow","title":"Documentation Workflow","text":"<pre><code># 1. Create documentation branch\ngit checkout -b docs/improve-operator-guide\n\n# 2. Edit documentation\n# Edit docs/source/user-guide/OPERATORS_GUIDE.md\n\n# 3. Build documentation locally\nmake docs\n# Or for MkDocs:\nmkdocs serve\n\n# 4. Review in browser\n# Sphinx: open docs/_build/html/index.html\n# MkDocs: http://127.0.0.1:8000\n\n# 5. Check internal references\nmake verify-refs\n\n# 6. Commit and push\ngit add docs/\ngit commit -m \"Docs: improve operator guide\"\ngit push origin docs/improve-operator-guide\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#factory-function-development","title":"Factory Function Development","text":"<pre><code># 1. Plan your factory\n# - Decide naming: make_*, build_*, or create_*\n# - Define inputs and outputs\n# - List validation requirements\n# - Document structural invariants\n\n# 2. Create stub implementation\n# Edit src/tnfr/mathematics/operators_factory.py\ndef make_new_operator(dim: int, *, param: float = 1.0) -&gt; NewOperator:\n    \"\"\"Create validated new operator.\n\n    Parameters\n    ----------\n    dim : int\n        Dimensionality.\n    param : float, optional\n        Parameter description (default: 1.0).\n\n    Returns\n    -------\n    NewOperator\n        Validated operator instance.\n    \"\"\"\n    if dim &lt;= 0:\n        raise ValueError(f\"Dimension must be positive, got {dim}\")\n\n    # TODO: Implementation\n    raise NotImplementedError\n\n# 3. Generate stub file\nmake stubs\n\n# 4. Write tests\n# Edit tests/mathematics/test_factory_patterns.py\nclass TestMakeNewOperator:\n    def test_valid_construction(self):\n        op = make_new_operator(dim=5)\n        assert op.shape == (5, 5)\n\n    def test_invalid_dimension(self):\n        with pytest.raises(ValueError):\n            make_new_operator(dim=0)\n\n# 5. Implement factory\n# Follow template from ARCHITECTURE_GUIDE.md\n\n# 6. Run tests iteratively\npytest tests/mathematics/test_factory_patterns.py::TestMakeNewOperator -vv\n\n# 7. Verify all checks pass\nmake stubs-check-sync\npytest tests/mathematics/test_factory_patterns.py\nmypy src/tnfr/mathematics/operators_factory.py\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#code-quality","title":"Code Quality","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Automatically run on <code>git commit</code>:</p> <pre><code># .pre-commit-config.yaml (excerpt)\nrepos:\n  - repo: local\n    hooks:\n      - id: check-stubs\n        name: Check for missing .pyi stub files\n        entry: make stubs-check\n        language: system\n        pass_filenames: false\n        always_run: true\n</code></pre> <p>Hooks include: - Stub file checks - Code formatting (if configured) - Trailing whitespace removal - YAML validation - Large file prevention</p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#manual-quality-checks","title":"Manual Quality Checks","text":"<pre><code># Type checking\nmypy src/tnfr\n\n# Stub validation\nmake stubs-check       # Check for missing stubs\nmake stubs-check-sync  # Check for outdated stubs\n\n# Testing\npytest tests/ -n auto               # All tests\npytest tests/ --cov=tnfr            # With coverage\npytest tests/ -m \"not slow\"         # Fast tests only\n\n# Documentation\nmake docs                           # Build Sphinx docs\nmake verify-refs                    # Check internal references\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#naming-conventions","title":"Naming Conventions","text":"<pre><code># Factory functions\ndef make_operator_name(...)      # Creates objects\ndef build_generator_name(...)    # Builds data structures\ndef create_nfr_name(...)         # Creates nodes/networks\n\n# Private functions\ndef _internal_helper(...)        # Leading underscore\n\n# Constants\nMAX_ITERATIONS = 100             # UPPER_CASE\nDEFAULT_TOLERANCE = 1e-9\n\n# Type aliases\nGraphLike = Union[nx.Graph, TNFRGraph]\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#docstring-style","title":"Docstring Style","text":"<p>Use NumPy-style docstrings:</p> <pre><code>def compute_metric(G, nodes, *, threshold=0.5):\n    \"\"\"Compute structural metric for specified nodes.\n\n    Parameters\n    ----------\n    G : TNFRGraph\n        Network graph with TNFR attributes.\n    nodes : list of str\n        Node identifiers to compute metric for.\n    threshold : float, optional\n        Minimum threshold for inclusion (default: 0.5).\n\n    Returns\n    -------\n    dict\n        Mapping from node ID to metric value.\n\n    Raises\n    ------\n    ValueError\n        If graph lacks required attributes.\n\n    Notes\n    -----\n    This function preserves structural invariants and does not\n    modify the input graph.\n\n    Examples\n    --------\n    &gt;&gt;&gt; G = create_test_graph()\n    &gt;&gt;&gt; metrics = compute_metric(G, ['n1', 'n2'])\n    &gt;&gt;&gt; assert all(0 &lt;= v &lt;= 1 for v in metrics.values())\n    \"\"\"\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#type-annotations","title":"Type Annotations","text":"<pre><code>from typing import Optional, Union, Dict, List\nimport networkx as nx\nimport numpy as np\n\n# Function signatures\ndef process_graph(\n    G: nx.Graph,\n    nodes: List[str],\n    *,\n    weights: Optional[np.ndarray] = None,\n    backend: str = 'numpy',\n) -&gt; Dict[str, float]:\n    \"\"\"Process graph nodes.\"\"\"\n    ...\n\n# Type aliases for clarity\nNodeID = str\nWeight = float\nGraphLike = Union[nx.Graph, 'TNFRGraph']\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#documentation","title":"Documentation","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#documentation-types","title":"Documentation Types","text":"<ol> <li>API Reference (<code>docs/source/api/</code>)</li> <li>Auto-generated from docstrings</li> <li>One file per module/category</li> <li> <p>Examples included</p> </li> <li> <p>User Guides (<code>docs/source/user-guide/</code>)</p> </li> <li>How-to guides for common tasks</li> <li>Tutorial-style with examples</li> <li> <p>Operator guides, troubleshooting</p> </li> <li> <p>Advanced Guides (<code>docs/source/advanced/</code>)</p> </li> <li>Architecture guide (factory patterns, dependencies)</li> <li>Performance optimization</li> <li>Testing strategies</li> <li> <p>Development workflow</p> </li> <li> <p>Theory (<code>docs/source/theory/</code>)</p> </li> <li>Mathematical foundations</li> <li>Jupyter notebooks</li> <li>Operator derivations</li> </ol>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#building-documentation","title":"Building Documentation","text":"<pre><code># Sphinx documentation\nmake docs\nopen docs/_build/html/index.html\n\n# MkDocs documentation\nmkdocs serve\n# Visit http://127.0.0.1:8000\n\n# Verify internal references\nmake verify-refs\nmake verify-refs-verbose  # Detailed output\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#documentation-guidelines","title":"Documentation Guidelines","text":"<p>DO: - \u2705 Use concrete examples - \u2705 Show both valid and invalid usage - \u2705 Include expected outputs - \u2705 Link to related documentation - \u2705 Document TNFR-specific semantics (\u03bdf, phase, \u0394NFR) - \u2705 Update when APIs change</p> <p>DON'T: - \u274c Copy-paste code without testing - \u274c Use generic placeholder examples - \u274c Forget to update cross-references - \u274c Skip documenting edge cases - \u274c Use jargon without explanation</p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#cicd-pipeline","title":"CI/CD Pipeline","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#github-actions-workflows","title":"GitHub Actions Workflows","text":"<p>The project uses multiple CI workflows:</p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#1-main-ci-workflow-githubworkflowsciyml","title":"1. Main CI Workflow (<code>.github/workflows/ci.yml</code>)","text":"<pre><code>jobs:\n  test:\n    # Run tests on Python 3.9-3.13\n    # Generate coverage reports\n\n  type-check:\n    # Verify type stubs\n    # Run mypy\n\n  docs:\n    # Build documentation\n    # Verify no broken links\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#2-security-workflow","title":"2. Security Workflow","text":"<pre><code>jobs:\n  bandit:\n    # Static security analysis\n\n  dependency-audit:\n    # Check for vulnerable dependencies\n\n  codeql:\n    # CodeQL security scanning\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#3-release-workflow","title":"3. Release Workflow","text":"<pre><code>jobs:\n  publish:\n    # Build distributions\n    # Publish to PyPI\n    # Create GitHub release\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#ci-stages","title":"CI Stages","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Push to GitHub \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u251c\u2500\u2500\u2500 Type Check \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502    - Stub validation       \u2502\n         \u2502    - mypy                  \u2502\n         \u2502                            \u2502\n         \u251c\u2500\u2500\u2500 Test (3.9-3.13) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502    - Unit tests            \u2502\n         \u2502    - Integration tests     \u2502\n         \u2502    - Coverage report       \u2502\n         \u2502                            \u2502\n         \u251c\u2500\u2500\u2500 Docs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502    - Build Sphinx          \u2502\n         \u2502    - Verify references     \u2502\n         \u2502                            \u2502\n         \u251c\u2500\u2500\u2500 Security \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502    - Bandit                \u2502\n         \u2502    - Dependency audit      \u2502\n         \u2502    - CodeQL                \u2502\n         \u2502                            \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502  All Checks Pass \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#local-ci-simulation","title":"Local CI Simulation","text":"<p>Run the same checks locally before pushing:</p> <pre><code># Type checks\nmake stubs-check\nmake stubs-check-sync\nmypy src/tnfr\n\n# Tests\npytest tests/ -n auto --cov=tnfr\n\n# Documentation\nmake docs\nmake verify-refs\n\n# Security (optional)\nbandit -r src -ll -f json -o bandit.json\npython tools/bandit_to_sarif.py bandit.json bandit.sarif\n\n# All-in-one pre-push check\n./scripts/pre-push-check.sh  # If available\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#release-process","title":"Release Process","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#version-numbering","title":"Version Numbering","text":"<p>TNFR follows Semantic Versioning:</p> <pre><code>MAJOR.MINOR.PATCH\n\nExamples:\n1.0.0  - First stable release\n1.1.0  - New feature, backward compatible\n1.1.1  - Bug fix, backward compatible\n2.0.0  - Breaking change\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#release-checklist","title":"Release Checklist","text":"<pre><code># 1. Ensure clean state\ngit checkout main\ngit pull origin main\ngit status  # Should be clean\n\n# 2. Update version\n# Edit pyproject.toml or use tool\nbumpversion minor  # or major, patch\n\n# 3. Update changelog\n# Edit CHANGELOG.md or use towncrier\ntowncrier build --version 1.2.0\n\n# 4. Run full test suite\npytest tests/ -n auto\nmake docs\nmake verify-refs\n\n# 5. Create release commit\ngit add .\ngit commit -m \"Release 1.2.0\"\n\n# 6. Tag release\ngit tag -a v1.2.0 -m \"Release version 1.2.0\"\n\n# 7. Push to GitHub\ngit push origin main\ngit push origin v1.2.0\n\n# 8. GitHub Actions will:\n#    - Run all CI checks\n#    - Build distributions\n#    - Publish to PyPI (if configured)\n#    - Create GitHub release\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#changelog-fragments","title":"Changelog Fragments","text":"<p>Use towncrier for managing changelog entries:</p> <pre><code># Create fragment for new feature\necho \"Add new operator feature\" &gt; docs/changelog.d/123.feature.md\n\n# Types: .feature, .bugfix, .doc, .removal, .misc\n\n# Build changelog\ntowncrier build --version 1.2.0\n\n# Preview without modifying files\ntowncrier build --draft --version 1.2.0\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#common-issues","title":"Common Issues","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#issue-import-errors-after-installation","title":"Issue: Import errors after installation","text":"<p>Solution: <pre><code># Reinstall in editable mode\npip install -e .\n\n# Or with dev dependencies\npip install -e .[dev-full]\n\n# Verify installation\npython -c \"import tnfr; print(tnfr.__version__)\"\n</code></pre></p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#issue-pre-commit-hooks-failing","title":"Issue: Pre-commit hooks failing","text":"<p>Solution: <pre><code># Update hooks to latest version\npre-commit autoupdate\n\n# Run manually to see detailed errors\npre-commit run --all-files --verbose\n\n# Skip hooks for emergency commit (use sparingly!)\ngit commit --no-verify -m \"Emergency fix\"\n</code></pre></p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#issue-tests-passing-locally-but-failing-in-ci","title":"Issue: Tests passing locally but failing in CI","text":"<p>Possible causes: 1. Different Python version 2. Missing seed for random operations 3. Platform-specific behavior 4. Missing test dependency</p> <p>Diagnosis: <pre><code># Match CI Python version\npyenv install 3.12\npyenv local 3.12\n\n# Run tests exactly as CI does\npytest tests/ -n auto --cov=tnfr --cov-report=xml\n\n# Check for missing seeds\ngrep -r \"random\" tests/ | grep -v \"seed\"\n</code></pre></p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#issue-documentation-build-fails","title":"Issue: Documentation build fails","text":"<p>Solution: <pre><code># Install docs dependencies\npip install -e .[docs]\n\n# Clean build directory\nrm -rf docs/_build\n\n# Build with verbose output\nsphinx-build -v docs/source docs/_build/html\n\n# Check for missing references\nmake verify-refs-verbose\n</code></pre></p>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#getting-help","title":"Getting Help","text":"<ol> <li>Check existing documentation:</li> <li>This guide</li> <li>ARCHITECTURE_GUIDE.md</li> <li>TESTING_STRATEGIES.md</li> <li> <p>CONTRIBUTING.md</p> </li> <li> <p>Search GitHub Issues:</p> </li> <li>Known issues and solutions</li> <li> <p>Feature discussions</p> </li> <li> <p>Ask in Discussions:</p> </li> <li>Questions about development</li> <li>Feature proposals</li> <li> <p>Best practices</p> </li> <li> <p>Open an Issue:</p> </li> <li>Bug reports</li> <li>Feature requests</li> <li>Documentation improvements</li> </ol>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#do","title":"DO:","text":"<ul> <li>\u2705 Write tests before code (TDD)</li> <li>\u2705 Generate stubs for all .py files</li> <li>\u2705 Use explicit seeds for reproducibility</li> <li>\u2705 Document TNFR-specific semantics</li> <li>\u2705 Run pre-push checks locally</li> <li>\u2705 Keep commits focused and atomic</li> <li>\u2705 Update documentation with code changes</li> </ul>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#dont","title":"DON'T:","text":"<ul> <li>\u274c Skip writing tests</li> <li>\u274c Commit without running pre-commit hooks</li> <li>\u274c Break structural invariants</li> <li>\u274c Push untested code</li> <li>\u274c Ignore CI failures</li> <li>\u274c Commit generated files (unless .pyi stubs)</li> <li>\u274c Make breaking changes without discussion</li> </ul>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#quick-reference","title":"Quick Reference","text":""},{"location":"advanced/DEVELOPMENT_WORKFLOW/#essential-commands","title":"Essential Commands","text":"<pre><code># Setup\npip install -e .[dev-full]\npre-commit install\n\n# Development\npytest tests/ -n auto              # Run tests\nmake stubs-sync                    # Update stubs\nmypy src/tnfr                      # Type check\nmake docs                          # Build docs\n\n# Quality\nmake stubs-check-sync              # Verify stubs\npytest tests/ --cov=tnfr           # Coverage\nmake verify-refs                   # Check doc links\n\n# Help\nmake help                          # Available make targets\npytest --help                      # Pytest options\nmypy --help                        # Mypy options\n</code></pre>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#file-locations","title":"File Locations","text":"<ul> <li>Source code: <code>src/tnfr/</code></li> <li>Tests: <code>tests/</code></li> <li>Documentation: <code>docs/source/</code></li> <li>Scripts: <code>scripts/</code></li> <li>Configuration: <code>pyproject.toml</code></li> <li>CI workflows: <code>.github/workflows/</code></li> </ul>"},{"location":"advanced/DEVELOPMENT_WORKFLOW/#see-also","title":"See Also","text":"<ul> <li>Architecture Guide - Factory patterns and dependencies</li> <li>Testing Strategies - Testing best practices</li> <li>Performance Optimization - Optimization techniques</li> <li>CONTRIBUTING.md - Contribution guidelines</li> <li>README.md - Project overview</li> </ul> <p>Last Updated: 2025-11-06 Status: Active - consolidated workflow documentation Maintenance: Update when processes change, review quarterly</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/","title":"Performance Optimization Guide","text":"<p>Home \u203a Advanced \u203a Performance Optimization</p> <p>This guide covers performance optimization techniques for TNFR networks, including backend selection, caching strategies, factory patterns, and dependency management.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#overview","title":"Overview","text":"<p>TNFR provides multiple optimization strategies: 1. Computational backends (NumPy, JAX, PyTorch) 2. Caching and memoization 3. Factory patterns for efficient object creation 4. Sparse network topologies 5. Dependency management</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#quick-optimization-checklist","title":"Quick Optimization Checklist","text":"<pre><code>\u25a1 Use JAX/PyTorch backend for large networks (&gt;100 nodes)\n\u25a1 Enable caching (install tnfr[orjson])\n\u25a1 Use sparse connectivity (&lt;10% density)\n\u25a1 Profile hot paths\n\u25a1 Leverage factory functions for repeated creations\n\u25a1 Monitor memory usage\n\u25a1 Batch operator applications where possible\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#1-computational-backends","title":"1. Computational Backends","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#backend-comparison","title":"Backend Comparison","text":"Backend Best For Speed GPU Support Memory NumPy Small networks (&lt;100 nodes) Baseline No Low JAX Large networks, GPU available 10-100x Yes Medium PyTorch Integration with ML pipelines 5-50x Yes Medium"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#numpy-backend-default","title":"NumPy Backend (Default)","text":"<pre><code>import tnfr\n\n# NumPy is default\nprint(tnfr.get_backend())  # 'numpy'\n\n# Pros:\n# - No extra dependencies\n# - Low memory footprint\n# - Stable and well-tested\n\n# Cons:\n# - Slowest for large networks\n# - No GPU acceleration\n</code></pre> <p>When to use: Networks with &lt;100 nodes, no GPU available, minimal dependencies desired.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#jax-backend","title":"JAX Backend","text":"<pre><code># Install JAX backend\npip install tnfr[compute-jax]\n</code></pre> <pre><code>import tnfr\n\n# Switch to JAX\ntnfr.set_backend('jax')\n\n# Pros:\n# - 10-100x faster on GPU\n# - JIT compilation for repeated ops\n# - Automatic differentiation\n\n# Cons:\n# - Larger dependency footprint\n# - Requires GPU for full benefit\n# - JIT warmup cost\n\n# Verify GPU\nimport jax\nprint(jax.devices())  # Should show GPU if available\n</code></pre> <p>When to use: Networks with 100+ nodes, GPU available, performance critical.</p> <p>Performance Tips: <pre><code># Pre-compile frequently used operations\nfrom jax import jit\n\n@jit\ndef coherence_batch(G):\n    \"\"\"JIT-compiled coherence for repeated calls.\"\"\"\n    from tnfr.operators import Coherence\n    Coherence()(G)\n\n# First call: compilation overhead\ncoherence_batch(G)  # Slow (JIT compilation)\n\n# Subsequent calls: fast\ncoherence_batch(G)  # Fast (cached compilation)\ncoherence_batch(G)  # Fast\n</code></pre></p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#pytorch-backend","title":"PyTorch Backend","text":"<pre><code># Install PyTorch backend\npip install tnfr[compute-torch]\n</code></pre> <pre><code>import tnfr\n\n# Switch to PyTorch\ntnfr.set_backend('torch')\n\n# Pros:\n# - Good GPU performance\n# - Easy ML integration\n# - Rich ecosystem\n\n# Cons:\n# - Slightly slower than JAX\n# - Larger memory footprint\n</code></pre> <p>When to use: Integration with PyTorch ML models, hybrid TNFR/ML systems.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#backend-selection-strategy","title":"Backend Selection Strategy","text":"<pre><code>import tnfr\n\ndef select_optimal_backend(num_nodes, has_gpu=None):\n    \"\"\"Automatically select best backend.\"\"\"\n    if has_gpu is None:\n        # Auto-detect\n        try:\n            import jax\n            has_gpu = len(jax.devices('gpu')) &gt; 0\n        except:\n            has_gpu = False\n\n    if num_nodes &lt; 50:\n        return 'numpy'  # NumPy sufficient\n    elif num_nodes &lt; 200 and not has_gpu:\n        return 'numpy'  # NumPy acceptable\n    elif has_gpu:\n        return 'jax'  # JAX for GPU\n    else:\n        return 'numpy'  # NumPy fallback\n\n# Use it\nbackend = select_optimal_backend(len(G.nodes()))\ntnfr.set_backend(backend)\nprint(f\"Selected backend: {backend}\")\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#2-caching-strategies","title":"2. Caching Strategies","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#enable-caching","title":"Enable Caching","text":"<pre><code># Install caching support\npip install tnfr[orjson]\n</code></pre> <pre><code># Caching is automatic once orjson is installed\nimport tnfr\nprint(\"Caching available:\", tnfr.caching_enabled())\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#cache-hot-paths","title":"Cache Hot Paths","text":"<p>TNFR automatically caches: - Laplacian matrices: Graph structure computations - C(t) history: Time-series coherence data - Si projections: Sense index buffer arrays - Phase calculations: Synchronization metrics</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#cache-configuration","title":"Cache Configuration","text":"<pre><code>from tnfr.cache import configure_cache\n\n# Default: 128 entries per cache\nconfigure_cache(max_entries=256)  # Increase for larger networks\n\n# Clear caches manually if needed\nfrom tnfr.cache import clear_all_caches\nclear_all_caches()\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#buffer-management","title":"Buffer Management","text":"<p>TNFR uses unified buffer management for hot paths:</p> <pre><code># Example: Sense index uses cached buffers\nfrom tnfr.metrics import sense_index\n\n# First call: allocates buffers\nSi1 = sense_index(G)  # Slower (allocation)\n\n# Subsequent calls: reuses buffers\nSi2 = sense_index(G)  # Faster (cached)\nSi3 = sense_index(G)  # Faster (cached)\n</code></pre> <p>Internal details (for reference): - Buffers are keyed by <code>(operation, node_count, buffer_count)</code> - Automatic invalidation on graph structure change - LRU eviction when cache full</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#cache-optimization-tips","title":"Cache Optimization Tips","text":"<ol> <li>Reuse graph objects: Cache is per-graph instance</li> <li>Batch operations: Multiple ops benefit from cached data</li> <li>Monitor cache hits: Enable telemetry to see cache efficiency</li> <li>Adjust size: Increase max_entries for complex networks</li> </ol>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#3-factory-patterns","title":"3. Factory Patterns","text":"<p>Factory functions provide efficient, validated object creation.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#naming-conventions","title":"Naming Conventions","text":"Pattern Prefix Purpose Example Operator Factories <code>make_*</code> Create validated operators <code>make_coherence_operator()</code> Generator Factories <code>build_*</code> Construct matrices <code>build_laplacian()</code> Node Factories <code>create_*</code> Create nodes/networks <code>create_network()</code>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#using-operator-factories","title":"Using Operator Factories","text":"<pre><code>from tnfr.factories import make_coherence_operator\n\n# Create validated operator\ncoherence_op = make_coherence_operator(\n    dim=10,\n    threshold=0.5,\n    strict=True\n)\n\n# Apply to network\ncoherence_op.apply(G)\n</code></pre> <p>Benefits: - \u2705 Automatic validation - \u2705 Type checking - \u2705 Performance optimization - \u2705 Consistent interface</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#generator-factories","title":"Generator Factories","text":"<pre><code>from tnfr.factories import build_delta_nfr_generator\n\n# Efficient \u0394NFR computation\ngenerator = build_delta_nfr_generator(\n    topology=G,\n    coupling_strength=0.8\n)\n\n# Compute \u0394NFR for all nodes\ndelta_nfr_values = generator.compute()\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#node-factories","title":"Node Factories","text":"<pre><code>from tnfr.factories import create_network\n\n# Optimized network creation\nG = create_network(\n    nodes=100,\n    connectivity=0.05,  # Sparse: 5%\n    initial_frequency=1.0,\n    phase_distribution='uniform',\n    optimize=True  # Enable factory optimizations\n)\n</code></pre> <p>Factory optimization features: - Pre-allocated buffers - Cached templates - Vectorized initialization - Validated invariants</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#factory-function-template","title":"Factory Function Template","text":"<p>For creating custom factories:</p> <pre><code>def make_custom_operator(\n    dim: int,\n    *,\n    param1: float = 1.0,\n    param2: str = 'default',\n) -&gt; CustomOperator:\n    \"\"\"Create validated custom operator.\n\n    Parameters\n    ----------\n    dim : int\n        Hilbert space dimensionality\n    param1 : float, optional\n        Parameter description (default: 1.0)\n    param2 : str, optional\n        Parameter description (default: 'default')\n\n    Returns\n    -------\n    CustomOperator\n        Validated operator instance\n\n    Raises\n    ------\n    ValueError\n        If validation fails\n    \"\"\"\n    # Validation\n    if dim &lt; 1:\n        raise ValueError(f\"dim must be positive, got {dim}\")\n\n    # Construction\n    operator = CustomOperator(dim, param1, param2)\n\n    # Post-validation\n    operator.validate()\n\n    return operator\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#4-network-topology-optimization","title":"4. Network Topology Optimization","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#sparse-vs-dense-networks","title":"Sparse vs Dense Networks","text":"<p>Dense network (poor performance): <pre><code># 100 nodes, 100% connectivity = 4,950 edges\nG_dense = tnfr.create_network(nodes=100, connectivity=1.0)\n# Memory: High, Speed: Slow\n</code></pre></p> <p>Sparse network (good performance): <pre><code># 100 nodes, 5% connectivity = ~250 edges\nG_sparse = tnfr.create_network(nodes=100, connectivity=0.05)\n# Memory: Low, Speed: Fast\n</code></pre></p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#connectivity-guidelines","title":"Connectivity Guidelines","text":"Network Size Recommended Connectivity Edges Performance &lt;50 nodes 10-30% &lt;400 Fast 50-200 nodes 5-15% &lt;3000 Good 200-1000 nodes 2-10% &lt;50k Acceptable 1000+ nodes 1-5% &lt;100k Use GPU"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#dynamic-sparsification","title":"Dynamic Sparsification","text":"<p>Remove weak couplings to maintain sparsity:</p> <pre><code>def sparsify_network(G, threshold=0.1):\n    \"\"\"Remove weak couplings below threshold.\"\"\"\n    edges_to_remove = []\n\n    for u, v in G.edges():\n        strength = G[u][v].get('coupling', 1.0)\n        if strength &lt; threshold:\n            edges_to_remove.append((u, v))\n\n    print(f\"Removing {len(edges_to_remove)} weak edges\")\n    G.remove_edges_from(edges_to_remove)\n\n    return G\n\n# Apply periodically\nif G.number_of_edges() &gt; 1000:\n    G = sparsify_network(G, threshold=0.15)\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#5-profiling-and-monitoring","title":"5. Profiling and Monitoring","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#basic-profiling","title":"Basic Profiling","text":"<pre><code>import time\nfrom tnfr.operators import Coherence, Resonance\n\ndef profile_operators(G, operators, iterations=100):\n    \"\"\"Profile operator performance.\"\"\"\n    results = {}\n\n    for op in operators:\n        op_name = op.__class__.__name__\n        start = time.time()\n\n        for _ in range(iterations):\n            op(G)\n\n        elapsed = time.time() - start\n        results[op_name] = elapsed / iterations\n\n    print(\"Operator Performance (avg time):\")\n    for op_name, avg_time in sorted(results.items(), key=lambda x: x[1], reverse=True):\n        print(f\"  {op_name}: {avg_time*1000:.2f} ms\")\n\n    return results\n\n# Profile\noperators = [Coherence(), Resonance()]\nprofile_operators(G, operators)\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#memory-profiling","title":"Memory Profiling","text":"<pre><code>import psutil\nimport os\n\ndef memory_usage_mb():\n    \"\"\"Current process memory usage in MB.\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / 1024 / 1024\n\n# Before\nmem_before = memory_usage_mb()\n\n# Operation\nlarge_network = tnfr.create_network(nodes=1000, connectivity=0.1)\n\n# After\nmem_after = memory_usage_mb()\nprint(f\"Memory increase: {mem_after - mem_before:.1f} MB\")\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#hot-path-identification","title":"Hot Path Identification","text":"<pre><code>import cProfile\nimport pstats\n\ndef identify_hot_paths():\n    \"\"\"Profile to find performance bottlenecks.\"\"\"\n    profiler = cProfile.Profile()\n\n    profiler.enable()\n\n    # Your code here\n    G = tnfr.create_network(nodes=100)\n    for _ in range(10):\n        Coherence()(G)\n        Resonance()(G, list(G.nodes())[0])\n\n    profiler.disable()\n\n    # Print stats\n    stats = pstats.Stats(profiler)\n    stats.sort_stats('cumulative')\n    stats.print_stats(20)  # Top 20 functions\n\nidentify_hot_paths()\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#6-optimization-recipes","title":"6. Optimization Recipes","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#recipe-1-small-network-50-nodes","title":"Recipe 1: Small Network (&lt; 50 nodes)","text":"<pre><code>import tnfr\n\n# Configuration\nconfig = {\n    'backend': 'numpy',  # Default, no extra deps\n    'caching': False,  # Overhead not worth it\n    'connectivity': 0.2,  # 20%\n}\n\n# Create\nG = tnfr.create_network(nodes=30, connectivity=config['connectivity'])\n\n# Use directly\nfrom tnfr.operators import Coherence\nCoherence()(G)\n</code></pre> <p>Expected performance: &lt;10ms per operator</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#recipe-2-medium-network-50-200-nodes","title":"Recipe 2: Medium Network (50-200 nodes)","text":"<pre><code>import tnfr\n\n# Configuration\nconfig = {\n    'backend': 'numpy',  # Or 'jax' if GPU available\n    'caching': True,  # Enable caching\n    'connectivity': 0.1,  # 10%\n}\n\n# Enable caching\n# (requires: pip install tnfr[orjson])\n\n# Create\nG = tnfr.create_network(nodes=100, connectivity=config['connectivity'])\n\n# Use with factory patterns\nfrom tnfr.factories import make_coherence_operator\ncoherence = make_coherence_operator(dim=100)\ncoherence.apply(G)\n</code></pre> <p>Expected performance: 10-100ms per operator</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#recipe-3-large-network-200-1000-nodes","title":"Recipe 3: Large Network (200-1000 nodes)","text":"<pre><code>import tnfr\n\n# Configuration - GPU required\ntnfr.set_backend('jax')\n\nconfig = {\n    'connectivity': 0.05,  # 5% - keep sparse\n    'caching': True,\n    'batch_size': 10,  # Batch operations\n}\n\n# Create sparse network\nG = tnfr.create_network(\n    nodes=500,\n    connectivity=config['connectivity']\n)\n\n# Batch operator applications\nfrom tnfr.operators import Coherence\ncoherence_op = Coherence()\n\nfor batch in range(10):\n    coherence_op(G)  # Reuses JIT-compiled code\n\n# Periodic sparsification\nfrom tnfr.optimization import sparsify_network\nif G.number_of_edges() &gt; 5000:\n    G = sparsify_network(G, threshold=0.1)\n</code></pre> <p>Expected performance: 50-500ms per operator (with GPU)</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#recipe-4-very-large-network-1000-nodes","title":"Recipe 4: Very Large Network (1000+ nodes)","text":"<pre><code>import tnfr\n\n# Requires GPU + JAX\ntnfr.set_backend('jax')\n\n# Aggressive sparsity\nG = tnfr.create_network(\n    nodes=2000,\n    connectivity=0.02  # 2% = ~40k edges\n)\n\n# Optimize for GPU\nfrom jax import jit\nfrom tnfr.operators import Coherence\n\n# Pre-compile\n@jit\ndef optimized_coherence(G):\n    Coherence()(G)\n\n# Warmup JIT\noptimized_coherence(G)\n\n# Fast execution\nfor _ in range(100):\n    optimized_coherence(G)  # &lt; 100ms per call with GPU\n</code></pre> <p>Expected performance: 100-1000ms per operator (with GPU)</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#7-dependency-management","title":"7. Dependency Management","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#core-dependencies","title":"Core Dependencies","text":"<pre><code>numpy&gt;=1.20\nnetworkx&gt;=2.5\ncachetools&gt;=4.0\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#optional-dependencies-by-use-case","title":"Optional Dependencies by Use Case","text":"<p>Performance: <pre><code>pip install tnfr[compute-jax]      # GPU acceleration\npip install tnfr[compute-torch]    # PyTorch backend\npip install tnfr[orjson]           # Fast serialization\n</code></pre></p> <p>Visualization: <pre><code>pip install tnfr[viz-basic]        # Matplotlib plotting\n</code></pre></p> <p>Development: <pre><code>pip install tnfr[dev-full]         # All dev tools\n</code></pre></p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#dependency-audit","title":"Dependency Audit","text":"<p>Check what's installed:</p> <pre><code>import tnfr\n\nprint(\"TNFR version:\", tnfr.__version__)\nprint(\"Backend:\", tnfr.get_backend())\nprint(\"Caching:\", tnfr.caching_enabled())\n\n# Check optional deps\ntry:\n    import jax\n    print(\"JAX available:\", jax.__version__)\nexcept ImportError:\n    print(\"JAX: not installed\")\n\ntry:\n    import torch\n    print(\"PyTorch available:\", torch.__version__)\nexcept ImportError:\n    print(\"PyTorch: not installed\")\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#8-best-practices-summary","title":"8. Best Practices Summary","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#do","title":"DO:","text":"<ul> <li>\u2705 Profile before optimizing</li> <li>\u2705 Use sparse networks when possible</li> <li>\u2705 Enable caching for medium+ networks</li> <li>\u2705 Use JAX backend with GPU for large networks</li> <li>\u2705 Batch operator applications</li> <li>\u2705 Monitor memory usage</li> <li>\u2705 Use factory functions for repeated creations</li> </ul>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#dont","title":"DON'T:","text":"<ul> <li>\u274c Optimize prematurely (small networks don't need it)</li> <li>\u274c Use dense connectivity without reason</li> <li>\u274c Switch backends frequently (JIT compilation overhead)</li> <li>\u274c Ignore memory constraints</li> <li>\u274c Create new graph objects unnecessarily</li> </ul>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#9-grammar-20-performance","title":"9. Grammar 2.0 Performance","text":"<p>Grammar 2.0 introduces advanced sequence validation, health analysis, pattern detection, and cycle validation with optimized performance.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#performance-characteristics","title":"Performance Characteristics","text":"<p>Benchmarked Performance (all well below targets):</p> Component Target Actual Status Basic validation &lt; 2ms ~16-45\u03bcs \u2713 98% under target Health analysis &lt; 10ms ~8.6\u03bcs \u2713 99.9% under target Pattern detection &lt; 5ms ~0.24\u03bcs \u2713 99.995% under target Cycle validation &lt; 3ms ~43\u03bcs \u2713 98.6% under target Full validation + health &lt; 10ms ~54\u03bcs \u2713 99.5% under target"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#optimization-techniques","title":"Optimization Techniques","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#1-single-pass-analysis","title":"1. Single-Pass Analysis","text":"<p>Health analysis uses a single scan to extract all statistics:</p> <pre><code>from tnfr.operators.health_analyzer import SequenceHealthAnalyzer\n\nanalyzer = SequenceHealthAnalyzer()\n\n# Single pass computes all metrics efficiently\nsequence = [\"emission\", \"reception\", \"coherence\", \"dissonance\", \n            \"self_organization\", \"coherence\", \"silence\"]\nhealth = analyzer.analyze_health(sequence)\n\n# Results cached for repeated analysis\nhealth2 = analyzer.analyze_health(sequence)  # Cache hit - instant\n</code></pre> <p>Benefit: 25-30% faster than naive multi-pass approach.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#2-result-caching","title":"2. Result Caching","text":"<p>Both health analysis and pattern detection use <code>lru_cache</code> for repeated sequences:</p> <pre><code>from tnfr.operators.patterns import AdvancedPatternDetector\n\ndetector = AdvancedPatternDetector()\n\n# First call - computes and caches\npattern1 = detector.detect_pattern(sequence)  # ~0.4\u03bcs\n\n# Repeated calls - cache hits\npattern2 = detector.detect_pattern(sequence)  # ~0.24\u03bcs (50% faster)\npattern3 = detector.detect_pattern(sequence)  # ~0.24\u03bcs\n</code></pre> <p>Cache Configuration: - Health analyzer: <code>maxsize=128</code> (workflow sequences) - Pattern detector: <code>maxsize=256</code> (pattern exploration)</p> <p>Benefit: 50-100x speedup for repeated sequences.</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#3-batch-processing","title":"3. Batch Processing","text":"<p>Reuse analyzer instances to maximize cache efficiency:</p> <pre><code># Good - benefits from caching\nanalyzer = SequenceHealthAnalyzer()\ndetector = AdvancedPatternDetector()\n\nresults = []\nfor sequence in batch_of_sequences:\n    health = analyzer.analyze_health(sequence)\n    pattern = detector.detect_pattern(sequence)\n    results.append((health, pattern))\n\n# Not recommended - recreates instances\nfor sequence in batch_of_sequences:\n    analyzer = SequenceHealthAnalyzer()  # No cache reuse\n    health = analyzer.analyze_health(sequence)\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#best-practices","title":"Best Practices","text":"<ol> <li>Reuse analyzer instances for cache benefits</li> <li>Use tuples for sequences when possible (hashable for caching)</li> <li>Batch process related sequences together</li> <li>Profile with tools in <code>tools/performance/</code> before optimizing</li> </ol>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#profiling-tools","title":"Profiling Tools","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#grammar-profiler","title":"Grammar Profiler","text":"<p>Detailed component-level analysis:</p> <pre><code># Run profiler\nTNFR_LOG_LEVEL=ERROR python tools/performance/grammar_profiler.py\n\n# Output includes:\n# - Component timings (min/max/mean/median/stdev)\n# - Bottleneck identification\n# - Target compliance checking\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#benchmark-suite","title":"Benchmark Suite","text":"<p>Comprehensive regression testing:</p> <pre><code># Run benchmarks\nTNFR_LOG_LEVEL=ERROR python benchmarks/grammar_2_0_benchmarks.py\n\n# Tests:\n# - Validation across sequence lengths\n# - Pattern detection for all types\n# - Health analysis performance\n# - Cycle detection efficiency\n# - Caching effectiveness\n# - Worst-case scenarios\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#pytest-benchmarks","title":"Pytest Benchmarks","text":"<p>Integrated performance tests:</p> <pre><code># Run with benchmark reporting\npytest tests/performance/test_grammar_2_0_performance.py --benchmark-only -v\n\n# Reports ops/sec and timing statistics\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#performance-monitoring","title":"Performance Monitoring","text":"<p>Monitor performance in production:</p> <pre><code>from time import perf_counter\nfrom tnfr.operators.grammar import validate_sequence_with_health\n\ndef validate_with_timing(sequence):\n    \"\"\"Validate and track timing.\"\"\"\n    start = perf_counter()\n    result = validate_sequence_with_health(sequence)\n    elapsed_us = (perf_counter() - start) * 1e6\n\n    # Log if above threshold\n    if elapsed_us &gt; 100:  # 100\u03bcs threshold\n        print(f\"Slow validation: {elapsed_us:.2f}\u03bcs for {len(sequence)} ops\")\n\n    return result\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#optimization-checklist","title":"Optimization Checklist","text":"<pre><code>\u25a1 Reuse SequenceHealthAnalyzer instances\n\u25a1 Reuse AdvancedPatternDetector instances\n\u25a1 Batch process related sequences\n\u25a1 Use tuples for frequently analyzed sequences\n\u25a1 Profile with grammar_profiler.py before optimizing\n\u25a1 Monitor with pytest benchmarks\n\u25a1 Check cache hit rates in production\n\u25a1 Stay within performance targets (&lt; 10ms)\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#memory-considerations","title":"Memory Considerations","text":"<p>Grammar 2.0 uses minimal memory:</p> <ul> <li>Base overhead: ~50KB for analyzer instances</li> <li>Cache overhead: ~5KB per cached sequence (LRU evicts old entries)</li> <li>No memory leaks: LRU cache automatically manages size</li> </ul> <p>Memory-constrained environments:</p> <pre><code># Reduce cache sizes if needed\nfrom functools import lru_cache\n\n# Modify cache size (example - not recommended unless necessary)\n# The default sizes (128/256) are already conservative\n</code></pre>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#when-to-optimize-further","title":"When to Optimize Further","text":"<p>Grammar 2.0 is already highly optimized. Further optimization is only needed if:</p> <ol> <li>Processing millions of sequences in tight loops</li> <li>Real-time validation with sub-millisecond requirements</li> <li>Memory extremely constrained (&lt; 1MB available)</li> </ol> <p>In these cases: - Consider pre-validation to filter invalid sequences - Use simpler validation (skip health/pattern analysis) - Disable caching if memory is critical</p>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#see-also","title":"See Also","text":""},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#related-documentation","title":"Related Documentation:","text":"<ul> <li>Math Backends - Backend configuration details</li> <li>Scalability Guide - Scaling to very large networks</li> <li>Architecture Guide - Factory patterns and dependency analysis</li> <li>Testing Strategies - Test optimization and automation</li> <li>Development Workflow - Contributing and CI/CD practices</li> </ul>"},{"location":"advanced/PERFORMANCE_OPTIMIZATION/#external-resources","title":"External Resources:","text":"<ul> <li>JAX Documentation</li> <li>PyTorch Documentation</li> <li>NetworkX Performance Tips</li> </ul> <p>Next: Explore Mathematical Foundations for rigorous mathematical derivations \u2192</p>"},{"location":"advanced/TESTING_STRATEGIES/","title":"TNFR Testing Strategies","text":"<p>Comprehensive guide to testing patterns, compatibility verification, and automation in TNFR</p> <p>This guide consolidates testing knowledge for the TNFR Python Engine, covering test strategies, dependency compatibility, test optimization, and type stub automation workflows.</p>"},{"location":"advanced/TESTING_STRATEGIES/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Testing Philosophy</li> <li>Test Infrastructure</li> <li>Dependency Compatibility</li> <li>Test Optimization</li> <li>Type Stub Testing</li> <li>Testing Patterns</li> <li>CI/CD Integration</li> <li>Troubleshooting</li> </ol>"},{"location":"advanced/TESTING_STRATEGIES/#testing-philosophy","title":"Testing Philosophy","text":""},{"location":"advanced/TESTING_STRATEGIES/#tnfr-testing-principles","title":"TNFR Testing Principles","text":"<ol> <li>Structural Integrity First: Tests must verify TNFR invariants (coherence, phase, \u03bdf, \u0394NFR)</li> <li>Reproducibility: All tests must be deterministic with explicit seeds</li> <li>Traceability: Test failures should clearly indicate which structural invariant was violated</li> <li>Isolation: Each test should be independent and not rely on global state</li> <li>Completeness: Cover valid cases, invalid inputs, edge cases, and structural invariants</li> </ol>"},{"location":"advanced/TESTING_STRATEGIES/#test-categories","title":"Test Categories","text":"<pre><code>Unit Tests (tests/unit/)\n\u251c\u2500\u2500 Fast (&lt;1ms each)\n\u251c\u2500\u2500 Test single functions in isolation\n\u251c\u2500\u2500 Mock external dependencies\n\u2514\u2500\u2500 60%+ of test suite\n\nIntegration Tests (tests/integration/)\n\u251c\u2500\u2500 Moderate speed (1-100ms each)\n\u251c\u2500\u2500 Test component interactions\n\u251c\u2500\u2500 Use real graph structures\n\u2514\u2500\u2500 30%+ of test suite\n\nCritical Path Tests\n\u251c\u2500\u2500 Verify TNFR invariants\n\u251c\u2500\u2500 Test structural operators\n\u251c\u2500\u2500 Ensure canonical behavior\n\u2514\u2500\u2500 10%+ of test suite (must pass)\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#test-infrastructure","title":"Test Infrastructure","text":""},{"location":"advanced/TESTING_STRATEGIES/#testing-dependencies","title":"Testing Dependencies","text":"<p>All testing dependencies are fully compatible with pytest 8.x:</p> Package Version Status Purpose pytest <code>&gt;=7,&lt;9</code> \u2705 Compatible Core testing framework pytest-cov <code>&gt;=4,&lt;8</code> \u2705 Compatible Coverage reporting pytest-timeout <code>&gt;=2,&lt;3</code> \u2705 Compatible Timeout functionality pytest-xdist <code>&gt;=3,&lt;4</code> \u2705 Compatible Parallel execution pytest-benchmark <code>&gt;=4,&lt;6</code> \u2705 Compatible Performance benchmarks hypothesis <code>&gt;=6,&lt;7</code> \u2705 Compatible Property-based testing hypothesis-networkx <code>&gt;=0.3,&lt;1.0</code> \u2705 Compatible Network graph generation"},{"location":"advanced/TESTING_STRATEGIES/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest tests/\n\n# Run with coverage\npytest tests/ --cov=tnfr --cov-report=html\n\n# Run with parallelization\npytest tests/ -n auto\n\n# Run specific category\npytest tests/unit/           # Unit tests only\npytest tests/integration/    # Integration tests only\n\n# Run with timeout protection\npytest tests/ --timeout=300\n\n# Run benchmarks\npytest tests/ --benchmark-only\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#test-configuration","title":"Test Configuration","text":"<p>The test suite is configured in <code>pyproject.toml</code>:</p> <pre><code>[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"--strict-markers\",\n    \"--strict-config\",\n    \"--tb=short\",\n]\nmarkers = [\n    \"unit: Unit tests\",\n    \"integration: Integration tests\",\n    \"critical: Critical path tests that must pass\",\n    \"slow: Tests that take &gt;1s\",\n]\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#dependency-compatibility","title":"Dependency Compatibility","text":""},{"location":"advanced/TESTING_STRATEGIES/#pytest-8x-compatibility","title":"Pytest 8.x Compatibility","text":""},{"location":"advanced/TESTING_STRATEGIES/#verified-compatibility","title":"Verified Compatibility","text":"<p>All testing dependencies work correctly with pytest 8.x:</p> <pre><code># Install test dependencies\npip install -e .[test-all]\n\n# Verify pytest version\npytest --version  # Should show 8.x\n\n# Run compatibility tests\npytest tests/ci/test_pytest_compatibility.py -v\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#compatibility-test-suite","title":"Compatibility Test Suite","text":"<p>The repository includes a comprehensive compatibility test suite at <code>tests/ci/test_pytest_compatibility.py</code> that verifies:</p> <ul> <li>\u2705 Pytest version is 8.x</li> <li>\u2705 All plugins are available and loaded</li> <li>\u2705 Plugin functionality works correctly</li> <li>\u2705 No pytest deprecation warnings</li> <li>\u2705 All pytest features work as expected</li> <li>\u2705 Configuration from pyproject.toml loads correctly</li> </ul>"},{"location":"advanced/TESTING_STRATEGIES/#migration-from-pytest-7x-to-8x","title":"Migration from Pytest 7.x to 8.x","text":"<p>Good news: No code changes required! The migration is seamless:</p> <ul> <li>All existing tests run without modification</li> <li>No API changes affecting this codebase</li> <li>All plugins work identically</li> <li>Configuration remains unchanged</li> </ul>"},{"location":"advanced/TESTING_STRATEGIES/#dependency-version-strategy","title":"Dependency Version Strategy","text":"<p>TNFR uses a forward-compatible version pinning strategy:</p> <pre><code># pyproject.toml strategy\ndependencies = [\n    \"pytest&gt;=7,&lt;9\",        # Allow 7.x and 8.x\n    \"pytest-cov&gt;=4,&lt;8\",    # Allow 4.x through 7.x\n    \"pytest-timeout&gt;=2,&lt;3\", # Pin major version\n]\n</code></pre> <p>Benefits: - \u2705 Pin major versions to avoid breaking changes - \u2705 Allow minor and patch updates for bug fixes - \u2705 Test with latest versions in CI - \u2705 Document compatibility explicitly</p>"},{"location":"advanced/TESTING_STRATEGIES/#future-considerations","title":"Future Considerations","text":"<p>When pytest 9.x is released:</p> <ol> <li>Review release notes for breaking changes</li> <li>Update version constraint from <code>&lt;9</code> to <code>&lt;10</code></li> <li>Run compatibility test suite</li> <li>Update this documentation</li> </ol>"},{"location":"advanced/TESTING_STRATEGIES/#test-optimization","title":"Test Optimization","text":""},{"location":"advanced/TESTING_STRATEGIES/#test-execution-speed","title":"Test Execution Speed","text":"Optimization Technique Speedup Trade-off Parallelization <code>pytest -n auto</code> 2-8x None (recommended) Selective Running <code>-k pattern</code> N/A Must know what changed Test Markers <code>-m unit</code> 10x+ Skips integration tests Fast Backend <code>TNFR_BACKEND=numpy</code> 1.5x vs. unoptimized Python Caching <code>--cache-clear=no</code> 1.2x May miss cache invalidations"},{"location":"advanced/TESTING_STRATEGIES/#parallel-test-execution","title":"Parallel Test Execution","text":"<pre><code># Automatic parallelization\npytest tests/ -n auto\n\n# Explicit worker count\npytest tests/ -n 4\n\n# With coverage (slower but accurate)\npytest tests/ -n auto --cov=tnfr\n</code></pre> <p>Best practices: - Use <code>-n auto</code> for CI/CD pipelines - Use specific <code>-n N</code> for local development (N = CPU cores) - Disable parallelization for debugging: <code>pytest tests/ -n 0</code></p>"},{"location":"advanced/TESTING_STRATEGIES/#selective-test-running","title":"Selective Test Running","text":"<pre><code># Run only fast tests\npytest tests/ -m \"not slow\"\n\n# Run only unit tests\npytest tests/ -m unit\n\n# Run only critical path tests\npytest tests/ -m critical\n\n# Run tests matching pattern\npytest tests/ -k \"test_coherence\"\n\n# Run specific test file\npytest tests/unit/test_operators.py\n\n# Run specific test function\npytest tests/unit/test_operators.py::test_coherence_operator\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#test-profiling","title":"Test Profiling","text":"<p>Identify slow tests:</p> <pre><code># Show slowest 10 tests\npytest tests/ --durations=10\n\n# Show all test durations\npytest tests/ --durations=0\n\n# Profile with detailed timing\npytest tests/ --durations=0 --verbose\n</code></pre> <p>Example output: <pre><code>slowest durations\n==================\n2.45s call     tests/integration/test_large_network.py::test_1000_nodes\n1.23s call     tests/integration/test_operators.py::test_resonance_propagation\n0.89s call     tests/integration/test_coherence.py::test_global_coherence\n...\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#mocking-for-speed","title":"Mocking for Speed","text":"<p>Use mocks to avoid slow operations in unit tests:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, patch\n\ndef test_operator_with_mock_graph():\n    \"\"\"Test operator without real graph creation.\"\"\"\n    # Create mock graph\n    mock_graph = Mock()\n    mock_graph.nodes.return_value = ['n1', 'n2', 'n3']\n    mock_graph.edges.return_value = [('n1', 'n2'), ('n2', 'n3')]\n\n    # Test operator logic\n    from tnfr.operators import Coherence\n    op = Coherence()\n    # ... test with mock_graph ...\n\n@patch('tnfr.backends.get_backend')\ndef test_with_mocked_backend(mock_backend):\n    \"\"\"Test without loading actual backend.\"\"\"\n    mock_backend.return_value = Mock()\n    # ... test logic ...\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#fixture-optimization","title":"Fixture Optimization","text":"<p>Share expensive fixtures across tests:</p> <pre><code>import pytest\nimport networkx as nx\n\n@pytest.fixture(scope=\"module\")\ndef large_graph():\n    \"\"\"Create graph once per module.\"\"\"\n    G = nx.erdos_renyi_graph(1000, 0.1, seed=42)\n    # Add TNFR attributes\n    for node in G.nodes():\n        G.nodes[node]['nu_f'] = 1.0\n        G.nodes[node]['phase'] = 0.0\n    return G\n\n@pytest.fixture(scope=\"session\")\ndef test_config():\n    \"\"\"Load config once per test session.\"\"\"\n    return {\n        'seed': 42,\n        'tolerance': 1e-9,\n        'backend': 'numpy',\n    }\n\ndef test_with_expensive_fixture(large_graph, test_config):\n    \"\"\"Test reuses pre-created graph.\"\"\"\n    assert len(large_graph) == 1000\n</code></pre> <p>Fixture scopes: - <code>function</code> (default): New instance per test - <code>class</code>: One instance per test class - <code>module</code>: One instance per test file - <code>session</code>: One instance for entire test run</p>"},{"location":"advanced/TESTING_STRATEGIES/#type-stub-testing","title":"Type Stub Testing","text":""},{"location":"advanced/TESTING_STRATEGIES/#type-stub-automation","title":"Type Stub Automation","text":"<p>TNFR uses automated <code>.pyi</code> stub generation to maintain type safety. Type stubs are tested at multiple levels:</p>"},{"location":"advanced/TESTING_STRATEGIES/#pre-commit-hook","title":"Pre-commit Hook","text":"<pre><code># .pre-commit-config.yaml\n- repo: local\n  hooks:\n    - id: check-stubs\n      name: Check for missing .pyi stub files\n      entry: make stubs-check\n      language: system\n      pass_filenames: false\n      always_run: true\n</code></pre> <p>Behavior: - Runs automatically before every commit - Checks for missing <code>.pyi</code> stub files - Prevents commits if stubs are missing - Fast (&lt;1s typically)</p>"},{"location":"advanced/TESTING_STRATEGIES/#ci-checks","title":"CI Checks","text":"<p>The CI pipeline includes two stub checks:</p> <pre><code># .github/workflows/ci.yml (type-check job)\n- name: Check stub files exist\n  run: python scripts/generate_stubs.py --check\n\n- name: Check stub file synchronization\n  run: python scripts/generate_stubs.py --check-sync\n</code></pre> <p>Checks: 1. Missing stubs (<code>--check</code>): Verifies all Python modules have corresponding <code>.pyi</code> files 2. Outdated stubs (<code>--check-sync</code>): Verifies stubs are synchronized with implementations</p>"},{"location":"advanced/TESTING_STRATEGIES/#stub-generation-commands","title":"Stub Generation Commands","text":"<pre><code># Generate missing stub files\nmake stubs\n\n# Check for missing stubs (exit code 1 if any missing)\nmake stubs-check\n\n# Check if stubs are synchronized (exit code 1 if outdated)\nmake stubs-check-sync\n\n# Regenerate outdated stub files\nmake stubs-sync\n\n# Display all available commands\nmake help\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#type-checking","title":"Type Checking","text":"<p>Run mypy to verify type correctness:</p> <pre><code># Type check entire codebase\nmypy src/tnfr\n\n# Type check specific module\nmypy src/tnfr/operators/\n\n# Type check with strict settings\nmypy src/tnfr --strict\n\n# Type check tests too\nmypy src/tnfr tests/\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#stub-troubleshooting","title":"Stub Troubleshooting","text":""},{"location":"advanced/TESTING_STRATEGIES/#issue-ci-fails-with-stub-files-outdated","title":"Issue: CI fails with \"stub files outdated\"","text":"<p>Solution: <pre><code># Run locally before pushing\nmake stubs-check-sync\n\n# Regenerate outdated stubs\nmake stubs-sync\n\n# Commit both .py and .pyi files\ngit add src/tnfr/module.py src/tnfr/module.pyi\ngit commit -m \"Update module and regenerate stub\"\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#issue-pre-commit-hook-fails","title":"Issue: Pre-commit hook fails","text":"<p>Solution: <pre><code># Generate missing stubs\nmake stubs\n\n# Add generated stubs\ngit add src/tnfr/*.pyi\n\n# Retry commit\ngit commit\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#issue-stub-generation-fails","title":"Issue: Stub generation fails","text":"<p>Solution: <pre><code># Ensure mypy is installed\npip install -e .[typecheck]\n\n# Check for syntax errors in .py files\npython -m py_compile src/tnfr/module.py\n\n# Run with verbose output\npython scripts/generate_stubs.py --verbose\n\n# Try dry-run to see what would be generated\npython scripts/generate_stubs.py --dry-run\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#testing-patterns","title":"Testing Patterns","text":""},{"location":"advanced/TESTING_STRATEGIES/#factory-function-testing","title":"Factory Function Testing","text":"<p>Every factory function should follow this test pattern:</p> <pre><code>import pytest\nimport numpy as np\nfrom tnfr.mathematics.operators_factory import make_coherence_operator\n\nclass TestMakeCoherenceOperator:\n    \"\"\"Test suite for coherence operator factory.\"\"\"\n\n    def test_valid_construction_defaults(self):\n        \"\"\"Test construction with default parameters.\"\"\"\n        op = make_coherence_operator(dim=5)\n        assert op.shape == (5, 5)\n        assert op.is_hermitian()\n        assert op.is_positive_semidefinite()\n\n    def test_valid_construction_custom_params(self):\n        \"\"\"Test construction with custom parameters.\"\"\"\n        spectrum = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\n        op = make_coherence_operator(dim=5, spectrum=spectrum)\n        eigenvalues = np.sort(np.linalg.eigvals(op.to_array()))\n        assert np.allclose(eigenvalues, spectrum, atol=1e-9)\n\n    def test_invalid_dimension(self):\n        \"\"\"Test that invalid dimensions raise ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Dimension must be positive\"):\n            make_coherence_operator(dim=0)\n        with pytest.raises(ValueError, match=\"Dimension must be positive\"):\n            make_coherence_operator(dim=-5)\n\n    def test_structural_invariant_hermiticity(self):\n        \"\"\"Test that Hermiticity is guaranteed.\"\"\"\n        op = make_coherence_operator(dim=10)\n        matrix = op.to_array()\n        assert np.allclose(matrix, matrix.conj().T, atol=1e-9)\n\n    def test_structural_invariant_psd(self):\n        \"\"\"Test that positive semidefiniteness is guaranteed.\"\"\"\n        op = make_coherence_operator(dim=10)\n        eigenvalues = np.linalg.eigvalsh(op.to_array())\n        assert np.all(eigenvalues &gt;= -1e-9)  # Numerical tolerance\n\n    def test_reproducibility(self):\n        \"\"\"Test that same inputs produce same outputs.\"\"\"\n        spec = np.linspace(0.1, 0.5, 5)\n        op1 = make_coherence_operator(dim=5, spectrum=spec)\n        op2 = make_coherence_operator(dim=5, spectrum=spec)\n        assert np.allclose(op1.to_array(), op2.to_array())\n</code></pre> <p>Coverage checklist for factory tests: - \u2713 Valid construction with defaults - \u2713 Valid construction with custom parameters - \u2713 Invalid dimension handling - \u2713 Invalid parameter handling - \u2713 Structural invariants (Hermiticity, PSD, etc.) - \u2713 Reproducibility (deterministic output) - \u2713 Edge cases (boundary values)</p>"},{"location":"advanced/TESTING_STRATEGIES/#structural-operator-testing","title":"Structural Operator Testing","text":"<p>Test structural operators against TNFR invariants:</p> <pre><code>import pytest\nimport networkx as nx\nfrom tnfr.operators import Coherence\n\nclass TestCoherenceOperator:\n    \"\"\"Test Coherence structural operator.\"\"\"\n\n    @pytest.fixture\n    def simple_graph(self):\n        \"\"\"Create a simple test graph.\"\"\"\n        G = nx.Graph()\n        G.add_node('n1', nu_f=1.0, phase=0.0, coherence=0.5)\n        G.add_node('n2', nu_f=1.0, phase=0.5, coherence=0.5)\n        G.add_node('n3', nu_f=1.0, phase=1.0, coherence=0.5)\n        G.add_edge('n1', 'n2')\n        G.add_edge('n2', 'n3')\n        return G\n\n    def test_coherence_increases_c_t(self, simple_graph):\n        \"\"\"Test that Coherence operator increases total coherence C(t).\"\"\"\n        from tnfr.metrics import total_coherence\n\n        G = simple_graph\n        c_before = total_coherence(G)\n\n        # Apply Coherence operator\n        Coherence()(G)\n\n        c_after = total_coherence(G)\n        assert c_after &gt;= c_before, \"Coherence should increase C(t)\"\n\n    def test_coherence_preserves_phase(self, simple_graph):\n        \"\"\"Test that Coherence operator does not modify phase.\"\"\"\n        G = simple_graph\n        phases_before = {n: G.nodes[n]['phase'] for n in G.nodes()}\n\n        # Apply Coherence operator\n        Coherence()(G)\n\n        phases_after = {n: G.nodes[n]['phase'] for n in G.nodes()}\n        for node in G.nodes():\n            assert phases_before[node] == phases_after[node]\n\n    def test_coherence_preserves_vf(self, simple_graph):\n        \"\"\"Test that Coherence operator does not modify \u03bdf.\"\"\"\n        G = simple_graph\n        vf_before = {n: G.nodes[n]['nu_f'] for n in G.nodes()}\n\n        # Apply Coherence operator\n        Coherence()(G)\n\n        vf_after = {n: G.nodes[n]['nu_f'] for n in G.nodes()}\n        for node in G.nodes():\n            assert vf_before[node] == vf_after[node]\n\n    def test_coherence_bounded(self, simple_graph):\n        \"\"\"Test that coherence stays in [0, 1] range.\"\"\"\n        G = simple_graph\n\n        # Apply Coherence operator multiple times\n        for _ in range(10):\n            Coherence()(G)\n\n        # Verify bounds\n        for node in G.nodes():\n            c = G.nodes[node]['coherence']\n            assert 0.0 &lt;= c &lt;= 1.0, f\"Coherence {c} out of bounds for {node}\"\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#property-based-testing","title":"Property-Based Testing","text":"<p>Use Hypothesis for property-based testing:</p> <pre><code>from hypothesis import given, strategies as st\nfrom hypothesis_networkx import graph_builder\nimport networkx as nx\n\n@given(\n    graph=graph_builder(\n        graph_type=nx.Graph,\n        min_nodes=3,\n        max_nodes=20,\n        edge_probability=st.floats(0.1, 0.5)\n    ),\n    nu_f=st.floats(0.1, 10.0),\n    phase=st.floats(0.0, 2 * 3.14159)\n)\ndef test_operator_preserves_structural_invariants(graph, nu_f, phase):\n    \"\"\"Test that operators preserve structural invariants for any valid graph.\"\"\"\n    # Initialize graph with TNFR attributes\n    for node in graph.nodes():\n        graph.nodes[node]['nu_f'] = nu_f\n        graph.nodes[node]['phase'] = phase\n        graph.nodes[node]['coherence'] = 1.0\n\n    # Apply operator\n    from tnfr.operators import Coherence\n    Coherence()(graph)\n\n    # Verify invariants\n    for node in graph.nodes():\n        assert graph.nodes[node]['nu_f'] &gt;= 0, \"\u03bdf must be non-negative\"\n        assert 0 &lt;= graph.nodes[node]['phase'] &lt; 2 * 3.14159, \"Phase must be in [0, 2\u03c0)\"\n        assert 0 &lt;= graph.nodes[node]['coherence'] &lt;= 1, \"Coherence in [0, 1]\"\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#reproducibility-testing","title":"Reproducibility Testing","text":"<p>Ensure deterministic behavior:</p> <pre><code>import pytest\nimport networkx as nx\nfrom tnfr.structural import create_nfr\n\ndef test_create_nfr_reproducibility():\n    \"\"\"Test that create_nfr is deterministic with same seed.\"\"\"\n    G1 = nx.Graph()\n    G2 = nx.Graph()\n\n    # Create with same seed\n    G1, node1 = create_nfr(G1, nu_f=2.0, phase=0.5, seed=42)\n    G2, node2 = create_nfr(G2, nu_f=2.0, phase=0.5, seed=42)\n\n    # Should produce identical results\n    assert node1 == node2\n    assert G1.nodes[node1]['nu_f'] == G2.nodes[node2]['nu_f']\n    assert G1.nodes[node1]['phase'] == G2.nodes[node2]['phase']\n\ndef test_operator_sequence_reproducibility():\n    \"\"\"Test that operator sequences are reproducible.\"\"\"\n    import numpy as np\n    from tnfr.operators import Coherence, Resonance\n\n    # Create two identical graphs\n    np.random.seed(42)\n    G1 = nx.erdos_renyi_graph(10, 0.3, seed=42)\n    for node in G1.nodes():\n        G1.nodes[node]['nu_f'] = 1.0\n        G1.nodes[node]['phase'] = 0.0\n        G1.nodes[node]['coherence'] = 1.0\n\n    np.random.seed(42)\n    G2 = nx.erdos_renyi_graph(10, 0.3, seed=42)\n    for node in G2.nodes():\n        G2.nodes[node]['nu_f'] = 1.0\n        G2.nodes[node]['phase'] = 0.0\n        G2.nodes[node]['coherence'] = 1.0\n\n    # Apply same operations\n    ops = [Coherence(), Resonance()]\n    for op in ops:\n        op(G1)\n        op(G2)\n\n    # Compare results\n    for node in G1.nodes():\n        assert G1.nodes[node]['coherence'] == G2.nodes[node]['coherence']\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"advanced/TESTING_STRATEGIES/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>The CI pipeline runs tests at multiple stages:</p> <pre><code># .github/workflows/ci.yml (simplified)\nname: CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.9', '3.10', '3.11', '3.12', '3.13']\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          pip install -e .[test-all]\n\n      - name: Run tests\n        run: |\n          pytest tests/ -n auto --cov=tnfr --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n\n  type-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Check stub files exist\n        run: make stubs-check\n\n      - name: Check stub file synchronization\n        run: make stubs-check-sync\n\n      - name: Run mypy\n        run: mypy src/tnfr\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#test-stages","title":"Test Stages","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Pre-commit     \u2502  \u2190 Local: Stub checks, formatting\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Push to GitHub \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Type Check Job \u2502  \u2190 CI: Stub validation, mypy\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Test Job       \u2502  \u2190 CI: pytest with coverage\n\u2502  (3.9-3.13)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Coverage       \u2502  \u2190 Upload to Codecov\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#local-pre-push-checks","title":"Local Pre-Push Checks","text":"<p>Run these checks before pushing:</p> <pre><code># 1. Check for missing stubs\nmake stubs-check\n\n# 2. Check stub synchronization\nmake stubs-check-sync\n\n# 3. Run tests\npytest tests/ -n auto\n\n# 4. Check coverage\npytest tests/ --cov=tnfr --cov-report=term-missing\n\n# 5. Type check\nmypy src/tnfr\n\n# All-in-one command\nmake stubs-check &amp;&amp; make stubs-check-sync &amp;&amp; pytest tests/ -n auto &amp;&amp; mypy src/tnfr\n</code></pre>"},{"location":"advanced/TESTING_STRATEGIES/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/TESTING_STRATEGIES/#common-test-failures","title":"Common Test Failures","text":""},{"location":"advanced/TESTING_STRATEGIES/#issue-modulenotfounderror-no-module-named-tnfr","title":"Issue: \"ModuleNotFoundError: No module named 'tnfr'\"","text":"<p>Cause: Package not installed in editable mode</p> <p>Solution: <pre><code>pip install -e .\n# Or with test dependencies\npip install -e .[test-all]\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#issue-tests-hang-or-timeout","title":"Issue: Tests hang or timeout","text":"<p>Cause: Infinite loop or deadlock in code</p> <p>Solution: <pre><code># Run with timeout protection\npytest tests/ --timeout=300\n\n# Run specific test with verbose output\npytest tests/path/to/test.py::test_function -vv\n\n# Add timeout to specific test\n@pytest.mark.timeout(10)\ndef test_might_hang():\n    ...\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#issue-flaky-tests-passfail-randomly","title":"Issue: Flaky tests (pass/fail randomly)","text":"<p>Cause: Missing or incorrect random seeds</p> <p>Solution: <pre><code># Add explicit seeds\ndef test_with_seed():\n    np.random.seed(42)\n    rng = np.random.default_rng(42)\n    # ... test code ...\n\n# Use fixtures for consistent state\n@pytest.fixture\ndef seeded_rng():\n    return np.random.default_rng(42)\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#issue-coverage-drops-unexpectedly","title":"Issue: Coverage drops unexpectedly","text":"<p>Cause: New code without tests, or test skipped</p> <p>Solution: <pre><code># Check what's not covered\npytest tests/ --cov=tnfr --cov-report=term-missing\n\n# Look for skipped tests\npytest tests/ -v | grep SKIPPED\n\n# Check branch coverage\npytest tests/ --cov=tnfr --cov-branch\n</code></pre></p>"},{"location":"advanced/TESTING_STRATEGIES/#performance-issues","title":"Performance Issues","text":""},{"location":"advanced/TESTING_STRATEGIES/#issue-tests-take-too-long","title":"Issue: Tests take too long","text":"<p>Diagnosis: <pre><code># Find slow tests\npytest tests/ --durations=20\n</code></pre></p> <p>Solutions: 1. Use smaller graphs in tests 2. Mock expensive operations 3. Use module/session-scoped fixtures 4. Enable parallelization: <code>pytest -n auto</code></p>"},{"location":"advanced/TESTING_STRATEGIES/#issue-high-memory-usage","title":"Issue: High memory usage","text":"<p>Diagnosis: <pre><code># Profile memory\npytest tests/ --memprof\n</code></pre></p> <p>Solutions: 1. Use <code>del</code> to free large objects 2. Scope fixtures appropriately 3. Use generators instead of lists 4. Run fewer tests in parallel</p>"},{"location":"advanced/TESTING_STRATEGIES/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"advanced/TESTING_STRATEGIES/#do","title":"DO:","text":"<ul> <li>\u2705 Write tests for all factory functions</li> <li>\u2705 Test structural invariants (Hermiticity, PSD, phase bounds)</li> <li>\u2705 Use explicit seeds for reproducibility</li> <li>\u2705 Run tests in parallel (<code>-n auto</code>)</li> <li>\u2705 Keep unit tests fast (&lt;1ms)</li> <li>\u2705 Use fixtures to share expensive setup</li> <li>\u2705 Generate stubs before committing</li> <li>\u2705 Run pre-push checks locally</li> </ul>"},{"location":"advanced/TESTING_STRATEGIES/#dont","title":"DON'T:","text":"<ul> <li>\u274c Skip testing structural invariants</li> <li>\u274c Rely on global state or random behavior</li> <li>\u274c Create massive graphs in unit tests</li> <li>\u274c Forget to add timeouts to potentially slow tests</li> <li>\u274c Commit without running stub checks</li> <li>\u274c Ignore deprecation warnings</li> <li>\u274c Mock core TNFR logic (test real behavior)</li> </ul>"},{"location":"advanced/TESTING_STRATEGIES/#see-also","title":"See Also","text":"<ul> <li>Architecture Guide - Factory patterns and dependency management</li> <li>Performance Optimization - Optimization strategies</li> <li>Development Workflow - Contributing guidelines</li> <li>CONTRIBUTING.md - General contribution guide</li> <li>TESTING.md - Test strategy overview</li> </ul> <p>Last Updated: 2025-11-06 Status: Active - consolidates TESTING_, STUB_, TEST_ docs Maintenance*: Update when testing patterns change, review quarterly</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/","title":"TNFR Structural Operators: Visual Guide","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#introduction","title":"Introduction","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#what-are-structural-operators","title":"What are Structural Operators?","text":"<p>Structural operators are the only canonical way to reorganize coherence in TNFR networks. They are not descriptive representations - they activate transformations that preserve TNFR invariants while enabling controlled evolution of Primary Information Structures (EPIs).</p> <p>Key Principle: Operators don't represent change; they activate resonance.</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#how-operators-reorganize-nodal-networks","title":"How Operators Reorganize Nodal Networks","text":"<p>Every structural operator: - Modifies nodes through the nodal equation: <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code> - Preserves operator closure (valid sequences maintain TNFR system integrity) - Maintains structural coherence (C(t) remains bounded) - Respects phase alignment (\u03b8 continuity across transformations)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#the-paradigm-they-dont-represent-they-activate","title":"The Paradigm: \"They Don't Represent, They Activate\"","text":"<p>Traditional approaches represent systems as static objects. TNFR operators activate dynamic reorganization of coherent patterns.</p> <p>Think of operators as musical gestures rather than mechanical operations: - They initiate, modulate, and propagate vibrational patterns - They work through resonance, not force - They preserve structural identity while enabling evolution</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#the-13-canonical-operators","title":"The 13 Canonical Operators","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#overview-table","title":"Overview Table","text":"Operator Glyph Function Primary Effect Typical Use Emission AL Foundational activation Increases \u03bdf, positive \u0394NFR Initiation, starting patterns Reception EN Information anchoring Integrates external coherence Learning, receiving signals Coherence IL Structural stabilization Reduces \u0394NFR, raises C(t) Consolidation, stabilization Dissonance OZ Controlled instability Increases |\u0394NFR|, triggers bifurcation Exploration, breaking patterns Coupling UM Node synchronization Phase alignment (\u03b8\u1d62 \u2248 \u03b8\u2c7c) Network formation, coordination Resonance RA Coherence propagation Amplifies patterns through network Pattern spreading, reinforcement Silence SHA Evolution freeze Sets \u03bdf \u2248 0 Observation, pausing Expansion VAL Structural growth Increases EPI dimensionality Elaboration, scaling up Contraction NUL Densification Reduces EPI dimensionality Simplification, focusing Self-organization THOL Spontaneous reconfiguration Creates sub-EPIs Emergence, pattern formation Mutation ZHIR Phase transformation \u03b8 \u2192 \u03b8' (qualitative change) State transitions, adaptation Transition NAV Controlled movement Guided EPI evolution Navigation, pathway following Recursivity REMESH Self-reinforcement Maintains adaptive memory Multi-scale operations, nesting"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operators-of-initiation","title":"Operators of Initiation","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#al-emission","title":"AL - Emission","text":"<p>Function: Activates an EPI from latent state to active resonance</p> <p>Structural Transformation: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)  [\u0394NFR becomes positive]\n\u03bdf: 0.1 \u2192 1.0+ Hz_str   [frequency activates]\nEPI: 0.2 \u2192 0.5+         [form emerges]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before AL:              After AL:\n    \u00b7                      \u25cb\n  (latent)            \u2571    \u2502    \u2572\n                    \u2022      \u2022      \u2022\n                   Emission radiates\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Latent State           Active Resonance\n      \u25cb                      \u25c9\n      \u2502                    \u2571 \u2502 \u2572\n      \u2502         AL       \u2571   \u2502   \u2572\n   (silent)    \u2500\u2500\u2192     \u2022    \u2022    \u2022\n                      Outward coherence\n</code></pre></p> <p>Applications: - Creative Processes: Idea germination, artistic inspiration - Therapeutic: Session initiation, therapeutic space activation - Biological: Cell activation, neural firing initiation - Social: Community emergence, movement initiation</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Emission\n\n# Create latent node\nG, node = create_nfr(\"creative_seed\", epi=0.18, vf=0.1)\n\n# Apply Emission - activate the node\nrun_sequence(G, node, [Emission()])\n\n# Result: Node transitions from latent to active\nprint(f\"EPI after AL: {G.nodes[node]['epi']:.2f}\")  # ~0.25\nprint(f\"\u03bdf after AL: {G.nodes[node]['vf']:.2f}\")    # ~1.02\n</code></pre></p> <p>Typical Sequences: - <code>AL \u2192 IL</code>: Emission followed by immediate stabilization - <code>AL \u2192 EN</code>: Bidirectional activation (emit and receive) - <code>AL \u2192 RA</code>: Emission with immediate propagation - <code>AL \u2192 NAV \u2192 IL</code>: Phased activation with transition</p> <p>Preconditions: - EPI &lt; 0.8 (below saturation) - Node in latent or low-activation state - Sufficient network coupling potential</p> <p>Structural Effects: - EPI: \u2191 (form activation) - \u03bdf: \u2191\u2191 (frequency increases significantly) - \u0394NFR: \u2192 positive (reorganization pressure builds) - \u03b8: May shift (phase begins to align with network)</p> <p>Metrics to Monitor: - \u0394EPI &gt; 0.05 (significant activation) - \u0394\u03bdf &gt; 0.5 Hz_str (frequency jump) - C(t) increase (global coherence improves)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#en-reception","title":"EN - Reception","text":"<p>Function: Anchors external coherence into local EPI structure</p> <p>Structural Transformation: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)  [integrates external pattern]\n\u0394NFR: high \u2192 reduced    [stabilization through integration]\nEPI: +0.05 to +0.15     [form incorporates external coherence]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before EN:              After EN:\n    \u25cb     \u2192               \u25c9\n           \u2193            integrated\n    \u25cb  (receiving)        \u25cb\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  External Pattern      Integrated State\n      \u25bc \u25bc \u25bc                  \u25c9\n       \u2572\u2502\u2571                 \u2571 \u2502 \u2572\n        \u25cb        EN       \u2022  \u2022  \u2022\n      (open)    \u2500\u2500\u2192    Pattern anchored\n</code></pre></p> <p>Applications: - Learning: Student integrating teacher's explanation - Biofeedback: Patient receiving HRV coherence signal - Communication: Team member integrating collaborative input - Therapeutic: Client receiving therapist's coherent presence</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Reception\n\n# Create receptive node\nG, learner = create_nfr(\"student_mind\", epi=0.30, vf=0.95)\n\n# Apply Reception - integrate external information\nrun_sequence(G, learner, [Reception()])\n\n# Result: External coherence anchors into EPI\nprint(f\"EPI after EN: {G.nodes[learner]['epi']:.2f}\")  # ~0.35\nprint(f\"\u0394NFR after EN: {G.nodes[learner]['dnfr']:.2f}\")  # reduced\n</code></pre></p> <p>Typical Sequences: - <code>EN \u2192 IL</code>: Reception with immediate stabilization - <code>AL \u2192 EN</code>: Bidirectional flow (emit and receive) - <code>RA \u2192 EN</code>: Resonance propagation followed by reception - <code>EN \u2192 THOL</code>: Reception triggering self-organization</p> <p>Preconditions: - Non-saturated EPI (capacity to receive) - External coherence sources present in network - Phase compatibility with emitting nodes</p> <p>Structural Effects: - EPI: \u2191 (integration of external patterns) - \u0394NFR: \u2193 (stabilization through integration) - \u03b8: \u2192 alignment (phase moves toward sources) - Network coupling: \u2191 (connections strengthen)</p> <p>Metrics to Monitor: - \u0394EPI: +0.05 to +0.15 (integration magnitude) - \u0394NFR reduction: 30-50% (stabilization effectiveness) - Phase alignment: increasing similarity to sources</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#il-coherencia-coherence","title":"IL - Coherencia (Coherence)","text":"<p>Function: Stabilizes structural form by reducing reorganization pressure</p> <p>Structural Transformation: <pre><code>\u2202EPI/\u2202t \u2192 0 as \u0394NFR \u2192 0  [evolution stabilizes]\nC(t): increases          [global coherence rises]\n|\u0394NFR|: reduced          [reorganization pressure drops]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before IL:              After IL:\n  \u25cb~~~\u25cb                   \u25cb\u2550\u2550\u2550\u25cb\n   \u2572 \u2571                     \u2551 \u2551\n    \u25cb  (unstable)          \u25cb  (stable)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Unstable State        Stable Coherence\n    \u25cb ~ \u25cb                   \u25cb\u2550\u2550\u2550\u25cb\n     \u2572\u2571                     \u2551   \u2551\n      \u25cb       IL            \u25cb   \u25cb\n   (drift)   \u2500\u2500\u2192        Locked form\n</code></pre></p> <p>Applications: - Meditation: Establishing sustained coherent state - Therapy: Consolidating therapeutic gains - Learning: Stabilizing newly learned concepts - Teams: Crystallizing group agreements</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Coherence\n\n# Create node with some instability\nG, node = create_nfr(\"meditation_practice\", epi=0.45, vf=0.85)\n\n# Apply Coherence - stabilize the structure\nrun_sequence(G, node, [Coherence()])\n\n# Result: \u0394NFR reduced, form stabilized\nprint(f\"\u0394NFR after IL: {G.nodes[node]['dnfr']:.3f}\")  # ~0.01\nprint(f\"C(t): {G.graph['coherence']:.2f}\")  # increased\n</code></pre></p> <p>Typical Sequences: - <code>AL \u2192 IL</code>: Activation followed by stabilization - <code>EN \u2192 IL</code>: Reception followed by consolidation - <code>OZ \u2192 IL</code>: Dissonance followed by restabilization - <code>IL \u2192 SHA</code>: Stabilization followed by pause</p> <p>Preconditions: - Node must have active EPI (cannot stabilize non-existent structure) - \u0394NFR should be moderate (extreme values need other operators first)</p> <p>Structural Effects: - EPI: \u2192 stable (minimal change) - \u0394NFR: \u2193\u2193 (significant reduction) - C(t): \u2191 (global coherence increases) - \u03bdf: slight \u2193 (frequency moderates)</p> <p>Metrics to Monitor: - \u0394NFR: should approach 0.01 or less - C(t): should increase by 0.1-0.3 - Structural stability: \u2202EPI/\u2202t \u2192 0</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operators-of-transformation","title":"Operators of Transformation","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#oz-disonancia-dissonance","title":"OZ - Disonancia (Dissonance)","text":"<p>Function: Introduces controlled instability to enable exploration and evolution</p> <p>Structural Transformation: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)  [\u0394NFR increases significantly]\n|\u0394NFR|: low \u2192 high      [reorganization pressure builds]\n\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4           [may trigger bifurcation]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before OZ:              After OZ:\n    \u25cb\u2550\u2550\u2550\u25cb                 \u25cb~~~\u25cb\n     \u2551 \u2551                   \u2572 \u2571\n     \u25cb                 \u25cb ? \u25cb ? \u25cb\n  (locked)           (exploring paths)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Stable State          Exploratory State\n      \u25cb                    \u25cb\u2571 \u2572\u25cb\n      \u2551         OZ        \u2571\u2502?\u2502\u2572\n      \u25cb        \u2500\u2500\u2192       \u25cb \u2502 \u2502 \u25cb\n   (static)           Multiple paths\n</code></pre></p> <p>Applications: - Creative Breakthroughs: Breaking mental blocks - Therapeutic: Disrupting maladaptive patterns - Organizational: Challenging status quo for innovation - Scientific: Hypothesis generation, paradigm shifts</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Dissonance, Coherence\n\n# Create overly stable node (stuck)\nG, node = create_nfr(\"rigid_pattern\", epi=0.60, vf=0.70)\n\n# Apply Dissonance - introduce controlled instability\nrun_sequence(G, node, [Dissonance()])\n\n# Result: \u0394NFR increases, enabling exploration\nprint(f\"\u0394NFR after OZ: {G.nodes[node]['dnfr']:.2f}\")  # significantly increased\n\n# Follow with Coherence to restabilize after exploration\nrun_sequence(G, node, [Coherence()])\n</code></pre></p> <p>Typical Sequences: - <code>OZ \u2192 THOL</code>: Dissonance triggering self-organization - <code>OZ \u2192 ZHIR</code>: Dissonance enabling mutation - <code>OZ \u2192 IL</code>: Controlled disruption then restabilization - <code>IL \u2192 OZ \u2192 IL</code>: Stable \u2192 explore \u2192 restabilize cycle</p> <p>Preconditions: - Node should be in relatively stable state (to disrupt) - C(t) should be sufficient to tolerate instability - Follow with stabilizing operators to avoid collapse</p> <p>Structural Effects: - EPI: variable (exploration begins) - \u0394NFR: \u2191\u2191\u2191 (significant increase) - \u03bdf: may \u2191 (increased reorganization rate) - Bifurcation risk: increases</p> <p>Metrics to Monitor: - \u0394NFR: expect 2-5\u00d7 increase - \u2202\u00b2EPI/\u2202t\u00b2: watch for bifurcation threshold - C(t): should remain above collapse threshold</p> <p>\u26a0\ufe0f Warning: Use OZ carefully - excessive dissonance can trigger node collapse. Always monitor C(t) and be ready to apply IL (Coherence) or SHA (Silence) if instability grows too large.</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#thol-autoorganizacion-self-organization","title":"THOL - Autoorganizaci\u00f3n (Self-Organization)","text":"<p>Function: Enables spontaneous reconfiguration into emergent coherent structures</p> <p>Structural Transformation: <pre><code>\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4           [bifurcation occurs]\nEPI \u2192 {EPI\u2081, EPI\u2082, ...} [sub-structures emerge]\nGlobal form preserved    [operational fractality]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before THOL:            After THOL:\n      \u25cb                   \u25c9\n      \u2551                 \u2571 \u2502 \u2572\n      \u25cb              \u25cb   \u25cb   \u25cb\n   (monolithic)    (self-organized)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Uniform State        Organized Structure\n      \u25cf\u25cf\u25cf                  \u25c9\n      \u25cf\u25cf\u25cf      THOL       \u2571\u2502\u2572\n      \u25cf\u25cf\u25cf       \u2500\u2500\u2192      \u25ce \u25ce \u25ce\n   (undifferentiated)  Sub-patterns\n</code></pre></p> <p>Applications: - Biological: Cell differentiation, tissue organization - Cognitive: Concept categorization, mental schema formation - Social: Team role emergence, community structure formation - Creative: Compositional structure emergence in art/music</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import SelfOrganization\n\n# Create node ready for organization\nG, collective = create_nfr(\"community_seed\", epi=0.50, vf=1.10)\n\n# Apply Self-Organization - trigger spontaneous structuring\nrun_sequence(G, collective, [SelfOrganization()])\n\n# Result: Sub-EPIs form while preserving global structure\nprint(f\"Node count after THOL: {G.number_of_nodes()}\")  # may increase\nprint(f\"Global coherence: {G.graph.get('coherence', 0):.2f}\")\n</code></pre></p> <p>Typical Sequences: - <code>OZ \u2192 THOL</code>: Dissonance enabling self-organization - <code>EN \u2192 THOL</code>: Reception triggering emergent organization - <code>THOL \u2192 IL</code>: Self-organization followed by stabilization - <code>AL \u2192 THOL \u2192 RA</code>: Emit, organize, propagate</p> <p>Preconditions: - Sufficient \u0394NFR (reorganization pressure) - \u2202\u00b2EPI/\u2202t\u00b2 approaching threshold - Network context supporting differentiation</p> <p>Structural Effects: - EPI: fractional (creates sub-EPIs) - Network topology: may add nodes/edges - C(t): typically increases (better organization) - Operational fractality: preserved</p> <p>Metrics to Monitor: - Sub-structure count (emergent components) - Global coherence (should increase) - Fractal dimension (structural complexity)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#zhir-mutation","title":"ZHIR - Mutation","text":"<p>Function: Triggers qualitative phase transformation when structural threshold crossed</p> <p>Structural Transformation: <pre><code>\u03b8 \u2192 \u03b8' if \u0394EPI/\u0394t &gt; \u03be   [phase shift when threshold exceeded]\nQualitative change       [state transformation]\nForm identity preserved  [EPI maintains coherence]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before ZHIR:            After ZHIR:\n    \u25cb (\u03b8)                 \u25c9 (\u03b8')\n    \u2502                     \u2502\n  State A              State B\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Phase State A        Phase State B\n      \u25cb                    \u25c9\n      \u2502                    \u2502\n   \u03b8 = 0.2    ZHIR     \u03b8' = 1.8\n      \u2502        \u2500\u2500\u2192         \u2502\n   (liquid)            (crystal)\n</code></pre></p> <p>Applications: - Physical: Phase transitions (liquid \u2194 solid) - Biological: Developmental stage transitions, metamorphosis - Cognitive: Paradigm shifts, gestalt switches - Organizational: Cultural transformation, business model pivots</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Mutation\n\n# Create node approaching transformation threshold\nG, organism = create_nfr(\"metamorphosis\", epi=0.55, vf=1.00, theta=0.5)\n\n# Apply Mutation - trigger phase transformation\nrun_sequence(G, organism, [Mutation()])\n\n# Result: \u03b8 shifts to new phase while preserving structural identity\nprint(f\"Phase after ZHIR: {G.nodes[organism]['theta']:.2f}\")  # significantly different\nprint(f\"EPI after ZHIR: {G.nodes[organism]['epi']:.2f}\")  # maintained coherence\n</code></pre></p> <p>Typical Sequences: - <code>OZ \u2192 ZHIR</code>: Dissonance enabling mutation - <code>ZHIR \u2192 IL</code>: Mutation followed by stabilization in new phase - <code>NAV \u2192 ZHIR</code>: Transition triggering transformation - <code>ZHIR \u2192 THOL</code>: Mutation enabling new organization</p> <p>Preconditions: - \u0394EPI/\u0394t &gt; \u03be (threshold parameter, configurable) - Sufficient \u03bdf to support transformation - Network context compatible with new phase</p> <p>Structural Effects: - \u03b8: \u2191\u2191 or \u2193\u2193 (significant phase shift) - EPI: maintained (identity preserved) - \u03bdf: may change (new phase dynamics) - Qualitative state: transformed</p> <p>Metrics to Monitor: - \u0394\u03b8: expect &gt;0.5 radians shift - EPI coherence: should remain bounded - State classification: qualitatively different</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operators-of-connection","title":"Operators of Connection","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#um-coupling","title":"UM - Coupling","text":"<p>Function: Synchronizes nodes through phase alignment</p> <p>Structural Transformation: <pre><code>\u03c6\u1d62(t) \u2248 \u03c6\u2c7c(t)          [phase synchronization]\nCoupling strength \u2191     [connection reinforcement]\nInformation exchange \u2191  [bidirectional flow enabled]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before UM:              After UM:\n  \u25cb     \u25cb                 \u25cb\u2550\u2550\u2550\u25cb\n (\u03b8\u2081)  (\u03b8\u2082)              (\u03b8 \u2248 \u03b8)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Independent Nodes     Coupled System\n    \u25cb \u00b7 \u00b7 \u25cb               \u25cb\u2550\u2550\u2550\u25cb\n    \u2502     \u2502       UM      \u2551   \u2551\n  \u03b8\u2081\u2260\u03b8\u2082           \u2500\u2500\u2192     \u03b8\u2248\u03b8\n  Unsynchronized      Synchronized\n</code></pre></p> <p>Applications: - Cardiac: Heart-brain coherence coupling - Neurological: Neural synchronization, brain regions coupling - Social: Team alignment, collaborative synchrony - Musical: Ensemble synchronization</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Coupling\nimport networkx as nx\n\n# Create two nodes with different phases\nG = nx.DiGraph()\nG, node1 = create_nfr(\"heart\", epi=0.40, vf=1.0, theta=0.3, G=G)\nG, node2 = create_nfr(\"brain\", epi=0.45, vf=0.95, theta=0.8, G=G)\n\n# Add edge to enable coupling\nG.add_edge(node1, node2)\n\n# Apply Coupling - synchronize phases\nrun_sequence(G, node1, [Coupling()])\n\n# Result: Phases converge, enabling coherent interaction\nprint(f\"Phase difference reduced\")\n</code></pre></p> <p>Typical Sequences: - <code>UM \u2192 RA</code>: Coupling enabling resonance propagation - <code>AL \u2192 UM</code>: Emission preparing for coupling - <code>UM \u2192 IL</code>: Coupling followed by stabilization - <code>EN \u2192 UM \u2192 EN</code>: Reception-coupling-reception cycle</p> <p>Preconditions: - Nodes must be network neighbors (edges exist) - Both nodes must have active \u03bdf - Initial phase difference should not be too large</p> <p>Structural Effects: - \u03b8: convergence (\u03c6\u1d62 \u2192 \u03c6\u2c7c) - Coupling strength: \u2191 - Network coherence: \u2191 - Information exchange: enabled</p> <p>Metrics to Monitor: - Phase difference: \u0394\u03b8 = |\u03b8\u1d62 - \u03b8\u2c7c| (should decrease) - Coupling coefficient: should increase - C(t): global coherence should improve</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#ra-resonance","title":"RA - Resonance","text":"<p>Function: Propagates coherence patterns through network without loss of identity</p> <p>Structural Transformation: <pre><code>EPI\u2099 \u2192 EPI\u2099\u208a\u2081           [pattern propagation]\nCoupling amplification  [effective connectivity \u2191]\nIdentity preservation   [form maintained]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Initial:                After RA:\n  \u25c9                     \u25c9\u2550\u2550\u2550\u25cb\u2550\u2550\u2550\u25cb\n  \u2502                     Pattern spreads\n  \u25cb     \u25cb               without distortion\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Source Node          Network Resonance\n      \u25c9                  \u25c9\u2550\u2550\u2550\u25cb\n      \u2502        RA        \u2551   \u2551\n      \u25cb        \u2500\u2500\u2192       \u25cb\u2550\u2550\u2550\u25cb\n   (isolated)         (propagated)\n</code></pre></p> <p>Applications: - Biological: Action potential propagation, immune response spreading - Cognitive: Insight spreading through mental network, \"aha moment\" - Social: Viral ideas, social movements, cultural memes - Therapeutic: Coherence spreading from therapist to client system</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Resonance\nimport networkx as nx\n\n# Create network with central coherent node\nG = nx.DiGraph()\nG, source = create_nfr(\"coherent_source\", epi=0.70, vf=1.2, G=G)\nG, target1 = create_nfr(\"receiver1\", epi=0.20, vf=0.8, G=G)\nG, target2 = create_nfr(\"receiver2\", epi=0.18, vf=0.9, G=G)\n\n# Connect network\nG.add_edge(source, target1)\nG.add_edge(source, target2)\n\n# Apply Resonance - propagate coherence\nrun_sequence(G, source, [Resonance()])\n\n# Result: Coherence spreads to connected nodes\nprint(f\"Target1 EPI after RA: {G.nodes[target1]['epi']:.2f}\")  # increased\nprint(f\"Target2 EPI after RA: {G.nodes[target2]['epi']:.2f}\")  # increased\n</code></pre></p> <p>Typical Sequences: - <code>UM \u2192 RA</code>: Coupling enabling resonance - <code>AL \u2192 RA</code>: Emission immediately propagating - <code>RA \u2192 EN</code>: Resonance propagation followed by reception - <code>IL \u2192 RA</code>: Stabilization then propagation</p> <p>Preconditions: - Source node must have high coherence (EPI &gt; threshold) - Network paths must exist to targets - Target nodes must have receptive capacity</p> <p>Structural Effects: - EPI: propagates to neighbors - Network coupling: amplified - C(t): significant increase - Pattern identity: preserved during propagation</p> <p>Metrics to Monitor: - Propagation distance (how far pattern spreads) - Pattern fidelity (identity preservation) - C(t) increase (global coherence improvement)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#nav-transition","title":"NAV - Transition","text":"<p>Function: Enables controlled movement between structural states along defined pathways</p> <p>Structural Transformation: <pre><code>EPI\u2090 \u2192 EPI\u1d66             [guided evolution]\nPath constraints        [trajectory control]\nCreative threshold      [\u0394NFR \u2248 \u03bdf]\n</code></pre></p> <p>ASCII Visualization: <pre><code>State A                 State B\n  \u25cb                       \u25cb\n  \u2502      NAV path         \u2502\n  \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192       \u2502\n(start)              (destination)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  State Space            Transition Path\n    \u25cbA        \u25cbB           \u25cbA \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7&gt; \u25cbB\n    \u2502         \u2502     NAV    \u2502            \u2502\n    \u25cb         \u25cb     \u2500\u2500\u2192    \u2514\u2500\u2500trajectory\u2500\u2518\n  Static              Dynamic movement\n</code></pre></p> <p>Applications: - Developmental: Life stage transitions (childhood \u2192 adolescence) - Therapeutic: Moving from problematic to healthy state - Organizational: Strategic transitions, change management - Learning: Progressive skill acquisition, mastery levels</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Transition\n\n# Create node in initial state\nG, project = create_nfr(\"development_phase\", epi=0.35, vf=1.0)\n\n# Apply Transition - move to next phase\nrun_sequence(G, project, [Transition()])\n\n# Result: Controlled evolution along pathway\nprint(f\"EPI after NAV: {G.nodes[project]['epi']:.2f}\")  # evolved\nprint(f\"State: transitioned to next phase\")\n</code></pre></p> <p>Typical Sequences: - <code>AL \u2192 NAV \u2192 IL</code>: Activate, transition, stabilize - <code>NAV \u2192 ZHIR</code>: Transition enabling mutation - <code>OZ \u2192 NAV</code>: Dissonance opening transition pathway - <code>NAV \u2192 THOL</code>: Transition triggering organization</p> <p>Preconditions: - \u0394NFR \u2248 \u03bdf (creative threshold) - Valid pathway exists in state space - Sufficient \u03bdf to support movement</p> <p>Structural Effects: - EPI: evolves along trajectory - \u0394NFR: fluctuates (pathway navigation) - State classification: changes - Path memory: may be recorded</p> <p>Metrics to Monitor: - Trajectory coherence (smooth vs. erratic path) - Distance traveled in state space - Threshold crossings (\u0394NFR \u2248 \u03bdf moments)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operators-of-modulation","title":"Operators of Modulation","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#sha-silence","title":"SHA - Silence","text":"<p>Function: Temporarily freezes structural evolution for observation or synchronization</p> <p>Structural Transformation: <pre><code>\u03bdf \u2192 0                  [frequency drops to zero]\n\u2202EPI/\u2202t \u2248 0            [evolution pauses]\nEPI preserved           [form maintained]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Active State:           Silent State:\n    \u25c9                     \u25cb\n   \u2571\u2502\u2572                    \u2502\n  \u2022 \u2022 \u2022     SHA          (frozen)\n (dynamic)    \u2500\u2500\u2192      No evolution\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Evolving System       Paused System\n      \u25c9 \u2192               \u25cb \u2014\n      \u2502                 \u2502\n    Active    SHA     Latent\n               \u2500\u2500\u2192   \n   \u2202EPI/\u2202t\u22600        \u2202EPI/\u2202t\u22480\n</code></pre></p> <p>Applications: - Therapeutic: Creating space for integration, therapeutic pause - Meditation: Deep stillness, observation without action - Scientific: Measurement window, observation without perturbation - Social: Silence in conversation, reflective pause</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Silence, Emission\n\n# Create active node\nG, node = create_nfr(\"active_process\", epi=0.50, vf=1.2)\n\n# Apply Silence - pause evolution\nrun_sequence(G, node, [Silence()])\n\n# Result: \u03bdf drops, evolution freezes, EPI preserved\nprint(f\"\u03bdf after SHA: {G.nodes[node]['vf']:.2f}\")  # ~0.0\nprint(f\"EPI after SHA: {G.nodes[node]['epi']:.2f}\")  # unchanged\n\n# Can reactivate later with Emission\nrun_sequence(G, node, [Emission()])\n</code></pre></p> <p>Typical Sequences: - <code>IL \u2192 SHA</code>: Stabilize then pause - <code>SHA \u2192 AL</code>: Pause then reactivate - <code>EN \u2192 SHA \u2192 IL</code>: Receive, pause, consolidate - <code>SHA \u2192 measurement \u2192 SHA\u207b\u00b9</code>: Observation window</p> <p>Preconditions: - Node must have active EPI to preserve - Should be used temporarily (not permanent) - Network context should support pause</p> <p>Structural Effects: - \u03bdf: \u2192 0 (frequency drops) - \u2202EPI/\u2202t: \u2192 0 (evolution ceases) - EPI: preserved unchanged - Network influence: paused</p> <p>Metrics to Monitor: - \u03bdf: should approach 0.0 - EPI stability: should be constant - Duration of silence (time in paused state)</p> <p>\u26a0\ufe0f Note: Prolonged SHA can lead to node collapse if not reactivated. Use for observation/synchronization windows, not permanent states.</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#val-expansion","title":"VAL - Expansion","text":"<p>Function: Increases structural complexity by scaling EPI dimensionality</p> <p>Structural Transformation: <pre><code>EPI \u2192 k\u00b7EPI, k \u2208 \u2115\u207a     [scalar multiplication]\nDimensionality \u2191        [degrees of freedom increase]\nComplexity \u2191            [structural elaboration]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before VAL:             After VAL:\n    \u25cb                    \u25c9\u25c9\u25c9\n    \u2502                   \u2571\u2502\u2551\u2502\u2572\n   (simple)            \u25c9 \u25c9 \u25c9 \u25c9\n                       (elaborated)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Compact State        Expanded State\n      \u25cb                  \u25c9\u2550\u2550\u2550\u25c9\n      \u2502       VAL       \u2571\u2502   \u2502\u2572\n      \u25cb        \u2500\u2500\u2192     \u25c9 \u25c9   \u25c9 \u25c9\n   (minimal)         (elaborated)\n</code></pre></p> <p>Applications: - Creative: Elaborating ideas, compositional development - Organizational: Scaling teams, expanding operations - Biological: Growth, tissue expansion - Cognitive: Concept elaboration, knowledge expansion</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Expansion\n\n# Create minimal structure\nG, seed = create_nfr(\"startup\", epi=0.30, vf=1.0)\n\n# Apply Expansion - scale up complexity\nrun_sequence(G, seed, [Expansion()])\n\n# Result: Structural complexity increases\nprint(f\"EPI after VAL: {G.nodes[seed]['epi']:.2f}\")  # increased\nprint(f\"Structural scale expanded\")\n</code></pre></p> <p>Typical Sequences: - <code>AL \u2192 VAL</code>: Activate then expand - <code>VAL \u2192 IL</code>: Expand then stabilize - <code>VAL \u2192 THOL</code>: Expansion enabling organization - <code>IL \u2192 VAL \u2192 IL</code>: Stabilize, expand, restabilize</p> <p>Preconditions: - Node must have sufficient coherence to maintain expanded form - Network must support increased complexity - C(t) should be adequate (&gt;0.4)</p> <p>Structural Effects: - EPI: \u2191 (dimensionality increases) - Complexity: \u2191 (more degrees of freedom) - \u0394NFR: may \u2191 temporarily (reorganization needed) - Network load: \u2191 (more structural information)</p> <p>Metrics to Monitor: - EPI magnitude (scalar growth) - Structural complexity (dimensionality) - C(t) maintenance (coherence during expansion)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#nul-contraction","title":"NUL - Contraction","text":"<p>Function: Reduces structural complexity through densification and focusing</p> <p>Structural Transformation: <pre><code>\u2016EPI\u2032\u2016 \u2265 \u03c4              [density threshold maintained]\nSupport reduced         [fewer dimensions]\nInformation concentrated [focused structure]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Before NUL:             After NUL:\n  \u25c9\u2550\u25c9\u2550\u25c9                   \u25cb\n  \u2551 \u2551 \u2551       NUL         \u2502\n  \u25c9 \u25c9 \u25c9        \u2500\u2500\u2192      (dense)\n(distributed)          (concentrated)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Diffuse State        Contracted State\n   \u25c9 \u25c9 \u25c9                   \u25cf\n   \u2572 \u2502 \u2571       NUL         \u2502\n    \u25c9\u2571          \u2500\u2500\u2192     (focused)\n  (scattered)          \n</code></pre></p> <p>Applications: - Cognitive: Insight compression, essential concept extraction - Therapeutic: Focusing scattered attention, centering - Organizational: Streamlining, focusing on core business - Creative: Distillation, finding essence</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Contraction\n\n# Create scattered structure\nG, diffuse = create_nfr(\"scattered_effort\", epi=0.60, vf=0.90)\n\n# Apply Contraction - focus and densify\nrun_sequence(G, diffuse, [Contraction()])\n\n# Result: Structure becomes more focused and dense\nprint(f\"EPI after NUL: {G.nodes[diffuse]['epi']:.2f}\")  # maintained\nprint(f\"Structural density increased\")\n</code></pre></p> <p>Typical Sequences: - <code>VAL \u2192 NUL</code>: Expand then contract (breathing cycle) - <code>NUL \u2192 IL</code>: Contract then stabilize - <code>OZ \u2192 NUL</code>: Dissonance then focusing - <code>EN \u2192 NUL</code>: Receive then distill essence</p> <p>Preconditions: - Node must have distributed structure to contract - \u2016EPI\u2032\u2016 \u2265 \u03c4 (density threshold) - Information should be preservable during compression</p> <p>Structural Effects: - EPI: maintained or slightly reduced - Dimensionality: \u2193 (fewer degrees of freedom) - Density: \u2191 (concentrated information) - Focus: \u2191 (clearer structure)</p> <p>Metrics to Monitor: - Structural density (information per dimension) - Dimensionality reduction (degree of contraction) - Information preservation (no essential loss)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#remesh-recursivity","title":"REMESH - Recursivity","text":"<p>Function: Maintains adaptive memory through nested operator application</p> <p>Structural Transformation: <pre><code>EPI(t) = f(EPI(t - \u03c4))  [memory integration]\nOperational fractality  [self-similar nesting]\nMulti-scale coherence   [cross-level consistency]\n</code></pre></p> <p>ASCII Visualization: <pre><code>Linear Operation:       Recursive Operation:\n    \u25cb                       \u25c9\n    \u2502                     \u2571 \u2502 \u2572\n    \u2193                    \u25cb  \u25c9  \u25cb\n    \u25cb                      \u2571\u2502\u2572\n                          \u25cb \u25cb \u25cb\n                        (nested)\n</code></pre></p> <p>Conceptual Diagram: <pre><code>  Single Layer          Recursive Layers\n      \u25cb                     \u25c9\n      \u2502       REMESH      \u2571\u2502\u2572  \n      \u25cb         \u2500\u2500\u2192      \u25c9 \u25c9 \u25c9\n   (flat)              \u2571\u2502\u2572 \u2571\u2502\u2572\n                      \u25cb\u25cb\u25cb \u25cb\u25cb\u25cb\n                    (self-similar)\n</code></pre></p> <p>Applications: - Cognitive: Hierarchical concept structures, recursive thinking - Biological: Fractal organ structures, recursive development - Social: Nested organizational structures, holarchies - Computational: Recursive algorithms, self-referential systems</p> <p>Code Example: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Recursivity\n\n# Create node ready for recursive organization\nG, system = create_nfr(\"hierarchical_system\", epi=0.50, vf=1.1)\n\n# Apply Recursivity - create nested structure\nrun_sequence(G, system, [Recursivity()])\n\n# Result: Operational fractality maintained across scales\nprint(f\"Recursive depth: {G.graph.get('recursive_depth', 1)}\")\nprint(f\"Fractal structure established\")\n</code></pre></p> <p>Typical Sequences: - <code>THOL \u2192 REMESH</code>: Self-organization with recursion - <code>REMESH \u2192 IL</code>: Recursive structure then stabilization - <code>VAL \u2192 REMESH</code>: Expansion with recursive nesting - <code>REMESH \u2192 REMESH</code>: Recursive recursion (meta-levels)</p> <p>Preconditions: - Node must support nested structures - Operational fractality must be preservable - Memory parameter \u03c4 must be defined</p> <p>Structural Effects: - EPI: nested (contains sub-EPIs) - Structural depth: \u2191 (hierarchical levels) - Memory: \u2191 (past states integrated) - Fractality: maintained (self-similarity)</p> <p>Metrics to Monitor: - Recursive depth (nesting levels) - Fractal dimension (self-similarity measure) - Cross-scale coherence (consistency across levels)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operator-flow-diagram","title":"Operator Flow Diagram","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#typical-operator-relationships","title":"Typical Operator Relationships","text":"<pre><code>         Initiation Layer\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502       \u2502       \u2502\n     AL      EN      IL\n   (Emit) (Receive) (Stabilize)\n      \u2502       \u2502       \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n         Transformation Layer\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502       \u2502       \u2502\n     OZ     THOL    ZHIR\n (Dissonance) (Self-Org) (Mutation)\n      \u2502       \u2502       \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n         Connection Layer\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502       \u2502       \u2502\n     UM      RA      NAV\n (Coupling) (Resonance) (Transition)\n      \u2502       \u2502       \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n         Modulation Layer\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502       \u2502       \u2502   \u2502\n    SHA     VAL     NUL  REMESH\n (Silence) (Expand) (Contract) (Recursivity)\n      \u2502       \u2502       \u2502   \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#canonical-sequence-patterns","title":"Canonical Sequence Patterns","text":"<p>Growth Cycle: <pre><code>AL \u2192 VAL \u2192 THOL \u2192 IL\n(activate \u2192 expand \u2192 organize \u2192 stabilize)\n</code></pre></p> <p>Exploration Cycle: <pre><code>IL \u2192 OZ \u2192 ZHIR \u2192 IL\n(stable \u2192 disrupt \u2192 mutate \u2192 restabilize)\n</code></pre></p> <p>Network Propagation: <pre><code>AL \u2192 UM \u2192 RA \u2192 EN\n(emit \u2192 couple \u2192 resonate \u2192 receive)\n</code></pre></p> <p>Learning Cycle: <pre><code>EN \u2192 IL \u2192 REMESH \u2192 SHA\n(receive \u2192 stabilize \u2192 integrate \u2192 pause)\n</code></pre></p> <p>Transformation Cycle: <pre><code>OZ \u2192 NAV \u2192 ZHIR \u2192 THOL \u2192 IL\n(disrupt \u2192 transition \u2192 mutate \u2192 organize \u2192 stabilize)\n</code></pre></p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operator-combinations-to-avoid","title":"Operator Combinations to Avoid","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#contraindicated-sequences","title":"Contraindicated Sequences","text":"<ol> <li>SHA \u2192 OZ (Silence then Dissonance)</li> <li>Problem: Cannot disrupt frozen structure effectively</li> <li> <p>Solution: AL \u2192 OZ (activate first)</p> </li> <li> <p>IL \u2192 IL \u2192 IL (Repeated Coherence)</p> </li> <li>Problem: Over-stabilization, rigidity</li> <li> <p>Solution: Intersperse with OZ or VAL for flexibility</p> </li> <li> <p>VAL \u2192 VAL \u2192 VAL (Repeated Expansion)</p> </li> <li>Problem: Unbounded growth, loss of coherence</li> <li> <p>Solution: VAL \u2192 IL or VAL \u2192 NUL for containment</p> </li> <li> <p>SHA during RA (Silence during Resonance)</p> </li> <li>Problem: Contradicts propagation intent</li> <li> <p>Solution: Complete RA first, then SHA if needed</p> </li> <li> <p>ZHIR without preparation</p> </li> <li>Problem: Uncontrolled mutation, collapse risk</li> <li>Solution: OZ \u2192 ZHIR or NAV \u2192 ZHIR (prepare first)</li> </ol>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#interactive-examples","title":"Interactive Examples","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#example-1-creative-process","title":"Example 1: Creative Process","text":"<p>Scenario: Artist developing a new work</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import (\n    Emission, Dissonance, SelfOrganization, \n    Coherence, Expansion\n)\n\n# Create artist's creative process\nG, creative = create_nfr(\"artist_mind\", epi=0.25, vf=0.90)\n\n# 1. Initial inspiration (Emission)\nrun_sequence(G, creative, [Emission()])\nprint(\"Phase 1: Inspiration activated\")\n\n# 2. Explore possibilities (Dissonance)\nrun_sequence(G, creative, [Dissonance()])\nprint(\"Phase 2: Exploring possibilities\")\n\n# 3. Patterns emerge (Self-Organization)\nrun_sequence(G, creative, [SelfOrganization()])\nprint(\"Phase 3: Compositional structure emerges\")\n\n# 4. Expand the work (Expansion)\nrun_sequence(G, creative, [Expansion()])\nprint(\"Phase 4: Elaborating themes\")\n\n# 5. Finalize (Coherence)\nrun_sequence(G, creative, [Coherence()])\nprint(\"Phase 5: Work completed and stable\")\n\n# Check final state\nprint(f\"\\nFinal EPI: {G.nodes[creative]['epi']:.2f}\")\nprint(f\"Final Coherence: {G.graph.get('coherence', 0):.2f}\")\n</code></pre>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#example-2-therapeutic-process","title":"Example 2: Therapeutic Process","text":"<p>Scenario: Client working through therapeutic transformation</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import (\n    Reception, Coherence, Dissonance, \n    Mutation, Silence\n)\n\n# Create client's therapeutic process\nG, client = create_nfr(\"client_process\", epi=0.40, vf=0.85)\n\n# 1. Receive therapeutic input (Reception)\nrun_sequence(G, client, [Reception()])\nprint(\"Session start: Therapist presence received\")\n\n# 2. Initial stabilization (Coherence)\nrun_sequence(G, client, [Coherence()])\nprint(\"Safety established\")\n\n# 3. Disrupt old pattern (Dissonance)\nrun_sequence(G, client, [Dissonance()])\nprint(\"Challenging maladaptive pattern\")\n\n# 4. Transform state (Mutation)\nrun_sequence(G, client, [Mutation()])\nprint(\"New perspective emerges\")\n\n# 5. Integration pause (Silence)\nrun_sequence(G, client, [Silence()])\nprint(\"Silent integration\")\n\n# 6. Final stabilization (Coherence)\nrun_sequence(G, client, [Coherence()])\nprint(\"New pattern stabilized\")\n\nprint(f\"\\nTransformation complete\")\nprint(f\"Phase shift: {G.nodes[client]['theta']:.2f}\")\n</code></pre>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#example-3-network-coordination","title":"Example 3: Network Coordination","text":"<p>Scenario: Team achieving collaborative coherence</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import (\n    Emission, Coupling, Resonance, Coherence\n)\nimport networkx as nx\n\n# Create team network\nG = nx.DiGraph()\nG, leader = create_nfr(\"team_leader\", epi=0.60, vf=1.1, theta=0.5, G=G)\nG, member1 = create_nfr(\"member1\", epi=0.35, vf=0.9, theta=0.8, G=G)\nG, member2 = create_nfr(\"member2\", epi=0.30, vf=0.95, theta=1.2, G=G)\n\n# Connect team\nG.add_edge(leader, member1)\nG.add_edge(leader, member2)\nG.add_edge(member1, member2)\n\nprint(\"Initial team state:\")\nprint(f\"  Leader phase: {G.nodes[leader]['theta']:.2f}\")\nprint(f\"  Member1 phase: {G.nodes[member1]['theta']:.2f}\")\nprint(f\"  Member2 phase: {G.nodes[member2]['theta']:.2f}\")\n\n# 1. Leader initiates (Emission)\nrun_sequence(G, leader, [Emission()])\nprint(\"\\nPhase 1: Leader vision emitted\")\n\n# 2. Team couples (Coupling)\nrun_sequence(G, leader, [Coupling()])\nrun_sequence(G, member1, [Coupling()])\nrun_sequence(G, member2, [Coupling()])\nprint(\"Phase 2: Team synchronizing\")\n\n# 3. Coherence propagates (Resonance)\nrun_sequence(G, leader, [Resonance()])\nprint(\"Phase 3: Vision spreading through team\")\n\n# 4. Stabilize team (Coherence)\nfor node in [leader, member1, member2]:\n    run_sequence(G, node, [Coherence()])\nprint(\"Phase 4: Team alignment stabilized\")\n\nprint(f\"\\nFinal global coherence: {G.graph.get('coherence', 0):.2f}\")\n</code></pre>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#practical-guidelines","title":"Practical Guidelines","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#when-to-use-each-operator","title":"When to Use Each Operator","text":"<p>Use AL (Emission) when: - Starting new projects, initiatives, or processes - Activating latent potential - Beginning creative or therapeutic work - Initiating network activity</p> <p>Use EN (Reception) when: - Learning or integrating new information - Receiving feedback or input - Synchronizing with external patterns - Biofeedback or signal integration</p> <p>Use IL (Coherence) when: - Stabilizing recent changes - Consolidating learning or gains - Reducing instability or drift - After any transformative operator</p> <p>Use OZ (Dissonance) when: - Breaking out of stuck patterns - Exploring new possibilities - Preparing for transformation - Innovation or creative breakthrough needed</p> <p>Use UM (Coupling) when: - Connecting independent entities - Synchronizing phases - Building collaborative relationships - Establishing communication channels</p> <p>Use RA (Resonance) when: - Spreading coherent patterns - Amplifying successful structures - Building network-wide coherence - Propagating insights or innovations</p> <p>Use SHA (Silence) when: - Observation or measurement needed - Integration time required - Synchronization pause helpful - Before strategic decision-making</p> <p>Use VAL (Expansion) when: - Scaling successful patterns - Elaborating structures - Growing operations or capacity - Developing ideas or systems</p> <p>Use NUL (Contraction) when: - Focusing scattered effort - Distilling essence from complexity - Streamlining operations - Finding core insight</p> <p>Use THOL (Self-Organization) when: - Spontaneous structure emerging - Differentiation needed - Complexity organizing itself - Hierarchical patterns forming</p> <p>Use ZHIR (Mutation) when: - Qualitative transformation needed - Phase transition occurring - Paradigm shift required - Developmental stage change</p> <p>Use NAV (Transition) when: - Moving between defined states - Following developmental pathway - Strategic change implementation - Controlled transformation needed</p> <p>Use REMESH (Recursivity) when: - Nested structures forming - Multi-scale coordination needed - Fractal organization emerging - Hierarchical memory important</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#problem-node-collapse","title":"Problem: Node Collapse","text":"<p>Symptoms: EPI \u2192 0, \u03bdf \u2192 0, node becomes inactive</p> <p>Causes: - Excessive OZ without stabilization - Insufficient C(t) during transformation - \u03bdf dropped too low (prolonged SHA)</p> <p>Solutions: 1. Apply IL (Coherence) immediately 2. Apply AL (Emission) to reactivate 3. Reduce dissonance intensity 4. Monitor C(t) during operations</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#problem-over-stabilization","title":"Problem: Over-Stabilization","text":"<p>Symptoms: \u0394NFR \u2192 0, no evolution, rigidity</p> <p>Causes: - Repeated IL without variation - No OZ or VAL to enable growth - Insufficient network coupling</p> <p>Solutions: 1. Apply OZ (Dissonance) to introduce flexibility 2. Apply VAL (Expansion) or NAV (Transition) 3. Increase network interactions 4. Use RA (Resonance) to bring fresh patterns</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#problem-uncontrolled-bifurcation","title":"Problem: Uncontrolled Bifurcation","text":"<p>Symptoms: \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4 unexpectedly, fragmentation</p> <p>Causes: - OZ too strong without preparation - \u0394NFR exceeded threshold - Network instability</p> <p>Solutions: 1. Apply SHA (Silence) immediately to pause 2. Apply IL (Coherence) to restabilize 3. Reduce transformation rate 4. Strengthen network coupling with UM</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#problem-phase-desynchronization","title":"Problem: Phase Desynchronization","text":"<p>Symptoms: \u03b8\u1d62 \u2260 \u03b8\u2c7c for coupled nodes, coordination failure</p> <p>Causes: - Insufficient UM (Coupling) - Nodes evolving at different rates - Network connectivity issues</p> <p>Solutions: 1. Apply UM (Coupling) to resynchronize 2. Apply RA (Resonance) for coherence spreading 3. Verify network topology (edges present) 4. Monitor phase differences regularly</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#problem-pattern-propagation-failure","title":"Problem: Pattern Propagation Failure","text":"<p>Symptoms: RA doesn't spread coherence, isolated nodes</p> <p>Causes: - Insufficient source coherence (EPI too low) - Network disconnected - Receivers not receptive</p> <p>Solutions: 1. Apply IL to source first (strengthen pattern) 2. Verify network connectivity 3. Apply EN to receivers (increase receptivity) 4. Use UM before RA (couple first, then resonate)</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#advanced-topics","title":"Advanced Topics","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#operator-composition-theory","title":"Operator Composition Theory","text":"<p>Operators can be composed into operator strings that form coherent transformation trajectories:</p> <p>Formal Composition: <pre><code>\u03a9 = \u03c9\u2081 \u2218 \u03c9\u2082 \u2218 ... \u2218 \u03c9\u2099\n</code></pre></p> <p>Where: - \u03a9 is the composed operator - \u03c9\u1d62 are individual operators - \u2218 denotes sequential composition</p> <p>Closure Property: Any valid composition \u03a9 preserves TNFR invariants: 1. Operator closure maintained 2. C(t) remains bounded 3. Phase continuity preserved 4. Nodal equation satisfied</p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#operator-metrics","title":"Operator Metrics","text":"<p>Effectiveness Metrics: <pre><code>def measure_operator_effectiveness(G, node, operator):\n    \"\"\"Measure operator's effectiveness.\"\"\"\n    state_before = capture_state(G, node)\n\n    operator(G, node)\n\n    state_after = capture_state(G, node)\n\n    return {\n        'delta_epi': state_after['epi'] - state_before['epi'],\n        'delta_dnfr': state_after['dnfr'] - state_before['dnfr'],\n        'delta_coherence': G.graph['coherence'] - state_before['C_t'],\n        'phase_shift': state_after['theta'] - state_before['theta'],\n    }\n</code></pre></p>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#optimization-strategies","title":"Optimization Strategies","text":"<p>Goal-Oriented Operator Selection:</p> <pre><code>def select_operator_for_goal(current_state, goal_state):\n    \"\"\"Select optimal operator to move toward goal.\"\"\"\n    delta_epi = goal_state['epi'] - current_state['epi']\n    delta_coherence = goal_state['C_t'] - current_state['C_t']\n\n    if delta_epi &gt; 0.2:\n        if delta_coherence &lt; 0:\n            return [Expansion(), Coherence()]  # grow then stabilize\n        else:\n            return [Emission(), Expansion()]  # activate then grow\n\n    elif current_state['dnfr'] &gt; 0.3:\n        return [Coherence(), Silence()]  # stabilize then pause\n\n    elif delta_coherence &lt; -0.1:\n        return [Dissonance(), SelfOrganization(), Coherence()]  # reorganize\n\n    else:\n        return [Coherence()]  # default stabilization\n</code></pre>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#summary-and-best-practices","title":"Summary and Best Practices","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#core-principles","title":"Core Principles","text":"<ol> <li>Operators activate, not represent: They initiate structural reorganization</li> <li>Always preserve invariants: C(t) bounded, \u03bdf &gt; 0, phase continuity</li> <li>Use canonical sequences: Proven patterns ensure coherence</li> <li>Monitor metrics continuously: C(t), \u0394NFR, Si, \u03b8</li> <li>Stabilize after transformation: Follow disruptive operators with IL</li> </ol>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Start with clear intent: What coherence do you want to activate?</li> <li>Select appropriate operator(s): Match intent to structural function</li> <li>Apply in sequence: Use canonical patterns when available</li> <li>Monitor continuously: Watch C(t), \u0394NFR, phase alignment</li> <li>Stabilize results: Apply IL after transformative operators</li> <li>Verify outcomes: Check that goals achieved, invariants preserved</li> </ol>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#quick-reference-commands","title":"Quick Reference Commands","text":"<pre><code># Basic imports\nfrom tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import (\n    Emission, Reception, Coherence, Dissonance,\n    Coupling, Resonance, Silence, Expansion,\n    Contraction, SelfOrganization, Mutation,\n    Transition, Recursivity\n)\n\n# Create and activate node\nG, node = create_nfr(\"node_id\", epi=0.3, vf=1.0)\nrun_sequence(G, node, [Emission(), Coherence()])\n\n# Monitor state\nprint(f\"EPI: {G.nodes[node]['epi']:.2f}\")\nprint(f\"\u0394NFR: {G.nodes[node]['dnfr']:.3f}\")\nprint(f\"C(t): {G.graph.get('coherence', 0):.2f}\")\n</code></pre>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#further-reading","title":"Further Reading","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#related-documentation","title":"Related Documentation","text":"<ul> <li>GLYPH_SEQUENCES_GUIDE.md: Comprehensive canonical sequences and patterns</li> <li>TNFR_CONCEPTS.md: Core theoretical concepts</li> <li>OPERATORS_GUIDE.md: Practical operator usage guide</li> <li>operators.md: API reference for structural operators</li> </ul>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#theoretical-foundations","title":"Theoretical Foundations","text":"<ul> <li>TNFR.pdf: Complete paradigm documentation</li> <li>Nodal Equation: <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code></li> <li>Operator Closure: Mathematical proof of invariant preservation</li> <li>Phase Synchrony: Theory of coupling and resonance</li> </ul>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#examples-and-tutorials","title":"Examples and Tutorials","text":"<ul> <li>examples/README.md: Practical examples across domains</li> <li>INTERACTIVE_TUTORIAL.md: Hands-on learning</li> <li>quickstart.md: Quick start guide</li> </ul>"},{"location":"api/OPERATORS_VISUAL_GUIDE/#appendix-operator-cheat-sheet","title":"Appendix: Operator Cheat Sheet","text":""},{"location":"api/OPERATORS_VISUAL_GUIDE/#quick-operator-selection-matrix","title":"Quick Operator Selection Matrix","text":"Intent Primary Operator Supporting Operators Stabilization Start new process AL (Emission) VAL, UM IL Receive information EN (Reception) UM, RA IL Stabilize structure IL (Coherence) SHA - Explore alternatives OZ (Dissonance) NAV, ZHIR IL Connect entities UM (Coupling) RA, EN IL Spread pattern RA (Resonance) UM, EN IL Pause evolution SHA (Silence) - IL (to resume) Grow complexity VAL (Expansion) THOL, REMESH IL Focus essence NUL (Contraction) IL SHA Organize spontaneously THOL (Self-Org) OZ, VAL IL Transform qualitatively ZHIR (Mutation) OZ, NAV IL Navigate pathway NAV (Transition) ZHIR, THOL IL Create hierarchy REMESH (Recursivity) THOL, VAL IL"},{"location":"api/OPERATORS_VISUAL_GUIDE/#emergency-interventions","title":"Emergency Interventions","text":"Problem Immediate Action Follow-up Node collapsing IL, then AL Monitor C(t) Too rigid OZ NAV, then IL Desynchronized UM RA, then IL Chaotic SHA IL, reduce \u0394NFR Fragmenting RA UM, then IL Stagnant VAL or OZ THOL, then IL <p>Document Version: 1.0 Last Updated: 2025 Maintainer: TNFR Core Team License: Same as TNFR-Python-Engine</p> <p>Remember: Structural operators don't represent\u2014they activate. Use them to initiate, modulate, and propagate coherence in resonant networks.</p>"},{"location":"api/docstring_style/","title":"TNFR docstring guide","text":"<p>TNFR engine APIs use NumPy-style docstrings. The format integrates with the automatic reference builders, pydocstyle, and the operator semantics linters that backstop the project. Every new function or class must describe the structural effect on the Primary Information Structure (EPI), the structural frequency (\u03bdf), and the internal reorganiser \u0394NFR. Docstring linting now requires complete coverage: modules, classes, public functions, and magic methods must include an appropriate description or, in rare cases, a <code># noqa: Dxxx</code> with a clear justification.</p>"},{"location":"api/docstring_style/#base-template","title":"Base template","text":"<p>Follow this structure in each docstring. Keep the narrative in English (per the repository policy) and focus on how the callable reorganises coherence and TNFR metrics.</p> <pre><code>\"\"\"Resume the structural effect in one sentence.\n\nParameters\n----------\nname : type\n    Clarify how the parameter influences EPI, \u03bdf, or \u0394NFR.\n\nReturns\n-------\nreturn_type\n    Explain the structural outcome or telemetry exposed.\n\nRaises\n------\nExceptionType\n    Document dissonance paths or validation guards.\n\nExamples\n--------\n&gt;&gt;&gt; # Minimal runnable example that respects TNFR invariants\n\"\"\"\n</code></pre>"},{"location":"api/docstring_style/#key-notes","title":"Key notes","text":"<ul> <li>Summary line: one sentence that highlights the structural effect.</li> <li>Parameters: list arguments in order with types and TNFR context. Use   English sentences and reference EPI, \u03bdf, \u0394NFR, or phase explicitly when it   applies.</li> <li>Returns: describe what the caller receives and how coherence can continue   to be measured (for example, tuples that include TNFR graphs or \u0394NFR hooks).</li> <li>Raises: only when validations or dissonance conditions are meaningful.</li> <li>Examples: provide runnable fragments that show the expected workflow.   Annotate EPI, \u03bdf, and \u0394NFR values when it clarifies semantics.</li> </ul>"},{"location":"api/docstring_style/#operators-in-tnfroperatorsdefinitions","title":"Operators in <code>tnfr.operators.definitions</code>","text":"<p>Operator classes describe how they reorganise coherence when applied to a node. Each docstring must explain the structural effect (what the operator does to EPI, \u0394NFR, \u03bdf, and phase) before covering implementation notes. Use the following template when adding or updating operators:</p> <pre><code>\"\"\"State the operator's structural effect in one sentence.\"\"\"\n\nclass Emission(Operator):\n    \"\"\"Boost \u0394NFR towards positive expansion while preserving phase locks.\"\"\"\n\n    def __call__(self, graph, node, /, *, intensity=1.0):\n        \"\"\"Apply the emission pulse to increase \u03bdf and \u0394NFR coherently.\n\n        Parameters\n        ----------\n        graph : TNFRGraph\n            Graph containing the node; carries EPI, \u03bdf, \u0394NFR, and phase data.\n        node : Hashable\n            Node receiving the emission. Document how the pulse alters its EPI.\n        intensity : float, default 1.0\n            Scales the emission; explain expected \u0394NFR growth and phase guardrails.\n\n        Returns\n        -------\n        TNFRGraph\n            The updated graph. Describe telemetry adjustments (\u0394NFR hooks, phase).\n\n        Examples\n        --------\n        &gt;&gt;&gt; from tnfr import operators, structural\n        &gt;&gt;&gt; G, node = structural.create_nfr(\"seed\", epi=0.3, vf=1.0)\n        &gt;&gt;&gt; op = operators.definitions.Emission(intensity=0.5)\n        &gt;&gt;&gt; G = op(G, node)\n        &gt;&gt;&gt; round(G.nodes[node][\"vf\"], 2)\n        1.0\n        &gt;&gt;&gt; G.nodes[node][\"phase\"]\n        ...  # Illustrate phase guard and \u0394NFR change (\u0394NFR &gt; 0).\n        \"\"\"\n</code></pre> <p>Reminders</p> <ul> <li>Highlight how \u0394NFR shifts (sign, magnitude) and how \u03bdf and phase react.</li> <li>Show an example where \u0394NFR, \u03bdf, and phase are logged or asserted so reviewers   can trace the structural impact.</li> </ul>"},{"location":"api/docstring_style/#metrics-in-tnfrmetricssense_index","title":"Metrics in <code>tnfr.metrics.sense_index</code>","text":"<p>Metrics expose how coherence and sensing change over time. Docstrings must clarify how the metric reads \u0394NFR and \u03bdf to produce a sense index while referencing phase as needed. Start from this template:</p> <pre><code>def sense_index(graph, node):\n    \"\"\"Compute Si by mapping \u0394NFR, \u03bdf, and phase to a stability score.\n\n    Parameters\n    ----------\n    graph : TNFRGraph\n        Graph with stored \u0394NFR traces, \u03bdf (Hz_str), and phase for each node.\n    node : Hashable\n        Node whose sensory coherence is measured. Describe expected \u0394NFR bounds.\n\n    Returns\n    -------\n    float\n        Sense index (Si). Explain how \u0394NFR, \u03bdf, and phase contribute to the\n        final value.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from tnfr import metrics, structural\n    &gt;&gt;&gt; G, node = structural.create_nfr(\"seed\", epi=0.8, vf=1.5)\n    &gt;&gt;&gt; G.nodes[node][\"phase\"] = 0.0\n    &gt;&gt;&gt; G.nodes[node][\"delta_nfr\"] = 0.12\n    &gt;&gt;&gt; metrics.sense_index.sense_index(G, node)\n    0.92\n    &gt;&gt;&gt; # Detail how \u0394NFR and \u03bdf shifts change the score.\n    \"\"\"\n</code></pre> <p>Reminders</p> <ul> <li>Include a brief explanation of structural phase handling (e.g., phase drift   lowering Si).</li> <li>Document telemetry expectations (\u0394NFR traces or \u03bdf history) in the parameters   or returns section.</li> <li>Ensure examples demonstrate how \u0394NFR, \u03bdf, and phase values are set before the   metric call.</li> </ul>"},{"location":"api/docstring_style/#examples-from-tnfrstructural","title":"Examples from <code>tnfr.structural</code>","text":""},{"location":"api/docstring_style/#create_nfr","title":"<code>create_nfr</code>","text":"<pre><code>\"\"\"Create a graph with an initialised NFR node.\n\nParameters\n----------\nname : str\n    Identifier for the new node; it anchors the primary EPI container.\nepi : float, default 0.0\n    Primary Information Structure (EPI) value assigned to the node.\nvf : float, default 1.0\n    Structural frequency \u03bdf in Hz_str that governs reorganisation pace.\ntheta : float, default 0.0\n    Initial phase used for coupling checks against neighbour nodes.\ngraph : TNFRGraph | None, optional\n    Existing TNFR graph to reuse; a new graph is created when ``None``.\ndnfr_hook : DeltaNFRHook, default dnfr_epi_vf_mixed\n    Callback that recalculates \u0394NFR after each operator invocation.\n\nReturns\n-------\nTNFRGraph, str\n    Tuple containing the TNFR graph and the node name for chaining.\n\nExamples\n--------\n&gt;&gt;&gt; from tnfr import structural\n&gt;&gt;&gt; G, node = structural.create_nfr(\"seed\", epi=0.42, vf=2.0)\n&gt;&gt;&gt; G.nodes[node][\"epi\"]\n0.42\n&gt;&gt;&gt; G.graph[\"compute_delta_nfr\"].__name__\n'dnfr_epi_vf_mixed'\n\"\"\"\n</code></pre>"},{"location":"api/docstring_style/#run_sequence","title":"<code>run_sequence</code>","text":"<pre><code>\"\"\"Execute a sequence of operators on ``node`` after validation.\n\nParameters\n----------\nG : TNFRGraph\n    Graph that stores EPI, \u03bdf, and \u0394NFR metadata for each node.\nnode : NodeId\n    Node that will receive the operator sequence.\nops : Iterable[Operator]\n    Ordered structural operators to apply; validation preserves grammar.\n\nRaises\n------\nValueError\n    Raised when the operator names violate the canonical TNFR grammar.\n\nExamples\n--------\n&gt;&gt;&gt; from tnfr import operators, structural\n&gt;&gt;&gt; G, node = structural.create_nfr(\"seed\", epi=1.0, vf=1.5)\n&gt;&gt;&gt; structural.run_sequence(G, node, [operators.Emission(), operators.Coherence()])\n&gt;&gt;&gt; round(G.nodes[node][\"vf\"], 2)\n1.5\n\"\"\"\n</code></pre>"},{"location":"api/docstring_style/#tooling-that-relies-on-this-style","title":"Tooling that relies on this style","text":"<ul> <li><code>pydocstyle</code> validates the presence of these sections.</li> <li>Automated documentation builders (MkDocs plus autodoc plugins) expect the   NumPy shape to render tables and examples correctly.</li> <li>Human reviewers and automated assistants use the TNFR vocabulary laid out   here to check coherence, \u0394NFR, and \u03bdf without ambiguity.</li> </ul>"},{"location":"api/operators/","title":"Structural operators and workflow design","text":"<p>Structural operators reorganise coherence while preserving TNFR invariants. Use this reference to plan trajectories for simulations, experiments, or CLI runs.</p> <p>\ud83d\udcd6 Extended Guides:  - See OPERATORS_VISUAL_GUIDE.md for comprehensive visual documentation, ASCII diagrams, and interactive examples of all 13 operators - See GLYPH_SEQUENCES_GUIDE.md for comprehensive canonical sequences, multi-domain examples, and grammar compatibility patterns - See UNIFIED_GRAMMAR_RULES.md for grammar validation rules (U1-U4) and physics derivations - See NAV_GUIDE.md for NAV (Transition) operator canonical sequences, anti-patterns, and troubleshooting</p>"},{"location":"api/operators/#canonical-operator-map","title":"Canonical operator map","text":"<p>Every trajectory must be composed from the 13 canonical operators and their resonant role. Starting in TNFR 2.0 the canonical tokens and class names are aligned on the English vocabulary; use the identifiers below when orchestrating pipelines or configuring the CLI.</p> <ul> <li>Emission \u2014 initiates a resonant pattern (\u03c6(\u03bdf, \u03b8)).</li> <li>Reception \u2014 captures incoming information (\u222b \u03c8(x, t) dx).</li> <li>Coherence \u2014 stabilises the form ($\u2202EPI/\u2202t \u2192 0$ when \u0394NFR \u2192 0).</li> <li>Dissonance \u2014 introduces productive instability (\u0394NFR(t) &gt; \u03bdf).</li> <li>Coupling \u2014 synchronises nodes (\u03c6\u1d62(t) \u2248 \u03c6\u2c7c(t)).</li> <li>Resonance \u2014 propagates coherence through the network (EPI\u2099 \u2192 EPI\u2099\u208a\u2081).</li> <li>Silence \u2014 keeps phase latent (\u03bdf \u2248 0 \u21d2 \u2202EPI/\u2202t \u2248 0).</li> <li>Expansion \u2014 scales the structure (EPI \u2192 k\u00b7EPI, k \u2208 \u2115\u207a).</li> <li>Contraction \u2014 densifies the form (\u2016EPI\u2032\u2016 \u2265 \u03c4, reduced support).</li> <li>Self-organisation \u2014 reorganises coherently ($\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4$).</li> <li>Mutation \u2014 adjusts phase without destroying the form (\u03b8 \u2192 \u03b8\u2032 if \u0394EPI/\u0394t &gt; \u03be).</li> <li>Transition \u2014 triggers creative thresholds (\u0394NFR \u2248 \u03bdf).</li> <li>Recursivity \u2014 maintains adaptive memory (EPI(t) = EPI(t \u2212 \u03c4)).</li> </ul>"},{"location":"api/operators/#key-concepts-operational-summary","title":"Key concepts (operational summary)","text":"<ul> <li>Node (NFR) \u2014 a unit that persists because it resonates. Parameterised by \u03bdf (frequency),   \u03b8 (phase), and EPI (coherent form).</li> <li>Structural operators \u2014 functions that reorganise the network. Compose them in canonical   sequences to preserve operator closure.</li> <li>Magnitudes</li> <li>C(t) \u2014 global coherence.</li> <li>\u0394NFR \u2014 nodal gradient (need for reorganisation).</li> <li>\u03bdf \u2014 structural frequency (Hz_str).</li> <li>Si \u2014 sense index (capacity to generate stable shared coherence).</li> </ul>"},{"location":"api/operators/#typical-workflow","title":"Typical workflow","text":"<ol> <li>Model your system as a network: nodes (agents, ideas, tissues, modules) and couplings.</li> <li>Select a trajectory of operators aligned with your goal (e.g., start \u2192 couple \u2192    stabilise).</li> <li>Simulate the dynamics: number of steps, step size, tolerances.</li> <li>Measure: C(t), \u0394NFR, Si; identify bifurcations and collapses.</li> <li>Iterate with controlled dissonance to open mutations without losing form.</li> </ol>"},{"location":"api/operators/#main-metrics-glance","title":"Main metrics (glance)","text":"<ul> <li><code>coherence(traj) \u2192 C(t)</code> \u2014 global stability; higher values indicate sustained form.</li> <li><code>gradient(state) \u2192 \u0394NFR</code> \u2014 local demand for reorganisation (high = risk of collapse or   bifurcation).</li> <li><code>sense_index(traj) \u2192 Si</code> \u2014 proxy for structural sense combining \u03bdf, phase, and topology.</li> </ul> <p>See telemetry and utilities for detailed metric APIs and trace integration.</p>"},{"location":"api/overview/","title":"Architecture overview","text":"<p>The TNFR Python Engine enforces the nodal equation by orchestrating structural operators, dynamics hooks, and telemetry layers. Use this map to locate functionality before extending or debugging the engine.</p>"},{"location":"api/overview/#core-packages-srctnfr","title":"Core packages (<code>src/tnfr/...</code>)","text":"<pre><code>tnfr.structural    \u2014 canonical node factory and operator orchestration\ntnfr.operators     \u2014 operator classes + registry discovery\ntnfr.dynamics      \u2014 \u0394NFR hooks, nodal equation, phase/\u03bdf adaptation\ntnfr.metrics       \u2014 coherence, \u0394NFR, Si, telemetry helpers\ntnfr.trace         \u2014 structured history/trace capture via callbacks\ntnfr.utils         \u2014 stable facade for caches, structural history, numerics\ntnfr.locking       \u2014 process-wide named locks (shared by RNG/caches)\ntnfr.utils.cache   \u2014 cache managers exposing shared metrics/evictions\n</code></pre> <ul> <li> <p><code>tnfr.cache</code> and <code>tnfr.io</code> have been removed. Import cache helpers from   :mod:<code>tnfr.utils.cache</code> and IO helpers from :mod:<code>tnfr.utils.io</code> to stay on the   supported API surface.</p> </li> <li> <p><code>tnfr.structural</code> exposes <code>create_nfr</code> and <code>run_sequence</code>, wiring node creation to \u0394NFR   hooks so every operator pass recomputes the gradient canonically.</p> </li> <li>Operator implementations self-register through <code>tnfr.operators.registry</code> to guard name   collisions and support discovery.</li> <li>Dynamics modules maintain the nodal equation, phase coordination, and \u0394NFR plumbing,   keeping \u03bdf/phase adjustments consistent with the operator grammar.</li> <li>Metrics, trace capture, helper facades, locking, and cache managers provide the utilities   required by structural pipelines.</li> </ul>"},{"location":"api/overview/#data-flow-between-structural-operators","title":"Data flow between structural operators","text":"<pre><code>flowchart LR\n    subgraph Registry\n        R[tnfr.operators.registry]\n    end\n    subgraph Structural Loop\n        S[tnfr.structural.run_sequence]\n        D[\u0394NFR hooks]\n        N[tnfr.dynamics]\n        M[tnfr.metrics]\n        T[tnfr.trace]\n    end\n    R --&gt; S --&gt; D --&gt; N --&gt; M --&gt; T --&gt; S\n</code></pre> <ol> <li>Operators self-register once <code>tnfr.operators.registry.discover_operators()</code> walks the    package tree.</li> <li><code>run_sequence</code> validates canonical order, executes each operator, and triggers the    configured \u0394NFR hook after every call.</li> <li>Dynamics hooks compute \u0394NFR mixes, update EPI via the nodal equation, and coordinate    phase/global coupling before publishing metrics.</li> <li>Telemetry layers accumulate coherence/Si, register trace callbacks, and persist structured    history snapshots for diagnostics.</li> </ol>"},{"location":"api/overview/#telemetry-logging-and-shared-services","title":"Telemetry, logging, and shared services","text":"<ul> <li><code>tnfr.trace.register_trace</code> attaches before/after callbacks through the shared callback   manager, capturing \u0393 specs, selector state, \u0394NFR weights, Kuramoto metrics, and operator   counts in the graph history so every simulation leaves an auditable trail.</li> <li>Named locks from <code>tnfr.utils.get_lock</code> (re-exporting <code>tnfr.locking.get_lock</code>) synchronise shared caches such as the RNG seed   tables, ensuring deterministic jitter across processes without duplicating lock   definitions.</li> <li>Helper facades re-export cache utilities so higher layers depend on a stable API while   telemetry-aware caches in <code>tnfr.utils.cache</code> expose capacity controls and per-entry   metrics for debugging coherence regressions.</li> </ul>"},{"location":"api/overview/#canonical-invariants-enforcing-modules","title":"Canonical invariants \u2192 enforcing modules","text":"<ul> <li>Invariant 1 \u2014 EPI changes only through structural operators. <code>run_sequence</code> validates   canonical order and delegates EPI updates to the nodal equation so operators never mutate   EPI ad-hoc, while <code>update_epi_via_nodal_equation</code> integrates   $\\partial EPI/\\partial t = \\nu_f \\cdot \\Delta NFR + \\Gamma_i(R)$.</li> <li>Invariant 2 \u2014 \u03bdf stays in Hz_str. Dynamics modules document the structural unit and   update \u03bdf/EPI together, preventing stray unit conversions.</li> <li>Invariant 3 \u2014 \u0394NFR preserves canonical semantics. <code>default_compute_delta_nfr</code> mixes   phase, EPI, \u03bdf, and topology through the configured hook so \u0394NFR remains the structural   gradient rather than an ML loss proxy.</li> <li>Invariant 4 \u2014 Operator closure. Syntax validation enforces the RECEPTION \u2192 COHERENCE   segment, checks THOL closure, and rejects unknown tokens before execution.</li> <li>Invariant 5 \u2014 Explicit phase checks. <code>coordinate_global_local_phase</code> adapts kG/kL and   records Kuramoto history so coupling never proceeds without synchrony analysis.</li> <li>Invariant 6 \u2014 Node birth/collapse boundaries. <code>create_nfr</code> seeds \u03bdf, \u03b8, and EPI together   and installs the \u0394NFR hook, guaranteeing nodes meet minimum coherence bookkeeping from the   first step.</li> <li>Invariant 7 \u2014 Operational fractality. THOL evaluation recursively expands nested   operator blocks while preserving closure tokens, allowing sub-EPIs to run without   flattening the grammar.</li> <li>Invariant 8 \u2014 Controlled determinism. RNG scaffolding routes every seed through   telemetry-aware caches guarded by named locks so stochastic paths remain reproducible.</li> <li>Invariant 9 \u2014 Structural metrics transparency. Coherence utilities compute C(t), \u0394NFR,   and dEPI aggregates with deterministic accumulation and cache neighbour maps for reuse.</li> <li>Invariant 10 \u2014 Domain neutrality. Grammar enforcement coerces structural tokens against   canonical compatibility tables, preventing domain-specific operator drift and keeping the   alphabet canonical.</li> </ul> <p>Consult telemetry and utilities for the metrics API and cache helpers, and operators for the structural grammar.</p>"},{"location":"api/overview/#unified-validation-interface","title":"Unified validation interface","text":"<p>Use :mod:<code>tnfr.validation</code> as the single entry point for canonical validation. It re-exports the grammar helpers (<code>validate_sequence</code>, <code>apply_glyph_with_grammar</code>) alongside the graph invariants enforced by <code>run_validators</code> and <code>GRAPH_VALIDATORS</code>. Projects should import from <code>tnfr.validation</code> directly\u2014<code>tnfr.utils</code> no longer re-exports <code>validate_window</code> or <code>run_validators</code>\u2014so grammar checks and structural graph invariants run together before executing TNFR operators. <code>NFRValidator</code> is now exposed exclusively from :mod:<code>tnfr.validation</code> (or :mod:<code>tnfr.validation.spectral</code> for the concrete implementation); update any remaining imports that still target <code>tnfr.mathematics.validators</code>.</p> <p>When extending the validation pipeline, reuse :data:<code>tnfr.types.ValidatorFunc</code> to type graph validators. The alias captures the canonical signature accepted by <code>GRAPH_VALIDATORS</code> and downstream tooling, letting new validators plug into the engine without redefining typing contracts.</p> <p>Selector helpers and glyph telemetry exporters reuse the shared :mod:<code>tnfr.types</code> module as well. Import :data:<code>tnfr.types.GlyphCode</code> for selector-compatible identifiers and :data:<code>tnfr.types.SigmaTrace</code> or the glyph timing aliases when consuming the metrics payloads, ensuring typed extensions stay in sync with the public API.</p>"},{"location":"api/overview/#grammar-schema-validation","title":"Grammar schema validation","text":"<p><code>tnfr.validation.GrammarContext</code> now validates the soft and canonical grammar dictionaries against the bundled JSON schema (<code>tnfr.schemas/grammar.json</code>) whenever the optional <code>jsonschema</code> dependency is available. Validation runs in <code>auto</code> mode by default\u2014if the dependency or resource cannot be loaded the engine keeps operating without raising. Set the environment variable <code>TNFR_GRAMMAR_VALIDATE=1</code> to require validation (raising when the schema or dependency is missing) or <code>TNFR_GRAMMAR_VALIDATE=0</code> to skip schema checks when working with experimental configurations.</p> <p>For symbol-level references and canonical validators, see {doc}<code>api/api_mapping</code> and {doc}<code>api/canonical_validators</code>.</p>"},{"location":"api/telemetry/","title":"Telemetry, metrics, and utilities","text":"<p>TNFR simulations require auditable telemetry, deterministic caches, and reproducible metrics. This guide consolidates the APIs that expose coherence data, structural histories, and helper facades.</p> <p>Migration note: <code>tnfr.mathematics.validators</code> has been removed. Use <code>tnfr.validation</code> (preferred) or <code>tnfr.validation.spectral</code> when wiring validators alongside the telemetry hooks described in this guide so the engine stays aligned with the supported API surface.</p>"},{"location":"api/telemetry/#official-metrics-and-telemetry","title":"Official metrics and telemetry","text":"<ul> <li>C(t) \u2014 <code>tnfr.metrics.common.compute_coherence</code>: global stability with optional means for   \u0394NFR and dEPI/dt.</li> <li>\u0394NFR \u2014 computed via graph hooks such as <code>compute_delta_nfr</code>, blending phase, EPI, \u03bdf, and   topology. Set <code>G.graph[\"DNFR_CHUNK_SIZE\"]</code> to constrain the NumPy accumulator   batches; otherwise the helper auto-tunes the chunk length using the same   heuristics as Si.</li> <li>\u03bdf \u2014 structural frequency in Hz_str, maintained by dynamics modules.</li> <li>Si \u2014 <code>tnfr.metrics.sense_index.compute_Si</code>: ability to produce meaningful reorganisation   combining \u03bdf, phase, and topology. The routine accepts an optional   <code>chunk_size</code> parameter (or the graph-level knob <code>G.graph[\"SI_CHUNK_SIZE\"]</code>)   to process nodes in deterministic batches. When omitted the engine derives a   safe chunk length from the node count, available CPUs, and conservative   memory heuristics so vectorised and Python fallbacks stay balanced.</li> <li>Phase \u03b8 \u2014 <code>tnfr.dynamics.coordinate_global_local_phase</code> and related helpers.</li> <li>Compatibility \u2014 graphs must expose only the English <code>\"theta\"</code>/<code>\"phase\"</code>   keys before importing TNFR 15.0.0+. Remove any deprecated aliases (including   the historical standalone <code>\"\u03b8\"</code> symbol) because alias helpers now operate   purely on the canonical names and reject untranslated payloads.</li> <li>Topology \u2014 coupling maps available through operator utilities like   <code>tnfr.operators.apply_topological_remesh</code>.</li> </ul> <p>Batching Si or \u0394NFR is useful when the network contains tens of thousands of nodes or when simulations run on shared machines with strict memory caps. Set a smaller chunk size (for example 2048) to bound the temporary NumPy buffers and to balance the Python worker payload when NumPy is unavailable. Leave the value unset for medium graphs so the heuristics scale naturally with the workload.</p> <p>Register telemetry callbacks before running dynamics:</p> <pre><code>from tnfr.metrics import register_metrics_callbacks\nfrom tnfr.trace import register_trace\n\nregister_metrics_callbacks(G)\nregister_trace(G)\n</code></pre> <p>Histories are stored under <code>G.graph['history']</code> and can be prepared with the structural history helpers exposed by the <code>tnfr.glyph_history</code> module.</p>"},{"location":"api/telemetry/#cache-telemetry-publishers","title":"Cache telemetry publishers","text":"<p>Cache usage is exported through :func:<code>tnfr.telemetry.publish_graph_cache_metrics</code> which iterates over the shared :class:<code>~tnfr.utils.cache.CacheManager</code> and emits snapshots via the :class:<code>~tnfr.telemetry.cache_metrics.CacheTelemetryPublisher</code>. The publisher logs structured JSON records under the <code>tnfr.telemetry.cache</code> logger and invokes callbacks registered for <code>CallbackEvent.CACHE_METRICS</code> so observers can react to hit ratio or latency regressions.</p> <p>Typical wiring attaches a recorder and lets :func:<code>~tnfr.dynamics.runtime.step</code> publish metrics at the end of each iteration:</p> <pre><code>from tnfr.callback_utils import CallbackEvent, callback_manager\nfrom tnfr.telemetry import publish_graph_cache_metrics\n\ncallback_manager.register_callback(\n    G,\n    CallbackEvent.CACHE_METRICS,\n    lambda graph, ctx: graph.graph.setdefault(\"cache_events\", []).append(ctx),\n)\n\n# Manual snapshots are available when running imperative cache workloads.\npublish_graph_cache_metrics(G)\n</code></pre> <p>Snapshots include derived ratios (<code>hit_ratio</code>, <code>miss_ratio</code>) and a mean latency estimate so log pipelines or observability hooks can alert when the hit rate drifts below the default 50% threshold or when the average cache latency exceeds 100 ms.</p>"},{"location":"api/telemetry/#trace-capture-and-callback-safety","title":"Trace capture and callback safety","text":"<p><code>tnfr.trace.register_trace</code> attaches before/after callbacks via the shared callback manager. It records \u0393 specs, selector state, \u0394NFR weights, Kuramoto metrics, and operator counts so every simulation leaves an auditable trail. Callback errors are stored in a ring buffer attached to the graph (default length 100). Adjust or inspect the buffer at runtime with <code>tnfr.callback_utils.callback_manager.set_callback_error_limit</code> and <code>get_callback_error_limit</code>. The ring buffer exposes entries as <code>tnfr.types.CallbackError</code> mappings so typed consumers can rely on a stable schema when exporting diagnostics.</p>"},{"location":"api/telemetry/#trace-verbosity-presets","title":"Trace verbosity presets","text":"<p><code>G.graph[\"TRACE\"]</code> accepts a <code>verbosity</code> knob that determines which field producers execute when no explicit <code>capture</code> list is provided. The CLI mirrors these presets through the <code>--trace-verbosity {basic,detailed,debug}</code> switch so scripted runs can stay in sync with manual API configuration. The presets are:</p> <ul> <li><code>\"basic\"</code> \u2014 captures the structural configuration (<code>gamma</code>, grammar, selector, \u0394NFR/SI weights,   callback map, THOL state) while skipping the heavier collectors. Use this for smoke tests or   performance-sensitive runs where topology snapshots are enough.</li> <li><code>\"detailed\"</code> \u2014 extends the basic payload with the Kuramoto order parameters and \u03a3\u20d7 snapshot while   omitting glyph counts, avoiding the most expensive history walk. Pick this tier when you need   coherence metrics without paying the full glyph audit cost.</li> <li><code>\"debug\"</code> \u2014 executes the full collector suite, including glyph counts, to preserve the legacy   trace payload. This remains the default level and is intended for investigations and regression   hunts where complete operator coverage matters more than runtime.</li> </ul> <p>If you still need a custom field mix, set <code>TRACE[\"capture\"]</code> explicitly; the resolver will honour that list (or mapping) and ignore the verbosity preset. Identifiers are case-sensitive and the following capture names are recognised:</p> <ul> <li><code>\"gamma\"</code> \u2014 canonical \u0393 specification snapshot.</li> <li><code>\"grammar\"</code> \u2014 canonical grammar configuration.</li> <li><code>\"selector\"</code> \u2014 active glyph selector name.</li> <li><code>\"dnfr_weights\"</code> \u2014 \u0394NFR mixing weights.</li> <li><code>\"si_weights\"</code> \u2014 Si weighting and sensitivity payload.</li> <li><code>\"callbacks\"</code> \u2014 registered callback names per phase.</li> <li><code>\"thol_open_nodes\"</code> \u2014 count of nodes with an open THOL block.</li> <li><code>\"kuramoto\"</code> \u2014 network Kuramoto order parameters.</li> <li><code>\"sigma\"</code> \u2014 global sense-plane vector \u03a3\u20d7.</li> <li><code>\"glyph_counts\"</code> (alias <code>\"glyphs\"</code>) \u2014 per-step glyph/operator count audit.</li> </ul>"},{"location":"api/telemetry/#metrics-verbosity-tiers","title":"Metrics verbosity tiers","text":"<p>The metrics orchestrator follows the same pattern via <code>G.graph[\"METRICS\"][\"verbosity\"]</code>, which is exposed on the CLI as <code>--metrics-verbosity {basic,detailed,debug}</code>:</p> <ul> <li><code>\"basic\"</code> keeps the coherence and stability core (C(t), \u0394Si, B) while skipping phase sync,   \u03a3\u20d7 statistics, Si aggregates, glyph timing, and the coherence/diagnosis callback hooks. This is   useful for lightweight runs or smoke tests.</li> <li><code>\"detailed\"</code> enables <code>_update_phase_sync</code>, <code>_update_sigma</code>, and <code>_aggregate_si</code> while attaching   the coherence observers. It deliberately skips <code>_compute_advanced_metrics</code> and the diagnosis   callbacks so you get richer stability traces without the most expensive glyph timing jobs.</li> <li><code>\"debug\"</code> retains the entire collector suite, including <code>_compute_advanced_metrics</code> and the   diagnosis callbacks, to mirror the legacy payload. This remains the default verbosity for   investigations that require a full glyph and diagnosis audit trail.</li> </ul> <p>As with traces, an explicit override of <code>METRICS</code> parameters (for example <code>save_by_node</code> or <code>normalize_series</code>) still applies regardless of the verbosity preset.</p>"},{"location":"api/telemetry/#locking-policy","title":"Locking policy","text":"<p>The engine centralises reusable process-wide locks in <code>tnfr.locking</code>. Obtain named locks with <code>tnfr.utils.get_lock()</code> (re-exporting :func:<code>tnfr.locking.get_lock</code>) and reuse them for caches, RNG seeds, and other shared resources. Avoid scattering bare <code>threading.Lock</code> instances across modules; only short-lived objects may instantiate ad-hoc locks when they are not shared.</p>"},{"location":"api/telemetry/#helper-utilities-api-tnfrutils","title":"Helper utilities API (<code>tnfr.utils</code>)","text":"<p>Compatibility note: <code>tnfr.cache</code> and <code>tnfr.io</code> continue to exist as compatibility shims that re-export the helpers in <code>tnfr.utils.cache</code> and <code>tnfr.utils.io</code>. Update new code to import from <code>tnfr.utils</code> directly so the structural helpers stay aligned with the canonical namespace.</p>"},{"location":"api/telemetry/#collections-and-numeric-helpers","title":"Collections and numeric helpers","text":"<ul> <li><code>ensure_collection(it, *, max_materialize=...)</code> \u2014 materialise potentially lazy iterables   once, enforcing a configurable limit to keep simulations bounded.</li> <li><code>clamp(x, a, b)</code> and <code>clamp01(x)</code> \u2014 restrict scalars to safe ranges for operator parameters.</li> <li><code>kahan_sum_nd(values, dims)</code> \u2014 numerically stable accumulators used to track coherence   magnitudes across long trajectories.</li> <li><code>angle_diff(a, b)</code> \u2014 compute minimal angular differences (radians) to compare structural   phases.</li> </ul>"},{"location":"api/telemetry/#structural-history-helpers","title":"Structural history helpers","text":"<ul> <li><code>push_glyph(nd, glyph, window)</code> \u2014 record operator usage in the node history while honouring   the configured window.</li> <li><code>recent_glyph(nd, glyph, window)</code> \u2014 check whether a specific operator appears in a node's   recent history.</li> <li><code>ensure_history(G)</code> \u2014 prepare the graph-level history container with appropriate bounds.</li> <li><code>last_glyph(nd)</code> \u2014 inspect the last operator emitted by a node.</li> <li><code>count_glyphs(G, window=None, *, last_only=False)</code> \u2014 aggregate operator usage across the   network using the full history or a bounded window.</li> </ul>"},{"location":"api/telemetry/#graph-caches-and-nfr-invalidation","title":"Graph caches and \u0394NFR invalidation","text":"<ul> <li><code>cached_node_list(G)</code> \u2014 lazily cache a stable tuple of node identifiers, respecting opt-in   sorted ordering.</li> <li><code>ensure_node_index_map(G)</code> / <code>ensure_node_offset_map(G)</code> \u2014 expose cached index and offset   mappings for graphs that need to project nodes to arrays.</li> <li><code>node_set_checksum(G, nodes=None, *, presorted=False, store=True)</code> \u2014 produce deterministic   BLAKE2b hashes to detect topology changes.</li> <li><code>stable_json(obj)</code> \u2014 render deterministic JSON strings suited for hashing and reproducible   logs.</li> <li><code>get_graph(obj)</code> / <code>get_graph_mapping(G, key, warn_msg)</code> \u2014 normalise access to graph-level   metadata regardless of wrappers.</li> <li><code>EdgeCacheManager</code>, <code>edge_version_cache</code>, <code>cached_nodes_and_A</code>, <code>edge_version_update</code>, and   <code>increment_edge_version</code> \u2014 encapsulate the edge version cache and bump versions for   imperative workflows.</li> <li><code>mark_dnfr_prep_dirty(G)</code> \u2014 invalidate precomputed \u0394NFR preparation when mutating edges   outside the cache helpers.</li> </ul>"},{"location":"api/telemetry/#simulation-best-practices","title":"Simulation best practices","text":"<ul> <li>Configure histories with <code>G.graph['history']</code> and <code>HISTORY_MAXLEN</code> to cap series without   losing traceability.</li> <li>Use random sampling (<code>G.graph['_node_sample']</code>) and the jitter cache   (<code>tnfr.operators.get_jitter_manager</code>) to accelerate comparisons and deterministic noise.</li> <li>Coordinate edge updates with <code>edge_version_update(G)</code> to keep topology versions and derived   caches aligned.</li> </ul>"},{"location":"api/telemetry/#topological-remeshing","title":"Topological remeshing","text":"<p>Use <code>tnfr.operators.apply_topological_remesh</code> (<code>from tnfr.operators import apply_topological_remesh</code>) to reorganise connectivity based on nodal EPI similarity while preserving graph connectivity. Pair it with <code>tnfr.operators.apply_remesh_if_globally_stable(G, stable_step_window=...)</code> to gate remeshing on a minimum window of stable steps. Only the English <code>stable_step_window</code> keyword is accepted. Modes:</p> <ul> <li><code>\"knn\"</code> \u2014 connect each node to its <code>k</code> nearest neighbours (with optional rewiring).</li> <li><code>\"mst\"</code> \u2014 retain only a minimum spanning tree.</li> <li><code>\"community\"</code> \u2014 collapse modular communities and reconnect them by similarity.</li> </ul> <p>All modes ensure connectivity by adding a base MST.</p>"},{"location":"api/telemetry/#additional-references","title":"Additional references","text":"<ul> <li><code>scripts/run_tests.sh</code> runs the canonical QA battery (<code>pydocstyle</code>, <code>pytest</code> with coverage,   and <code>vulture</code>).</li> <li>The <code>tnfr</code> CLI exposes subcommands such as <code>sequence</code>, <code>metrics</code>, and more. Inspect <code>tnfr   --help</code> for the full list.</li> <li>Explore <code>tnfr.dynamics</code>, <code>tnfr.structural</code>, <code>tnfr.metrics</code>, <code>tnfr.operators</code>, <code>tnfr.utils</code>,   and <code>tnfr.observers</code> for domain-specific extensions.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Home \u203a Examples</p> <p>Runnable examples illustrate how the TNFR engine orchestrates canonical operators in realistic scenarios. Each script can be executed directly with Python 3.9+ after installing <code>tnfr</code> and optional extras.</p>"},{"location":"examples/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Use Cases Guide - NEW! Domain mappings and operator selection guide</li> <li>Getting Started Examples - Simple, educational examples</li> <li>Domain Examples - Biology, social, technical applications</li> <li>Advanced Examples - Complex operator sequences</li> <li>CLI Examples - Command-line interface usage</li> </ul> <p>\ud83d\udcd8 New to TNFR applications? Start with the Use Cases Guide to understand when and how to use different operators for your domain!</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/#controlled-dissonance-with-re-coherence","title":"Controlled Dissonance with Re-coherence","text":"<p>File: <code>controlled_dissonance.py</code></p> <p>Summary: Three-node ring where node C receives a controlled dissonance pulse, bifurcates, and re-stabilises while telemetry records C(t), \u0394NFR, Si, and history windows.</p> <p>Key Concepts: - Dissonance operator - Bifurcation detection - Coherence recovery - Telemetry and metrics</p> <p>Run: <pre><code>python docs/source/examples/controlled_dissonance.py\n</code></pre></p> <p>Learn: How to use controlled instability for exploration while maintaining network coherence.</p>"},{"location":"examples/#optical-cavity-feedback-loop","title":"Optical Cavity Feedback Loop","text":"<p>File: <code>optical_cavity_feedback.py</code></p> <p>Summary: Tabletop optical cavity (laser head, piezo mirror stage, detector array) realigns after a thermal drift using self-organisation, mutation, and resonance sequences.</p> <p>Key Concepts: - Self-organization - Mutation operator - Resonance propagation - Feedback control</p> <p>Run: <pre><code>python docs/source/examples/optical_cavity_feedback.py\n</code></pre></p> <p>Learn: How TNFR models physical systems with feedback loops and self-correction.</p>"},{"location":"examples/#domain-examples","title":"Domain Examples","text":""},{"location":"examples/#biological-cell-communication","title":"Biological Cell Communication","text":"<p>File: <code>biological_coherence_example.py</code></p> <p>Summary: Models how cells in a tissue coordinate responses through chemical signaling. Demonstrates cell-to-cell communication using emission/reception operators, gap junction formation via coupling, and tissue organization through coherence metrics.</p> <p>Key Concepts: - Emission operator (chemical signal secretion) - Reception operator (receptor binding) - Coupling operator (gap junctions, cell contacts) - Coherence as tissue organization - Sense index as cell responsiveness</p> <p>Run: <pre><code>python docs/source/examples/biological_coherence_example.py\n</code></pre></p> <p>Learn: How TNFR models biological systems with cellular communication and tissue formation.</p>"},{"location":"examples/#social-network-information-dynamics","title":"Social Network Information Dynamics","text":"<p>File: <code>social_network_dynamics.py</code></p> <p>Summary: Models information propagation and opinion formation in social networks. Demonstrates how individuals (nodes) interact, debate (dissonance), evolve opinions (mutation), and reach consensus (coherence).</p> <p>Key Concepts: - Nodes as individuals in a social network - Resonance operator (consensus building, viral spread) - Dissonance operator (conflict, debate, diverse opinions) - Mutation operator (opinion evolution) - Coherence as group cohesion</p> <p>Run: <pre><code>python docs/source/examples/social_network_dynamics.py\n</code></pre></p> <p>Learn: How TNFR analyzes social dynamics, consensus formation, and network stability vs. change.</p>"},{"location":"examples/#adaptive-ai-self-organization","title":"Adaptive AI Self-Organization","text":"<p>File: <code>adaptive_ai_system.py</code></p> <p>Summary: Models an AI system that learns through structural reorganization rather than gradient descent. Demonstrates how intelligent agents self-organize and adapt using TNFR operators.</p> <p>Key Concepts: - Nodes as intelligent agents - SelfOrganization operator (THOL) for autonomous structuring - Learning as coherence increase (not error minimization) - Structural adaptation without backpropagation</p> <p>Run: <pre><code>python docs/source/examples/adaptive_ai_system.py\n</code></pre></p> <p>Learn: TNFR's alternative paradigm for learning and adaptation in AI systems.</p>"},{"location":"examples/#supply-chain-resilience-under-disruption","title":"Supply Chain Resilience Under Disruption","text":"<p>File: <code>supply_chain_resilience.py</code></p> <p>Summary: Models an adaptive supply chain responding to external disruptions. Demonstrates how suppliers and distributors reorganize using mutation operators to maintain system coherence.</p> <p>Key Concepts: - Nodes as supply chain facilities (suppliers, warehouses, distributors) - Mutation operator (ZHIR) for adaptive reconfiguration - Dissonance as disruption/shock - Resilience metrics through sense index - Recovery patterns and system adaptation</p> <p>Run: <pre><code>python docs/source/examples/supply_chain_resilience.py\n</code></pre></p> <p>Learn: How TNFR models business resilience and adaptive logistics networks.</p>"},{"location":"examples/#urban-traffic-flow-optimization","title":"Urban Traffic Flow Optimization","text":"<p>File: <code>urban_traffic_flow.py</code></p> <p>Summary: Models urban traffic grid with adaptive signal coordination. Demonstrates traffic flow optimization by treating intersections as nodes and using transition operators for signal timing.</p> <p>Key Concepts: - Intersections as nodes, traffic flow as coherence - Transition operator (NAV) for coordinated signal changes - Dissonance minimization (congestion reduction) - Dynamic adaptation to traffic patterns - Green wave propagation through resonance</p> <p>Run: <pre><code>python docs/source/examples/urban_traffic_flow.py\n</code></pre></p> <p>Learn: How TNFR applies to urban planning and intelligent transportation systems.</p>"},{"location":"examples/#technical-systems","title":"Technical Systems","text":"<p>File: Available in main <code>examples/</code> directory</p> <p>Examples include: - Distributed computing - Network resilience - Load balancing</p> <p>Key Concepts: - System synchronization - Fault tolerance through coherence - Adaptive reorganization</p>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/#multi-scale-network","title":"Multi-scale Network","text":"<p>File: Available in main <code>examples/</code></p> <p>Summary: Demonstrates operational fractality with nested EPIs at multiple scales.</p> <p>Key Concepts: - Recursivity operator - Hierarchical coherence - Multi-scale metrics</p>"},{"location":"examples/#parallel-computation","title":"Parallel Computation","text":"<p>File: Available in main <code>examples/</code></p> <p>Summary: Shows how to leverage JAX/PyTorch backends for GPU acceleration.</p> <p>Key Concepts: - Backend selection - Parallel operator application - Performance optimization</p>"},{"location":"examples/#intelligent-caching","title":"Intelligent Caching","text":"<p>File: Available in main <code>examples/</code></p> <p>Summary: Demonstrates caching strategies for large networks.</p> <p>Key Concepts: - Buffer management - Cache configuration - Performance monitoring</p>"},{"location":"examples/#cli-examples","title":"CLI Examples","text":""},{"location":"examples/#reproduce-optical-cavity-with-cli","title":"Reproduce Optical Cavity with CLI","text":"<p>Use the TNFR CLI to reproduce the optical cavity workflow using canonical tokens:</p> <p>Files: - Configuration: <code>config.json</code> - Sequence: <code>sequence.json</code></p> <p>Command: <pre><code>tnfr sequence \\\n  --nodes 3 --topology ring --seed 1 \\\n  --sequence-file docs/source/examples/sequence.json \\\n  --config docs/source/examples/config.json \\\n  --save-history history.json\n</code></pre></p> <p>Token Legend:</p> Token English Operator <code>AL</code> Emission <code>EN</code> Reception <code>IL</code> Coherence <code>UM</code> Coupling <code>RA</code> Resonance <code>SHA</code> Silence <code>NAV</code> Transition <code>OZ</code> Dissonance <code>ZHIR</code> Mutation <p>The CLI run writes telemetry to <code>history.json</code>, mirroring the metrics produced by Python scripts. Inspect <code>W_stats</code> and <code>nodal_diag</code> entries to correlate coherence spans with node states.</p>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>Complete collection of examples in the main repository:</p> <p>Location: <code>examples/</code> directory</p> <p>Includes: - <code>hello_world.py</code> - Simplest possible TNFR code - <code>sdk_example.py</code> - Full SDK capabilities - <code>canonical_equation_demo.py</code> - Nodal equation demonstration - <code>backend_performance_comparison.py</code> - Backend benchmarks - <code>sparse_graph_demo.py</code> - Sparse network optimization - And more!</p> <p>Browse all: GitHub Examples Directory</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#by-learning-goal","title":"By Learning Goal","text":"<p>Understanding Basics: 1. <code>controlled_dissonance.py</code> - Core operator sequence 2. <code>hello_world.py</code> - Minimal TNFR code 3. <code>canonical_equation_demo.py</code> - Nodal equation</p> <p>Domain Applications: 1. Biological examples - Cell/neural networks 2. Social examples - Group dynamics 3. Technical examples - Distributed systems</p> <p>Performance Optimization: 1. <code>backend_performance_comparison.py</code> - Backend selection 2. <code>parallel_computation_demo.py</code> - GPU acceleration 3. <code>intelligent_caching_demo.py</code> - Caching strategies</p> <p>Advanced Techniques: 1. <code>multiscale_network_demo.py</code> - Recursivity and fractality 2. <code>optical_cavity_feedback.py</code> - Self-organization 3. <code>sparse_graph_demo.py</code> - Large networks</p>"},{"location":"examples/#by-complexity","title":"By Complexity","text":"<p>Beginner (&lt; 50 lines): - <code>hello_world.py</code> - <code>canonical_equation_demo.py</code></p> <p>Intermediate (50-200 lines): - <code>controlled_dissonance.py</code> - <code>sdk_example.py</code> - <code>backend_performance_comparison.py</code></p> <p>Advanced (200+ lines): - <code>optical_cavity_feedback.py</code> - <code>multiscale_network_demo.py</code> - <code>parallel_computation_demo.py</code></p>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<pre><code># Install TNFR\npip install tnfr\n\n# Optional: Install extras for specific examples\npip install tnfr[viz-basic]        # Visualization\npip install tnfr[compute-jax]      # GPU acceleration\npip install tnfr[orjson]           # Fast caching\n</code></pre>"},{"location":"examples/#general-pattern","title":"General Pattern","text":"<pre><code># Run from repository root\ncd /path/to/TNFR-Python-Engine\n\n# Basic examples (in docs/source/examples/)\npython docs/source/examples/controlled_dissonance.py\n\n# Main examples (in examples/)\npython examples/hello_world.py\npython examples/sdk_example.py\n\n# With visualization (requires viz-basic)\npython examples/canonical_equation_demo.py\n</code></pre>"},{"location":"examples/#cli-examples_1","title":"CLI Examples","text":"<pre><code># Help\ntnfr --help\ntnfr sequence --help\n\n# Run predefined sequence\ntnfr sequence \\\n  --nodes 5 --topology ring \\\n  --sequence-file examples/sequence.json\n</code></pre>"},{"location":"examples/#creating-your-own-examples","title":"Creating Your Own Examples","text":"<p>Template for new examples:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nExample: Your Example Name\n\nDescription: Brief description of what this demonstrates.\n\nKey Concepts:\n- Concept 1\n- Concept 2\n\nRun:\n    python your_example.py\n\"\"\"\n\nimport tnfr\nfrom tnfr.operators import Coherence, Resonance\nfrom tnfr.metrics import total_coherence, sense_index\n\ndef main():\n    # Create network\n    G = tnfr.create_network(nodes=10, connectivity=0.3)\n\n    # Apply operators\n    Coherence()(G)\n    Resonance()(G, list(G.nodes())[0])\n\n    # Measure results\n    C_t = total_coherence(G)\n    Si = sense_index(G)\n\n    print(f\"Coherence: {C_t:.3f}\")\n    print(f\"Sense Index: {Si:.3f}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>Quickstart Tutorial - Basic usage</li> <li>Operators Guide - Operator details</li> <li>API Reference - Complete API</li> <li>Performance Optimization - Speed tips</li> </ul> <p>Need help? Check the FAQ or Troubleshooting Guide.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/","title":"SHA (Silence) - Clinical Applications &amp; Therapeutic Protocols","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#overview","title":"Overview","text":"<p>SHA (Silence) is a structural operator that reduces \u03bdf (structural frequency) to near-zero, preserving the node's EPI (Primary Information Structure) intact despite external pressures. This document details clinical applications with reproducible protocols, expected telemetry, and scientific correlates.</p> <p>Core Principle: SHA implements structural pause - a deliberate reduction of reorganization activity that allows patterns to consolidate, memories to form, and systems to recover while maintaining their structural identity.</p> <p>Nodal Equation Context: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n\nWhen SHA is applied:\n- \u03bdf \u2192 0 (frequency suppression)\n- \u2202EPI/\u2202t \u2248 0 (minimal structural change)\n- EPI preserved (form maintained)\n- \u0394NFR present but inactive (pressure contained)\n</code></pre></p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#1-cardiac-coherence-training","title":"1. Cardiac Coherence Training","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#clinical-context","title":"Clinical Context","text":"<p>Heart Rate Variability (HRV) coherence training uses breathing protocols to synchronize heart rhythm, autonomic nervous system, and emotional state. SHA consolidates the coherent pattern before session completion, strengthening physiological memory.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#protocol-coherence-consolidation","title":"Protocol: Coherence Consolidation","text":"<p>Clinical Goal: Establish and preserve cardiac coherence pattern for lasting autonomic regulation benefits.</p> <p>TNFR Sequence: <pre><code>AL \u2192 IL \u2192 RA \u2192 SHA\n(Activate \u2192 Stabilize \u2192 Propagate \u2192 Preserve)\n</code></pre></p> <p>Step-by-Step:</p> <ol> <li>Emission (AL): Patient begins guided breathing (5-6 breaths/min)</li> <li>Initiates coherent heart rhythm pattern</li> <li> <p>Activates resonance between heart, breath, and autonomic system</p> </li> <li> <p>Coherence (IL): Pattern stabilizes across cardiac-respiratory coupling</p> </li> <li>HRV enters coherent state (sinusoidal pattern at breathing frequency)</li> <li> <p>Parasympathetic activation increases</p> </li> <li> <p>Resonance (RA): Coherence propagates to nervous system</p> </li> <li>Baroreceptor sensitivity increases</li> <li>Vagal tone strengthens</li> <li> <p>Emotional regulation improves</p> </li> <li> <p>Silence (SHA): Pre-session consolidation</p> </li> <li>Breathing continues at minimal effort</li> <li>Pattern \"locks in\" through reduced reorganization</li> <li>Creates physiological memory of coherent state</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#expected-telemetry","title":"Expected Telemetry","text":"<pre><code>Pre-SHA (active coherence):\n  EPI = 0.68 \u00b1 0.05    # Strong coherent pattern\n  \u03bdf = 1.15 \u00b1 0.10     # Active reorganization\n  \u0394NFR = 0.03 \u00b1 0.02   # Low pressure (stable state)\n  Phase coherence = 0.85  # High synchrony\n\nPost-SHA (preserved coherence):\n  EPI = 0.68 \u00b1 0.02    # Pattern maintained (variance reduced)\n  \u03bdf = 0.05 \u00b1 0.02     # Minimal activity (structural pause)\n  \u0394NFR = 0.03 \u00b1 0.02   # Pressure contained\n  Phase coherence = 0.82  # Slight reduction acceptable\n</code></pre> <p>Key Metrics: - Preservation integrity: <code>|EPI_pre - EPI_post| &lt; 0.05</code> (pattern intact) - Frequency suppression: <code>\u03bdf_post &lt; 0.1</code> (successful pause) - Phase maintenance: Phase coherence remains &gt; 0.75</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#clinical-outcomes","title":"Clinical Outcomes","text":"<p>Immediate (post-session): - Sustained HRV coherence for 10-30 minutes post-training - Reduced sympathetic activation markers - Subjective calm and centeredness</p> <p>Long-term (with practice): - Increased baseline vagal tone - Faster return to coherence under stress - Improved emotional regulation capacity</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#physiological-correlates","title":"Physiological Correlates","text":"<ul> <li>SHA \u2194 Vagal activation: Reduced \u03bdf corresponds to sustained parasympathetic dominance</li> <li>EPI preservation \u2194 Cardiac memory: Pattern stability reflects baroreceptor adaptation</li> <li>\u0394NFR containment \u2194 Homeostatic balance: Low reorganization pressure indicates autonomic equilibrium</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#research-applications","title":"Research Applications","text":"<ul> <li>Studying HRV biofeedback effectiveness</li> <li>Modeling autonomic regulation mechanisms</li> <li>Predicting long-term coherence training outcomes</li> <li>Quantifying \"coherence memory\" formation</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#references","title":"References","text":"<ul> <li>McCraty, R., &amp; Shaffer, F. (2015). Heart rate variability: new perspectives on physiological mechanisms. Glob Adv Health Med, 4(1), 46-61.</li> <li>Lehrer, P. M., &amp; Gevirtz, R. (2014). Heart rate variability biofeedback. Biofeedback, 42(1), 26-31.</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#2-trauma-therapy-containment-protocol","title":"2. Trauma Therapy (Containment Protocol)","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#clinical-context_1","title":"Clinical Context","text":"<p>Patients with PTSD accessing traumatic memories can experience overwhelming activation (high \u0394NFR, excessive dissonance). SHA provides protective containment - a therapeutic pause that stabilizes the patient without suppressing awareness, preventing retraumatization while maintaining access to the material.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#protocol-dissonance-containment","title":"Protocol: Dissonance Containment","text":"<p>Clinical Goal: Access traumatic material safely, contain activation, prevent overwhelm while preserving therapeutic access.</p> <p>TNFR Sequence: <pre><code>AL \u2192 EN \u2192 OZ \u2192 SHA\n(Activate memory \u2192 Receive emotion \u2192 Access dissonance \u2192 Contain)\n</code></pre></p> <p>Step-by-Step:</p> <ol> <li>Emission (AL): Therapist guides access to traumatic memory</li> <li>Patient begins narrative or imagery exposure</li> <li> <p>Activation begins (EPI shifts toward trauma-associated state)</p> </li> <li> <p>Reception (EN): Emotion emerges and is received</p> </li> <li>Affect tolerance maintained</li> <li>Therapist provides empathic witnessing</li> <li> <p>Patient remains present with emotional experience</p> </li> <li> <p>Dissonance (OZ): Conflict/distress becomes conscious</p> </li> <li>\u0394NFR spikes (high reorganization pressure)</li> <li>Arousal increases (hyperactivation risk)</li> <li> <p>Patient reports intense distress but remains engaged</p> </li> <li> <p>Silence (SHA): Protective containment</p> </li> <li>Therapist guides \"pause and notice\" intervention</li> <li>Patient maintains awareness but reduces processing intensity</li> <li>System stabilizes without dissociation or shutdown</li> <li>Dissonance remains present but contained (not resolved)</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#expected-telemetry_1","title":"Expected Telemetry","text":"<pre><code>Pre-OZ (baseline):\n  EPI = 0.35 \u00b1 0.05    # Moderate baseline structure\n  \u03bdf = 1.00 \u00b1 0.10     # Normal reorganization rate\n  \u0394NFR = 0.08 \u00b1 0.03   # Low baseline pressure\n\nPost-OZ (active dissonance):\n  EPI = 0.42 \u00b1 0.08    # Increased complexity/fragmentation\n  \u03bdf = 1.35 \u00b1 0.15     # Heightened reorganization\n  \u0394NFR = 0.28 \u00b1 0.05   # High pressure (distress signal)\n  Phase dispersion = 0.55  # Reduced synchrony\n\nPost-SHA (contained):\n  EPI = 0.42 \u00b1 0.03    # Structure preserved (no forced change)\n  \u03bdf = 0.08 \u00b1 0.03     # Minimal activity (pause achieved)\n  \u0394NFR = 0.28 \u00b1 0.04   # Pressure STILL PRESENT but inactive\n  Phase dispersion = 0.52  # Slight stabilization\n</code></pre> <p>Critical Observation: SHA does not resolve the trauma (\u0394NFR remains high). It creates a safe pause that: - Prevents dissociation (EPI maintained, not fragmented) - Avoids retraumatization (\u03bdf reduced, processing slowed) - Maintains access (dissonance present for future work)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#clinical-outcomes_1","title":"Clinical Outcomes","text":"<p>Within-Session: - Patient reports \"holding\" distress without overwhelm - Physiological arousal decreases while awareness remains - Safe session termination possible - Therapeutic relationship strengthened (safety demonstrated)</p> <p>Between-Sessions: - Reduced avoidance (patient knows pause is available) - Increased tolerance for exposure work - Less post-session dysregulation - Foundation for deeper processing (THOL, ZHIR in future sessions)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#therapeutic-considerations","title":"Therapeutic Considerations","text":"<p>SHA is NOT: - Suppression (patient remains aware) - Avoidance (material stays accessible) - Resolution (trauma still requires processing)</p> <p>SHA IS: - Stabilization tool for crisis moments - Safety mechanism during intense work - Bridge to session closure - Preparation for subsequent transformation</p> <p>When to Use SHA: - Patient approaching window of tolerance limits - High arousal with adequate awareness - Need to end session before resolution possible - After intense exposure before closure</p> <p>When NOT to Use SHA: - Dissociation already present (use UM/IL instead) - Avoidance patterns dominate (needs EN/OZ first) - No therapeutic alliance (build with AL/EN/IL)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#neuroscientific-correlates","title":"Neuroscientific Correlates","text":"<ul> <li>SHA \u2194 Prefrontal regulation: \u03bdf reduction reflects increased cognitive control over limbic activation</li> <li>\u0394NFR containment \u2194 Amygdala modulation: Pressure present but not expressed = regulated threat response</li> <li>EPI preservation \u2194 Hippocampal function: Memory structure maintained = no dissociative fragmentation</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#research-applications_1","title":"Research Applications","text":"<ul> <li>Modeling trauma therapy dose-response</li> <li>Predicting session safety and tolerability</li> <li>Studying regulatory capacity development</li> <li>Quantifying \"window of tolerance\" dynamics</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#references_1","title":"References","text":"<ul> <li>van der Kolk, B. A. (2015). The Body Keeps the Score. Penguin Books.</li> <li>Ogden, P., &amp; Fisher, J. (2015). Sensorimotor Psychotherapy. Norton.</li> <li>Porges, S. W. (2011). The Polyvagal Theory. Norton.</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#3-sleep-memory-consolidation","title":"3. Sleep &amp; Memory Consolidation","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#neuroscientific-context","title":"Neuroscientific Context","text":"<p>During sleep, particularly deep slow-wave sleep (SWS), neuronal firing rates decrease dramatically while synaptic consolidation occurs. SHA models this process: reduced \u03bdf preserves learned patterns (EPI) while allowing structural integration without interference.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#protocol-learning-sleep-memory","title":"Protocol: Learning \u2192 Sleep \u2192 Memory","text":"<p>Scientific Goal: Model memory consolidation during sleep using TNFR operators to understand how structural pause enables learning retention.</p> <p>TNFR Sequence: <pre><code>[Awake/Learning] AL \u2192 EN \u2192 IL \u2192 RA \u2192 IL\n[Sleep] SHA\n[Awake/Recall] NAV \u2192 AL\n</code></pre></p> <p>Step-by-Step:</p> <ol> <li>Day - Active Learning:</li> <li>Emission (AL): New information encoded</li> <li>Reception (EN): Synaptic integration</li> <li>Coherence (IL): Initial stabilization</li> <li>Resonance (RA): Pattern propagates through neural network</li> <li> <p>Coherence (IL): Secondary stabilization</p> </li> <li> <p>Night - Sleep Consolidation:</p> </li> <li>Silence (SHA): Deep sleep state</li> <li>Neuronal firing rate \u2192 minimal</li> <li>Learned pattern preserved intact</li> <li> <p>Synaptic consolidation occurs structurally</p> </li> <li> <p>Next Day - Memory Reactivation:</p> </li> <li>Transition (NAV): Sleep \u2192 wake transition</li> <li>Emission (AL): Memory recall initiated</li> <li>Pattern retrieved with high fidelity</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#expected-telemetry_2","title":"Expected Telemetry","text":"<pre><code>Post-Learning (awake):\n  EPI = 0.73 \u00b1 0.04    # Rich learned pattern\n  \u03bdf = 1.20 \u00b1 0.10     # High activity (awake brain)\n  \u0394NFR = 0.05 \u00b1 0.02   # Low (pattern stabilized)\n\nDuring Sleep (SHA):\n  EPI = 0.73 \u00b1 0.01    # Pattern preserved (minimal variance)\n  \u03bdf = 0.03 \u00b1 0.02     # Minimal activity (deep sleep)\n  \u0394NFR = 0.05 \u00b1 0.02   # Unchanged (no active processing)\n  Duration = 6-8 hours # Typical sleep period\n\nPost-Recall (next day):\n  EPI = 0.71 \u00b1 0.05    # High fidelity recall\n  Recall accuracy = |EPI_recall - EPI_learned| &lt; 0.10\n  Memory consolidation = (1 - |\u0394EPI|/EPI_learned) \u00d7 100%\n                       = ~97% preservation\n</code></pre> <p>Key Metrics: - Preservation fidelity: <code>|EPI_sleep - EPI_learned| &lt; 0.02</code> (minimal drift) - Frequency suppression: <code>\u03bdf &lt; 0.05</code> (deep sleep state) - Recall accuracy: <code>|EPI_recall - EPI_learned| &lt; 0.10</code> (successful consolidation)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#neuroscientific-correlates_1","title":"Neuroscientific Correlates","text":"TNFR Element Neural Correlate Measurement SHA activation Slow-wave sleep onset \u03b4 waves (0.5-4 Hz) \u03bdf \u2192 0 Reduced firing rate Single-unit recordings EPI preservation Synaptic consolidation LTP maintenance \u0394NFR inactive Reduced interference Memory stability tests SHA duration Sleep stage duration Polysomnography"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#research-applications_2","title":"Research Applications","text":"<p>Computational Neuroscience: - Model sleep-dependent learning - Predict optimal sleep timing for retention - Study interference effects on consolidation - Quantify sleep quality via preservation metrics</p> <p>Clinical Applications: - Sleep disorder impact on memory - Optimal study-sleep schedules - Sleep therapy for learning disabilities - Aging and memory consolidation</p> <p>Experimental Predictions: 1. SHA duration correlates with retention: Longer structural pause \u2192 better preservation 2. EPI variance during SHA predicts recall: Lower variance \u2192 higher fidelity 3. \u0394NFR pre-SHA affects consolidation: Lower pressure \u2192 better stabilization</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#mathematical-model","title":"Mathematical Model","text":"<p>Memory retention as a function of SHA quality:</p> <pre><code>Retention(t) = EPI\u2080 \u00b7 exp(-k \u00b7 Var(EPI_SHA) \u00b7 t)\n\nWhere:\n- EPI\u2080 = learned pattern strength\n- k = interference constant\n- Var(EPI_SHA) = variance during structural pause\n- t = time since learning\n</code></pre> <p>Prediction: Lower EPI variance during SHA (better structural pause quality) leads to exponentially better retention.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#references_2","title":"References","text":"<ul> <li>Tononi, G., &amp; Cirelli, C. (2014). Sleep and the price of plasticity. Neuron, 81(1), 12-34.</li> <li>Rasch, B., &amp; Born, J. (2013). About sleep's role in memory. Physiol Rev, 93(2), 681-766.</li> <li>Diekelmann, S., &amp; Born, J. (2010). The memory function of sleep. Nat Rev Neurosci, 11(2), 114-126.</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#4-post-exercise-recovery-protocol","title":"4. Post-Exercise Recovery Protocol","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#physiological-context","title":"Physiological Context","text":"<p>Intense exercise creates controlled stress (OZ) that triggers adaptive responses. Recovery (SHA) is essential for consolidating physiological adaptations - muscle repair, metabolic adjustments, and performance gains require structural pause for integration.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#protocol-exercise-adaptation-recovery","title":"Protocol: Exercise \u2192 Adaptation \u2192 Recovery","text":"<p>Athletic Goal: Optimize training adaptations through structured recovery periods using TNFR principles.</p> <p>TNFR Sequence: <pre><code>[Training] VAL \u2192 OZ \u2192 IL\n[Recovery] SHA\n[Next Session] NAV \u2192 AL\n</code></pre></p> <p>Step-by-Step:</p> <ol> <li>Training Phase:</li> <li>Expansion (VAL): Muscular activation, increased metabolic demand</li> <li>Dissonance (OZ): Metabolic stress (lactate, ROS, microdamage)</li> <li> <p>Coherence (IL): Acute homeostatic compensation</p> </li> <li> <p>Recovery Phase:</p> </li> <li>Silence (SHA): Active recovery/rest period</li> <li>Reduced activity allows adaptation consolidation</li> <li>Structural changes integrate (protein synthesis, mitochondrial biogenesis)</li> <li> <p>System reorganizes at minimal \u03bdf</p> </li> <li> <p>Next Training:</p> </li> <li>Transition (NAV): Return to active state</li> <li>Emission (AL): Training resumes with adapted system</li> <li>Performance capacity increased</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#expected-telemetry_3","title":"Expected Telemetry","text":"<pre><code>Post-Exercise (acute stress):\n  EPI = 0.58 \u00b1 0.08    # Elevated complexity (stress response)\n  \u03bdf = 1.45 \u00b1 0.12     # High metabolic activity\n  \u0394NFR = 0.35 \u00b1 0.06   # Significant reorganization pressure\n\nRecovery Day 1 (SHA):\n  EPI = 0.58 \u00b1 0.03    # Structure stabilizing\n  \u03bdf = 0.15 \u00b1 0.05     # Reduced activity (rest)\n  \u0394NFR = 0.22 \u00b1 0.05   # Decreasing pressure\n\nRecovery Day 2 (SHA continues):\n  EPI = 0.62 \u00b1 0.02    # Adapted structure emerging\n  \u03bdf = 0.08 \u00b1 0.03     # Minimal activity (deep recovery)\n  \u0394NFR = 0.08 \u00b1 0.03   # Low pressure (adaptation consolidating)\n\nNext Training (post-recovery):\n  EPI = 0.62 \u00b1 0.04    # Adapted baseline (improvement)\n  \u03bdf = 1.00 \u00b1 0.10     # Normal baseline activity\n  \u0394NFR = 0.05 \u00b1 0.02   # Ready for next cycle\n\nPerformance gain = (EPI_adapted - EPI_baseline) / EPI_baseline \u00d7 100%\n                 = ~8% structural improvement\n</code></pre> <p>Key Metrics: - Adaptation quality: EPI increase during SHA - Recovery completeness: \u0394NFR return to baseline - Frequency normalization: \u03bdf restoration - Readiness indicators: Low \u0394NFR + normal \u03bdf</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#physiological-correlates_1","title":"Physiological Correlates","text":"TNFR Metric Physiological Marker Measurement Tool SHA activation Recovery mode HRV, resting HR \u03bdf reduction Metabolic downregulation VO2, RMR EPI preservation/growth Structural adaptation Muscle cross-section, performance tests \u0394NFR normalization Stress marker clearance Cortisol, CK, inflammation markers SHA duration Recovery time requirement Performance testing, subjective recovery"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#training-applications","title":"Training Applications","text":"<p>Periodization Model: - High frequency: Short SHA (24-48h) for maintenance training - Medium frequency: Moderate SHA (48-72h) for progressive overload - Low frequency: Extended SHA (72-96h+) for adaptation/taper</p> <p>Overtraining Prevention: - Warning signs: \u0394NFR fails to normalize during SHA - Intervention: Extend SHA duration, reduce training load - Recovery verification: \u03bdf returns to baseline range</p> <p>Performance Optimization: - SHA timing: Match recovery to adaptation timeline (muscle: 48-72h, nervous system: 72-96h) - SHA quality: Monitor EPI variance (lower = better recovery) - Return criteria: \u0394NFR &lt; 0.10 + \u03bdf normalized before next high-intensity session</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#case-study-marathon-training","title":"Case Study: Marathon Training","text":"<p>Week 1-3 (Build Phase): <pre><code>Training: VAL \u2192 OZ \u2192 IL (long run 20km)\nRecovery: SHA (2 days)\nTraining: VAL \u2192 OZ \u2192 IL (interval workout)\nRecovery: SHA (1 day)\nTraining: VAL \u2192 OZ \u2192 IL (tempo run)\nRecovery: SHA (1 day)\n</code></pre></p> <p>Week 4 (Recovery/Adaptation Week): <pre><code>Training: AL \u2192 IL (easy runs only)\nExtended SHA: 5-7 days\nResult: EPI consolidates, performance ceiling raises\n</code></pre></p> <p>Telemetry Prediction: - Build phase: Cumulative \u0394NFR increases (controlled stress) - SHA phases: Partial \u0394NFR normalization - Recovery week: Complete \u0394NFR normalization, EPI increase - Post-taper: Peak performance (high EPI, low \u0394NFR, optimal \u03bdf)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#references_3","title":"References","text":"<ul> <li>Kellmann, M., et al. (2018). Recovery and Performance in Sport. Routledge.</li> <li>Halson, S. L. (2014). Monitoring training load to understand fatigue in athletes. Sports Med, 44(S2), 139-147.</li> <li>Bompa, T. O., &amp; Haff, G. (2009). Periodization: Theory and Methodology of Training. Human Kinetics.</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#5-meditation-mindfulness-protocol","title":"5. Meditation &amp; Mindfulness Protocol","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#contemplative-context","title":"Contemplative Context","text":"<p>Meditation practices across traditions share a common structural pattern: intentional reduction of mental elaboration (\u03bdf) while maintaining awareness (EPI). SHA provides a formal model for these contemplative states.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#protocol-mindfulness-based-stress-reduction-mbsr","title":"Protocol: Mindfulness-Based Stress Reduction (MBSR)","text":"<p>Contemplative Goal: Cultivate \"effortless awareness\" - stable presence with minimal mental reactivity.</p> <p>TNFR Sequence: <pre><code>AL \u2192 EN \u2192 IL \u2192 RA \u2192 SHA\n(Attention) \u2192 (Reception) \u2192 (Stabilization) \u2192 (Expansion) \u2192 (Stillness)\n</code></pre></p> <p>Step-by-Step:</p> <ol> <li>Emission (AL): Attention directed to anchor (breath, body)</li> <li>Initiates meditative focus</li> <li> <p>Establishes intentional awareness</p> </li> <li> <p>Reception (EN): Open awareness to present-moment experience</p> </li> <li>Non-judgmental observation</li> <li> <p>Thoughts, sensations received without attachment</p> </li> <li> <p>Coherence (IL): Attention stabilizes</p> </li> <li>Reduced mind-wandering</li> <li> <p>Sustained focus emerges</p> </li> <li> <p>Resonance (RA): Awareness expands</p> </li> <li>Spacious presence</li> <li>Choiceless awareness</li> <li> <p>\"Being\" rather than \"doing\"</p> </li> <li> <p>Silence (SHA): Effortless awareness</p> </li> <li>Mental elaboration ceases (\u03bdf \u2192 0)</li> <li>Pure presence without reactivity</li> <li>\"Witness consciousness\"</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#expected-telemetry_4","title":"Expected Telemetry","text":"<pre><code>Pre-Meditation (baseline):\n  EPI = 0.45 \u00b1 0.12    # High variance (discursive mind)\n  \u03bdf = 1.35 \u00b1 0.25     # High mental activity\n  \u0394NFR = 0.15 \u00b1 0.08   # Moderate pressure (stress/thoughts)\n  Mind-wandering rate = 0.65 (65% off-task)\n\nDuring AL \u2192 RA (active practice):\n  EPI = 0.52 \u00b1 0.06    # Stabilizing (reduced variance)\n  \u03bdf = 0.85 \u00b1 0.15     # Decreasing activity\n  \u0394NFR = 0.08 \u00b1 0.04   # Reduced pressure\n\nDuring SHA (deep meditation):\n  EPI = 0.52 \u00b1 0.02    # Stable presence (minimal variance)\n  \u03bdf = 0.06 \u00b1 0.03     # Minimal reactivity\n  \u0394NFR = 0.03 \u00b1 0.02   # Very low pressure\n  Mind-wandering rate = 0.15 (15% off-task)\n\nPost-Meditation (residual):\n  EPI = 0.48 \u00b1 0.05    # Return to baseline with less variance\n  \u03bdf = 0.95 \u00b1 0.15     # Partially normalized\n  \u0394NFR = 0.06 \u00b1 0.03   # Reduced baseline pressure\n  Equanimity score = +35% (subjective report)\n</code></pre> <p>Key Metrics: - Stability increase: Variance reduction in EPI - Activity reduction: \u03bdf approaches zero - Pressure release: \u0394NFR decrease - Sustainability: SHA duration before mind-wandering returns</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#contemplative-traditions-mapped-to-tnfr","title":"Contemplative Traditions Mapped to TNFR","text":"Tradition Practice TNFR Sequence SHA Characteristics Vipassana Insight meditation EN \u2192 IL \u2192 SHA Long durations (10+ min), minimal EPI variance Zazen Zen sitting AL \u2192 SHA Direct entry, \"just sitting\" TM Transcendental Meditation AL \u2192 RA \u2192 SHA Mantra dissolves into silence Dzogchen Tibetan awareness SHA (direct) \"Natural state\" without sequence Centering Prayer Christian contemplation AL \u2192 IL \u2192 SHA Sacred word \u2192 release \u2192 silence"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#cognitive-spiritual-benefits","title":"Cognitive &amp; Spiritual Benefits","text":"<p>Immediate (within session): - Reduced rumination (lower \u0394NFR) - Present-moment awareness (stable EPI) - Emotional regulation (reduced \u03bdf reactivity) - Spaciousness (expanded phase coherence)</p> <p>Long-term (with practice): - Lower baseline \u0394NFR (reduced stress reactivity) - Faster SHA access (meditation efficiency) - Increased EPI stability (trait equanimity) - \"Off-cushion\" carryover (sustained benefits)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#neuroscientific-correlates_2","title":"Neuroscientific Correlates","text":"TNFR Element Neural Signature Research Finding SHA onset Default Mode Network (DMN) deactivation fMRI studies (Brewer et al., 2011) \u03bdf \u2192 0 Reduced frontal theta power EEG meta-analysis (Lomas et al., 2015) EPI stability Increased alpha synchrony Neurofeedback studies \u0394NFR reduction Decreased amygdala reactivity Emotional regulation research Phase coherence Increased functional connectivity Graph theory studies"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#research-applications_3","title":"Research Applications","text":"<p>Meditation Science: - Quantify meditation \"depth\" via SHA metrics - Compare traditions structurally (different SHA entry sequences) - Predict expertise level from telemetry patterns - Study dose-response (practice time vs. SHA stability)</p> <p>Clinical Applications: - MBSR effectiveness tracking - Anxiety/depression treatment outcomes - Trauma therapy augmentation (SHA as resource state) - Addiction recovery support</p> <p>Experimental Questions: 1. Does SHA duration correlate with therapeutic benefit? 2. Can we predict \"breakthrough\" insights from \u0394NFR patterns? 3. Do expert meditators show different SHA entry sequences? 4. Is SHA quality (EPI variance) more important than duration?</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#references_4","title":"References","text":"<ul> <li>Tang, Y. Y., et al. (2015). The neuroscience of mindfulness meditation. Nat Rev Neurosci, 16(4), 213-225.</li> <li>Lutz, A., et al. (2008). Attention regulation and monitoring in meditation. Trends Cogn Sci, 12(4), 163-169.</li> <li>Davidson, R. J., &amp; Kaszniak, A. W. (2015). Conceptual and methodological issues in research on mindfulness and meditation. Am Psychol, 70(7), 581-592.</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#6-organizational-strategy-strategic-pause-protocol","title":"6. Organizational Strategy (Strategic Pause Protocol)","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#business-context","title":"Business Context","text":"<p>In rapidly changing markets, organizations face pressure to constantly reorganize (high \u0394NFR). SHA models strategic pause - deliberate non-action that preserves organizational identity while market conditions clarify, enabling better decisions.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#protocol-wait-and-see-strategy","title":"Protocol: \"Wait and See\" Strategy","text":"<p>Strategic Goal: Maintain market position during uncertainty, avoid reactive changes, preserve strategic coherence until informed action is possible.</p> <p>TNFR Sequence: <pre><code>IL \u2192 SHA \u2192 EN \u2192 NAV\n(Stabilize current position) \u2192 (Strategic pause) \u2192 (Scan environment) \u2192 (Informed move)\n</code></pre></p> <p>Step-by-Step:</p> <ol> <li>Coherence (IL): Stabilize current operations</li> <li>Document current strategy (EPI baseline)</li> <li>Ensure operational stability</li> <li> <p>Build organizational buffer (resources, morale)</p> </li> <li> <p>Silence (SHA): Strategic pause</p> </li> <li>Resist pressure to \"do something\"</li> <li>Maintain current positioning</li> <li> <p>Observe market without reacting</p> </li> <li> <p>Reception (EN): Environmental scanning</p> </li> <li>Gather intelligence (SHA continues)</li> <li>Analyze competitor moves</li> <li> <p>Assess market trends</p> </li> <li> <p>Transition (NAV): Informed strategic move</p> </li> <li>Act from clarity, not pressure</li> <li>Deliberate repositioning</li> <li>Resource-efficient pivot</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#expected-telemetry_5","title":"Expected Telemetry","text":"<pre><code>Pre-SHA (market turbulence):\n  EPI = 0.55 \u00b1 0.08    # Stable strategy under pressure\n  \u03bdf = 1.10 \u00b1 0.15     # Normal organizational activity\n  \u0394NFR = 0.32 \u00b1 0.06   # HIGH external pressure (market shifts, competition)\n  Board pressure = 0.75 (75% want immediate action)\n\nDuring SHA (strategic pause):\n  EPI = 0.55 \u00b1 0.02    # Strategy preserved (resisting change)\n  \u03bdf = 0.12 \u00b1 0.05     # Minimal reorganization\n  \u0394NFR = 0.32 \u00b1 0.05   # Pressure STILL PRESENT (contained, not resolved)\n  SHA duration = 2-6 months (varies by industry)\n\nPost-SHA + NAV (informed pivot):\n  EPI = 0.61 \u00b1 0.04    # NEW strategy (deliberate shift)\n  \u03bdf = 1.05 \u00b1 0.10     # Normal activity resumed\n  \u0394NFR = 0.08 \u00b1 0.03   # Low pressure (good strategic fit)\n  Success probability = 0.78 (vs. 0.45 for reactive pivot)\n</code></pre> <p>Key Insight: SHA allowed organization to contain high \u0394NFR without reactive change, enabling better decision-making when conditions clarified.</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#business-applications","title":"Business Applications","text":"<p>Crisis Management: - Scenario: Product recall, PR crisis, supply chain disruption - SHA Role: Pause expansion plans, preserve core operations, avoid panic decisions - Outcome: Organizational identity maintained through crisis</p> <p>Market Uncertainty: - Scenario: New technology emerges, regulatory changes pending, competitive disruption - SHA Role: Observe without committing, maintain current positioning - Outcome: Data-driven decision when uncertainty resolves</p> <p>Strategic Inflection Points: - Scenario: Industry paradigm shift (e.g., digital transformation) - SHA Role: Assess fit with core identity before pivoting - Outcome: Aligned transformation vs. identity-destroying reaction</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#case-studies","title":"Case Studies","text":"<p>Case 1: Tech Company During Platform Shift <pre><code>Context: Social media platform facing regulatory threat\nSHA Decision: Maintain current model for 18 months while policy clarifies\nPressure: Investors demand immediate pivot to new business model\nResult: Regulations changed favorably, competitors who pivoted lost market share\nTNFR Interpretation: SHA contained \u0394NFR, preserved EPI, superior outcome vs. reactive change\n</code></pre></p> <p>Case 2: Manufacturing During Supply Chain Crisis <pre><code>Context: Key supplier failure creates 40% cost increase\nSHA Decision: Accept margin compression for 6 months, observe market\nPressure: Competitors raising prices immediately, Board wants action\nResult: Alternative supplier emerged at better terms, market rejected price increases\nTNFR Interpretation: \u03bdf suppression (no hasty contracts) enabled better opportunity capture\n</code></pre></p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#organizational-metrics","title":"Organizational Metrics","text":"TNFR Metric Business Indicator Measurement EPI stability Strategic consistency Mission/vision alignment, product portfolio coherence \u03bdf suppression Change initiative freeze Project count, reorganization rate \u0394NFR magnitude External pressure Market volatility, competitor actions, stakeholder demands SHA duration Pause period Time from pressure onset to strategic move Post-SHA outcome Strategic success Market share, financial performance, organizational health"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#when-sha-fails-cautionary-tales","title":"When SHA Fails (Cautionary Tales)","text":"<p>Anti-Pattern 1: SHA as Avoidance <pre><code>Problem: Using \"strategic pause\" to avoid necessary adaptation\nTNFR Signature: SHA duration excessive, \u0394NFR continues rising, EPI degrading\nOutcome: Organizational decline (e.g., Kodak ignoring digital photography)\nLesson: SHA requires \u0394NFR stabilization; rising pressure indicates failure\n</code></pre></p> <p>Anti-Pattern 2: Premature SHA Termination <pre><code>Problem: Ending pause before clarity emerges\nTNFR Signature: SHA \u2192 NAV with persistent high \u0394NFR\nOutcome: Poor decision quality, resource waste, repeated pivots\nLesson: NAV requires \u0394NFR normalization for effective transition\n</code></pre></p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#strategic-decision-framework","title":"Strategic Decision Framework","text":"<p>Enter SHA when: - High external uncertainty (\u0394NFR from environment, not internal dysfunction) - Strong current position (EPI stable, organization healthy) - Time available (not immediate existential threat) - Observation can inform better decision</p> <p>Exit SHA when: - Uncertainty resolves (\u0394NFR stabilizes) - Clear strategic path emerges (NAV target identified) - Competitive window closing (SHA cost &gt; benefit) - Internal pressure exceeds external (organization degrading)</p> <p>Avoid SHA when: - Existential threat (requires immediate AL/THOL) - Clear best action (paralysis worse than imperfect move) - Internal dysfunction (needs IL/OZ/THOL first) - Stakeholder confidence critical (SHA may signal weakness)</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#references_5","title":"References","text":"<ul> <li>Grove, A. S. (1996). Only the Paranoid Survive. Currency/Doubleday.</li> <li>McGrath, R. G. (2013). The End of Competitive Advantage. Harvard Business Review Press.</li> <li>Sull, D., &amp; Eisenhardt, K. M. (2015). Simple Rules. Houghton Mifflin Harcourt.</li> </ul>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#cross-domain-synthesis","title":"Cross-Domain Synthesis","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#common-sha-structural-patterns","title":"Common SHA Structural Patterns","text":"<p>Across all domains, successful SHA implementation shows:</p> <ol> <li>Pre-SHA Stabilization: IL often precedes SHA (cardiac, meditation, organizational)</li> <li>Pressure Containment: High \u0394NFR is contained, not resolved by SHA (trauma, organizational)</li> <li>Duration Variability: SHA ranges from seconds (cardiac) to months (organizational)</li> <li>Preservation Fidelity: EPI variance during SHA predicts outcome quality (all domains)</li> <li>Reactivation Protocol: SHA typically exits through NAV or AL with intermediate stabilization (sleep, organizational)</li> </ol>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#sha-quality-metrics-universal","title":"SHA Quality Metrics (Universal)","text":"<p>Good SHA: - \u03bdf &lt; 0.1 (effective suppression) - EPI variance &lt; 5% of baseline (tight preservation) - \u0394NFR stable or decreasing (pressure not accumulating) - Duration appropriate to context - Clear exit strategy</p> <p>Poor SHA: - \u03bdf &gt; 0.2 (inadequate suppression, \"busy silence\") - EPI variance &gt; 10% (pattern drifting) - \u0394NFR increasing (pressure building dangerously) - Duration excessive or insufficient - Unclear purpose or endpoint</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#research-directions","title":"Research Directions","text":"<p>Comparative Studies: - Do SHA metrics predict therapeutic outcomes across modalities? - Can optimal SHA duration be calculated from \u0394NFR dynamics? - Are there individual differences in SHA capacity? - Does SHA training in one domain transfer to others?</p> <p>Theoretical Questions: - What is the computational cost of SHA? (\u03bdf \u2192 0 requires energy to maintain) - Are there fundamental limits to SHA duration before EPI drift? - Can SHA be \"stacked\" fractally (organizational pause contains departmental pauses)? - What is the relationship between SHA quality and subsequent transformation capacity (THOL/ZHIR)?</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#implementation-notes","title":"Implementation Notes","text":""},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#code-examples","title":"Code Examples","text":"<p>All protocols documented here are implemented as executable examples in: - <code>examples/biomedical/cardiac_coherence_sha.py</code> - <code>examples/biomedical/trauma_containment_sha.py</code> - <code>examples/biomedical/sleep_consolidation_sha.py</code> - <code>examples/biomedical/recovery_protocols_sha.py</code></p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#running-examples","title":"Running Examples","text":"<pre><code># Cardiac coherence protocol\npython examples/biomedical/cardiac_coherence_sha.py\n\n# Trauma containment protocol\npython examples/biomedical/trauma_containment_sha.py\n\n# Sleep consolidation protocol\npython examples/biomedical/sleep_consolidation_sha.py\n\n# Recovery protocol\npython examples/biomedical/recovery_protocols_sha.py\n</code></pre>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#telemetry-validation","title":"Telemetry Validation","text":"<p>Each example generates expected telemetry and validates against protocol specifications. Look for: - Preservation integrity assertions - Frequency suppression verification - Phase coherence checks - Duration tracking</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#glossary","title":"Glossary","text":"<p>EPI (Estructura Primaria de Informaci\u00f3n): Primary Information Structure - the coherent \"form\" or pattern of a node</p> <p>\u03bdf (Frecuencia estructural): Structural frequency - the rate of internal reorganization, measured in Hz_str</p> <p>\u0394NFR (Gradiente Nodal): Internal reorganization operator - the \"pressure\" driving structural change</p> <p>Phase (\u03c6, \u03b8): Relative synchrony with network neighbors</p> <p>C(t): Total coherence - global network stability measure</p> <p>Si (Sense Index): Reorganization stability capacity</p> <p>SHA (Silence): Structural operator that reduces \u03bdf to preserve EPI</p> <p>Hz_str: Structural hertz - units for \u03bdf, distinct from physical frequency</p>"},{"location":"examples/SHA_CLINICAL_APPLICATIONS/#conclusion","title":"Conclusion","text":"<p>SHA (Silence) is a powerful structural operator with applications across biomedical, clinical, cognitive, and organizational domains. The common thread is preservation through structural pause - reducing reorganization activity to consolidate patterns, protect identity, and enable better subsequent action.</p> <p>Key principles: - SHA contains pressure (\u0394NFR), doesn't resolve it - SHA preserves structure (EPI), doesn't freeze it permanently - SHA quality matters more than duration (low variance critical) - SHA requires appropriate entry (stabilization) and exit (transition) protocols</p> <p>This documentation provides the foundation for applying SHA in research, clinical practice, and strategic decision-making using TNFR's rigorous structural framework.</p>"},{"location":"examples/USE_CASES_GUIDE/","title":"TNFR Use Cases Guide","text":"<p>Home \u203a Examples \u203a Use Cases Guide</p> <p>This guide helps you understand when and how to apply TNFR to different domains and problems. It maps real-world scenarios to TNFR operators and patterns.</p>"},{"location":"examples/USE_CASES_GUIDE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Domain Selector</li> <li>Operator Selection Guide</li> <li>Common Application Patterns</li> <li>Domain-Specific Mappings</li> <li>Use Case Examples</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#quick-domain-selector","title":"Quick Domain Selector","text":"<p>Which domain are you working in?</p> Domain Best Starting Example Key Operators Typical Metrics Biology biological_coherence_example.py Emission, Reception, Coupling, Coherence C(t), Si, phase synchrony Social Systems social_network_dynamics.py Resonance, Dissonance, Mutation C(t), Si, opinion convergence AI/ML adaptive_ai_system.py SelfOrganization, Mutation, Coherence C(t), Si, learning trajectory Supply Chain supply_chain_resilience.py Mutation, Transition, Coupling C(t), resilience index Urban Systems urban_traffic_flow.py Transition, Coherence, Dissonance C(t), congestion index Physical Systems optical_cavity_feedback.py SelfOrganization, Mutation, Resonance C(t), Si, stability"},{"location":"examples/USE_CASES_GUIDE/#operator-selection-guide","title":"Operator Selection Guide","text":""},{"location":"examples/USE_CASES_GUIDE/#when-to-use-each-operator","title":"When to Use Each Operator","text":""},{"location":"examples/USE_CASES_GUIDE/#communication-interaction","title":"Communication &amp; Interaction","text":"<ul> <li>Emission (AL) - When nodes need to:</li> <li>Send signals/messages</li> <li>Broadcast information</li> <li>Initiate interaction</li> <li> <p>Example: Cells secreting hormones, servers broadcasting status</p> </li> <li> <p>Reception (EN) - When nodes need to:</p> </li> <li>Receive incoming signals</li> <li>Process information from neighbors</li> <li>Update internal state based on environment</li> <li>Example: Receptors binding ligands, sensors receiving data</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#stability-organization","title":"Stability &amp; Organization","text":"<ul> <li>Coherence (IL) - When you need to:</li> <li>Stabilize existing structures</li> <li>Reduce internal fluctuations</li> <li>Consolidate patterns</li> <li> <p>Example: Tissue organization, consensus building</p> </li> <li> <p>Coupling (UM) - When you need to:</p> </li> <li>Create functional links between nodes</li> <li>Establish dependencies</li> <li>Form channels or connections</li> <li>Example: Gap junctions, service dependencies, partnerships</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#pattern-propagation","title":"Pattern Propagation","text":"<ul> <li>Resonance (RA) - When you need to:</li> <li>Amplify synchronized patterns</li> <li>Spread coherent information</li> <li>Create network-wide effects</li> <li>Example: Viral content, synchronized firing, cascade effects</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#exploration-change","title":"Exploration &amp; Change","text":"<ul> <li>Dissonance (OZ) - When you need to:</li> <li>Introduce controlled instability</li> <li>Test system robustness</li> <li>Create variation for exploration</li> <li> <p>Example: Debate, stress testing, perturbations</p> </li> <li> <p>Mutation (ZHIR) - When you need to:</p> </li> <li>Allow phase/state changes</li> <li>Adapt to new conditions</li> <li>Reconfigure structure</li> <li>Example: Opinion shift, system reconfiguration, adaptation</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#advanced-patterns","title":"Advanced Patterns","text":"<ul> <li>SelfOrganization (THOL) - When you need to:</li> <li>Create emergent sub-structures</li> <li>Enable autonomous organization</li> <li>Form functional modules</li> <li> <p>Example: Organ formation, team clustering, module creation</p> </li> <li> <p>Transition (NAV) - When you need to:</p> </li> <li>Coordinate state changes</li> <li>Synchronize phase shifts</li> <li>Manage collective transitions</li> <li> <p>Example: Traffic light coordination, workflow stages</p> </li> <li> <p>Silence (SHA) - When you need to:</p> </li> <li>Pause evolution temporarily</li> <li>Create rest periods</li> <li>Observe without intervention</li> <li> <p>Example: Rest periods, observation windows, checkpoints</p> </li> <li> <p>Expansion (YIRA) &amp; Contraction (RU) - When you need to:</p> </li> <li>Grow or shrink structures</li> <li>Adjust system scale</li> <li>Modulate connectivity</li> <li> <p>Example: Network growth, resource allocation</p> </li> <li> <p>Recursivity (IZIKHINA) - When you need to:</p> </li> <li>Create nested structures</li> <li>Implement hierarchical organization</li> <li>Enable fractal patterns</li> <li>Example: Multi-scale systems, hierarchies</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#common-application-patterns","title":"Common Application Patterns","text":""},{"location":"examples/USE_CASES_GUIDE/#pattern-1-basic-activation-sequence","title":"Pattern 1: Basic Activation Sequence","text":"<p>Use when: Initializing or activating a network</p> <pre><code># Typical sequence\nEmission()       # Start broadcasting\nReception()      # Process incoming\nCoherence()      # Stabilize\nResonance()      # Amplify patterns\nSilence()        # Rest/observe\n</code></pre> <p>Applications: System startup, initial communication, baseline establishment</p>"},{"location":"examples/USE_CASES_GUIDE/#pattern-2-network-synchronization","title":"Pattern 2: Network Synchronization","text":"<p>Use when: Coordinating distributed nodes</p> <pre><code># Synchronization sequence\nEmission()\nReception()\nCoherence()\nCoupling()       # Strengthen connections\nResonance()      # Synchronize\nSilence()\n</code></pre> <p>Applications: Distributed systems, coordinated behavior, consensus protocols</p>"},{"location":"examples/USE_CASES_GUIDE/#pattern-3-adaptive-response","title":"Pattern 3: Adaptive Response","text":"<p>Use when: System needs to adapt to changes</p> <pre><code># Adaptation sequence\nEmission()\nReception()\nDissonance()     # Detect mismatch\nMutation()       # Adapt structure\nCoherence()      # Stabilize new state\nResonance()      # Consolidate\n</code></pre> <p>Applications: Learning, adaptation, recovery from disruptions</p>"},{"location":"examples/USE_CASES_GUIDE/#pattern-4-exploration-consolidation","title":"Pattern 4: Exploration &amp; Consolidation","text":"<p>Use when: Searching solution space then stabilizing</p> <pre><code># Creative exploration\nEmission()\nDissonance()     # Create variation\nMutation()       # Allow change\nSelfOrganization()  # Form new patterns\nCoherence()      # Stabilize discoveries\nResonance()      # Amplify good solutions\n</code></pre> <p>Applications: Optimization, creative problem-solving, innovation</p>"},{"location":"examples/USE_CASES_GUIDE/#pattern-5-stress-test-recovery","title":"Pattern 5: Stress Test &amp; Recovery","text":"<p>Use when: Testing resilience and recovery</p> <pre><code># Resilience testing\nCoherence()      # Establish baseline\nDissonance()     # Apply stress\nMutation()       # Allow adaptation\nCoherence()      # Recover stability\nResonance()      # Consolidate learned response\n</code></pre> <p>Applications: Fault tolerance, stress testing, robustness analysis</p>"},{"location":"examples/USE_CASES_GUIDE/#domain-specific-mappings","title":"Domain-Specific Mappings","text":""},{"location":"examples/USE_CASES_GUIDE/#biological-systems","title":"Biological Systems","text":"Biological Concept TNFR Element Cell Node (NFR) Chemical signal Emission operator Receptor binding Reception operator Gap junction Coupling operator Tissue organization Coherence C(t) Cell cycle Phase \u03c6 Metabolic rate Frequency \u03bdf Cell differentiation Mutation operator Organ formation SelfOrganization Homeostasis Coherence maintenance <p>Key Metrics: - <code>C(t)</code> = Tissue coherence/organization - <code>Si</code> = Cell adaptability/responsiveness - Phase synchrony = Coordinated behavior</p> <p>Example Applications: - Cell signaling networks - Tissue formation - Neural synchronization - Immune response coordination - Metabolic networks</p>"},{"location":"examples/USE_CASES_GUIDE/#social-systems","title":"Social Systems","text":"Social Concept TNFR Element Individual Node (NFR) Communication Emission/Reception Opinion Phase \u03c6 Influence rate Frequency \u03bdf Consensus Coherence C(t) Debate Dissonance operator Opinion change Mutation operator Community formation SelfOrganization Viral spread Resonance operator Group cohesion Coupling strength <p>Key Metrics: - <code>C(t)</code> = Group cohesion/consensus - <code>Si</code> = Individual adaptability - Phase distribution = Opinion diversity</p> <p>Example Applications: - Social network dynamics - Opinion formation - Information propagation - Community emergence - Polarization analysis - Consensus building</p>"},{"location":"examples/USE_CASES_GUIDE/#technology-systems","title":"Technology Systems","text":"Technical Concept TNFR Element Server/Service Node (NFR) Message passing Emission/Reception Request rate Frequency \u03bdf System state Phase \u03c6 Reliability Coherence C(t) Dependency Coupling operator Load balancing Resonance operator Failover Mutation operator Service discovery SelfOrganization Graceful degradation Silence operator <p>Key Metrics: - <code>C(t)</code> = System reliability/stability - <code>Si</code> = Service resilience - Phase synchrony = Coordination quality</p> <p>Example Applications: - Distributed systems - Microservices architecture - Network protocols - Load balancing - Fault tolerance - Service mesh</p>"},{"location":"examples/USE_CASES_GUIDE/#supply-chain-logistics","title":"Supply Chain &amp; Logistics","text":"Logistics Concept TNFR Element Facility (warehouse, factory) Node (NFR) Shipment Emission/Reception Throughput Frequency \u03bdf Inventory state Phase \u03c6 Supply chain stability Coherence C(t) Partnership Coupling operator Demand propagation Resonance operator Disruption response Mutation operator Network reconfiguration SelfOrganization Resilience Si <p>Key Metrics: - <code>C(t)</code> = Supply chain stability - <code>Si</code> = Facility adaptability/resilience - Phase alignment = Synchronized logistics</p> <p>Example Applications: - Supply chain optimization - Disruption response - Inventory management - Logistics coordination - Resilience analysis</p>"},{"location":"examples/USE_CASES_GUIDE/#urban-systems","title":"Urban Systems","text":"Urban Concept TNFR Element Intersection/Node Node (NFR) Traffic flow Emission/Reception Signal timing Phase \u03c6 Flow rate Frequency \u03bdf Traffic efficiency Coherence C(t) Road connection Coupling operator Congestion Dissonance operator Signal coordination Transition operator Grid optimization Resonance operator Adaptive signals Mutation operator <p>Key Metrics: - <code>C(t)</code> = Traffic flow efficiency - <code>Si</code> = Intersection adaptability - Dissonance level = Congestion</p> <p>Example Applications: - Traffic signal optimization - Congestion management - Public transport coordination - Emergency routing - Smart city systems</p>"},{"location":"examples/USE_CASES_GUIDE/#use-case-examples","title":"Use Case Examples","text":""},{"location":"examples/USE_CASES_GUIDE/#example-1-cell-communication-biological_coherence_examplepy","title":"Example 1: Cell Communication \u2192 biological_coherence_example.py","text":"<p>Problem: How do cells in a tissue coordinate their behavior?</p> <p>TNFR Approach: <pre><code># 1. Model cells as nodes\nnetwork.add_nodes(25, vf_range=(0.3, 0.9))  # Different metabolic rates\n\n# 2. Establish connections (gap junctions, paracrine signaling)\nnetwork.connect_nodes(0.5, 'ring')\n\n# 3. Simulate signaling cycles\napply_sequence([\n    Emission(),      # Secrete signals\n    Reception(),     # Detect signals\n    Coherence(),     # Coordinate response\n    Coupling(),      # Strengthen contacts\n    Resonance(),     # Amplify coordination\n    Silence()        # Rest period\n])\n</code></pre></p> <p>Key Insight: C(t) measures tissue organization quality. Higher coherence = better coordinated tissue.</p>"},{"location":"examples/USE_CASES_GUIDE/#example-2-social-opinion-dynamics-social_network_dynamicspy","title":"Example 2: Social Opinion Dynamics \u2192 social_network_dynamics.py","text":"<p>Problem: How do opinions spread and evolve in social networks?</p> <p>TNFR Approach: <pre><code># 1. Model individuals as nodes\nnetwork.add_nodes(30)  # Community members\n\n# 2. Create social connections\nnetwork.connect_nodes(0.25, 'random')\n\n# 3. Simulate discussion and opinion evolution\napply_sequence([\n    Emission(),      # Express opinions\n    Reception(),     # Listen to others\n    Dissonance(),    # Debate/conflict\n    Mutation(),      # Opinion shifts\n    Coherence(),     # Build consensus\n    Resonance()      # Spread agreement\n])\n</code></pre></p> <p>Key Insight: C(t) measures group consensus. Dissonance \u2192 Mutation \u2192 Coherence models opinion evolution.</p>"},{"location":"examples/USE_CASES_GUIDE/#example-3-adaptive-ai-adaptive_ai_systempy","title":"Example 3: Adaptive AI \u2192 adaptive_ai_system.py","text":"<p>Problem: Can learning happen through structural reorganization instead of gradient descent?</p> <p>TNFR Approach: <pre><code># 1. Start with unorganized agents\nnetwork.add_nodes(15)\nnetwork.connect_nodes(0.25, 'random')\n\n# 2. \"Train\" through structural operators\nfor epoch in range(training_epochs):\n    apply_sequence([\n        SelfOrganization(),  # Form functional modules\n        Mutation(),          # Explore variations\n        Coherence(),         # Consolidate patterns\n        Resonance()          # Amplify good patterns\n    ])\n</code></pre></p> <p>Key Insight: Learning = coherence increase. No backprop needed, just structural reorganization!</p>"},{"location":"examples/USE_CASES_GUIDE/#example-4-supply-chain-resilience-supply_chain_resiliencepy","title":"Example 4: Supply Chain Resilience \u2192 supply_chain_resilience.py","text":"<p>Problem: How can supply chains adapt to disruptions?</p> <p>TNFR Approach: <pre><code># 1. Model supply chain\nnetwork.add_nodes(20)  # Suppliers, warehouses, distributors\nnetwork.connect_nodes(0.3, 'small_world')\n\n# 2. Establish baseline\napply_sequence([Emission(), Reception(), Coherence()])\n\n# 3. Simulate disruption + recovery\napply_sequence([\n    Dissonance(),    # Disruption occurs\n    Mutation(),      # Adapt routes/suppliers\n    Coupling(),      # Form new partnerships\n    Coherence(),     # Stabilize new configuration\n    Resonance()      # Propagate recovery\n])\n</code></pre></p> <p>Key Insight: Si measures individual facility resilience. High Si = quick recovery from disruptions.</p>"},{"location":"examples/USE_CASES_GUIDE/#example-5-traffic-optimization-urban_traffic_flowpy","title":"Example 5: Traffic Optimization \u2192 urban_traffic_flow.py","text":"<p>Problem: How to minimize congestion in urban traffic grids?</p> <p>TNFR Approach: <pre><code># 1. Model intersections\nnetwork.add_nodes(9, vf_range=(0.6, 1.2))  # 3x3 grid\nnetwork.connect_nodes(topology='grid')\n\n# 2. Coordinate traffic signals\napply_sequence([\n    Emission(),      # Detect incoming traffic\n    Reception(),     # Process sensor data\n    Coherence(),     # Optimize timing\n    Transition(),    # Coordinate phase changes\n    Resonance()      # Propagate green waves\n])\n</code></pre></p> <p>Key Insight: Lower dissonance = less congestion. Transition operator coordinates signal timing.</p>"},{"location":"examples/USE_CASES_GUIDE/#how-to-choose-the-right-pattern","title":"How to Choose the Right Pattern","text":""},{"location":"examples/USE_CASES_GUIDE/#decision-tree","title":"Decision Tree","text":"<pre><code>START: What is your primary goal?\n\n\u251c\u2500 Establish communication\n\u2502  \u2514\u2500 Use: Emission + Reception + Coherence\n\u2502\n\u251c\u2500 Synchronize distributed nodes\n\u2502  \u2514\u2500 Use: Network Sync pattern (+ Coupling + Resonance)\n\u2502\n\u251c\u2500 Adapt to changes\n\u2502  \u2514\u2500 Use: Adaptive Response pattern (+ Dissonance + Mutation)\n\u2502\n\u251c\u2500 Explore solution space\n\u2502  \u2514\u2500 Use: Exploration pattern (+ Dissonance + SelfOrganization)\n\u2502\n\u251c\u2500 Test robustness\n\u2502  \u2514\u2500 Use: Stress Test pattern (+ Dissonance + recovery)\n\u2502\n\u2514\u2500 Build hierarchical structure\n   \u2514\u2500 Use: SelfOrganization + Recursivity\n</code></pre>"},{"location":"examples/USE_CASES_GUIDE/#metrics-interpretation-guide","title":"Metrics Interpretation Guide","text":""},{"location":"examples/USE_CASES_GUIDE/#coherence-ct","title":"Coherence C(t)","text":"<p>What it measures: Overall system stability and organization</p> <p>Interpretation: - <code>C(t) &gt; 0.7</code> = Highly organized, stable - <code>0.4 &lt; C(t) &lt; 0.7</code> = Moderately organized - <code>C(t) &lt; 0.4</code> = Loosely organized, unstable</p> <p>Use cases: - Tissue organization quality (biology) - Group consensus (social) - System reliability (technology) - Supply chain stability (logistics)</p>"},{"location":"examples/USE_CASES_GUIDE/#sense-index-si","title":"Sense Index Si","text":"<p>What it measures: Individual node's capacity for effective reorganization</p> <p>Interpretation: - <code>Si &gt; 0.6</code> = Highly adaptable - <code>0.3 &lt; Si &lt; 0.6</code> = Moderately responsive - <code>Si &lt; 0.3</code> = Rigid, low adaptability</p> <p>Use cases: - Cell responsiveness (biology) - Individual adaptability (social) - Service resilience (technology) - Facility flexibility (logistics)</p>"},{"location":"examples/USE_CASES_GUIDE/#phase","title":"Phase \u03c6","text":"<p>What it measures: Node's position in its cycle/state</p> <p>Interpretation: - Phase alignment (|\u03c6_i - \u03c6_j| \u2248 0) = Synchrony - Phase diversity = Functional specialization - Phase locking = Stable coordination</p> <p>Use cases: - Cell cycle position (biology) - Opinion alignment (social) - Operational state (technology) - Timing coordination (urban systems)</p>"},{"location":"examples/USE_CASES_GUIDE/#frequency-f-hz_str","title":"Frequency \u03bdf (Hz_str)","text":"<p>What it measures: Rate of structural reorganization</p> <p>Interpretation: - High \u03bdf = Fast dynamics - Low \u03bdf = Slow, stable evolution - Matched \u03bdf = Resonance potential</p> <p>Use cases: - Metabolic rate (biology) - Communication frequency (social) - Processing rate (technology) - Throughput (logistics)</p>"},{"location":"examples/USE_CASES_GUIDE/#common-pitfalls-solutions","title":"Common Pitfalls &amp; Solutions","text":""},{"location":"examples/USE_CASES_GUIDE/#pitfall-1-applying-operators-without-context","title":"Pitfall 1: Applying operators without context","text":"<p>\u274c Wrong: Randomly applying operators hoping for good results \u2705 Right: Choose operators based on system needs and desired outcomes</p>"},{"location":"examples/USE_CASES_GUIDE/#pitfall-2-ignoring-phase-synchrony","title":"Pitfall 2: Ignoring phase synchrony","text":"<p>\u274c Wrong: Coupling nodes without checking phase alignment \u2705 Right: Use Coherence before Coupling to ensure synchrony</p>"},{"location":"examples/USE_CASES_GUIDE/#pitfall-3-over-stabilization","title":"Pitfall 3: Over-stabilization","text":"<p>\u274c Wrong: Only using Coherence, never allowing exploration \u2705 Right: Balance stability (Coherence) with exploration (Dissonance/Mutation)</p>"},{"location":"examples/USE_CASES_GUIDE/#pitfall-4-wrong-operator-order","title":"Pitfall 4: Wrong operator order","text":"<p>\u274c Wrong: Resonance before establishing couplings \u2705 Right: Emission \u2192 Reception \u2192 Coherence \u2192 Coupling \u2192 Resonance</p>"},{"location":"examples/USE_CASES_GUIDE/#pitfall-5-misinterpreting-metrics","title":"Pitfall 5: Misinterpreting metrics","text":"<p>\u274c Wrong: Assuming high C(t) is always good \u2705 Right: Consider context - exploration phases need some instability</p>"},{"location":"examples/USE_CASES_GUIDE/#next-steps","title":"Next Steps","text":""},{"location":"examples/USE_CASES_GUIDE/#getting-started","title":"Getting Started","text":"<ol> <li>Choose a domain from the Domain Selector</li> <li>Study the relevant example to understand the mapping</li> <li>Adapt the pattern to your specific problem</li> <li>Run experiments and iterate</li> </ol>"},{"location":"examples/USE_CASES_GUIDE/#going-deeper","title":"Going Deeper","text":"<ul> <li>Read OPERATORS_GUIDE.md for operator details</li> <li>Study foundations.md for theoretical background</li> <li>Explore TNFR.pdf for complete paradigm explanation</li> <li>Check API Reference for implementation details</li> </ul>"},{"location":"examples/USE_CASES_GUIDE/#contributing-examples","title":"Contributing Examples","text":"<p>Have a new use case? See CONTRIBUTING.md for guidelines on adding examples.</p>"},{"location":"examples/USE_CASES_GUIDE/#see-also","title":"See Also","text":"<ul> <li>Examples README - All available examples</li> <li>Hello TNFR Tutorial - Getting started</li> <li>Operators Guide - Detailed operator reference</li> <li>API Documentation - Complete API</li> <li>AGENTS.md - Canonical invariants and rules</li> </ul> <p>Questions? Check the FAQ or open an issue on GitHub.</p>"},{"location":"examples/adaptive_ai_system/","title":"Adaptive ai system","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nTitle: Adaptive AI System - Self-Organizing Intelligence\n\nProblem: Traditional AI systems learn by minimizing error gradients through\nbackpropagation. Can we model learning as structural reorganization instead?\nHow do intelligent agents self-organize to solve tasks?\n\nTNFR Approach: Model AI agents as NFR nodes where:\n- EPI represents agent's knowledge/skill structure\n- \u03bdf (Hz_str) is learning rate (structural reorganization speed)\n- Phase represents coordination with environment/task\n- Learning = Structural reorganization through \u0394NFR, not gradient descent\n- Self-organization creates emergent problem-solving strategies\n- Coherence measures solution stability\n\nKey Operators:\n- SelfOrganization (THOL): Spontaneous strategy formation\n- Reception (EN): Gather environmental feedback\n- Emission (AL): Execute actions/strategies\n- Coherence (IL): Consolidate learned patterns\n- Expansion (VAL): Increase solution complexity\n- Mutation (ZHIR): Explore alternative strategies\n\nRelevant Metrics:\n- C(t): Solution coherence (strategy stability)\n- Si: Learning stability (resistance to catastrophic forgetting)\n- \u0394NFR: Learning pressure (environment mismatch)\n- \u2202EPI/\u2202t: Rate of knowledge acquisition\n\nExpected Behavior:\n- Initially random/unstructured agents (low EPI)\n- Self-organization creates problem-solving structures\n- Agents adapt through structural reorganization\n- Coherence increases as solutions stabilize\n- Final state shows organized, capable agents\n\nRun:\n    python docs/source/examples/adaptive_ai_system.py\n\"\"\"\n</pre> \"\"\" Title: Adaptive AI System - Self-Organizing Intelligence  Problem: Traditional AI systems learn by minimizing error gradients through backpropagation. Can we model learning as structural reorganization instead? How do intelligent agents self-organize to solve tasks?  TNFR Approach: Model AI agents as NFR nodes where: - EPI represents agent's knowledge/skill structure - \u03bdf (Hz_str) is learning rate (structural reorganization speed) - Phase represents coordination with environment/task - Learning = Structural reorganization through \u0394NFR, not gradient descent - Self-organization creates emergent problem-solving strategies - Coherence measures solution stability  Key Operators: - SelfOrganization (THOL): Spontaneous strategy formation - Reception (EN): Gather environmental feedback - Emission (AL): Execute actions/strategies - Coherence (IL): Consolidate learned patterns - Expansion (VAL): Increase solution complexity - Mutation (ZHIR): Explore alternative strategies  Relevant Metrics: - C(t): Solution coherence (strategy stability) - Si: Learning stability (resistance to catastrophic forgetting) - \u0394NFR: Learning pressure (environment mismatch) - \u2202EPI/\u2202t: Rate of knowledge acquisition  Expected Behavior: - Initially random/unstructured agents (low EPI) - Self-organization creates problem-solving structures - Agents adapt through structural reorganization - Coherence increases as solutions stabilize - Final state shows organized, capable agents  Run:     python docs/source/examples/adaptive_ai_system.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coherence,\n    Dissonance,\n    Emission,\n    Expansion,\n    Mutation,\n    Reception,\n    SelfOrganization,\n    Silence,\n)\nfrom tnfr.trace import register_trace\nfrom tnfr.constants import inject_defaults\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coherence,     Dissonance,     Emission,     Expansion,     Mutation,     Reception,     SelfOrganization,     Silence, ) from tnfr.trace import register_trace from tnfr.constants import inject_defaults In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Model AI learning as structural reorganization, not gradient descent.\"\"\"\n    \n    print(\"=\" * 70)\n    print(\"TNFR Adaptive AI: Self-Organizing Intelligence\")\n    print(\"=\" * 70)\n    print()\n    \n    # 1. PROBLEM SETUP: Creating a multi-agent AI system\n    # ---------------------------------------------------\n    # Scenario: 4 AI agents learning to solve a coordination task\n    # Task requires: perception, planning, execution, adaptation\n    \n    print(\"Phase 1: Initializing naive AI agents...\")\n    print(\"Creating 4 agents with minimal initial structure\")\n    print()\n    \n    # Perception Agent: Processes environmental input\n    G, _ = create_nfr(\n        \"PerceptionAgent\",\n        epi=0.12,    # Low initial structure (untrained)\n        vf=1.4,      # High learning rate (rapid reorganization)\n        theta=0.0    # Starting phase\n    )\n    \n    # Planning Agent: Develops strategies\n    create_nfr(\n        \"PlanningAgent\",\n        epi=0.10,    # Minimal structure\n        vf=1.3,      # High learning rate\n        theta=0.5,\n        graph=G\n    )\n    \n    # Execution Agent: Implements actions\n    create_nfr(\n        \"ExecutionAgent\",\n        epi=0.15,    # Slightly more structure (basic actions)\n        vf=1.2,\n        theta=-0.3,\n        graph=G\n    )\n    \n    # Adaptation Agent: Meta-learning, adjusts strategies\n    create_nfr(\n        \"AdaptationAgent\",\n        epi=0.08,    # Very low initial structure\n        vf=1.5,      # Highest learning rate\n        theta=0.8,\n        graph=G\n    )\n    \n    # Store agent metadata\n    agent_roles = {\n        \"PerceptionAgent\": \"Sensory processing &amp; pattern recognition\",\n        \"PlanningAgent\": \"Strategy formation &amp; decision making\",\n        \"ExecutionAgent\": \"Action execution &amp; motor control\",\n        \"AdaptationAgent\": \"Meta-learning &amp; strategy adaptation\",\n    }\n    \n    for agent, role in agent_roles.items():\n        G.nodes[agent][\"role\"] = role\n    \n    # Inject required defaults for graph parameters\n    inject_defaults(G)\n    \n    # Measure initial state (before learning)\n    C_initial, dnfr_initial, depi_initial = compute_coherence(G, return_means=True)\n    Si_initial = compute_Si(G)\n    \n    print(\"Initial system state (BEFORE learning):\")\n    print(f\"  C(t) = {C_initial:.3f} (solution coherence - expect low)\")\n    print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (learning pressure)\")\n    print(f\"  Mean \u2202EPI/\u2202t = {depi_initial:.3f} (knowledge acquisition rate)\")\n    print()\n    \n    # Handle Si_initial being either dict or array\n    if isinstance(Si_initial, dict):\n        avg_si_initial = sum(Si_initial.values()) / len(Si_initial)\n    else:\n        avg_si_initial = float(Si_initial.mean()) if hasattr(Si_initial, 'mean') else 0.0\n    print(f\"  Average Si = {avg_si_initial:.3f} (learning stability)\")\n    print()\n    \n    # 2. TNFR MODELING: Learning as structural reorganization\n    # --------------------------------------------------------\n    \n    print(\"Phase 2: Defining learning protocols (NOT gradient descent)...\")\n    print()\n    \n    # Perception learning: Pattern recognition through self-organization\n    perception_learning = [\n        Emission(),          # Must start with emission\n        Reception(),         # Gather sensory input\n        Coherence(),         # Stabilize\n        Expansion(),         # Add representational capacity\n        Coherence(),         # Consolidate learning\n        Silence(),\n    ]\n    \n    # Planning learning: Strategy formation through exploration\n    planning_learning = [\n        Emission(),          # Must start with emission\n        Reception(),         # Receive perception inputs\n        Coherence(),         # Stabilize before creating pressure\n        Dissonance(),        # Create exploration pressure\n        Mutation(),          # Explore strategy variants\n        Coherence(),         # Stabilize successful strategies\n        Expansion(),         # Increase strategy complexity\n        Silence(),\n    ]\n    \n    # Execution learning: Action refinement through practice\n    execution_learning = [\n        Emission(),          # Execute actions (must start with emission)\n        Reception(),         # Receive planning commands\n        Coherence(),         # Stabilize\n        Expansion(),         # Add action repertoire\n        Coherence(),         # Stabilize successful actions\n        Silence(),\n    ]\n    \n    # Adaptation learning: Meta-learning, adjust learning itself\n    adaptation_learning = [\n        Emission(),          # Must start with emission\n        Reception(),         # Monitor all agents\n        Coherence(),         # Stabilize before creating adaptive pressure\n        Dissonance(),        # Create adaptive pressure\n        Mutation(),          # Explore learning algorithms\n        Coherence(),         # Stabilize\n        Expansion(),         # Increase adaptation capacity\n        Silence(),\n    ]\n    \n    # 3. OPERATOR APPLICATION: Execute learning\n    # ------------------------------------------\n    \n    print(\"Phase 3: Training agents through structural reorganization...\")\n    print()\n    \n    print(\"Training PerceptionAgent (pattern recognition)...\")\n    run_sequence(G, \"PerceptionAgent\", perception_learning)\n    \n    print(\"Training PlanningAgent (strategy formation)...\")\n    run_sequence(G, \"PlanningAgent\", planning_learning)\n    \n    print(\"Training ExecutionAgent (action refinement)...\")\n    run_sequence(G, \"ExecutionAgent\", execution_learning)\n    \n    print(\"Training AdaptationAgent (meta-learning)...\")\n    run_sequence(G, \"AdaptationAgent\", adaptation_learning)\n    print()\n    \n    # 4. SIMULATION: Run learning dynamics\n    # -------------------------------------\n    \n    print(\"Phase 4: Simulating learning dynamics...\")\n    print(\"(Multiple learning cycles with environmental feedback)\")\n    print()\n    \n    register_metrics_callbacks(G)\n    register_trace(G)\n    \n    # Run for 15 time steps = ~15 learning iterations\n    run(G, steps=15, dt=0.1)\n    \n    # 5. RESULTS INTERPRETATION\n    # --------------------------\n    \n    print(\"=\" * 70)\n    print(\"RESULTS: Learning Outcome Analysis\")\n    print(\"=\" * 70)\n    print()\n    \n    # Compute final metrics (after learning)\n    C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)\n    Si_final = compute_Si(G)\n    \n    print(\"System-Level Metrics (AFTER learning):\")\n    print(f\"  C(t): {C_initial:.3f} \u2192 {C_final:.3f} (\u0394C = {C_final - C_initial:+.3f})\")\n    print(f\"  Mean \u0394NFR: {dnfr_initial:.3f} \u2192 {dnfr_final:.3f}\")\n    print(f\"  Mean \u2202EPI/\u2202t: {depi_initial:.3f} \u2192 {depi_final:.3f}\")\n    print()\n    \n    print(\"Per-Agent Learning Outcomes:\")\n    for agent in sorted(G.nodes()):\n        if isinstance(Si_initial, dict):\n            si_before = Si_initial.get(agent, 0.0)\n            si_after = Si_final.get(agent, 0.0) if isinstance(Si_final, dict) else 0.0\n        else:\n            si_before = 0.0\n            si_after = Si_final.get(agent, 0.0) if isinstance(Si_final, dict) else 0.0\n        si_change = si_after - si_before\n        role_short = agent_roles[agent].split()[0]\n        \n        print(f\"  {agent:20s}\")\n        print(f\"    Si: {si_before:.3f} \u2192 {si_after:.3f} ({si_change:+.3f})\")\n        print(f\"    Role: {role_short}\")\n    print()\n    \n    # AI/ML interpretation\n    print(\"=\" * 70)\n    print(\"AI/ML INTERPRETATION\")\n    print(\"=\" * 70)\n    print()\n    \n    # Learning success analysis\n    if C_final &gt; 0.6:\n        learning_outcome = \"SUCCESSFUL LEARNING\"\n        explanation = \"Agents developed coherent, stable solutions\"\n    elif C_final &gt; 0.4:\n        learning_outcome = \"MODERATE LEARNING\"\n        explanation = \"Some structure formed, but incomplete\"\n    elif C_final &gt; C_initial:\n        learning_outcome = \"EARLY LEARNING\"\n        explanation = \"Initial progress, needs more training\"\n    else:\n        learning_outcome = \"LEARNING FAILURE\"\n        explanation = \"No coherent solution structure emerged\"\n    \n    print(f\"1. Learning Outcome: {learning_outcome}\")\n    print(f\"   {explanation}\")\n    print()\n    \n    # Knowledge consolidation\n    if isinstance(Si_final, dict):\n        avg_si_final = sum(Si_final.values()) / len(Si_final)\n    else:\n        avg_si_final = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0\n    \n    if avg_si_final &gt; 0.7:\n        consolidation = \"STRONG - Knowledge well-consolidated\"\n    elif avg_si_final &gt; 0.4:\n        consolidation = \"MODERATE - Some forgetting risk\"\n    else:\n        consolidation = \"WEAK - High forgetting risk\"\n    \n    print(f\"2. Knowledge Consolidation: {consolidation}\")\n    print(f\"   Average Si: {avg_si_initial:.3f} \u2192 {avg_si_final:.3f}\")\n    print()\n    \n    # Learning efficiency\n    if abs(depi_final) &lt; abs(depi_initial):\n        efficiency = \"Learning has stabilized (good)\"\n    else:\n        efficiency = \"Still actively learning (needs more time)\"\n    \n    print(f\"3. Learning Efficiency: {efficiency}\")\n    print(f\"   \u2202EPI/\u2202t: {depi_initial:.3f} \u2192 {depi_final:.3f}\")\n    print()\n    \n    # Compare to traditional ML\n    print(\"=\" * 70)\n    print(\"TNFR vs. Traditional ML: Key Differences\")\n    print(\"=\" * 70)\n    print()\n    print(\"Traditional ML (Gradient Descent):\")\n    print(\"  \u2022 Loss function: Minimize prediction error\")\n    print(\"  \u2022 Learning: Iterative weight updates via backprop\")\n    print(\"  \u2022 Representation: Fixed architecture, learned weights\")\n    print(\"  \u2022 Adaptation: Requires retraining on new data\")\n    print()\n    print(\"TNFR Paradigm (Structural Reorganization):\")\n    print(\"  \u2022 Coherence function: Maximize C(t), minimize |\u0394NFR|\")\n    print(\"  \u2022 Learning: Structural reorganization via operators\")\n    print(\"  \u2022 Representation: EPI evolves dynamically, no fixed arch\")\n    print(\"  \u2022 Adaptation: Continuous via SelfOrganization operator\")\n    print()\n    print(\"=\" * 70)\n    print(\"Key TNFR Insights:\")\n    print(\"=\" * 70)\n    print(\"\u2022 Learning \u2260 gradient descent, it's STRUCTURAL REORGANIZATION\")\n    print(\"\u2022 Knowledge = EPI (information structure), not weights\")\n    print(\"\u2022 SelfOrganization operator = spontaneous strategy emergence\")\n    print(\"\u2022 No loss function needed - guided by \u0394NFR and coherence\")\n    print(\"\u2022 Catastrophic forgetting \u2192 monitored via Si (stability)\")\n    print(\"\u2022 Agents coordinate through phase alignment, not explicit comm\")\n    print()\n    print(\"Advantages of TNFR Learning:\")\n    print(\"  \u2713 No architecture search needed (structure self-organizes)\")\n    print(\"  \u2713 Continuous adaptation (no train/test separation)\")\n    print(\"  \u2713 Interpretable (operators trace learning process)\")\n    print(\"  \u2713 Forgetting resistance (high Si = stable knowledge)\")\n    print(\"=\" * 70)\n</pre> def run_example() -&gt; None:     \"\"\"Model AI learning as structural reorganization, not gradient descent.\"\"\"          print(\"=\" * 70)     print(\"TNFR Adaptive AI: Self-Organizing Intelligence\")     print(\"=\" * 70)     print()          # 1. PROBLEM SETUP: Creating a multi-agent AI system     # ---------------------------------------------------     # Scenario: 4 AI agents learning to solve a coordination task     # Task requires: perception, planning, execution, adaptation          print(\"Phase 1: Initializing naive AI agents...\")     print(\"Creating 4 agents with minimal initial structure\")     print()          # Perception Agent: Processes environmental input     G, _ = create_nfr(         \"PerceptionAgent\",         epi=0.12,    # Low initial structure (untrained)         vf=1.4,      # High learning rate (rapid reorganization)         theta=0.0    # Starting phase     )          # Planning Agent: Develops strategies     create_nfr(         \"PlanningAgent\",         epi=0.10,    # Minimal structure         vf=1.3,      # High learning rate         theta=0.5,         graph=G     )          # Execution Agent: Implements actions     create_nfr(         \"ExecutionAgent\",         epi=0.15,    # Slightly more structure (basic actions)         vf=1.2,         theta=-0.3,         graph=G     )          # Adaptation Agent: Meta-learning, adjusts strategies     create_nfr(         \"AdaptationAgent\",         epi=0.08,    # Very low initial structure         vf=1.5,      # Highest learning rate         theta=0.8,         graph=G     )          # Store agent metadata     agent_roles = {         \"PerceptionAgent\": \"Sensory processing &amp; pattern recognition\",         \"PlanningAgent\": \"Strategy formation &amp; decision making\",         \"ExecutionAgent\": \"Action execution &amp; motor control\",         \"AdaptationAgent\": \"Meta-learning &amp; strategy adaptation\",     }          for agent, role in agent_roles.items():         G.nodes[agent][\"role\"] = role          # Inject required defaults for graph parameters     inject_defaults(G)          # Measure initial state (before learning)     C_initial, dnfr_initial, depi_initial = compute_coherence(G, return_means=True)     Si_initial = compute_Si(G)          print(\"Initial system state (BEFORE learning):\")     print(f\"  C(t) = {C_initial:.3f} (solution coherence - expect low)\")     print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (learning pressure)\")     print(f\"  Mean \u2202EPI/\u2202t = {depi_initial:.3f} (knowledge acquisition rate)\")     print()          # Handle Si_initial being either dict or array     if isinstance(Si_initial, dict):         avg_si_initial = sum(Si_initial.values()) / len(Si_initial)     else:         avg_si_initial = float(Si_initial.mean()) if hasattr(Si_initial, 'mean') else 0.0     print(f\"  Average Si = {avg_si_initial:.3f} (learning stability)\")     print()          # 2. TNFR MODELING: Learning as structural reorganization     # --------------------------------------------------------          print(\"Phase 2: Defining learning protocols (NOT gradient descent)...\")     print()          # Perception learning: Pattern recognition through self-organization     perception_learning = [         Emission(),          # Must start with emission         Reception(),         # Gather sensory input         Coherence(),         # Stabilize         Expansion(),         # Add representational capacity         Coherence(),         # Consolidate learning         Silence(),     ]          # Planning learning: Strategy formation through exploration     planning_learning = [         Emission(),          # Must start with emission         Reception(),         # Receive perception inputs         Coherence(),         # Stabilize before creating pressure         Dissonance(),        # Create exploration pressure         Mutation(),          # Explore strategy variants         Coherence(),         # Stabilize successful strategies         Expansion(),         # Increase strategy complexity         Silence(),     ]          # Execution learning: Action refinement through practice     execution_learning = [         Emission(),          # Execute actions (must start with emission)         Reception(),         # Receive planning commands         Coherence(),         # Stabilize         Expansion(),         # Add action repertoire         Coherence(),         # Stabilize successful actions         Silence(),     ]          # Adaptation learning: Meta-learning, adjust learning itself     adaptation_learning = [         Emission(),          # Must start with emission         Reception(),         # Monitor all agents         Coherence(),         # Stabilize before creating adaptive pressure         Dissonance(),        # Create adaptive pressure         Mutation(),          # Explore learning algorithms         Coherence(),         # Stabilize         Expansion(),         # Increase adaptation capacity         Silence(),     ]          # 3. OPERATOR APPLICATION: Execute learning     # ------------------------------------------          print(\"Phase 3: Training agents through structural reorganization...\")     print()          print(\"Training PerceptionAgent (pattern recognition)...\")     run_sequence(G, \"PerceptionAgent\", perception_learning)          print(\"Training PlanningAgent (strategy formation)...\")     run_sequence(G, \"PlanningAgent\", planning_learning)          print(\"Training ExecutionAgent (action refinement)...\")     run_sequence(G, \"ExecutionAgent\", execution_learning)          print(\"Training AdaptationAgent (meta-learning)...\")     run_sequence(G, \"AdaptationAgent\", adaptation_learning)     print()          # 4. SIMULATION: Run learning dynamics     # -------------------------------------          print(\"Phase 4: Simulating learning dynamics...\")     print(\"(Multiple learning cycles with environmental feedback)\")     print()          register_metrics_callbacks(G)     register_trace(G)          # Run for 15 time steps = ~15 learning iterations     run(G, steps=15, dt=0.1)          # 5. RESULTS INTERPRETATION     # --------------------------          print(\"=\" * 70)     print(\"RESULTS: Learning Outcome Analysis\")     print(\"=\" * 70)     print()          # Compute final metrics (after learning)     C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)     Si_final = compute_Si(G)          print(\"System-Level Metrics (AFTER learning):\")     print(f\"  C(t): {C_initial:.3f} \u2192 {C_final:.3f} (\u0394C = {C_final - C_initial:+.3f})\")     print(f\"  Mean \u0394NFR: {dnfr_initial:.3f} \u2192 {dnfr_final:.3f}\")     print(f\"  Mean \u2202EPI/\u2202t: {depi_initial:.3f} \u2192 {depi_final:.3f}\")     print()          print(\"Per-Agent Learning Outcomes:\")     for agent in sorted(G.nodes()):         if isinstance(Si_initial, dict):             si_before = Si_initial.get(agent, 0.0)             si_after = Si_final.get(agent, 0.0) if isinstance(Si_final, dict) else 0.0         else:             si_before = 0.0             si_after = Si_final.get(agent, 0.0) if isinstance(Si_final, dict) else 0.0         si_change = si_after - si_before         role_short = agent_roles[agent].split()[0]                  print(f\"  {agent:20s}\")         print(f\"    Si: {si_before:.3f} \u2192 {si_after:.3f} ({si_change:+.3f})\")         print(f\"    Role: {role_short}\")     print()          # AI/ML interpretation     print(\"=\" * 70)     print(\"AI/ML INTERPRETATION\")     print(\"=\" * 70)     print()          # Learning success analysis     if C_final &gt; 0.6:         learning_outcome = \"SUCCESSFUL LEARNING\"         explanation = \"Agents developed coherent, stable solutions\"     elif C_final &gt; 0.4:         learning_outcome = \"MODERATE LEARNING\"         explanation = \"Some structure formed, but incomplete\"     elif C_final &gt; C_initial:         learning_outcome = \"EARLY LEARNING\"         explanation = \"Initial progress, needs more training\"     else:         learning_outcome = \"LEARNING FAILURE\"         explanation = \"No coherent solution structure emerged\"          print(f\"1. Learning Outcome: {learning_outcome}\")     print(f\"   {explanation}\")     print()          # Knowledge consolidation     if isinstance(Si_final, dict):         avg_si_final = sum(Si_final.values()) / len(Si_final)     else:         avg_si_final = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0          if avg_si_final &gt; 0.7:         consolidation = \"STRONG - Knowledge well-consolidated\"     elif avg_si_final &gt; 0.4:         consolidation = \"MODERATE - Some forgetting risk\"     else:         consolidation = \"WEAK - High forgetting risk\"          print(f\"2. Knowledge Consolidation: {consolidation}\")     print(f\"   Average Si: {avg_si_initial:.3f} \u2192 {avg_si_final:.3f}\")     print()          # Learning efficiency     if abs(depi_final) &lt; abs(depi_initial):         efficiency = \"Learning has stabilized (good)\"     else:         efficiency = \"Still actively learning (needs more time)\"          print(f\"3. Learning Efficiency: {efficiency}\")     print(f\"   \u2202EPI/\u2202t: {depi_initial:.3f} \u2192 {depi_final:.3f}\")     print()          # Compare to traditional ML     print(\"=\" * 70)     print(\"TNFR vs. Traditional ML: Key Differences\")     print(\"=\" * 70)     print()     print(\"Traditional ML (Gradient Descent):\")     print(\"  \u2022 Loss function: Minimize prediction error\")     print(\"  \u2022 Learning: Iterative weight updates via backprop\")     print(\"  \u2022 Representation: Fixed architecture, learned weights\")     print(\"  \u2022 Adaptation: Requires retraining on new data\")     print()     print(\"TNFR Paradigm (Structural Reorganization):\")     print(\"  \u2022 Coherence function: Maximize C(t), minimize |\u0394NFR|\")     print(\"  \u2022 Learning: Structural reorganization via operators\")     print(\"  \u2022 Representation: EPI evolves dynamically, no fixed arch\")     print(\"  \u2022 Adaptation: Continuous via SelfOrganization operator\")     print()     print(\"=\" * 70)     print(\"Key TNFR Insights:\")     print(\"=\" * 70)     print(\"\u2022 Learning \u2260 gradient descent, it's STRUCTURAL REORGANIZATION\")     print(\"\u2022 Knowledge = EPI (information structure), not weights\")     print(\"\u2022 SelfOrganization operator = spontaneous strategy emergence\")     print(\"\u2022 No loss function needed - guided by \u0394NFR and coherence\")     print(\"\u2022 Catastrophic forgetting \u2192 monitored via Si (stability)\")     print(\"\u2022 Agents coordinate through phase alignment, not explicit comm\")     print()     print(\"Advantages of TNFR Learning:\")     print(\"  \u2713 No architecture search needed (structure self-organizes)\")     print(\"  \u2713 Continuous adaptation (no train/test separation)\")     print(\"  \u2713 Interpretable (operators trace learning process)\")     print(\"  \u2713 Forgetting resistance (high Si = stable knowledge)\")     print(\"=\" * 70) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/biological_coherence_example/","title":"Biological coherence example","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nTitle: Biological Coherence - Cell Communication Modeling\n\nProblem: Cells in tissues coordinate their responses through signaling molecules\n(hormones, cytokines, neurotransmitters) and direct contact (gap junctions).\nHow do individual cells organize into coherent tissues that respond adaptively\nto environmental signals?\n\nTNFR Approach: Model cells as NFR nodes where:\n- EPI represents cellular state (metabolic profile, gene expression)\n- \u03bdf (Hz_str) is the rate of cellular response/adaptation\n- Phase synchronization represents coordinated cellular behavior\n- Emission/Reception model chemical signaling\n- Coupling models gap junctions and contact-dependent signaling\n- Coherence represents tissue organization\n\nKey Operators:\n- Emission (AL): Cell secretes signaling molecules\n- Reception (EN): Cell detects and responds to signals\n- Coupling (UM): Gap junction formation, direct cell-cell contact\n- Coherence (IL): Tissue organization and homeostasis\n- Resonance (RA): Signal amplification, coordinated response\n\nRelevant Metrics:\n- C(t): Tissue coherence (how well cells coordinate)\n- Si: Individual cell stability (resistance to perturbation)\n- Phase coherence: Synchronization of cellular rhythms\n- \u0394NFR: Cellular stress/adaptation pressure\n\nExpected Behavior:\n- Initially scattered cells establish communication\n- Phase synchronization emerges through signaling\n- Tissue coherence increases as cells coordinate\n- Final state shows stable, organized tissue structure\n\nRun:\n    python docs/source/examples/biological_coherence_example.py\n\"\"\"\n</pre> \"\"\" Title: Biological Coherence - Cell Communication Modeling  Problem: Cells in tissues coordinate their responses through signaling molecules (hormones, cytokines, neurotransmitters) and direct contact (gap junctions). How do individual cells organize into coherent tissues that respond adaptively to environmental signals?  TNFR Approach: Model cells as NFR nodes where: - EPI represents cellular state (metabolic profile, gene expression) - \u03bdf (Hz_str) is the rate of cellular response/adaptation - Phase synchronization represents coordinated cellular behavior - Emission/Reception model chemical signaling - Coupling models gap junctions and contact-dependent signaling - Coherence represents tissue organization  Key Operators: - Emission (AL): Cell secretes signaling molecules - Reception (EN): Cell detects and responds to signals - Coupling (UM): Gap junction formation, direct cell-cell contact - Coherence (IL): Tissue organization and homeostasis - Resonance (RA): Signal amplification, coordinated response  Relevant Metrics: - C(t): Tissue coherence (how well cells coordinate) - Si: Individual cell stability (resistance to perturbation) - Phase coherence: Synchronization of cellular rhythms - \u0394NFR: Cellular stress/adaptation pressure  Expected Behavior: - Initially scattered cells establish communication - Phase synchronization emerges through signaling - Tissue coherence increases as cells coordinate - Final state shows stable, organized tissue structure  Run:     python docs/source/examples/biological_coherence_example.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coupling,\n    Coherence,\n    Emission,\n    Reception,\n    Resonance,\n    Silence,\n)\nfrom tnfr.trace import register_trace\nfrom tnfr.constants import inject_defaults\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coupling,     Coherence,     Emission,     Reception,     Resonance,     Silence, ) from tnfr.trace import register_trace from tnfr.constants import inject_defaults In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Model tissue formation through cellular communication and coordination.\"\"\"\n    \n    print(\"=\" * 70)\n    print(\"TNFR Biological Coherence: Cell Communication Modeling\")\n    print(\"=\" * 70)\n    print()\n    \n    # 1. PROBLEM SETUP: Creating a tissue with 6 cells\n    # ---------------------------------------------------\n    # We model a small tissue patch with different cell types:\n    # - 2 Signaling cells (high emission capacity)\n    # - 2 Responding cells (high reception sensitivity)\n    # - 2 Coordinator cells (balance emission/reception)\n    \n    print(\"Phase 1: Initializing cellular network...\")\n    print(\"Creating 6 cells with different communication profiles\")\n    print()\n    \n    # Signaling cell 1: High \u03bdf (fast response), initiates communication\n    G, _ = create_nfr(\n        \"SignalCell_1\",\n        epi=0.35,  # Active metabolic state\n        vf=1.2,    # Fast adaptation (1.2 Hz_str)\n        theta=0.0  # Starting phase\n    )\n    \n    # Signaling cell 2: Similar profile, slightly different phase\n    create_nfr(\n        \"SignalCell_2\",\n        epi=0.33,\n        vf=1.15,\n        theta=0.3,  # Slightly out of phase initially\n        graph=G\n    )\n    \n    # Responding cells: Moderate \u03bdf, receptive to signals\n    create_nfr(\n        \"ResponseCell_1\",\n        epi=0.20,  # Lower baseline activity\n        vf=0.9,    # Moderate adaptation rate\n        theta=-0.4,\n        graph=G\n    )\n    \n    create_nfr(\n        \"ResponseCell_2\",\n        epi=0.22,\n        vf=0.95,\n        theta=0.6,\n        graph=G\n    )\n    \n    # Coordinator cells: Balanced profile, help integrate signals\n    create_nfr(\n        \"CoordCell_1\",\n        epi=0.28,\n        vf=1.0,\n        theta=-0.2,\n        graph=G\n    )\n    \n    create_nfr(\n        \"CoordCell_2\",\n        epi=0.26,\n        vf=1.05,\n        theta=0.5,\n        graph=G\n    )\n    \n    # Store biological metadata\n    cell_types = {\n        \"SignalCell_1\": \"Hormone-secreting endocrine cell\",\n        \"SignalCell_2\": \"Hormone-secreting endocrine cell\",\n        \"ResponseCell_1\": \"Target cell with hormone receptors\",\n        \"ResponseCell_2\": \"Target cell with hormone receptors\",\n        \"CoordCell_1\": \"Intermediate cell (signal + response)\",\n        \"CoordCell_2\": \"Intermediate cell (signal + response)\",\n    }\n    \n    for node, cell_type in cell_types.items():\n        G.nodes[node][\"cell_type\"] = cell_type\n    \n    # Inject required defaults for graph parameters\n    inject_defaults(G)\n    \n    # Measure initial state\n    C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)\n    print(f\"Initial tissue state:\")\n    print(f\"  C(t) = {C_initial:.3f} (tissue coherence - should be low)\")\n    print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (cellular stress)\")\n    print()\n    \n    # 2. TNFR MODELING: Define cellular behaviors\n    # ---------------------------------------------\n    # Each cell type follows a different operator sequence based on its role\n    \n    print(\"Phase 2: Establishing cellular communication protocols...\")\n    print()\n    \n    # Signaling cells: Strong emission, establish connections\n    signaling_protocol = [\n        Emission(),      # Secrete signaling molecules\n        Reception(),     # Also receive feedback from neighbors\n        Coherence(),     # Stabilize secretion pattern\n        Resonance(),     # Amplify coordinated signals\n        Coupling(),      # Form gap junctions with neighbors\n        Silence(),       # Brief pause to allow signal propagation\n    ]\n    \n    # Response cells: Primarily receptive, integrate signals\n    response_protocol = [\n        Emission(),      # Send signals (must start with emission)\n        Reception(),     # Detect signaling molecules from neighbors\n        Coherence(),     # Stabilize response pattern\n        Resonance(),     # Participate in coordinated response\n        Coupling(),      # Form connections with signalers\n        Silence(),\n    ]\n    \n    # Coordinator cells: Balance emission and reception\n    coordinator_protocol = [\n        Emission(),      # Relay signals\n        Reception(),     # Integrate multiple inputs\n        Coherence(),     # Maintain balanced state\n        Resonance(),     # Facilitate tissue-wide coordination\n        Coupling(),      # Connect multiple cell types\n        Coherence(),     # Re-stabilize after coordination\n        Silence(),\n    ]\n    \n    # 3. OPERATOR APPLICATION: Execute cellular behaviors\n    # ----------------------------------------------------\n    \n    print(\"Applying signaling protocol to SignalCell_1 and SignalCell_2...\")\n    run_sequence(G, \"SignalCell_1\", signaling_protocol)\n    run_sequence(G, \"SignalCell_2\", signaling_protocol)\n    \n    print(\"Applying response protocol to ResponseCell_1 and ResponseCell_2...\")\n    run_sequence(G, \"ResponseCell_1\", response_protocol)\n    run_sequence(G, \"ResponseCell_2\", response_protocol)\n    \n    print(\"Applying coordinator protocol to CoordCell_1 and CoordCell_2...\")\n    run_sequence(G, \"CoordCell_1\", coordinator_protocol)\n    run_sequence(G, \"CoordCell_2\", coordinator_protocol)\n    print()\n    \n    # 4. SIMULATION: Run tissue dynamics\n    # ------------------------------------\n    \n    print(\"Phase 3: Simulating tissue dynamics over time...\")\n    print()\n    \n    # Register metrics collection\n    register_metrics_callbacks(G)\n    register_trace(G)\n    \n    # Run dynamics: cells communicate and synchronize\n    # 10 steps = ~10 cellular response cycles\n    run(G, steps=10, dt=0.1)  # dt=0.1 represents ~100ms time resolution\n    \n    # 5. RESULTS INTERPRETATION\n    # --------------------------\n    \n    print(\"=\" * 70)\n    print(\"RESULTS: Tissue Organization Analysis\")\n    print(\"=\" * 70)\n    print()\n    \n    # Compute final metrics\n    C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)\n    Si_values = compute_Si(G)\n    \n    print(\"Tissue-Level Metrics:\")\n    print(f\"  C(t) = {C_final:.3f} (final tissue coherence)\")\n    print(f\"  \u0394C = {C_final - C_initial:+.3f} (change from initial state)\")\n    print(f\"  Mean \u0394NFR = {dnfr_final:.3f} (residual cellular stress)\")\n    print(f\"  Mean \u2202EPI/\u2202t = {depi_final:.3f} (rate of structural change)\")\n    print()\n    \n    print(\"Cellular Stability (Sense Index):\")\n    if isinstance(Si_values, dict):\n        for cell_name, si_value in sorted(Si_values.items()):\n            cell_type_short = cell_types[cell_name].split()[0]\n            print(f\"  {cell_name:20s} Si = {si_value:.3f}  ({cell_type_short})\")\n    else:\n        # Handle array return type\n        for idx, cell_name in enumerate(sorted(G.nodes())):\n            si_value = float(Si_values[idx]) if hasattr(Si_values, '__getitem__') else 0.0\n            cell_type_short = cell_types[cell_name].split()[0]\n            print(f\"  {cell_name:20s} Si = {si_value:.3f}  ({cell_type_short})\")\n    print()\n    \n    # Biological interpretation\n    print(\"=\" * 70)\n    print(\"BIOLOGICAL INTERPRETATION\")\n    print(\"=\" * 70)\n    print()\n    \n    if C_final &gt; 0.6:\n        coherence_status = \"HIGH - Tissue is well-organized\"\n    elif C_final &gt; 0.4:\n        coherence_status = \"MODERATE - Tissue is forming but not fully organized\"\n    else:\n        coherence_status = \"LOW - Cells remain largely uncoordinated\"\n    \n    print(f\"1. Tissue Coherence: {coherence_status}\")\n    print(f\"   Initial C(t) = {C_initial:.3f} \u2192 Final C(t) = {C_final:.3f}\")\n    print()\n    \n    if isinstance(Si_values, dict):\n        avg_si = sum(Si_values.values()) / len(Si_values)\n    else:\n        avg_si = float(Si_values.mean()) if hasattr(Si_values, 'mean') else 0.0\n    \n    if avg_si &gt; 0.7:\n        stability_status = \"STABLE - Cells resist perturbation\"\n    elif avg_si &gt; 0.4:\n        stability_status = \"MODERATE - Some vulnerability to stress\"\n    else:\n        stability_status = \"UNSTABLE - Cells easily perturbed\"\n    \n    print(f\"2. Cellular Stability: {stability_status}\")\n    print(f\"   Average Si = {avg_si:.3f}\")\n    print()\n    \n    if C_final &gt; C_initial:\n        print(\"3. Outcome: \u2713 SUCCESSFUL TISSUE FORMATION\")\n        print(\"   - Cells established communication channels\")\n        print(\"   - Phase synchronization emerged\")\n        print(\"   - Coordinated tissue behavior achieved\")\n    else:\n        print(\"3. Outcome: \u26a0 LIMITED TISSUE ORGANIZATION\")\n        print(\"   - Communication was established but weak\")\n        print(\"   - Further coupling may be needed\")\n    print()\n    \n    print(\"=\" * 70)\n    print(\"Key TNFR Insights:\")\n    print(\"=\" * 70)\n    print(\"\u2022 Cells = NFR nodes with EPI (state), \u03bdf (adaptation rate), \u03b8 (phase)\")\n    print(\"\u2022 Signaling = Emission operator (AL) propagates structural information\")\n    print(\"\u2022 Reception = Integration of external structural patterns\")\n    print(\"\u2022 Gap junctions = Coupling operator (UM) enables direct synchrony\")\n    print(\"\u2022 Tissue coherence = Emergent property from cellular phase alignment\")\n    print(\"\u2022 C(t) metric = Quantitative measure of tissue organization\")\n    print(\"=\" * 70)\n</pre> def run_example() -&gt; None:     \"\"\"Model tissue formation through cellular communication and coordination.\"\"\"          print(\"=\" * 70)     print(\"TNFR Biological Coherence: Cell Communication Modeling\")     print(\"=\" * 70)     print()          # 1. PROBLEM SETUP: Creating a tissue with 6 cells     # ---------------------------------------------------     # We model a small tissue patch with different cell types:     # - 2 Signaling cells (high emission capacity)     # - 2 Responding cells (high reception sensitivity)     # - 2 Coordinator cells (balance emission/reception)          print(\"Phase 1: Initializing cellular network...\")     print(\"Creating 6 cells with different communication profiles\")     print()          # Signaling cell 1: High \u03bdf (fast response), initiates communication     G, _ = create_nfr(         \"SignalCell_1\",         epi=0.35,  # Active metabolic state         vf=1.2,    # Fast adaptation (1.2 Hz_str)         theta=0.0  # Starting phase     )          # Signaling cell 2: Similar profile, slightly different phase     create_nfr(         \"SignalCell_2\",         epi=0.33,         vf=1.15,         theta=0.3,  # Slightly out of phase initially         graph=G     )          # Responding cells: Moderate \u03bdf, receptive to signals     create_nfr(         \"ResponseCell_1\",         epi=0.20,  # Lower baseline activity         vf=0.9,    # Moderate adaptation rate         theta=-0.4,         graph=G     )          create_nfr(         \"ResponseCell_2\",         epi=0.22,         vf=0.95,         theta=0.6,         graph=G     )          # Coordinator cells: Balanced profile, help integrate signals     create_nfr(         \"CoordCell_1\",         epi=0.28,         vf=1.0,         theta=-0.2,         graph=G     )          create_nfr(         \"CoordCell_2\",         epi=0.26,         vf=1.05,         theta=0.5,         graph=G     )          # Store biological metadata     cell_types = {         \"SignalCell_1\": \"Hormone-secreting endocrine cell\",         \"SignalCell_2\": \"Hormone-secreting endocrine cell\",         \"ResponseCell_1\": \"Target cell with hormone receptors\",         \"ResponseCell_2\": \"Target cell with hormone receptors\",         \"CoordCell_1\": \"Intermediate cell (signal + response)\",         \"CoordCell_2\": \"Intermediate cell (signal + response)\",     }          for node, cell_type in cell_types.items():         G.nodes[node][\"cell_type\"] = cell_type          # Inject required defaults for graph parameters     inject_defaults(G)          # Measure initial state     C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)     print(f\"Initial tissue state:\")     print(f\"  C(t) = {C_initial:.3f} (tissue coherence - should be low)\")     print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (cellular stress)\")     print()          # 2. TNFR MODELING: Define cellular behaviors     # ---------------------------------------------     # Each cell type follows a different operator sequence based on its role          print(\"Phase 2: Establishing cellular communication protocols...\")     print()          # Signaling cells: Strong emission, establish connections     signaling_protocol = [         Emission(),      # Secrete signaling molecules         Reception(),     # Also receive feedback from neighbors         Coherence(),     # Stabilize secretion pattern         Resonance(),     # Amplify coordinated signals         Coupling(),      # Form gap junctions with neighbors         Silence(),       # Brief pause to allow signal propagation     ]          # Response cells: Primarily receptive, integrate signals     response_protocol = [         Emission(),      # Send signals (must start with emission)         Reception(),     # Detect signaling molecules from neighbors         Coherence(),     # Stabilize response pattern         Resonance(),     # Participate in coordinated response         Coupling(),      # Form connections with signalers         Silence(),     ]          # Coordinator cells: Balance emission and reception     coordinator_protocol = [         Emission(),      # Relay signals         Reception(),     # Integrate multiple inputs         Coherence(),     # Maintain balanced state         Resonance(),     # Facilitate tissue-wide coordination         Coupling(),      # Connect multiple cell types         Coherence(),     # Re-stabilize after coordination         Silence(),     ]          # 3. OPERATOR APPLICATION: Execute cellular behaviors     # ----------------------------------------------------          print(\"Applying signaling protocol to SignalCell_1 and SignalCell_2...\")     run_sequence(G, \"SignalCell_1\", signaling_protocol)     run_sequence(G, \"SignalCell_2\", signaling_protocol)          print(\"Applying response protocol to ResponseCell_1 and ResponseCell_2...\")     run_sequence(G, \"ResponseCell_1\", response_protocol)     run_sequence(G, \"ResponseCell_2\", response_protocol)          print(\"Applying coordinator protocol to CoordCell_1 and CoordCell_2...\")     run_sequence(G, \"CoordCell_1\", coordinator_protocol)     run_sequence(G, \"CoordCell_2\", coordinator_protocol)     print()          # 4. SIMULATION: Run tissue dynamics     # ------------------------------------          print(\"Phase 3: Simulating tissue dynamics over time...\")     print()          # Register metrics collection     register_metrics_callbacks(G)     register_trace(G)          # Run dynamics: cells communicate and synchronize     # 10 steps = ~10 cellular response cycles     run(G, steps=10, dt=0.1)  # dt=0.1 represents ~100ms time resolution          # 5. RESULTS INTERPRETATION     # --------------------------          print(\"=\" * 70)     print(\"RESULTS: Tissue Organization Analysis\")     print(\"=\" * 70)     print()          # Compute final metrics     C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)     Si_values = compute_Si(G)          print(\"Tissue-Level Metrics:\")     print(f\"  C(t) = {C_final:.3f} (final tissue coherence)\")     print(f\"  \u0394C = {C_final - C_initial:+.3f} (change from initial state)\")     print(f\"  Mean \u0394NFR = {dnfr_final:.3f} (residual cellular stress)\")     print(f\"  Mean \u2202EPI/\u2202t = {depi_final:.3f} (rate of structural change)\")     print()          print(\"Cellular Stability (Sense Index):\")     if isinstance(Si_values, dict):         for cell_name, si_value in sorted(Si_values.items()):             cell_type_short = cell_types[cell_name].split()[0]             print(f\"  {cell_name:20s} Si = {si_value:.3f}  ({cell_type_short})\")     else:         # Handle array return type         for idx, cell_name in enumerate(sorted(G.nodes())):             si_value = float(Si_values[idx]) if hasattr(Si_values, '__getitem__') else 0.0             cell_type_short = cell_types[cell_name].split()[0]             print(f\"  {cell_name:20s} Si = {si_value:.3f}  ({cell_type_short})\")     print()          # Biological interpretation     print(\"=\" * 70)     print(\"BIOLOGICAL INTERPRETATION\")     print(\"=\" * 70)     print()          if C_final &gt; 0.6:         coherence_status = \"HIGH - Tissue is well-organized\"     elif C_final &gt; 0.4:         coherence_status = \"MODERATE - Tissue is forming but not fully organized\"     else:         coherence_status = \"LOW - Cells remain largely uncoordinated\"          print(f\"1. Tissue Coherence: {coherence_status}\")     print(f\"   Initial C(t) = {C_initial:.3f} \u2192 Final C(t) = {C_final:.3f}\")     print()          if isinstance(Si_values, dict):         avg_si = sum(Si_values.values()) / len(Si_values)     else:         avg_si = float(Si_values.mean()) if hasattr(Si_values, 'mean') else 0.0          if avg_si &gt; 0.7:         stability_status = \"STABLE - Cells resist perturbation\"     elif avg_si &gt; 0.4:         stability_status = \"MODERATE - Some vulnerability to stress\"     else:         stability_status = \"UNSTABLE - Cells easily perturbed\"          print(f\"2. Cellular Stability: {stability_status}\")     print(f\"   Average Si = {avg_si:.3f}\")     print()          if C_final &gt; C_initial:         print(\"3. Outcome: \u2713 SUCCESSFUL TISSUE FORMATION\")         print(\"   - Cells established communication channels\")         print(\"   - Phase synchronization emerged\")         print(\"   - Coordinated tissue behavior achieved\")     else:         print(\"3. Outcome: \u26a0 LIMITED TISSUE ORGANIZATION\")         print(\"   - Communication was established but weak\")         print(\"   - Further coupling may be needed\")     print()          print(\"=\" * 70)     print(\"Key TNFR Insights:\")     print(\"=\" * 70)     print(\"\u2022 Cells = NFR nodes with EPI (state), \u03bdf (adaptation rate), \u03b8 (phase)\")     print(\"\u2022 Signaling = Emission operator (AL) propagates structural information\")     print(\"\u2022 Reception = Integration of external structural patterns\")     print(\"\u2022 Gap junctions = Coupling operator (UM) enables direct synchrony\")     print(\"\u2022 Tissue coherence = Emergent property from cellular phase alignment\")     print(\"\u2022 C(t) metric = Quantitative measure of tissue organization\")     print(\"=\" * 70) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/controlled_dissonance/","title":"Controlled dissonance","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Controlled dissonance scenario demonstrating bifurcation and re-coherence.\"\"\"\n</pre> \"\"\"Controlled dissonance scenario demonstrating bifurcation and re-coherence.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coupling,\n    Coherence,\n    Dissonance,\n    Emission,\n    Mutation,\n    Reception,\n    Resonance,\n    Silence,\n    Transition,\n)\nfrom tnfr.trace import register_trace\nfrom tnfr.glyph_history import ensure_history\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coupling,     Coherence,     Dissonance,     Emission,     Mutation,     Reception,     Resonance,     Silence,     Transition, ) from tnfr.trace import register_trace from tnfr.glyph_history import ensure_history In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Execute the three-node ring with a controlled dissonance pulse.\"\"\"\n    G, _ = create_nfr(\"A\", epi=0.24, vf=1.0, theta=0.0)\n    create_nfr(\"B\", epi=0.18, vf=0.9, theta=0.45, graph=G)\n    create_nfr(\"C\", epi=0.27, vf=1.1, theta=-0.35, graph=G)\n    G.add_edge(\"A\", \"B\")\n    G.add_edge(\"B\", \"C\")\n\n    G.graph.update(\n        {\n            \"UM_FUNCTIONAL_LINKS\": True,\n            \"UM_CANDIDATE_COUNT\": 2,\n            \"UM_CANDIDATE_MODE\": \"proximity\",\n        }\n    )\n\n    run_sequence(\n        G,\n        \"A\",\n        [Emission(), Reception(), Coherence(), Coupling(), Resonance(), Coherence(), Silence()],\n    )\n    run_sequence(\n        G,\n        \"B\",\n        [Emission(), Reception(), Coherence(), Resonance(), Coherence(), Silence()],\n    )\n    run_sequence(\n        G,\n        \"C\",\n        [\n            Emission(),\n            Reception(),\n            Coherence(),\n            Transition(),\n            Dissonance(),\n            Mutation(),\n            Coherence(),\n            Silence(),\n        ],\n    )\n\n    register_metrics_callbacks(G)\n    register_trace(G)\n    run(G, steps=8, dt=0.1)\n\n    C, dnfr_mean, depi_mean = compute_coherence(G, return_means=True)\n    Si = compute_Si(G)\n    history = ensure_history(G)\n\n    print(f\"C(t)={C:.3f}, \u0394NFR\u0304={dnfr_mean:.3f}, dEPI/dt\u0304={depi_mean:.3f}\")\n    print({node: round(val, 3) for node, val in Si.items()})\n    print(history[\"W_stats\"][-1])\n    print(list(history[\"nodal_diag\"][-1].items())[:2])\n</pre> def run_example() -&gt; None:     \"\"\"Execute the three-node ring with a controlled dissonance pulse.\"\"\"     G, _ = create_nfr(\"A\", epi=0.24, vf=1.0, theta=0.0)     create_nfr(\"B\", epi=0.18, vf=0.9, theta=0.45, graph=G)     create_nfr(\"C\", epi=0.27, vf=1.1, theta=-0.35, graph=G)     G.add_edge(\"A\", \"B\")     G.add_edge(\"B\", \"C\")      G.graph.update(         {             \"UM_FUNCTIONAL_LINKS\": True,             \"UM_CANDIDATE_COUNT\": 2,             \"UM_CANDIDATE_MODE\": \"proximity\",         }     )      run_sequence(         G,         \"A\",         [Emission(), Reception(), Coherence(), Coupling(), Resonance(), Coherence(), Silence()],     )     run_sequence(         G,         \"B\",         [Emission(), Reception(), Coherence(), Resonance(), Coherence(), Silence()],     )     run_sequence(         G,         \"C\",         [             Emission(),             Reception(),             Coherence(),             Transition(),             Dissonance(),             Mutation(),             Coherence(),             Silence(),         ],     )      register_metrics_callbacks(G)     register_trace(G)     run(G, steps=8, dt=0.1)      C, dnfr_mean, depi_mean = compute_coherence(G, return_means=True)     Si = compute_Si(G)     history = ensure_history(G)      print(f\"C(t)={C:.3f}, \u0394NFR\u0304={dnfr_mean:.3f}, dEPI/dt\u0304={depi_mean:.3f}\")     print({node: round(val, 3) for node, val in Si.items()})     print(history[\"W_stats\"][-1])     print(list(history[\"nodal_diag\"][-1].items())[:2]) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/optical_cavity_feedback/","title":"Optical cavity feedback","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Optical cavity feedback loop aligning laser, mirror stage, and detector.\"\"\"\n</pre> \"\"\"Optical cavity feedback loop aligning laser, mirror stage, and detector.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coupling,\n    Coherence,\n    Emission,\n    Expansion,\n    Mutation,\n    Reception,\n    Resonance,\n    SelfOrganization,\n    Silence,\n)\nfrom tnfr.trace import register_trace\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coupling,     Coherence,     Emission,     Expansion,     Mutation,     Reception,     Resonance,     SelfOrganization,     Silence, ) from tnfr.trace import register_trace In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Align an optical cavity after a thermal drift using TNFR operators.\"\"\"\n    G, _ = create_nfr(\"LaserHead\", epi=0.23, vf=1.0, theta=0.0)\n    create_nfr(\"MirrorStage\", epi=0.28, vf=1.08, theta=0.15, graph=G)\n    create_nfr(\"DetectorArray\", epi=0.19, vf=0.92, theta=-0.22, graph=G)\n\n    for node, component in {\n        \"LaserHead\": \"pump + modulation source\",\n        \"MirrorStage\": \"piezo alignment stage\",\n        \"DetectorArray\": \"photodiode feedback\",\n    }.items():\n        G.nodes[node][\"component\"] = component\n\n    workflow = {\n        \"LaserHead\": [\n            Emission(),\n            Reception(),\n            Coherence(),\n            Coupling(),\n            Resonance(),\n            Silence(),\n        ],\n        \"MirrorStage\": [\n            Emission(),\n            Reception(),\n            Coherence(),\n            SelfOrganization(),\n            Mutation(),\n            Coherence(),\n            Resonance(),\n            Silence(),\n        ],\n        \"DetectorArray\": [\n            Emission(),\n            Reception(),\n            Coherence(),\n            Expansion(),\n            Resonance(),\n            Silence(),\n        ],\n    }\n\n    for node, ops in workflow.items():\n        run_sequence(G, node, ops)\n\n    register_metrics_callbacks(G)\n    register_trace(G)\n    run(G, steps=6, dt=0.1)\n\n    C, mean_delta_nfr, _ = compute_coherence(G, return_means=True)\n    si = compute_Si(G)\n\n    print(f\"C(t)={C:.3f}, \u0394NFR\u0304={mean_delta_nfr:.3f}\")\n    print({device: round(value, 3) for device, value in si.items()})\n</pre> def run_example() -&gt; None:     \"\"\"Align an optical cavity after a thermal drift using TNFR operators.\"\"\"     G, _ = create_nfr(\"LaserHead\", epi=0.23, vf=1.0, theta=0.0)     create_nfr(\"MirrorStage\", epi=0.28, vf=1.08, theta=0.15, graph=G)     create_nfr(\"DetectorArray\", epi=0.19, vf=0.92, theta=-0.22, graph=G)      for node, component in {         \"LaserHead\": \"pump + modulation source\",         \"MirrorStage\": \"piezo alignment stage\",         \"DetectorArray\": \"photodiode feedback\",     }.items():         G.nodes[node][\"component\"] = component      workflow = {         \"LaserHead\": [             Emission(),             Reception(),             Coherence(),             Coupling(),             Resonance(),             Silence(),         ],         \"MirrorStage\": [             Emission(),             Reception(),             Coherence(),             SelfOrganization(),             Mutation(),             Coherence(),             Resonance(),             Silence(),         ],         \"DetectorArray\": [             Emission(),             Reception(),             Coherence(),             Expansion(),             Resonance(),             Silence(),         ],     }      for node, ops in workflow.items():         run_sequence(G, node, ops)      register_metrics_callbacks(G)     register_trace(G)     run(G, steps=6, dt=0.1)      C, mean_delta_nfr, _ = compute_coherence(G, return_means=True)     si = compute_Si(G)      print(f\"C(t)={C:.3f}, \u0394NFR\u0304={mean_delta_nfr:.3f}\")     print({device: round(value, 3) for device, value in si.items()}) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/social_network_dynamics/","title":"Social network dynamics","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nTitle: Social Network Dynamics - Information Propagation and Opinion Formation\n\nProblem: In social networks, individuals form opinions through exposure to\ninformation from their social contacts. How do opinions spread, stabilize,\nor fragment? When does consensus emerge vs. polarization?\n\nTNFR Approach: Model individuals as NFR nodes where:\n- EPI represents opinion/belief structure\n- \u03bdf (Hz_str) is openness to opinion change\n- Phase represents alignment with prevailing narrative\n- Emission models sharing information/opinions\n- Reception models exposure to others' views\n- Resonance models consensus building (opinions align)\n- Dissonance models conflict/debate (opinions clash)\n\nKey Operators:\n- Emission (AL): Individual shares their opinion\n- Reception (EN): Individual exposed to others' opinions\n- Resonance (RA): Opinion alignment, consensus building\n- Dissonance (OZ): Opinion conflict, debate\n- Coherence (IL): Opinion stabilization\n- Coupling (UM): Relationship formation, trust networks\n\nRelevant Metrics:\n- C(t): Social coherence (level of consensus)\n- Si: Opinion stability (resistance to influence)\n- Phase coherence: Opinion alignment across network\n- \u0394NFR: Pressure to change opinion\n\nExpected Behavior:\n- Initial diversity of opinions (low C(t))\n- Information spreads through network\n- Some opinions resonate and amplify (consensus)\n- Conflicting opinions create dissonance (debate)\n- Final state shows either consensus or polarization\n- Stable individuals (high Si) are opinion leaders\n\nRun:\n    python docs/source/examples/social_network_dynamics.py\n\"\"\"\n</pre> \"\"\" Title: Social Network Dynamics - Information Propagation and Opinion Formation  Problem: In social networks, individuals form opinions through exposure to information from their social contacts. How do opinions spread, stabilize, or fragment? When does consensus emerge vs. polarization?  TNFR Approach: Model individuals as NFR nodes where: - EPI represents opinion/belief structure - \u03bdf (Hz_str) is openness to opinion change - Phase represents alignment with prevailing narrative - Emission models sharing information/opinions - Reception models exposure to others' views - Resonance models consensus building (opinions align) - Dissonance models conflict/debate (opinions clash)  Key Operators: - Emission (AL): Individual shares their opinion - Reception (EN): Individual exposed to others' opinions - Resonance (RA): Opinion alignment, consensus building - Dissonance (OZ): Opinion conflict, debate - Coherence (IL): Opinion stabilization - Coupling (UM): Relationship formation, trust networks  Relevant Metrics: - C(t): Social coherence (level of consensus) - Si: Opinion stability (resistance to influence) - Phase coherence: Opinion alignment across network - \u0394NFR: Pressure to change opinion  Expected Behavior: - Initial diversity of opinions (low C(t)) - Information spreads through network - Some opinions resonate and amplify (consensus) - Conflicting opinions create dissonance (debate) - Final state shows either consensus or polarization - Stable individuals (high Si) are opinion leaders  Run:     python docs/source/examples/social_network_dynamics.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coupling,\n    Coherence,\n    Dissonance,\n    Emission,\n    Reception,\n    Resonance,\n    Silence,\n)\nfrom tnfr.trace import register_trace\nfrom tnfr.constants import inject_defaults\nimport math\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coupling,     Coherence,     Dissonance,     Emission,     Reception,     Resonance,     Silence, ) from tnfr.trace import register_trace from tnfr.constants import inject_defaults import math In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Model opinion dynamics in a social network under information flow.\"\"\"\n    \n    print(\"=\" * 70)\n    print(\"TNFR Social Network Dynamics: Opinion Formation &amp; Propagation\")\n    print(\"=\" * 70)\n    print()\n    \n    # 1. PROBLEM SETUP: Creating a social network\n    # --------------------------------------------\n    # Model a small online community discussing a contentious topic\n    # Different personality types have different responses to information\n    \n    print(\"Phase 1: Initializing social network...\")\n    print(\"Creating 8 individuals with diverse initial opinions\")\n    print()\n    \n    # Opinion Leaders: High stability (high Si), influence others\n    # Starting with strong, coherent opinions (high EPI)\n    G, _ = create_nfr(\n        \"Leader_A\",\n        epi=0.45,   # Strong opinion structure\n        vf=0.8,     # Moderate openness to change\n        theta=0.0   # Aligned with one narrative\n    )\n    \n    create_nfr(\n        \"Leader_B\",\n        epi=0.42,\n        vf=0.75,\n        theta=math.pi,  # Opposite narrative (polarized)\n        graph=G\n    )\n    \n    # Followers: Moderate stability, receptive to leaders\n    create_nfr(\n        \"Follower_1\",\n        epi=0.25,   # Moderate opinion strength\n        vf=1.1,     # More open to change\n        theta=0.3,  # Leaning toward Leader_A\n        graph=G\n    )\n    \n    create_nfr(\n        \"Follower_2\",\n        epi=0.23,\n        vf=1.15,\n        theta=-0.4,  # Leaning toward Leader_A\n        graph=G\n    )\n    \n    create_nfr(\n        \"Follower_3\",\n        epi=0.27,\n        vf=1.0,\n        theta=2.8,   # Leaning toward Leader_B\n        graph=G\n    )\n    \n    # Undecided/Neutral individuals: Low initial opinion structure\n    create_nfr(\n        \"Neutral_1\",\n        epi=0.15,    # Weak initial opinion\n        vf=1.3,      # Very open to influence\n        theta=1.5,   # Neutral phase\n        graph=G\n    )\n    \n    create_nfr(\n        \"Neutral_2\",\n        epi=0.18,\n        vf=1.25,\n        theta=1.6,\n        graph=G\n    )\n    \n    # Bridge person: Connects different groups\n    create_nfr(\n        \"Bridge\",\n        epi=0.30,\n        vf=0.95,\n        theta=0.8,   # Between narratives\n        graph=G\n    )\n    \n    # Add social connections (who influences whom)\n    # Leaders have broad influence\n    G.add_edge(\"Leader_A\", \"Follower_1\")\n    G.add_edge(\"Leader_A\", \"Follower_2\")\n    G.add_edge(\"Leader_A\", \"Bridge\")\n    \n    G.add_edge(\"Leader_B\", \"Follower_3\")\n    G.add_edge(\"Leader_B\", \"Bridge\")\n    \n    # Followers connect to each other\n    G.add_edge(\"Follower_1\", \"Follower_2\")\n    G.add_edge(\"Follower_1\", \"Neutral_1\")\n    G.add_edge(\"Follower_3\", \"Neutral_2\")\n    \n    # Bridge connects different camps\n    G.add_edge(\"Bridge\", \"Neutral_1\")\n    G.add_edge(\"Bridge\", \"Neutral_2\")\n    \n    # Store social metadata\n    roles = {\n        \"Leader_A\": \"Opinion Leader (Pro-position)\",\n        \"Leader_B\": \"Opinion Leader (Anti-position)\",\n        \"Follower_1\": \"Follower of Leader_A\",\n        \"Follower_2\": \"Follower of Leader_A\",\n        \"Follower_3\": \"Follower of Leader_B\",\n        \"Neutral_1\": \"Undecided/Neutral\",\n        \"Neutral_2\": \"Undecided/Neutral\",\n        \"Bridge\": \"Bridge person (connects groups)\",\n    }\n    \n    for node, role in roles.items():\n        G.nodes[node][\"role\"] = role\n    \n    # Inject required defaults for graph parameters\n    inject_defaults(G)\n    \n    # Measure initial state\n    C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)\n    Si_initial = compute_Si(G)\n    \n    print(f\"Initial network state:\")\n    print(f\"  C(t) = {C_initial:.3f} (social coherence - expect low due to diversity)\")\n    print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (opinion change pressure)\")\n    print(f\"  Network size: {G.number_of_nodes()} individuals\")\n    print(f\"  Connections: {G.number_of_edges()} relationships\")\n    print()\n    \n    # 2. TNFR MODELING: Define behavioral protocols\n    # ----------------------------------------------\n    \n    print(\"Phase 2: Defining opinion dynamics protocols...\")\n    print()\n    \n    # Opinion Leaders: Emit strongly, resist change, build consensus\n    leader_protocol = [\n        Emission(),      # Share strong opinions\n        Reception(),     # Listen to feedback (but less affected)\n        Coherence(),     # Reinforce own position\n        Resonance(),     # Attract like-minded individuals\n        Coupling(),      # Form strong influence networks\n        Coherence(),     # Stabilize position\n        Silence(),\n    ]\n    \n    # Followers: Receptive, adopt aligned opinions\n    follower_protocol = [\n        Emission(),      # Share opinions (must start with emission)\n        Reception(),     # Listen to leaders and peers\n        Coherence(),     # Try to stabilize\n        Resonance(),     # Align with dominant narrative\n        Silence(),\n    ]\n    \n    # Neutral/Undecided: Highly receptive, may experience conflict\n    neutral_protocol = [\n        Emission(),      # Must start with emission\n        Reception(),     # Exposed to multiple viewpoints\n        Coherence(),     # Attempt stabilization\n        Silence(),\n    ]\n    \n    # Bridge: Balance opposing views, experience tension\n    bridge_protocol = [\n        Emission(),      # Try to mediate (must start with emission)\n        Reception(),     # Listen to multiple sides\n        Coherence(),     # Try to maintain balance\n        Resonance(),     # Facilitate dialogue\n        Silence(),\n    ]\n    \n    # 3. OPERATOR APPLICATION: Execute social dynamics\n    # -------------------------------------------------\n    \n    print(\"Simulating opinion formation dynamics...\")\n    print()\n    \n    # Apply protocols\n    run_sequence(G, \"Leader_A\", leader_protocol)\n    run_sequence(G, \"Leader_B\", leader_protocol)\n    \n    run_sequence(G, \"Follower_1\", follower_protocol)\n    run_sequence(G, \"Follower_2\", follower_protocol)\n    run_sequence(G, \"Follower_3\", follower_protocol)\n    \n    run_sequence(G, \"Neutral_1\", neutral_protocol)\n    run_sequence(G, \"Neutral_2\", neutral_protocol)\n    \n    run_sequence(G, \"Bridge\", bridge_protocol)\n    \n    # 4. SIMULATION: Run opinion dynamics over time\n    # ----------------------------------------------\n    \n    print(\"Phase 3: Running social dynamics simulation...\")\n    print(\"(Simulating information flow and opinion evolution)\")\n    print()\n    \n    register_metrics_callbacks(G)\n    register_trace(G)\n    \n    # Run for 12 time steps = ~12 information exchange cycles\n    run(G, steps=12, dt=0.1)\n    \n    # 5. RESULTS INTERPRETATION\n    # --------------------------\n    \n    print(\"=\" * 70)\n    print(\"RESULTS: Social Network Analysis\")\n    print(\"=\" * 70)\n    print()\n    \n    # Compute final metrics\n    C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)\n    Si_final = compute_Si(G)\n    \n    print(\"Network-Level Metrics:\")\n    print(f\"  Initial C(t) = {C_initial:.3f}\")\n    print(f\"  Final C(t) = {C_final:.3f}\")\n    print(f\"  \u0394C = {C_final - C_initial:+.3f} (consensus change)\")\n    print(f\"  Mean \u0394NFR = {dnfr_final:.3f} (residual opinion pressure)\")\n    print()\n    \n    print(\"Individual Opinion Stability (Sense Index):\")\n    if isinstance(Si_final, dict):\n        for person in sorted(Si_final.keys()):\n            si_val = Si_final[person]\n            si_change = si_val - Si_initial.get(person, 0.0) if isinstance(Si_initial, dict) else 0.0\n            role_short = roles[person].split()[0]\n            print(f\"  {person:15s} Si = {si_val:.3f} ({si_change:+.3f})  [{role_short}]\")\n    else:\n        for idx, person in enumerate(sorted(G.nodes())):\n            si_val = float(Si_final[idx]) if hasattr(Si_final, '__getitem__') else 0.0\n            si_change = 0.0\n            role_short = roles[person].split()[0]\n            print(f\"  {person:15s} Si = {si_val:.3f} ({si_change:+.3f})  [{role_short}]\")\n    print()\n    \n    # Social science interpretation\n    print(\"=\" * 70)\n    print(\"SOCIAL SCIENCE INTERPRETATION\")\n    print(\"=\" * 70)\n    print()\n    \n    # Analyze consensus vs polarization\n    if C_final &gt; 0.65:\n        outcome = \"STRONG CONSENSUS\"\n        explanation = \"Network converged to shared understanding\"\n    elif C_final &gt; 0.45:\n        outcome = \"MODERATE CONSENSUS\"\n        explanation = \"Some agreement emerged, but diversity remains\"\n    elif C_final &gt; C_initial:\n        outcome = \"WEAK CONSENSUS\"\n        explanation = \"Slight movement toward alignment\"\n    else:\n        outcome = \"POLARIZATION\"\n        explanation = \"Network became more fragmented\"\n    \n    print(f\"1. Network Outcome: {outcome}\")\n    print(f\"   {explanation}\")\n    print(f\"   C(t): {C_initial:.3f} \u2192 {C_final:.3f}\")\n    print()\n    \n    # Identify opinion leaders (high Si + high EPI)\n    if isinstance(Si_final, dict):\n        avg_si = sum(Si_final.values()) / len(Si_final)\n        leaders = [p for p, si in Si_final.items() if si &gt; avg_si * 1.2]\n    else:\n        avg_si = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0\n        leaders = []\n    \n    print(f\"2. Opinion Leaders (high stability):\")\n    for leader in leaders:\n        print(f\"   \u2022 {leader}: {roles[leader]}\")\n    print()\n    \n    # Analyze information flow\n    if abs(dnfr_final) &lt; 0.3:\n        stability = \"STABLE - Opinions have settled\"\n    else:\n        stability = \"DYNAMIC - Opinions still evolving\"\n    \n    print(f\"3. Opinion Stability: {stability}\")\n    print(f\"   Mean \u0394NFR = {dnfr_final:.3f}\")\n    print()\n    \n    print(\"=\" * 70)\n    print(\"Key TNFR Insights:\")\n    print(\"=\" * 70)\n    print(\"\u2022 Individuals = NFR nodes with opinion structure (EPI)\")\n    print(\"\u2022 Opinion sharing = Emission operator propagates beliefs\")\n    print(\"\u2022 Influence = Reception operator integrates others' opinions\")\n    print(\"\u2022 Consensus = Resonance operator aligns opinion structures\")\n    print(\"\u2022 Debate = Dissonance operator creates cognitive tension\")\n    print(\"\u2022 Social coherence C(t) = Measure of consensus vs. polarization\")\n    print(\"\u2022 Stability Si = Resistance to opinion change (opinion leaders)\")\n    print()\n    print(\"Social Dynamics Principles:\")\n    print(\"\u2022 High C(t) + High Si \u2192 Stable consensus (echo chamber risk)\")\n    print(\"\u2022 Low C(t) + High \u0394NFR \u2192 Active debate (healthy discourse)\")\n    print(\"\u2022 Low C(t) + Low Si \u2192 Fragmentation (polarization risk)\")\n    print(\"=\" * 70)\n</pre> def run_example() -&gt; None:     \"\"\"Model opinion dynamics in a social network under information flow.\"\"\"          print(\"=\" * 70)     print(\"TNFR Social Network Dynamics: Opinion Formation &amp; Propagation\")     print(\"=\" * 70)     print()          # 1. PROBLEM SETUP: Creating a social network     # --------------------------------------------     # Model a small online community discussing a contentious topic     # Different personality types have different responses to information          print(\"Phase 1: Initializing social network...\")     print(\"Creating 8 individuals with diverse initial opinions\")     print()          # Opinion Leaders: High stability (high Si), influence others     # Starting with strong, coherent opinions (high EPI)     G, _ = create_nfr(         \"Leader_A\",         epi=0.45,   # Strong opinion structure         vf=0.8,     # Moderate openness to change         theta=0.0   # Aligned with one narrative     )          create_nfr(         \"Leader_B\",         epi=0.42,         vf=0.75,         theta=math.pi,  # Opposite narrative (polarized)         graph=G     )          # Followers: Moderate stability, receptive to leaders     create_nfr(         \"Follower_1\",         epi=0.25,   # Moderate opinion strength         vf=1.1,     # More open to change         theta=0.3,  # Leaning toward Leader_A         graph=G     )          create_nfr(         \"Follower_2\",         epi=0.23,         vf=1.15,         theta=-0.4,  # Leaning toward Leader_A         graph=G     )          create_nfr(         \"Follower_3\",         epi=0.27,         vf=1.0,         theta=2.8,   # Leaning toward Leader_B         graph=G     )          # Undecided/Neutral individuals: Low initial opinion structure     create_nfr(         \"Neutral_1\",         epi=0.15,    # Weak initial opinion         vf=1.3,      # Very open to influence         theta=1.5,   # Neutral phase         graph=G     )          create_nfr(         \"Neutral_2\",         epi=0.18,         vf=1.25,         theta=1.6,         graph=G     )          # Bridge person: Connects different groups     create_nfr(         \"Bridge\",         epi=0.30,         vf=0.95,         theta=0.8,   # Between narratives         graph=G     )          # Add social connections (who influences whom)     # Leaders have broad influence     G.add_edge(\"Leader_A\", \"Follower_1\")     G.add_edge(\"Leader_A\", \"Follower_2\")     G.add_edge(\"Leader_A\", \"Bridge\")          G.add_edge(\"Leader_B\", \"Follower_3\")     G.add_edge(\"Leader_B\", \"Bridge\")          # Followers connect to each other     G.add_edge(\"Follower_1\", \"Follower_2\")     G.add_edge(\"Follower_1\", \"Neutral_1\")     G.add_edge(\"Follower_3\", \"Neutral_2\")          # Bridge connects different camps     G.add_edge(\"Bridge\", \"Neutral_1\")     G.add_edge(\"Bridge\", \"Neutral_2\")          # Store social metadata     roles = {         \"Leader_A\": \"Opinion Leader (Pro-position)\",         \"Leader_B\": \"Opinion Leader (Anti-position)\",         \"Follower_1\": \"Follower of Leader_A\",         \"Follower_2\": \"Follower of Leader_A\",         \"Follower_3\": \"Follower of Leader_B\",         \"Neutral_1\": \"Undecided/Neutral\",         \"Neutral_2\": \"Undecided/Neutral\",         \"Bridge\": \"Bridge person (connects groups)\",     }          for node, role in roles.items():         G.nodes[node][\"role\"] = role          # Inject required defaults for graph parameters     inject_defaults(G)          # Measure initial state     C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)     Si_initial = compute_Si(G)          print(f\"Initial network state:\")     print(f\"  C(t) = {C_initial:.3f} (social coherence - expect low due to diversity)\")     print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (opinion change pressure)\")     print(f\"  Network size: {G.number_of_nodes()} individuals\")     print(f\"  Connections: {G.number_of_edges()} relationships\")     print()          # 2. TNFR MODELING: Define behavioral protocols     # ----------------------------------------------          print(\"Phase 2: Defining opinion dynamics protocols...\")     print()          # Opinion Leaders: Emit strongly, resist change, build consensus     leader_protocol = [         Emission(),      # Share strong opinions         Reception(),     # Listen to feedback (but less affected)         Coherence(),     # Reinforce own position         Resonance(),     # Attract like-minded individuals         Coupling(),      # Form strong influence networks         Coherence(),     # Stabilize position         Silence(),     ]          # Followers: Receptive, adopt aligned opinions     follower_protocol = [         Emission(),      # Share opinions (must start with emission)         Reception(),     # Listen to leaders and peers         Coherence(),     # Try to stabilize         Resonance(),     # Align with dominant narrative         Silence(),     ]          # Neutral/Undecided: Highly receptive, may experience conflict     neutral_protocol = [         Emission(),      # Must start with emission         Reception(),     # Exposed to multiple viewpoints         Coherence(),     # Attempt stabilization         Silence(),     ]          # Bridge: Balance opposing views, experience tension     bridge_protocol = [         Emission(),      # Try to mediate (must start with emission)         Reception(),     # Listen to multiple sides         Coherence(),     # Try to maintain balance         Resonance(),     # Facilitate dialogue         Silence(),     ]          # 3. OPERATOR APPLICATION: Execute social dynamics     # -------------------------------------------------          print(\"Simulating opinion formation dynamics...\")     print()          # Apply protocols     run_sequence(G, \"Leader_A\", leader_protocol)     run_sequence(G, \"Leader_B\", leader_protocol)          run_sequence(G, \"Follower_1\", follower_protocol)     run_sequence(G, \"Follower_2\", follower_protocol)     run_sequence(G, \"Follower_3\", follower_protocol)          run_sequence(G, \"Neutral_1\", neutral_protocol)     run_sequence(G, \"Neutral_2\", neutral_protocol)          run_sequence(G, \"Bridge\", bridge_protocol)          # 4. SIMULATION: Run opinion dynamics over time     # ----------------------------------------------          print(\"Phase 3: Running social dynamics simulation...\")     print(\"(Simulating information flow and opinion evolution)\")     print()          register_metrics_callbacks(G)     register_trace(G)          # Run for 12 time steps = ~12 information exchange cycles     run(G, steps=12, dt=0.1)          # 5. RESULTS INTERPRETATION     # --------------------------          print(\"=\" * 70)     print(\"RESULTS: Social Network Analysis\")     print(\"=\" * 70)     print()          # Compute final metrics     C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)     Si_final = compute_Si(G)          print(\"Network-Level Metrics:\")     print(f\"  Initial C(t) = {C_initial:.3f}\")     print(f\"  Final C(t) = {C_final:.3f}\")     print(f\"  \u0394C = {C_final - C_initial:+.3f} (consensus change)\")     print(f\"  Mean \u0394NFR = {dnfr_final:.3f} (residual opinion pressure)\")     print()          print(\"Individual Opinion Stability (Sense Index):\")     if isinstance(Si_final, dict):         for person in sorted(Si_final.keys()):             si_val = Si_final[person]             si_change = si_val - Si_initial.get(person, 0.0) if isinstance(Si_initial, dict) else 0.0             role_short = roles[person].split()[0]             print(f\"  {person:15s} Si = {si_val:.3f} ({si_change:+.3f})  [{role_short}]\")     else:         for idx, person in enumerate(sorted(G.nodes())):             si_val = float(Si_final[idx]) if hasattr(Si_final, '__getitem__') else 0.0             si_change = 0.0             role_short = roles[person].split()[0]             print(f\"  {person:15s} Si = {si_val:.3f} ({si_change:+.3f})  [{role_short}]\")     print()          # Social science interpretation     print(\"=\" * 70)     print(\"SOCIAL SCIENCE INTERPRETATION\")     print(\"=\" * 70)     print()          # Analyze consensus vs polarization     if C_final &gt; 0.65:         outcome = \"STRONG CONSENSUS\"         explanation = \"Network converged to shared understanding\"     elif C_final &gt; 0.45:         outcome = \"MODERATE CONSENSUS\"         explanation = \"Some agreement emerged, but diversity remains\"     elif C_final &gt; C_initial:         outcome = \"WEAK CONSENSUS\"         explanation = \"Slight movement toward alignment\"     else:         outcome = \"POLARIZATION\"         explanation = \"Network became more fragmented\"          print(f\"1. Network Outcome: {outcome}\")     print(f\"   {explanation}\")     print(f\"   C(t): {C_initial:.3f} \u2192 {C_final:.3f}\")     print()          # Identify opinion leaders (high Si + high EPI)     if isinstance(Si_final, dict):         avg_si = sum(Si_final.values()) / len(Si_final)         leaders = [p for p, si in Si_final.items() if si &gt; avg_si * 1.2]     else:         avg_si = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0         leaders = []          print(f\"2. Opinion Leaders (high stability):\")     for leader in leaders:         print(f\"   \u2022 {leader}: {roles[leader]}\")     print()          # Analyze information flow     if abs(dnfr_final) &lt; 0.3:         stability = \"STABLE - Opinions have settled\"     else:         stability = \"DYNAMIC - Opinions still evolving\"          print(f\"3. Opinion Stability: {stability}\")     print(f\"   Mean \u0394NFR = {dnfr_final:.3f}\")     print()          print(\"=\" * 70)     print(\"Key TNFR Insights:\")     print(\"=\" * 70)     print(\"\u2022 Individuals = NFR nodes with opinion structure (EPI)\")     print(\"\u2022 Opinion sharing = Emission operator propagates beliefs\")     print(\"\u2022 Influence = Reception operator integrates others' opinions\")     print(\"\u2022 Consensus = Resonance operator aligns opinion structures\")     print(\"\u2022 Debate = Dissonance operator creates cognitive tension\")     print(\"\u2022 Social coherence C(t) = Measure of consensus vs. polarization\")     print(\"\u2022 Stability Si = Resistance to opinion change (opinion leaders)\")     print()     print(\"Social Dynamics Principles:\")     print(\"\u2022 High C(t) + High Si \u2192 Stable consensus (echo chamber risk)\")     print(\"\u2022 Low C(t) + High \u0394NFR \u2192 Active debate (healthy discourse)\")     print(\"\u2022 Low C(t) + Low Si \u2192 Fragmentation (polarization risk)\")     print(\"=\" * 70) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/supply_chain_resilience/","title":"Supply chain resilience","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nTitle: Supply Chain Resilience - Adaptive Response to Disruptions\n\nProblem: Supply chains face disruptions (factory closures, shipping delays,\ndemand spikes). How do resilient supply chains adapt? What makes some\nsystems fragile and others robust?\n\nTNFR Approach: Model supply chain entities as NFR nodes where:\n- EPI represents operational capability/inventory structure\n- \u03bdf (Hz_str) is adaptation speed (how fast can operations change)\n- Phase represents synchronization with supply/demand cycles\n- Mutation operator models adaptation to disruptions\n- Coupling represents supply relationships\n- Coherence measures supply chain stability\n\nKey Operators:\n- Coupling (UM): Supply relationships, logistics connections\n- Mutation (ZHIR): Adaptation to disruptions (find alternatives)\n- Reception (EN): Monitor supply/demand signals\n- Emission (AL): Fulfill orders, ship products\n- SelfOrganization (THOL): Find alternative supply routes\n- Coherence (IL): Stabilize operations after disruption\n\nRelevant Metrics:\n- C(t): Supply chain coherence (operational stability)\n- Si: Resilience (ability to maintain operations under stress)\n- \u0394NFR: Operational pressure (supply-demand mismatch)\n- Phase coherence: Timing coordination across chain\n\nExpected Behavior:\n- Initial stable supply chain (high C(t))\n- Disruption causes coherence drop (shock)\n- Mutation operator enables adaptation\n- Self-organization finds alternative routes\n- Recovery: coherence increases as new equilibrium forms\n- High Si nodes = resilient entities (bounce back faster)\n\nRun:\n    python docs/source/examples/supply_chain_resilience.py\n\"\"\"\n</pre> \"\"\" Title: Supply Chain Resilience - Adaptive Response to Disruptions  Problem: Supply chains face disruptions (factory closures, shipping delays, demand spikes). How do resilient supply chains adapt? What makes some systems fragile and others robust?  TNFR Approach: Model supply chain entities as NFR nodes where: - EPI represents operational capability/inventory structure - \u03bdf (Hz_str) is adaptation speed (how fast can operations change) - Phase represents synchronization with supply/demand cycles - Mutation operator models adaptation to disruptions - Coupling represents supply relationships - Coherence measures supply chain stability  Key Operators: - Coupling (UM): Supply relationships, logistics connections - Mutation (ZHIR): Adaptation to disruptions (find alternatives) - Reception (EN): Monitor supply/demand signals - Emission (AL): Fulfill orders, ship products - SelfOrganization (THOL): Find alternative supply routes - Coherence (IL): Stabilize operations after disruption  Relevant Metrics: - C(t): Supply chain coherence (operational stability) - Si: Resilience (ability to maintain operations under stress) - \u0394NFR: Operational pressure (supply-demand mismatch) - Phase coherence: Timing coordination across chain  Expected Behavior: - Initial stable supply chain (high C(t)) - Disruption causes coherence drop (shock) - Mutation operator enables adaptation - Self-organization finds alternative routes - Recovery: coherence increases as new equilibrium forms - High Si nodes = resilient entities (bounce back faster)  Run:     python docs/source/examples/supply_chain_resilience.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coherence,\n    Coupling,\n    Dissonance,\n    Emission,\n    Mutation,\n    Reception,\n    SelfOrganization,\n    Silence,\n    Transition,\n)\nfrom tnfr.trace import register_trace\nfrom tnfr.constants import inject_defaults\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coherence,     Coupling,     Dissonance,     Emission,     Mutation,     Reception,     SelfOrganization,     Silence,     Transition, ) from tnfr.trace import register_trace from tnfr.constants import inject_defaults In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Model supply chain adaptation to disruptions using TNFR operators.\"\"\"\n    \n    print(\"=\" * 70)\n    print(\"TNFR Supply Chain Resilience: Adaptive Response to Disruptions\")\n    print(\"=\" * 70)\n    print()\n    \n    # 1. PROBLEM SETUP: Creating a supply chain network\n    # --------------------------------------------------\n    # Scenario: Electronics supply chain\n    # Tiers: Raw Materials \u2192 Component Suppliers \u2192 Manufacturer \u2192 Distributor\n    \n    print(\"Phase 1: Initializing supply chain network...\")\n    print()\n    \n    # Raw Material Suppliers: Low-level inputs\n    G, _ = create_nfr(\n        \"RawMaterial_Asia\",\n        epi=0.40,    # Established operations\n        vf=0.85,     # Moderate adaptation speed\n        theta=0.0    # Synchronized with production cycles\n    )\n    \n    create_nfr(\n        \"RawMaterial_Europe\",\n        epi=0.38,\n        vf=0.90,\n        theta=0.2,\n        graph=G\n    )\n    \n    # Component Suppliers: Mid-tier manufacturing\n    create_nfr(\n        \"Components_Taiwan\",\n        epi=0.45,    # Critical supplier (semiconductors)\n        vf=0.70,     # Lower adaptation (specialized)\n        theta=-0.1,\n        graph=G\n    )\n    \n    create_nfr(\n        \"Components_Mexico\",\n        epi=0.35,    # Alternative supplier\n        vf=1.0,      # More flexible\n        theta=0.3,\n        graph=G\n    )\n    \n    # Final Manufacturer: Assembly and production\n    create_nfr(\n        \"Manufacturer_USA\",\n        epi=0.50,    # Complex operations\n        vf=0.80,\n        theta=0.0,\n        graph=G\n    )\n    \n    # Distribution Centers: Last-mile logistics\n    create_nfr(\n        \"Distribution_East\",\n        epi=0.42,\n        vf=1.1,      # Flexible logistics\n        theta=-0.2,\n        graph=G\n    )\n    \n    create_nfr(\n        \"Distribution_West\",\n        epi=0.40,\n        vf=1.15,\n        theta=0.25,\n        graph=G\n    )\n    \n    # Backup/Alternative supplier (initially disconnected)\n    create_nfr(\n        \"Backup_India\",\n        epi=0.30,    # Smaller capacity\n        vf=1.2,      # High flexibility\n        theta=0.8,   # Not yet synchronized\n        graph=G\n    )\n    \n    # Establish supply chain connections\n    # Raw materials \u2192 Components\n    G.add_edge(\"RawMaterial_Asia\", \"Components_Taiwan\")\n    G.add_edge(\"RawMaterial_Europe\", \"Components_Taiwan\")\n    G.add_edge(\"RawMaterial_Europe\", \"Components_Mexico\")\n    \n    # Components \u2192 Manufacturer\n    G.add_edge(\"Components_Taiwan\", \"Manufacturer_USA\")\n    G.add_edge(\"Components_Mexico\", \"Manufacturer_USA\")\n    \n    # Manufacturer \u2192 Distribution\n    G.add_edge(\"Manufacturer_USA\", \"Distribution_East\")\n    G.add_edge(\"Manufacturer_USA\", \"Distribution_West\")\n    \n    # Note: Backup_India initially disconnected (activated during disruption)\n    \n    # Store supply chain metadata\n    entities = {\n        \"RawMaterial_Asia\": \"Raw materials (metals, minerals) - Asia\",\n        \"RawMaterial_Europe\": \"Raw materials (metals, minerals) - Europe\",\n        \"Components_Taiwan\": \"Semiconductors &amp; electronics - Taiwan\",\n        \"Components_Mexico\": \"Electronics assembly - Mexico\",\n        \"Manufacturer_USA\": \"Final product assembly - USA\",\n        \"Distribution_East\": \"Distribution center - East Coast\",\n        \"Distribution_West\": \"Distribution center - West Coast\",\n        \"Backup_India\": \"Backup component supplier - India\",\n    }\n    \n    for node, description in entities.items():\n        G.nodes[node][\"description\"] = description\n    \n    # Inject required defaults for graph parameters\n    inject_defaults(G)\n    \n    # Measure initial state (before disruption)\n    C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)\n    Si_initial = compute_Si(G)\n    \n    print(\"Initial supply chain state (BEFORE disruption):\")\n    print(f\"  C(t) = {C_initial:.3f} (operational stability)\")\n    print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (supply-demand balance)\")\n    print(f\"  Network: {G.number_of_nodes()} entities, {G.number_of_edges()} connections\")\n    print()\n    \n    # 2. TNFR MODELING: Normal operations\n    # ------------------------------------\n    \n    print(\"Phase 2: Establishing normal operations...\")\n    print()\n    \n    # Normal operation protocols (before disruption)\n    normal_ops = [\n        Emission(),      # Fulfill orders (must start with emission)\n        Reception(),     # Monitor supply/demand\n        Coupling(),      # Maintain relationships\n        Coherence(),     # Stable operations\n        Silence(),\n    ]\n    \n    # Run normal operations for all entities\n    for node in G.nodes():\n        if node != \"Backup_India\":  # Backup not yet active\n            run_sequence(G, node, normal_ops)\n    \n    print(\"Normal operations established. Measuring baseline...\")\n    register_metrics_callbacks(G)\n    register_trace(G)\n    \n    # Run baseline period\n    run(G, steps=5, dt=0.1)\n    \n    C_baseline, dnfr_baseline, _ = compute_coherence(G, return_means=True)\n    print(f\"Baseline C(t) = {C_baseline:.3f}\")\n    print()\n    \n    # 3. DISRUPTION EVENT: Taiwan supplier crisis\n    # --------------------------------------------\n    \n    print(\"=\" * 70)\n    print(\"DISRUPTION EVENT: Components_Taiwan experiences major outage!\")\n    print(\"(Simulating earthquake, factory fire, or geopolitical crisis)\")\n    print(\"=\" * 70)\n    print()\n    \n    # Simulate disruption: Dissonance on critical supplier\n    disruption_impact = [\n        Emission(),      # Must start with emission\n        Reception(),     # Sense the shock\n        Coherence(),     # Try to stabilize\n        Dissonance(),    # Major operational shock\n        Mutation(),      # Forced to adapt\n        Coherence(),     # Stabilize after mutation\n        Silence(),\n    ]\n    \n    run_sequence(G, \"Components_Taiwan\", disruption_impact)\n    \n    # Measure disruption impact\n    C_disrupted, dnfr_disrupted, _ = compute_coherence(G, return_means=True)\n    print(f\"Post-disruption C(t) = {C_disrupted:.3f} (\u0394C = {C_disrupted - C_baseline:.3f})\")\n    print()\n    \n    # 4. ADAPTATION RESPONSE: Supply chain reorganization\n    # ----------------------------------------------------\n    \n    print(\"Phase 3: Activating adaptation protocols...\")\n    print()\n    \n    # Manufacturer must adapt to lost supplier\n    manufacturer_adaptation = [\n        Emission(),          # Must start with emission\n        Reception(),         # Assess situation\n        Coherence(),         # Stabilize before crisis response\n        Dissonance(),        # Acknowledge supply crisis\n        Mutation(),          # Explore alternatives\n        SelfOrganization(),  # Restructure supply chain\n        Silence(),           # Close self-organization\n        Coupling(),          # Connect to backup supplier\n        Coherence(),         # Stabilize new operations\n        Silence(),\n    ]\n    \n    # Activate backup supplier\n    backup_activation = [\n        Emission(),          # Begin production (must start with emission)\n        Reception(),         # Understand requirements\n        Coherence(),         # Stabilize\n        Dissonance(),        # Acknowledge new challenge\n        Mutation(),          # Adapt to new customer\n        Coupling(),          # Establish connections\n        Coherence(),         # Stabilize operations\n        Silence(),\n    ]\n    \n    # Alternative existing supplier scales up\n    alternative_scaleup = [\n        Emission(),          # Increase output (must start with emission)\n        Reception(),         # See increased demand\n        Coherence(),         # Stabilize\n        Dissonance(),        # Acknowledge capacity challenge\n        Mutation(),          # Adapt capacity\n        SelfOrganization(),  # Optimize operations\n        Silence(),           # Close self-organization\n        Coherence(),         # Stabilize higher throughput\n        Silence(),\n    ]\n    \n    print(\"Manufacturer adapting to disruption...\")\n    run_sequence(G, \"Manufacturer_USA\", manufacturer_adaptation)\n    \n    print(\"Activating backup supplier (Backup_India)...\")\n    run_sequence(G, \"Backup_India\", backup_activation)\n    \n    # Establish new supply connection\n    G.add_edge(\"RawMaterial_Asia\", \"Backup_India\")\n    G.add_edge(\"Backup_India\", \"Manufacturer_USA\")\n    print(\"New supply route established: RawMaterial_Asia \u2192 Backup_India \u2192 Manufacturer\")\n    print()\n    \n    print(\"Alternative supplier (Components_Mexico) scaling up...\")\n    run_sequence(G, \"Components_Mexico\", alternative_scaleup)\n    print()\n    \n    # 5. RECOVERY SIMULATION\n    # -----------------------\n    \n    print(\"Phase 4: Simulating recovery dynamics...\")\n    print()\n    \n    # Run recovery period\n    run(G, steps=10, dt=0.1)\n    \n    # 6. RESULTS INTERPRETATION\n    # --------------------------\n    \n    print(\"=\" * 70)\n    print(\"RESULTS: Supply Chain Resilience Analysis\")\n    print(\"=\" * 70)\n    print()\n    \n    # Compute final metrics (after recovery)\n    C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)\n    Si_final = compute_Si(G)\n    \n    print(\"Supply Chain Metrics Timeline:\")\n    print(f\"  1. Baseline:      C(t) = {C_baseline:.3f}\")\n    print(f\"  2. Disruption:    C(t) = {C_disrupted:.3f} ({C_disrupted - C_baseline:+.3f})\")\n    print(f\"  3. Post-recovery: C(t) = {C_final:.3f} ({C_final - C_disrupted:+.3f})\")\n    print()\n    print(f\"  Net impact: \u0394C = {C_final - C_baseline:+.3f}\")\n    print(f\"  Recovery ratio: {(C_final - C_disrupted) / (C_baseline - C_disrupted) * 100:.1f}%\")\n    print()\n    \n    print(\"Entity Resilience (Sense Index):\")\n    if isinstance(Si_final, dict):\n        for entity in sorted(Si_final.keys()):\n            si_val = Si_final[entity]\n            si_initial_val = Si_initial.get(entity, 0.0) if isinstance(Si_initial, dict) else 0.0\n            change = si_val - si_initial_val\n            desc_short = entities[entity].split('-')[0].strip()\n            print(f\"  {entity:25s} Si = {si_val:.3f} ({change:+.3f})  [{desc_short}]\")\n    else:\n        for idx, entity in enumerate(sorted(G.nodes())):\n            si_val = float(Si_final[idx]) if hasattr(Si_final, '__getitem__') else 0.0\n            change = 0.0\n            desc_short = entities[entity].split('-')[0].strip()\n            print(f\"  {entity:25s} Si = {si_val:.3f} ({change:+.3f})  [{desc_short}]\")\n    print()\n    \n    # Business interpretation\n    print(\"=\" * 70)\n    print(\"BUSINESS INTERPRETATION\")\n    print(\"=\" * 70)\n    print()\n    \n    # Recovery assessment\n    if C_final &gt;= C_baseline * 0.95:\n        recovery = \"FULL RECOVERY\"\n        status = \"Supply chain restored to normal operations\"\n    elif C_final &gt;= C_disrupted * 1.5:\n        recovery = \"STRONG RECOVERY\"\n        status = \"Supply chain adapted successfully\"\n    elif C_final &gt; C_disrupted:\n        recovery = \"PARTIAL RECOVERY\"\n        status = \"Some adaptation, but still impaired\"\n    else:\n        recovery = \"RECOVERY FAILURE\"\n        status = \"Unable to adapt to disruption\"\n    \n    print(f\"1. Recovery Outcome: {recovery}\")\n    print(f\"   {status}\")\n    print()\n    \n    # Identify resilient entities\n    if isinstance(Si_final, dict):\n        avg_si = sum(Si_final.values()) / len(Si_final)\n        resilient = [e for e, si in Si_final.items() if si &gt; avg_si * 1.1]\n    else:\n        avg_si = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0\n        resilient = []\n    \n    print(f\"2. Most Resilient Entities (Si &gt; {avg_si * 1.1:.3f}):\")\n    for entity in resilient:\n        print(f\"   \u2022 {entity}: {entities[entity]}\")\n    print()\n    \n    # Adaptation effectiveness\n    if \"Backup_India\" in G.nodes():\n        if isinstance(Si_final, dict):\n            backup_si = Si_final.get(\"Backup_India\", 0.0)\n        else:\n            backup_si = 0.0\n        if backup_si &gt; 0.5:\n            adaptation_status = \"SUCCESSFUL - Backup supplier integrated\"\n        else:\n            adaptation_status = \"PARTIAL - Backup integration incomplete\"\n    else:\n        adaptation_status = \"NO BACKUP ACTIVATION\"\n    \n    print(f\"3. Adaptation Strategy: {adaptation_status}\")\n    print()\n    \n    print(\"=\" * 70)\n    print(\"Key TNFR Insights:\")\n    print(\"=\" * 70)\n    print(\"\u2022 Supply chain entities = NFR nodes with operational EPI\")\n    print(\"\u2022 Disruption = Dissonance operator (creates instability)\")\n    print(\"\u2022 Adaptation = Mutation operator (explore alternatives)\")\n    print(\"\u2022 Resilience = High Si (ability to maintain coherence under stress)\")\n    print(\"\u2022 Recovery = Self-organization (find new equilibrium)\")\n    print(\"\u2022 Network coherence C(t) = Overall supply chain stability\")\n    print()\n    print(\"Resilience Principles:\")\n    print(\"  \u2022 Redundancy: Multiple suppliers \u2192 higher recovery capacity\")\n    print(\"  \u2022 Flexibility: High \u03bdf \u2192 faster adaptation to shocks\")\n    print(\"  \u2022 Coupling: Strong relationships \u2192 coordinated response\")\n    print(\"  \u2022 Si metric: Predicts which entities will fail under stress\")\n    print()\n    print(\"Business Implications:\")\n    print(\"  \u2713 Monitor Si to identify vulnerable supply chain nodes\")\n    print(\"  \u2713 Maintain backup suppliers (even if disconnected initially)\")\n    print(\"  \u2713 High \u03bdf entities recover faster (invest in flexibility)\")\n    print(\"  \u2713 Track C(t) as real-time supply chain health indicator\")\n    print(\"=\" * 70)\n</pre> def run_example() -&gt; None:     \"\"\"Model supply chain adaptation to disruptions using TNFR operators.\"\"\"          print(\"=\" * 70)     print(\"TNFR Supply Chain Resilience: Adaptive Response to Disruptions\")     print(\"=\" * 70)     print()          # 1. PROBLEM SETUP: Creating a supply chain network     # --------------------------------------------------     # Scenario: Electronics supply chain     # Tiers: Raw Materials \u2192 Component Suppliers \u2192 Manufacturer \u2192 Distributor          print(\"Phase 1: Initializing supply chain network...\")     print()          # Raw Material Suppliers: Low-level inputs     G, _ = create_nfr(         \"RawMaterial_Asia\",         epi=0.40,    # Established operations         vf=0.85,     # Moderate adaptation speed         theta=0.0    # Synchronized with production cycles     )          create_nfr(         \"RawMaterial_Europe\",         epi=0.38,         vf=0.90,         theta=0.2,         graph=G     )          # Component Suppliers: Mid-tier manufacturing     create_nfr(         \"Components_Taiwan\",         epi=0.45,    # Critical supplier (semiconductors)         vf=0.70,     # Lower adaptation (specialized)         theta=-0.1,         graph=G     )          create_nfr(         \"Components_Mexico\",         epi=0.35,    # Alternative supplier         vf=1.0,      # More flexible         theta=0.3,         graph=G     )          # Final Manufacturer: Assembly and production     create_nfr(         \"Manufacturer_USA\",         epi=0.50,    # Complex operations         vf=0.80,         theta=0.0,         graph=G     )          # Distribution Centers: Last-mile logistics     create_nfr(         \"Distribution_East\",         epi=0.42,         vf=1.1,      # Flexible logistics         theta=-0.2,         graph=G     )          create_nfr(         \"Distribution_West\",         epi=0.40,         vf=1.15,         theta=0.25,         graph=G     )          # Backup/Alternative supplier (initially disconnected)     create_nfr(         \"Backup_India\",         epi=0.30,    # Smaller capacity         vf=1.2,      # High flexibility         theta=0.8,   # Not yet synchronized         graph=G     )          # Establish supply chain connections     # Raw materials \u2192 Components     G.add_edge(\"RawMaterial_Asia\", \"Components_Taiwan\")     G.add_edge(\"RawMaterial_Europe\", \"Components_Taiwan\")     G.add_edge(\"RawMaterial_Europe\", \"Components_Mexico\")          # Components \u2192 Manufacturer     G.add_edge(\"Components_Taiwan\", \"Manufacturer_USA\")     G.add_edge(\"Components_Mexico\", \"Manufacturer_USA\")          # Manufacturer \u2192 Distribution     G.add_edge(\"Manufacturer_USA\", \"Distribution_East\")     G.add_edge(\"Manufacturer_USA\", \"Distribution_West\")          # Note: Backup_India initially disconnected (activated during disruption)          # Store supply chain metadata     entities = {         \"RawMaterial_Asia\": \"Raw materials (metals, minerals) - Asia\",         \"RawMaterial_Europe\": \"Raw materials (metals, minerals) - Europe\",         \"Components_Taiwan\": \"Semiconductors &amp; electronics - Taiwan\",         \"Components_Mexico\": \"Electronics assembly - Mexico\",         \"Manufacturer_USA\": \"Final product assembly - USA\",         \"Distribution_East\": \"Distribution center - East Coast\",         \"Distribution_West\": \"Distribution center - West Coast\",         \"Backup_India\": \"Backup component supplier - India\",     }          for node, description in entities.items():         G.nodes[node][\"description\"] = description          # Inject required defaults for graph parameters     inject_defaults(G)          # Measure initial state (before disruption)     C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)     Si_initial = compute_Si(G)          print(\"Initial supply chain state (BEFORE disruption):\")     print(f\"  C(t) = {C_initial:.3f} (operational stability)\")     print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (supply-demand balance)\")     print(f\"  Network: {G.number_of_nodes()} entities, {G.number_of_edges()} connections\")     print()          # 2. TNFR MODELING: Normal operations     # ------------------------------------          print(\"Phase 2: Establishing normal operations...\")     print()          # Normal operation protocols (before disruption)     normal_ops = [         Emission(),      # Fulfill orders (must start with emission)         Reception(),     # Monitor supply/demand         Coupling(),      # Maintain relationships         Coherence(),     # Stable operations         Silence(),     ]          # Run normal operations for all entities     for node in G.nodes():         if node != \"Backup_India\":  # Backup not yet active             run_sequence(G, node, normal_ops)          print(\"Normal operations established. Measuring baseline...\")     register_metrics_callbacks(G)     register_trace(G)          # Run baseline period     run(G, steps=5, dt=0.1)          C_baseline, dnfr_baseline, _ = compute_coherence(G, return_means=True)     print(f\"Baseline C(t) = {C_baseline:.3f}\")     print()          # 3. DISRUPTION EVENT: Taiwan supplier crisis     # --------------------------------------------          print(\"=\" * 70)     print(\"DISRUPTION EVENT: Components_Taiwan experiences major outage!\")     print(\"(Simulating earthquake, factory fire, or geopolitical crisis)\")     print(\"=\" * 70)     print()          # Simulate disruption: Dissonance on critical supplier     disruption_impact = [         Emission(),      # Must start with emission         Reception(),     # Sense the shock         Coherence(),     # Try to stabilize         Dissonance(),    # Major operational shock         Mutation(),      # Forced to adapt         Coherence(),     # Stabilize after mutation         Silence(),     ]          run_sequence(G, \"Components_Taiwan\", disruption_impact)          # Measure disruption impact     C_disrupted, dnfr_disrupted, _ = compute_coherence(G, return_means=True)     print(f\"Post-disruption C(t) = {C_disrupted:.3f} (\u0394C = {C_disrupted - C_baseline:.3f})\")     print()          # 4. ADAPTATION RESPONSE: Supply chain reorganization     # ----------------------------------------------------          print(\"Phase 3: Activating adaptation protocols...\")     print()          # Manufacturer must adapt to lost supplier     manufacturer_adaptation = [         Emission(),          # Must start with emission         Reception(),         # Assess situation         Coherence(),         # Stabilize before crisis response         Dissonance(),        # Acknowledge supply crisis         Mutation(),          # Explore alternatives         SelfOrganization(),  # Restructure supply chain         Silence(),           # Close self-organization         Coupling(),          # Connect to backup supplier         Coherence(),         # Stabilize new operations         Silence(),     ]          # Activate backup supplier     backup_activation = [         Emission(),          # Begin production (must start with emission)         Reception(),         # Understand requirements         Coherence(),         # Stabilize         Dissonance(),        # Acknowledge new challenge         Mutation(),          # Adapt to new customer         Coupling(),          # Establish connections         Coherence(),         # Stabilize operations         Silence(),     ]          # Alternative existing supplier scales up     alternative_scaleup = [         Emission(),          # Increase output (must start with emission)         Reception(),         # See increased demand         Coherence(),         # Stabilize         Dissonance(),        # Acknowledge capacity challenge         Mutation(),          # Adapt capacity         SelfOrganization(),  # Optimize operations         Silence(),           # Close self-organization         Coherence(),         # Stabilize higher throughput         Silence(),     ]          print(\"Manufacturer adapting to disruption...\")     run_sequence(G, \"Manufacturer_USA\", manufacturer_adaptation)          print(\"Activating backup supplier (Backup_India)...\")     run_sequence(G, \"Backup_India\", backup_activation)          # Establish new supply connection     G.add_edge(\"RawMaterial_Asia\", \"Backup_India\")     G.add_edge(\"Backup_India\", \"Manufacturer_USA\")     print(\"New supply route established: RawMaterial_Asia \u2192 Backup_India \u2192 Manufacturer\")     print()          print(\"Alternative supplier (Components_Mexico) scaling up...\")     run_sequence(G, \"Components_Mexico\", alternative_scaleup)     print()          # 5. RECOVERY SIMULATION     # -----------------------          print(\"Phase 4: Simulating recovery dynamics...\")     print()          # Run recovery period     run(G, steps=10, dt=0.1)          # 6. RESULTS INTERPRETATION     # --------------------------          print(\"=\" * 70)     print(\"RESULTS: Supply Chain Resilience Analysis\")     print(\"=\" * 70)     print()          # Compute final metrics (after recovery)     C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)     Si_final = compute_Si(G)          print(\"Supply Chain Metrics Timeline:\")     print(f\"  1. Baseline:      C(t) = {C_baseline:.3f}\")     print(f\"  2. Disruption:    C(t) = {C_disrupted:.3f} ({C_disrupted - C_baseline:+.3f})\")     print(f\"  3. Post-recovery: C(t) = {C_final:.3f} ({C_final - C_disrupted:+.3f})\")     print()     print(f\"  Net impact: \u0394C = {C_final - C_baseline:+.3f}\")     print(f\"  Recovery ratio: {(C_final - C_disrupted) / (C_baseline - C_disrupted) * 100:.1f}%\")     print()          print(\"Entity Resilience (Sense Index):\")     if isinstance(Si_final, dict):         for entity in sorted(Si_final.keys()):             si_val = Si_final[entity]             si_initial_val = Si_initial.get(entity, 0.0) if isinstance(Si_initial, dict) else 0.0             change = si_val - si_initial_val             desc_short = entities[entity].split('-')[0].strip()             print(f\"  {entity:25s} Si = {si_val:.3f} ({change:+.3f})  [{desc_short}]\")     else:         for idx, entity in enumerate(sorted(G.nodes())):             si_val = float(Si_final[idx]) if hasattr(Si_final, '__getitem__') else 0.0             change = 0.0             desc_short = entities[entity].split('-')[0].strip()             print(f\"  {entity:25s} Si = {si_val:.3f} ({change:+.3f})  [{desc_short}]\")     print()          # Business interpretation     print(\"=\" * 70)     print(\"BUSINESS INTERPRETATION\")     print(\"=\" * 70)     print()          # Recovery assessment     if C_final &gt;= C_baseline * 0.95:         recovery = \"FULL RECOVERY\"         status = \"Supply chain restored to normal operations\"     elif C_final &gt;= C_disrupted * 1.5:         recovery = \"STRONG RECOVERY\"         status = \"Supply chain adapted successfully\"     elif C_final &gt; C_disrupted:         recovery = \"PARTIAL RECOVERY\"         status = \"Some adaptation, but still impaired\"     else:         recovery = \"RECOVERY FAILURE\"         status = \"Unable to adapt to disruption\"          print(f\"1. Recovery Outcome: {recovery}\")     print(f\"   {status}\")     print()          # Identify resilient entities     if isinstance(Si_final, dict):         avg_si = sum(Si_final.values()) / len(Si_final)         resilient = [e for e, si in Si_final.items() if si &gt; avg_si * 1.1]     else:         avg_si = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0         resilient = []          print(f\"2. Most Resilient Entities (Si &gt; {avg_si * 1.1:.3f}):\")     for entity in resilient:         print(f\"   \u2022 {entity}: {entities[entity]}\")     print()          # Adaptation effectiveness     if \"Backup_India\" in G.nodes():         if isinstance(Si_final, dict):             backup_si = Si_final.get(\"Backup_India\", 0.0)         else:             backup_si = 0.0         if backup_si &gt; 0.5:             adaptation_status = \"SUCCESSFUL - Backup supplier integrated\"         else:             adaptation_status = \"PARTIAL - Backup integration incomplete\"     else:         adaptation_status = \"NO BACKUP ACTIVATION\"          print(f\"3. Adaptation Strategy: {adaptation_status}\")     print()          print(\"=\" * 70)     print(\"Key TNFR Insights:\")     print(\"=\" * 70)     print(\"\u2022 Supply chain entities = NFR nodes with operational EPI\")     print(\"\u2022 Disruption = Dissonance operator (creates instability)\")     print(\"\u2022 Adaptation = Mutation operator (explore alternatives)\")     print(\"\u2022 Resilience = High Si (ability to maintain coherence under stress)\")     print(\"\u2022 Recovery = Self-organization (find new equilibrium)\")     print(\"\u2022 Network coherence C(t) = Overall supply chain stability\")     print()     print(\"Resilience Principles:\")     print(\"  \u2022 Redundancy: Multiple suppliers \u2192 higher recovery capacity\")     print(\"  \u2022 Flexibility: High \u03bdf \u2192 faster adaptation to shocks\")     print(\"  \u2022 Coupling: Strong relationships \u2192 coordinated response\")     print(\"  \u2022 Si metric: Predicts which entities will fail under stress\")     print()     print(\"Business Implications:\")     print(\"  \u2713 Monitor Si to identify vulnerable supply chain nodes\")     print(\"  \u2713 Maintain backup suppliers (even if disconnected initially)\")     print(\"  \u2713 High \u03bdf entities recover faster (invest in flexibility)\")     print(\"  \u2713 Track C(t) as real-time supply chain health indicator\")     print(\"=\" * 70) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/urban_traffic_flow/","title":"Urban traffic flow","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nTitle: Urban Traffic Flow - Dynamic Traffic Signal Optimization\n\nProblem: Urban traffic systems face congestion, especially during rush hours\nand incidents. Static traffic light timing is inefficient. How can traffic\nsignals adapt dynamically to real-time conditions?\n\nTNFR Approach: Model intersections as NFR nodes where:\n- EPI represents traffic state (flow capacity, queue lengths)\n- \u03bdf (Hz_str) is adaptation speed (how fast signals can adjust)\n- Phase represents traffic light timing coordination\n- Transition operator models traffic light state changes\n- Dissonance represents congestion/bottlenecks\n- Coherence measures traffic flow smoothness\n\nKey Operators:\n- Transition (NAV): Traffic light phase transitions\n- Reception (EN): Monitor traffic sensors (volume, speed)\n- Emission (AL): Release traffic (green light)\n- Coupling (UM): Coordinate adjacent intersections\n- Dissonance (OZ): Congestion, traffic jams\n- Coherence (IL): Smooth traffic flow\n- Mutation (ZHIR): Adapt timing patterns to conditions\n\nRelevant Metrics:\n- C(t): Traffic coherence (flow smoothness)\n- Si: Intersection stability (consistent throughput)\n- Phase coherence: Signal coordination (green wave)\n- \u0394NFR: Congestion pressure\n\nExpected Behavior:\n- Initial uncoordinated signals (low C(t))\n- Traffic sensors provide feedback (Reception)\n- Signals adapt timing (Transition, Mutation)\n- Coordination emerges (phase alignment)\n- Congestion decreases (Dissonance \u2192 Coherence)\n- Final state shows smooth, coordinated flow\n\nRun:\n    python docs/source/examples/urban_traffic_flow.py\n\"\"\"\n</pre> \"\"\" Title: Urban Traffic Flow - Dynamic Traffic Signal Optimization  Problem: Urban traffic systems face congestion, especially during rush hours and incidents. Static traffic light timing is inefficient. How can traffic signals adapt dynamically to real-time conditions?  TNFR Approach: Model intersections as NFR nodes where: - EPI represents traffic state (flow capacity, queue lengths) - \u03bdf (Hz_str) is adaptation speed (how fast signals can adjust) - Phase represents traffic light timing coordination - Transition operator models traffic light state changes - Dissonance represents congestion/bottlenecks - Coherence measures traffic flow smoothness  Key Operators: - Transition (NAV): Traffic light phase transitions - Reception (EN): Monitor traffic sensors (volume, speed) - Emission (AL): Release traffic (green light) - Coupling (UM): Coordinate adjacent intersections - Dissonance (OZ): Congestion, traffic jams - Coherence (IL): Smooth traffic flow - Mutation (ZHIR): Adapt timing patterns to conditions  Relevant Metrics: - C(t): Traffic coherence (flow smoothness) - Si: Intersection stability (consistent throughput) - Phase coherence: Signal coordination (green wave) - \u0394NFR: Congestion pressure  Expected Behavior: - Initial uncoordinated signals (low C(t)) - Traffic sensors provide feedback (Reception) - Signals adapt timing (Transition, Mutation) - Coordination emerges (phase alignment) - Congestion decreases (Dissonance \u2192 Coherence) - Final state shows smooth, coordinated flow  Run:     python docs/source/examples/urban_traffic_flow.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr import create_nfr, run_sequence\nfrom tnfr.dynamics import run\nfrom tnfr.metrics import register_metrics_callbacks\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import (\n    Coherence,\n    Coupling,\n    Dissonance,\n    Emission,\n    Mutation,\n    Reception,\n    Resonance,\n    Silence,\n)\nfrom tnfr.trace import register_trace\nfrom tnfr.constants import inject_defaults\n</pre> from tnfr import create_nfr, run_sequence from tnfr.dynamics import run from tnfr.metrics import register_metrics_callbacks from tnfr.metrics.common import compute_coherence from tnfr.metrics.sense_index import compute_Si from tnfr.structural import (     Coherence,     Coupling,     Dissonance,     Emission,     Mutation,     Reception,     Resonance,     Silence, ) from tnfr.trace import register_trace from tnfr.constants import inject_defaults In\u00a0[\u00a0]: Copied! <pre>def run_example() -&gt; None:\n    \"\"\"Model adaptive traffic signal control using TNFR operators.\"\"\"\n    \n    print(\"=\" * 70)\n    print(\"TNFR Urban Traffic Flow: Dynamic Signal Optimization\")\n    print(\"=\" * 70)\n    print()\n    \n    # 1. PROBLEM SETUP: Creating urban traffic network\n    # -------------------------------------------------\n    # Scenario: 3x3 grid of intersections (9 total)\n    # Challenge: Morning rush hour - heavy traffic from residential to downtown\n    \n    print(\"Phase 1: Initializing urban traffic network...\")\n    print(\"Creating 9-intersection grid with traffic sensors\")\n    print()\n    \n    # Residential area intersections (light initial load)\n    G, _ = create_nfr(\n        \"Intersection_A1\",  # Northwest residential\n        epi=0.25,    # Moderate traffic capacity utilization\n        vf=1.0,      # Standard adaptation rate\n        theta=0.0    # Traffic signal phase\n    )\n    \n    create_nfr(\n        \"Intersection_A2\",\n        epi=0.28,\n        vf=1.05,\n        theta=0.5,   # Out of sync initially\n        graph=G\n    )\n    \n    create_nfr(\n        \"Intersection_A3\",\n        epi=0.22,\n        vf=0.95,\n        theta=-0.3,\n        graph=G\n    )\n    \n    # Mid-city intersections (moderate load)\n    create_nfr(\n        \"Intersection_B1\",\n        epi=0.35,    # Higher utilization\n        vf=1.1,\n        theta=0.8,\n        graph=G\n    )\n    \n    create_nfr(\n        \"Intersection_B2\",  # Central hub\n        epi=0.40,    # High traffic\n        vf=0.85,     # Slower adaptation (complex)\n        theta=1.2,\n        graph=G\n    )\n    \n    create_nfr(\n        \"Intersection_B3\",\n        epi=0.38,\n        vf=1.0,\n        theta=-0.6,\n        graph=G\n    )\n    \n    # Downtown intersections (heavy load during rush hour)\n    create_nfr(\n        \"Intersection_C1\",\n        epi=0.48,    # High congestion\n        vf=0.90,\n        theta=1.5,\n        graph=G\n    )\n    \n    create_nfr(\n        \"Intersection_C2\",\n        epi=0.52,    # Highest congestion\n        vf=0.80,     # Slowest adaptation (very complex)\n        theta=-1.0,\n        graph=G\n    )\n    \n    create_nfr(\n        \"Intersection_C3\",\n        epi=0.45,\n        vf=0.95,\n        theta=0.4,\n        graph=G\n    )\n    \n    # Establish traffic network topology (grid connections)\n    # Horizontal connections\n    G.add_edge(\"Intersection_A1\", \"Intersection_A2\")\n    G.add_edge(\"Intersection_A2\", \"Intersection_A3\")\n    G.add_edge(\"Intersection_B1\", \"Intersection_B2\")\n    G.add_edge(\"Intersection_B2\", \"Intersection_B3\")\n    G.add_edge(\"Intersection_C1\", \"Intersection_C2\")\n    G.add_edge(\"Intersection_C2\", \"Intersection_C3\")\n    \n    # Vertical connections\n    G.add_edge(\"Intersection_A1\", \"Intersection_B1\")\n    G.add_edge(\"Intersection_B1\", \"Intersection_C1\")\n    G.add_edge(\"Intersection_A2\", \"Intersection_B2\")\n    G.add_edge(\"Intersection_B2\", \"Intersection_C2\")\n    G.add_edge(\"Intersection_A3\", \"Intersection_B3\")\n    G.add_edge(\"Intersection_B3\", \"Intersection_C3\")\n    \n    # Store intersection metadata\n    locations = {\n        \"Intersection_A1\": \"Residential NW - Low traffic\",\n        \"Intersection_A2\": \"Residential N - Low traffic\",\n        \"Intersection_A3\": \"Residential NE - Low traffic\",\n        \"Intersection_B1\": \"Mid-city W - Moderate traffic\",\n        \"Intersection_B2\": \"Mid-city Center - High traffic\",\n        \"Intersection_B3\": \"Mid-city E - Moderate traffic\",\n        \"Intersection_C1\": \"Downtown SW - Heavy traffic\",\n        \"Intersection_C2\": \"Downtown Center - Heaviest traffic\",\n        \"Intersection_C3\": \"Downtown SE - Heavy traffic\",\n    }\n    \n    for node, location in locations.items():\n        G.nodes[node][\"location\"] = location\n    \n    # Inject required defaults for graph parameters\n    inject_defaults(G)\n    \n    # Measure initial state (before optimization)\n    C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)\n    Si_initial = compute_Si(G)\n    \n    print(\"Initial traffic state (BEFORE optimization):\")\n    print(f\"  C(t) = {C_initial:.3f} (traffic flow coherence)\")\n    print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (congestion pressure)\")\n    print(f\"  Grid: 3x3 intersections, {G.number_of_edges()} connections\")\n    print()\n    \n    # 2. TNFR MODELING: Traffic control strategies\n    # ---------------------------------------------\n    \n    print(\"Phase 2: Deploying adaptive traffic control strategies...\")\n    print()\n    \n    # Residential area: Simple timing adjustments\n    residential_control = [\n        Emission(),      # Release traffic (green light) - must start with emission\n        Reception(),     # Monitor traffic sensors\n        Coherence(),     # Maintain smooth flow\n        Silence(),\n    ]\n    \n    # Mid-city: Adaptive coordination with neighbors\n    midcity_control = [\n        Emission(),      # Release traffic (must start with emission)\n        Reception(),     # Monitor local traffic\n        Resonance(),     # Coordinate with neighbors\n        Coupling(),      # Synchronize phases\n        Coherence(),     # Stabilize flow\n        Silence(),\n    ]\n    \n    # Downtown: Aggressive optimization, handle congestion\n    downtown_control = [\n        Emission(),      # Maximize throughput (must start with emission)\n        Reception(),     # Monitor heavy traffic\n        Coherence(),     # Stabilize before applying dissonance\n        Dissonance(),    # Acknowledge congestion\n        Mutation(),      # Try alternative timing patterns\n        Coherence(),     # Stabilize after mutation\n        Resonance(),     # Propagate successful patterns\n        Coupling(),      # Coordinate with neighbors\n        Coherence(),     # Stabilize under load\n        Silence(),\n    ]\n    \n    # Central hub: Complex coordination\n    hub_control = [\n        Emission(),      # Release traffic (must start with emission)\n        Reception(),     # Monitor all directions\n        Coherence(),     # Stabilize before conflicts\n        Dissonance(),    # Handle conflicts\n        Mutation(),      # Explore timing options\n        Coherence(),     # Stabilize after mutation\n        Resonance(),     # Propagate optimization\n        Coupling(),      # Strong neighbor coordination\n        Coherence(),     # Stabilize complex flows\n        Silence(),\n    ]\n    \n    # 3. OPERATOR APPLICATION: Deploy traffic control\n    # ------------------------------------------------\n    \n    print(\"Applying control strategies by zone...\")\n    print()\n    \n    # Residential zone\n    for intersection in [\"Intersection_A1\", \"Intersection_A2\", \"Intersection_A3\"]:\n        run_sequence(G, intersection, residential_control)\n    print(\"\u2713 Residential zone optimized\")\n    \n    # Mid-city zone (except hub)\n    for intersection in [\"Intersection_B1\", \"Intersection_B3\"]:\n        run_sequence(G, intersection, midcity_control)\n    print(\"\u2713 Mid-city zone optimized\")\n    \n    # Central hub (special handling)\n    run_sequence(G, \"Intersection_B2\", hub_control)\n    print(\"\u2713 Central hub optimized\")\n    \n    # Downtown zone\n    for intersection in [\"Intersection_C1\", \"Intersection_C2\", \"Intersection_C3\"]:\n        run_sequence(G, intersection, downtown_control)\n    print(\"\u2713 Downtown zone optimized\")\n    print()\n    \n    # 4. SIMULATION: Run traffic dynamics\n    # ------------------------------------\n    \n    print(\"Phase 3: Simulating rush hour traffic dynamics...\")\n    print(\"(Multiple signal cycles with adaptive adjustments)\")\n    print()\n    \n    register_metrics_callbacks(G)\n    register_trace(G)\n    \n    # Run simulation: 12 time steps = ~12 signal cycles\n    run(G, steps=12, dt=0.1)\n    \n    # 5. RESULTS INTERPRETATION\n    # --------------------------\n    \n    print(\"=\" * 70)\n    print(\"RESULTS: Traffic Optimization Analysis\")\n    print(\"=\" * 70)\n    print()\n    \n    # Compute final metrics (after optimization)\n    C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)\n    Si_final = compute_Si(G)\n    \n    print(\"Network-Level Traffic Metrics:\")\n    print(f\"  Initial C(t) = {C_initial:.3f}\")\n    print(f\"  Final C(t) = {C_final:.3f}\")\n    print(f\"  Improvement: \u0394C = {C_final - C_initial:+.3f}\")\n    print(f\"  Congestion pressure: \u0394NFR = {dnfr_initial:.3f} \u2192 {dnfr_final:.3f}\")\n    print()\n    \n    print(\"Per-Intersection Performance:\")\n    print(f\"{'Intersection':&lt;20} {'Si (Stability)':&lt;18} {'Location'}\")\n    print(\"-\" * 70)\n    if isinstance(Si_final, dict):\n        for intersection in sorted(Si_final.keys()):\n            si_val = Si_final[intersection]\n            si_initial_val = Si_initial.get(intersection, 0.0) if isinstance(Si_initial, dict) else 0.0\n            change = si_val - si_initial_val\n            loc_short = locations[intersection].split('-')[0].strip()\n            print(f\"{intersection:&lt;20} {si_val:.3f} ({change:+.3f})         {loc_short}\")\n    else:\n        for idx, intersection in enumerate(sorted(G.nodes())):\n            si_val = float(Si_final[idx]) if hasattr(Si_final, '__getitem__') else 0.0\n            change = 0.0\n            loc_short = locations[intersection].split('-')[0].strip()\n            print(f\"{intersection:&lt;20} {si_val:.3f} ({change:+.3f})         {loc_short}\")\n    print()\n    \n    # Urban planning interpretation\n    print(\"=\" * 70)\n    print(\"URBAN PLANNING INTERPRETATION\")\n    print(\"=\" * 70)\n    print()\n    \n    # Traffic flow assessment\n    if C_final &gt; 0.65:\n        flow_status = \"EXCELLENT FLOW\"\n        description = \"Signals well-coordinated, minimal congestion\"\n    elif C_final &gt; 0.45:\n        flow_status = \"GOOD FLOW\"\n        description = \"Most signals coordinated, some congestion\"\n    elif C_final &gt; C_initial:\n        flow_status = \"IMPROVED FLOW\"\n        description = \"Better than initial, but optimization ongoing\"\n    else:\n        flow_status = \"POOR FLOW\"\n        description = \"Optimization ineffective, congestion persists\"\n    \n    print(f\"1. Traffic Flow Status: {flow_status}\")\n    print(f\"   {description}\")\n    print(f\"   C(t) improvement: {(C_final - C_initial) / C_initial * 100:+.1f}%\")\n    print()\n    \n    # Identify problem intersections\n    if isinstance(Si_final, dict):\n        avg_si = sum(Si_final.values()) / len(Si_final)\n        problem_intersections = [i for i, si in Si_final.items() if si &lt; avg_si * 0.8]\n    else:\n        avg_si = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0\n        problem_intersections = []\n    \n    if problem_intersections:\n        print(f\"2. Problem Intersections (Si &lt; {avg_si * 0.8:.3f}):\")\n        for intersection in problem_intersections:\n            print(f\"   \u2022 {intersection}: {locations[intersection]}\")\n        print(\"   \u2192 Recommendation: Increase green time or add turn lanes\")\n    else:\n        print(\"2. \u2713 No critical problem intersections identified\")\n    print()\n    \n    # Coordination effectiveness\n    downtown_intersections = [\"Intersection_C1\", \"Intersection_C2\", \"Intersection_C3\"]\n    if isinstance(Si_final, dict):\n        downtown_avg_si = sum(Si_final.get(i, 0.0) for i in downtown_intersections) / len(downtown_intersections)\n    else:\n        downtown_avg_si = avg_si\n    \n    if downtown_avg_si &gt; avg_si:\n        coord_status = \"Downtown coordination SUCCESSFUL\"\n    else:\n        coord_status = \"Downtown needs further optimization\"\n    \n    print(f\"3. Downtown Corridor: {coord_status}\")\n    print(f\"   Average Si = {downtown_avg_si:.3f} (network avg = {avg_si:.3f})\")\n    print()\n    \n    # Congestion reduction\n    if abs(dnfr_initial) &gt; 0.001:\n        congestion_reduction = (dnfr_initial - dnfr_final) / abs(dnfr_initial) * 100\n        print(f\"4. Congestion Reduction: {congestion_reduction:.1f}%\")\n        if congestion_reduction &gt; 30:\n            print(\"   \u2713 Significant improvement in traffic flow\")\n        elif congestion_reduction &gt; 10:\n            print(\"   ~ Moderate improvement, continue optimization\")\n        else:\n            print(\"   \u26a0 Limited improvement, consider infrastructure changes\")\n    else:\n        print(f\"4. Congestion Status: Initial \u0394NFR was near zero (baseline: {dnfr_initial:.3f}, final: {dnfr_final:.3f})\")\n        if abs(dnfr_final) &lt; abs(dnfr_initial):\n            print(\"   \u2713 System maintained low congestion levels\")\n        else:\n            print(\"   ~ Congestion increased slightly\")\n    print()\n    \n    print(\"=\" * 70)\n    print(\"Key TNFR Insights:\")\n    print(\"=\" * 70)\n    print(\"\u2022 Intersections = NFR nodes with traffic state (EPI)\")\n    print(\"\u2022 Traffic signals = Emission operator (release vehicles)\")\n    print(\"\u2022 Sensor monitoring = Reception operator (gather data)\")\n    print(\"\u2022 Signal timing = Transition operator (phase changes)\")\n    print(\"\u2022 Coordination = Coupling + phase alignment (green wave)\")\n    print(\"\u2022 Congestion = Dissonance operator (flow breakdown)\")\n    print(\"\u2022 Adaptive timing = Mutation operator (pattern exploration)\")\n    print(\"\u2022 Flow coherence C(t) = Smoothness of traffic movement\")\n    print()\n    print(\"Traffic Engineering Principles:\")\n    print(\"  \u2022 High C(t) = coordinated signals, smooth flow\")\n    print(\"  \u2022 Low \u0394NFR = minimal congestion pressure\")\n    print(\"  \u2022 Phase alignment = green wave progression\")\n    print(\"  \u2022 High Si = stable throughput (good signal timing)\")\n    print()\n    print(\"Optimization Strategies:\")\n    print(\"  \u2713 Adaptive signals (high \u03bdf) respond faster to conditions\")\n    print(\"  \u2713 Coupling enables coordination (synchronized corridors)\")\n    print(\"  \u2713 Mutation explores timing alternatives under congestion\")\n    print(\"  \u2713 Monitor C(t) in real-time to detect emerging congestion\")\n    print(\"  \u2713 Low Si intersections need infrastructure investment\")\n    print()\n    print(\"Real-World Applications:\")\n    print(\"  \u2022 Predict congestion before it occurs (falling C(t))\")\n    print(\"  \u2022 Identify which intersections to upgrade (low Si)\")\n    print(\"  \u2022 Optimize signal timing without simulation (\u0394NFR-driven)\")\n    print(\"  \u2022 Coordinate emergency vehicle routing (phase manipulation)\")\n    print(\"=\" * 70)\n</pre> def run_example() -&gt; None:     \"\"\"Model adaptive traffic signal control using TNFR operators.\"\"\"          print(\"=\" * 70)     print(\"TNFR Urban Traffic Flow: Dynamic Signal Optimization\")     print(\"=\" * 70)     print()          # 1. PROBLEM SETUP: Creating urban traffic network     # -------------------------------------------------     # Scenario: 3x3 grid of intersections (9 total)     # Challenge: Morning rush hour - heavy traffic from residential to downtown          print(\"Phase 1: Initializing urban traffic network...\")     print(\"Creating 9-intersection grid with traffic sensors\")     print()          # Residential area intersections (light initial load)     G, _ = create_nfr(         \"Intersection_A1\",  # Northwest residential         epi=0.25,    # Moderate traffic capacity utilization         vf=1.0,      # Standard adaptation rate         theta=0.0    # Traffic signal phase     )          create_nfr(         \"Intersection_A2\",         epi=0.28,         vf=1.05,         theta=0.5,   # Out of sync initially         graph=G     )          create_nfr(         \"Intersection_A3\",         epi=0.22,         vf=0.95,         theta=-0.3,         graph=G     )          # Mid-city intersections (moderate load)     create_nfr(         \"Intersection_B1\",         epi=0.35,    # Higher utilization         vf=1.1,         theta=0.8,         graph=G     )          create_nfr(         \"Intersection_B2\",  # Central hub         epi=0.40,    # High traffic         vf=0.85,     # Slower adaptation (complex)         theta=1.2,         graph=G     )          create_nfr(         \"Intersection_B3\",         epi=0.38,         vf=1.0,         theta=-0.6,         graph=G     )          # Downtown intersections (heavy load during rush hour)     create_nfr(         \"Intersection_C1\",         epi=0.48,    # High congestion         vf=0.90,         theta=1.5,         graph=G     )          create_nfr(         \"Intersection_C2\",         epi=0.52,    # Highest congestion         vf=0.80,     # Slowest adaptation (very complex)         theta=-1.0,         graph=G     )          create_nfr(         \"Intersection_C3\",         epi=0.45,         vf=0.95,         theta=0.4,         graph=G     )          # Establish traffic network topology (grid connections)     # Horizontal connections     G.add_edge(\"Intersection_A1\", \"Intersection_A2\")     G.add_edge(\"Intersection_A2\", \"Intersection_A3\")     G.add_edge(\"Intersection_B1\", \"Intersection_B2\")     G.add_edge(\"Intersection_B2\", \"Intersection_B3\")     G.add_edge(\"Intersection_C1\", \"Intersection_C2\")     G.add_edge(\"Intersection_C2\", \"Intersection_C3\")          # Vertical connections     G.add_edge(\"Intersection_A1\", \"Intersection_B1\")     G.add_edge(\"Intersection_B1\", \"Intersection_C1\")     G.add_edge(\"Intersection_A2\", \"Intersection_B2\")     G.add_edge(\"Intersection_B2\", \"Intersection_C2\")     G.add_edge(\"Intersection_A3\", \"Intersection_B3\")     G.add_edge(\"Intersection_B3\", \"Intersection_C3\")          # Store intersection metadata     locations = {         \"Intersection_A1\": \"Residential NW - Low traffic\",         \"Intersection_A2\": \"Residential N - Low traffic\",         \"Intersection_A3\": \"Residential NE - Low traffic\",         \"Intersection_B1\": \"Mid-city W - Moderate traffic\",         \"Intersection_B2\": \"Mid-city Center - High traffic\",         \"Intersection_B3\": \"Mid-city E - Moderate traffic\",         \"Intersection_C1\": \"Downtown SW - Heavy traffic\",         \"Intersection_C2\": \"Downtown Center - Heaviest traffic\",         \"Intersection_C3\": \"Downtown SE - Heavy traffic\",     }          for node, location in locations.items():         G.nodes[node][\"location\"] = location          # Inject required defaults for graph parameters     inject_defaults(G)          # Measure initial state (before optimization)     C_initial, dnfr_initial, _ = compute_coherence(G, return_means=True)     Si_initial = compute_Si(G)          print(\"Initial traffic state (BEFORE optimization):\")     print(f\"  C(t) = {C_initial:.3f} (traffic flow coherence)\")     print(f\"  Mean \u0394NFR = {dnfr_initial:.3f} (congestion pressure)\")     print(f\"  Grid: 3x3 intersections, {G.number_of_edges()} connections\")     print()          # 2. TNFR MODELING: Traffic control strategies     # ---------------------------------------------          print(\"Phase 2: Deploying adaptive traffic control strategies...\")     print()          # Residential area: Simple timing adjustments     residential_control = [         Emission(),      # Release traffic (green light) - must start with emission         Reception(),     # Monitor traffic sensors         Coherence(),     # Maintain smooth flow         Silence(),     ]          # Mid-city: Adaptive coordination with neighbors     midcity_control = [         Emission(),      # Release traffic (must start with emission)         Reception(),     # Monitor local traffic         Resonance(),     # Coordinate with neighbors         Coupling(),      # Synchronize phases         Coherence(),     # Stabilize flow         Silence(),     ]          # Downtown: Aggressive optimization, handle congestion     downtown_control = [         Emission(),      # Maximize throughput (must start with emission)         Reception(),     # Monitor heavy traffic         Coherence(),     # Stabilize before applying dissonance         Dissonance(),    # Acknowledge congestion         Mutation(),      # Try alternative timing patterns         Coherence(),     # Stabilize after mutation         Resonance(),     # Propagate successful patterns         Coupling(),      # Coordinate with neighbors         Coherence(),     # Stabilize under load         Silence(),     ]          # Central hub: Complex coordination     hub_control = [         Emission(),      # Release traffic (must start with emission)         Reception(),     # Monitor all directions         Coherence(),     # Stabilize before conflicts         Dissonance(),    # Handle conflicts         Mutation(),      # Explore timing options         Coherence(),     # Stabilize after mutation         Resonance(),     # Propagate optimization         Coupling(),      # Strong neighbor coordination         Coherence(),     # Stabilize complex flows         Silence(),     ]          # 3. OPERATOR APPLICATION: Deploy traffic control     # ------------------------------------------------          print(\"Applying control strategies by zone...\")     print()          # Residential zone     for intersection in [\"Intersection_A1\", \"Intersection_A2\", \"Intersection_A3\"]:         run_sequence(G, intersection, residential_control)     print(\"\u2713 Residential zone optimized\")          # Mid-city zone (except hub)     for intersection in [\"Intersection_B1\", \"Intersection_B3\"]:         run_sequence(G, intersection, midcity_control)     print(\"\u2713 Mid-city zone optimized\")          # Central hub (special handling)     run_sequence(G, \"Intersection_B2\", hub_control)     print(\"\u2713 Central hub optimized\")          # Downtown zone     for intersection in [\"Intersection_C1\", \"Intersection_C2\", \"Intersection_C3\"]:         run_sequence(G, intersection, downtown_control)     print(\"\u2713 Downtown zone optimized\")     print()          # 4. SIMULATION: Run traffic dynamics     # ------------------------------------          print(\"Phase 3: Simulating rush hour traffic dynamics...\")     print(\"(Multiple signal cycles with adaptive adjustments)\")     print()          register_metrics_callbacks(G)     register_trace(G)          # Run simulation: 12 time steps = ~12 signal cycles     run(G, steps=12, dt=0.1)          # 5. RESULTS INTERPRETATION     # --------------------------          print(\"=\" * 70)     print(\"RESULTS: Traffic Optimization Analysis\")     print(\"=\" * 70)     print()          # Compute final metrics (after optimization)     C_final, dnfr_final, depi_final = compute_coherence(G, return_means=True)     Si_final = compute_Si(G)          print(\"Network-Level Traffic Metrics:\")     print(f\"  Initial C(t) = {C_initial:.3f}\")     print(f\"  Final C(t) = {C_final:.3f}\")     print(f\"  Improvement: \u0394C = {C_final - C_initial:+.3f}\")     print(f\"  Congestion pressure: \u0394NFR = {dnfr_initial:.3f} \u2192 {dnfr_final:.3f}\")     print()          print(\"Per-Intersection Performance:\")     print(f\"{'Intersection':&lt;20} {'Si (Stability)':&lt;18} {'Location'}\")     print(\"-\" * 70)     if isinstance(Si_final, dict):         for intersection in sorted(Si_final.keys()):             si_val = Si_final[intersection]             si_initial_val = Si_initial.get(intersection, 0.0) if isinstance(Si_initial, dict) else 0.0             change = si_val - si_initial_val             loc_short = locations[intersection].split('-')[0].strip()             print(f\"{intersection:&lt;20} {si_val:.3f} ({change:+.3f})         {loc_short}\")     else:         for idx, intersection in enumerate(sorted(G.nodes())):             si_val = float(Si_final[idx]) if hasattr(Si_final, '__getitem__') else 0.0             change = 0.0             loc_short = locations[intersection].split('-')[0].strip()             print(f\"{intersection:&lt;20} {si_val:.3f} ({change:+.3f})         {loc_short}\")     print()          # Urban planning interpretation     print(\"=\" * 70)     print(\"URBAN PLANNING INTERPRETATION\")     print(\"=\" * 70)     print()          # Traffic flow assessment     if C_final &gt; 0.65:         flow_status = \"EXCELLENT FLOW\"         description = \"Signals well-coordinated, minimal congestion\"     elif C_final &gt; 0.45:         flow_status = \"GOOD FLOW\"         description = \"Most signals coordinated, some congestion\"     elif C_final &gt; C_initial:         flow_status = \"IMPROVED FLOW\"         description = \"Better than initial, but optimization ongoing\"     else:         flow_status = \"POOR FLOW\"         description = \"Optimization ineffective, congestion persists\"          print(f\"1. Traffic Flow Status: {flow_status}\")     print(f\"   {description}\")     print(f\"   C(t) improvement: {(C_final - C_initial) / C_initial * 100:+.1f}%\")     print()          # Identify problem intersections     if isinstance(Si_final, dict):         avg_si = sum(Si_final.values()) / len(Si_final)         problem_intersections = [i for i, si in Si_final.items() if si &lt; avg_si * 0.8]     else:         avg_si = float(Si_final.mean()) if hasattr(Si_final, 'mean') else 0.0         problem_intersections = []          if problem_intersections:         print(f\"2. Problem Intersections (Si &lt; {avg_si * 0.8:.3f}):\")         for intersection in problem_intersections:             print(f\"   \u2022 {intersection}: {locations[intersection]}\")         print(\"   \u2192 Recommendation: Increase green time or add turn lanes\")     else:         print(\"2. \u2713 No critical problem intersections identified\")     print()          # Coordination effectiveness     downtown_intersections = [\"Intersection_C1\", \"Intersection_C2\", \"Intersection_C3\"]     if isinstance(Si_final, dict):         downtown_avg_si = sum(Si_final.get(i, 0.0) for i in downtown_intersections) / len(downtown_intersections)     else:         downtown_avg_si = avg_si          if downtown_avg_si &gt; avg_si:         coord_status = \"Downtown coordination SUCCESSFUL\"     else:         coord_status = \"Downtown needs further optimization\"          print(f\"3. Downtown Corridor: {coord_status}\")     print(f\"   Average Si = {downtown_avg_si:.3f} (network avg = {avg_si:.3f})\")     print()          # Congestion reduction     if abs(dnfr_initial) &gt; 0.001:         congestion_reduction = (dnfr_initial - dnfr_final) / abs(dnfr_initial) * 100         print(f\"4. Congestion Reduction: {congestion_reduction:.1f}%\")         if congestion_reduction &gt; 30:             print(\"   \u2713 Significant improvement in traffic flow\")         elif congestion_reduction &gt; 10:             print(\"   ~ Moderate improvement, continue optimization\")         else:             print(\"   \u26a0 Limited improvement, consider infrastructure changes\")     else:         print(f\"4. Congestion Status: Initial \u0394NFR was near zero (baseline: {dnfr_initial:.3f}, final: {dnfr_final:.3f})\")         if abs(dnfr_final) &lt; abs(dnfr_initial):             print(\"   \u2713 System maintained low congestion levels\")         else:             print(\"   ~ Congestion increased slightly\")     print()          print(\"=\" * 70)     print(\"Key TNFR Insights:\")     print(\"=\" * 70)     print(\"\u2022 Intersections = NFR nodes with traffic state (EPI)\")     print(\"\u2022 Traffic signals = Emission operator (release vehicles)\")     print(\"\u2022 Sensor monitoring = Reception operator (gather data)\")     print(\"\u2022 Signal timing = Transition operator (phase changes)\")     print(\"\u2022 Coordination = Coupling + phase alignment (green wave)\")     print(\"\u2022 Congestion = Dissonance operator (flow breakdown)\")     print(\"\u2022 Adaptive timing = Mutation operator (pattern exploration)\")     print(\"\u2022 Flow coherence C(t) = Smoothness of traffic movement\")     print()     print(\"Traffic Engineering Principles:\")     print(\"  \u2022 High C(t) = coordinated signals, smooth flow\")     print(\"  \u2022 Low \u0394NFR = minimal congestion pressure\")     print(\"  \u2022 Phase alignment = green wave progression\")     print(\"  \u2022 High Si = stable throughput (good signal timing)\")     print()     print(\"Optimization Strategies:\")     print(\"  \u2713 Adaptive signals (high \u03bdf) respond faster to conditions\")     print(\"  \u2713 Coupling enables coordination (synchronized corridors)\")     print(\"  \u2713 Mutation explores timing alternatives under congestion\")     print(\"  \u2713 Monitor C(t) in real-time to detect emerging congestion\")     print(\"  \u2713 Low Si intersections need infrastructure investment\")     print()     print(\"Real-World Applications:\")     print(\"  \u2022 Predict congestion before it occurs (falling C(t))\")     print(\"  \u2022 Identify which intersections to upgrade (low Si)\")     print(\"  \u2022 Optimize signal timing without simulation (\u0394NFR-driven)\")     print(\"  \u2022 Coordinate emergency vehicle routing (phase manipulation)\")     print(\"=\" * 70) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    run_example()\n</pre> if __name__ == \"__main__\":     run_example()"},{"location":"examples/worked_examples/","title":"Worked Examples: TNFR Calculations Step-by-Step","text":"<p>This document provides detailed, step-by-step walkthroughs of key TNFR calculations, showing both the mathematical derivation and Python implementation.</p>"},{"location":"examples/worked_examples/#purpose","title":"Purpose","text":"<p>These worked examples serve to:</p> <ol> <li>Bridge theory and practice: Show how mathematical formulas translate to code</li> <li>Verify correctness: Provide test cases with expected results</li> <li>Build intuition: Demonstrate how structural parameters interact</li> <li>Enable debugging: Offer reference calculations for troubleshooting</li> </ol>"},{"location":"examples/worked_examples/#example-1-computing-sense-index-si-for-a-single-node","title":"Example 1: Computing Sense Index (Si) for a Single Node","text":""},{"location":"examples/worked_examples/#overview","title":"Overview","text":"<p>The Sense Index ((\\text{Si})) quantifies a node's capacity for stable reorganization. It combines three structural signals:</p> <ul> <li>(\\nu_f): How fast the node reorganizes (structural frequency)</li> <li>(\\theta): How synchronized it is with neighbors (phase coupling)</li> <li>(\\Delta\\text{NFR}): How much reorganization pressure it experiences</li> </ul>"},{"location":"examples/worked_examples/#mathematical-definition","title":"Mathematical Definition","text":"<p>[ \\text{Si} = \\alpha \\cdot \\nu_{f,\\text{norm}} + \\beta \\cdot (1 - \\text{disp}\\theta) + \\gamma \\cdot (1 - |\\Delta\\text{NFR}|) ]}</p> <p>Where: - (\\nu_{f,\\text{norm}} = \\frac{|\\nu_f|}{\\nu_{f,\\max}}): Normalized structural frequency - (\\text{disp}\\theta = \\frac{|\\theta - \\bar{\\theta}|}{\\pi}): Phase dispersion from neighbor mean - (|\\Delta\\text{NFR}|): Normalized reorganization magnitude - (\\alpha, \\beta, \\gamma): Structural weights with (\\alpha + \\beta + \\gamma = 1)}} = \\frac{|\\Delta\\text{NFR}|}{\\Delta\\text{NFR}_{\\max}</p>"},{"location":"examples/worked_examples/#input-data","title":"Input Data","text":"<pre><code>import numpy as np\n\n# Node structural state\nnode_data = {\n    \"nu_f\": 0.8,           # Hz_str (structural frequency)\n    \"delta_nfr\": 0.2,      # Reorganization gradient\n    \"phase\": 0.5,          # radians\n    \"neighbors\": [\"n1\", \"n2\"],\n    \"neighbor_phases\": [0.4, 0.6]  # radians\n}\n\n# Structural weights (default TNFR configuration)\nweights = {\n    \"alpha\": 0.4,   # Frequency weight\n    \"beta\": 0.3,    # Phase coupling weight\n    \"gamma\": 0.3    # \u0394NFR damping weight\n}\n\n# Normalization limits\nmax_values = {\n    \"vfmax\": 1.0,      # Maximum structural frequency in network\n    \"dnfrmax\": 1.0     # Maximum |\u0394NFR| in network\n}\n</code></pre>"},{"location":"examples/worked_examples/#step-1-normalize-structural-frequency","title":"Step 1: Normalize Structural Frequency","text":"<p>Formula: [ \\nu_{f,\\text{norm}} = \\frac{|\\nu_f|}{\\nu_{f,\\max}} ]</p> <p>Calculation: [ \\nu_{f,\\text{norm}} = \\frac{|0.8|}{1.0} = \\frac{0.8}{1.0} = 0.8 ]</p> <p>Python: <pre><code>vf_norm = abs(node_data[\"nu_f\"]) / max_values[\"vfmax\"]\nprint(f\"Step 1: vf_norm = {vf_norm}\")\n# Output: Step 1: vf_norm = 0.8\n</code></pre></p>"},{"location":"examples/worked_examples/#step-2-compute-phase-dispersion","title":"Step 2: Compute Phase Dispersion","text":"<p>Phase mean (circular average using atan2): [ \\bar{\\theta} = \\text{atan2}\\left(\\sum_{j \\in \\text{neighbors}} \\sin\\theta_j, \\sum_{j \\in \\text{neighbors}} \\cos\\theta_j\\right) ]</p> <p>Calculation: <pre><code>neighbor_phases = np.array([0.4, 0.6])\n\n# Compute circular mean\ncos_sum = np.sum(np.cos(neighbor_phases))\nsin_sum = np.sum(np.sin(neighbor_phases))\ntheta_bar = np.arctan2(sin_sum, cos_sum)\n\nprint(f\"cos_sum = {cos_sum:.6f}\")\nprint(f\"sin_sum = {sin_sum:.6f}\")\nprint(f\"theta_bar = {theta_bar:.6f} rad\")\n</code></pre></p> <p>Numerical values: [ \\begin{aligned} \\sum \\cos\\theta_j &amp;= \\cos(0.4) + \\cos(0.6) \\approx 0.9211 + 0.8253 = 1.7464 \\ \\sum \\sin\\theta_j &amp;= \\sin(0.4) + \\sin(0.6) \\approx 0.3894 + 0.5646 = 0.9540 \\ \\bar{\\theta} &amp;= \\text{atan2}(0.9540, 1.7464) \\approx 0.500 \\text{ rad} \\end{aligned} ]</p> <p>Phase dispersion (normalized to ([0, 1])): [ \\text{disp}_\\theta = \\frac{|\\theta - \\bar{\\theta}|}{\\pi} = \\frac{|0.5 - 0.500|}{\\pi} \\approx \\frac{0.0}{\\pi} = 0.0 ]</p> <p>Python: <pre><code>phase_dispersion = abs(node_data[\"phase\"] - theta_bar) / np.pi\nprint(f\"Step 2: phase_dispersion = {phase_dispersion:.6f}\")\n# Output: Step 2: phase_dispersion = 0.000000\n</code></pre></p>"},{"location":"examples/worked_examples/#step-3-normalize-reorganization-gradient","title":"Step 3: Normalize Reorganization Gradient","text":"<p>Formula: [ |\\Delta\\text{NFR}|{\\text{norm}} = \\frac{|\\Delta\\text{NFR}|}{\\Delta\\text{NFR} ]}</p> <p>Calculation: [ |\\Delta\\text{NFR}|_{\\text{norm}} = \\frac{|0.2|}{1.0} = 0.2 ]</p> <p>Python: <pre><code>dnfr_norm = abs(node_data[\"delta_nfr\"]) / max_values[\"dnfrmax\"]\nprint(f\"Step 3: dnfr_norm = {dnfr_norm}\")\n# Output: Step 3: dnfr_norm = 0.2\n</code></pre></p>"},{"location":"examples/worked_examples/#step-4-combine-components","title":"Step 4: Combine Components","text":"<p>Formula: [ \\text{Si} = \\alpha \\cdot \\nu_{f,\\text{norm}} + \\beta \\cdot (1 - \\text{disp}\\theta) + \\gamma \\cdot (1 - |\\Delta\\text{NFR}|) ]}</p> <p>Substituting values: [ \\begin{aligned} \\text{Si} &amp;= 0.4 \\cdot 0.8 + 0.3 \\cdot (1 - 0.0) + 0.3 \\cdot (1 - 0.2) \\ &amp;= 0.4 \\cdot 0.8 + 0.3 \\cdot 1.0 + 0.3 \\cdot 0.8 \\ &amp;= 0.32 + 0.30 + 0.24 \\ &amp;= 0.86 \\end{aligned} ]</p> <p>Python: <pre><code>Si = (weights[\"alpha\"] * vf_norm +\n      weights[\"beta\"] * (1.0 - phase_dispersion) +\n      weights[\"gamma\"] * (1.0 - dnfr_norm))\n\nprint(f\"\\nStep 4: Si components\")\nprint(f\"  alpha * vf_norm           = {weights['alpha']} * {vf_norm} = {weights['alpha'] * vf_norm}\")\nprint(f\"  beta * (1 - disp_theta)   = {weights['beta']} * {1.0 - phase_dispersion} = {weights['beta'] * (1.0 - phase_dispersion)}\")\nprint(f\"  gamma * (1 - dnfr_norm)   = {weights['gamma']} * {1.0 - dnfr_norm} = {weights['gamma'] * (1.0 - dnfr_norm)}\")\nprint(f\"  Si (before clamp)         = {Si}\")\n</code></pre></p>"},{"location":"examples/worked_examples/#step-5-clamp-to-valid-range","title":"Step 5: Clamp to Valid Range","text":"<p>TNFR implementation clamps Si to ([0, 1]) to ensure bounded metrics:</p> <p>[ \\text{Si}_{\\text{final}} = \\max(0, \\min(1, \\text{Si})) ]</p> <p>For our example: [ \\text{Si}_{\\text{final}} = \\max(0, \\min(1, 0.86)) = 0.86 ]</p> <p>Python: <pre><code>def clamp01(x):\n    \"\"\"Clamp value to [0, 1].\"\"\"\n    return max(0.0, min(1.0, x))\n\nSi_final = clamp01(Si)\nprint(f\"Step 5: Si_final = {Si_final}\")\n# Output: Step 5: Si_final = 0.86\n</code></pre></p>"},{"location":"examples/worked_examples/#verification-with-implementation","title":"Verification with Implementation","text":"<pre><code>import networkx as nx\nfrom tnfr.metrics.sense_index import compute_Si\n\n# Create a minimal network matching our example\nG = nx.Graph()\nG.add_edge(\"n0\", \"n1\")\nG.add_edge(\"n0\", \"n2\")\n\n# Set node attributes\nG.nodes[\"n0\"].update({\n    \"nu_f\": 0.8,\n    \"delta_nfr\": 0.2,\n    \"phase\": 0.5\n})\nG.nodes[\"n1\"][\"phase\"] = 0.4\nG.nodes[\"n2\"][\"phase\"] = 0.6\n\n# Set global Si weights\nG.graph[\"SI_WEIGHTS\"] = {\"alpha\": 0.4, \"beta\": 0.3, \"gamma\": 0.3}\n\n# Compute Si using TNFR implementation\nSi_result = compute_Si(G, vfmax=1.0, dnfrmax=1.0, inplace=False)\n\nprint(f\"\\n\u2705 Verification:\")\nprint(f\"  Manual calculation:   Si = {Si_final}\")\nprint(f\"  TNFR implementation:  Si = {Si_result['n0']:.6f}\")\nprint(f\"  Match: {abs(Si_final - Si_result['n0']) &lt; 1e-6}\")\n</code></pre> <p>Expected output: <pre><code>\u2705 Verification:\n  Manual calculation:   Si = 0.86\n  TNFR implementation:  Si = 0.860000\n  Match: True\n</code></pre></p>"},{"location":"examples/worked_examples/#interpretation","title":"Interpretation","text":"<p>What does Si = 0.86 mean?</p> <ul> <li>High value (close to 1): This node has excellent reorganization stability</li> <li>Breakdown:</li> <li>Frequency contribution (0.32): Strong reorganization capacity ((\\nu_f = 0.8))</li> <li>Phase contribution (0.30): Perfect synchrony with neighbors ((\\text{disp}_\\theta = 0))</li> <li>\u0394NFR contribution (0.24): Low reorganization pressure ((\\Delta\\text{NFR} = 0.2))</li> </ul> <p>Physical meaning: This node can reorganize quickly ((\\nu_f = 0.8)), stays synchronized with its network ((\\theta \\approx \\bar{\\theta})), and experiences manageable structural pressure ((\\Delta\\text{NFR} = 0.2)). It's a stable, well-integrated node.</p>"},{"location":"examples/worked_examples/#example-2-computing-coherence-matrix-elements","title":"Example 2: Computing Coherence Matrix Elements","text":""},{"location":"examples/worked_examples/#overview_1","title":"Overview","text":"<p>The coherence matrix (W) approximates the coherence operator (\\hat{C}) in the discrete node basis. Each element (w_{ij}) measures structural similarity between nodes (i) and (j).</p>"},{"location":"examples/worked_examples/#mathematical-definition_1","title":"Mathematical Definition","text":"<p>Matrix element: [ w_{ij} \\approx \\langle i | \\hat{C} | j \\rangle ]</p> <p>Computed as weighted similarity: [ w_{ij} = w_{\\text{phase}} \\cdot s_{\\text{phase}}(i,j) + w_{\\text{EPI}} \\cdot s_{\\text{EPI}}(i,j) + w_{\\nu_f} \\cdot s_{\\nu_f}(i,j) + w_{\\text{Si}} \\cdot s_{\\text{Si}}(i,j) ]</p> <p>Similarity components: [ \\begin{aligned} s_{\\text{phase}}(i,j) &amp;= \\frac{1}{2}\\left(1 + \\cos(\\theta_i - \\theta_j)\\right) \\ s_{\\text{EPI}}(i,j) &amp;= 1 - \\frac{|\\text{EPI}i - \\text{EPI}_j|}{\\Delta \\ s_{\\nu_f}(i,j) &amp;= 1 - \\frac{|\\nu_{f,i} - \\nu_{f,j}|}{\\Delta_{\\nu_f}} \\ s_{\\text{Si}}(i,j) &amp;= 1 - |\\text{Si}_i - \\text{Si}_j| \\end{aligned} ]}}</p>"},{"location":"examples/worked_examples/#input-data_1","title":"Input Data","text":"<pre><code>import math\n\n# Two nodes with structural state\nnode_i = {\n    \"EPI\": 0.5,\n    \"nu_f\": 0.8,\n    \"phase\": 0.0,\n    \"Si\": 0.7\n}\n\nnode_j = {\n    \"EPI\": 0.6,\n    \"nu_f\": 0.7,\n    \"phase\": 0.1,\n    \"Si\": 0.8\n}\n\n# Network ranges (for normalization)\nranges = {\n    \"EPI_max\": 1.0,\n    \"EPI_min\": 0.0,\n    \"vf_max\": 1.0,\n    \"vf_min\": 0.0\n}\n\n# Coherence weights (default)\nweights = {\n    \"phase\": 0.25,\n    \"epi\": 0.25,\n    \"vf\": 0.25,\n    \"si\": 0.25\n}\n</code></pre>"},{"location":"examples/worked_examples/#step-1-compute-phase-similarity","title":"Step 1: Compute Phase Similarity","text":"<p>Formula: [ s_{\\text{phase}}(i,j) = \\frac{1}{2}\\left(1 + \\cos(\\theta_i - \\theta_j)\\right) ]</p> <p>Calculation: [ \\begin{aligned} \\theta_i - \\theta_j &amp;= 0.0 - 0.1 = -0.1 \\text{ rad} \\ \\cos(-0.1) &amp;\\approx 0.9950 \\ s_{\\text{phase}} &amp;= \\frac{1}{2}(1 + 0.9950) = \\frac{1.9950}{2} = 0.9975 \\end{aligned} ]</p> <p>Python: <pre><code>phase_diff = node_i[\"phase\"] - node_j[\"phase\"]\ns_phase = 0.5 * (1.0 + math.cos(phase_diff))\nprint(f\"Step 1: s_phase = {s_phase:.6f}\")\n# Output: Step 1: s_phase = 0.997502\n</code></pre></p>"},{"location":"examples/worked_examples/#step-2-compute-epi-similarity","title":"Step 2: Compute EPI Similarity","text":"<p>Formula: [ s_{\\text{EPI}}(i,j) = 1 - \\frac{|\\text{EPI}i - \\text{EPI}_j|}{\\Delta ]}}</p> <p>where (\\Delta_{\\text{EPI}} = \\text{EPI}{\\max} - \\text{EPI})</p> <p>Calculation: [ \\begin{aligned} \\Delta_{\\text{EPI}} &amp;= 1.0 - 0.0 = 1.0 \\ |\\text{EPI}i - \\text{EPI}_j| &amp;= |0.5 - 0.6| = 0.1 \\ s = 0.9 \\end{aligned} ]}} &amp;= 1 - \\frac{0.1}{1.0</p> <p>Python: <pre><code>epi_range = ranges[\"EPI_max\"] - ranges[\"EPI_min\"]\nepi_diff = abs(node_i[\"EPI\"] - node_j[\"EPI\"])\ns_epi = 1.0 - (epi_diff / epi_range if epi_range &gt; 0 else 0.0)\nprint(f\"Step 2: s_epi = {s_epi:.6f}\")\n# Output: Step 2: s_epi = 0.900000\n</code></pre></p>"},{"location":"examples/worked_examples/#step-3-compute-frequency-similarity","title":"Step 3: Compute Frequency Similarity","text":"<p>Formula: [ s_{\\nu_f}(i,j) = 1 - \\frac{|\\nu_{f,i} - \\nu_{f,j}|}{\\Delta_{\\nu_f}} ]</p> <p>Calculation: [ \\begin{aligned} \\Delta_{\\nu_f} &amp;= 1.0 - 0.0 = 1.0 \\ |\\nu_{f,i} - \\nu_{f,j}| &amp;= |0.8 - 0.7| = 0.1 \\ s_{\\nu_f} &amp;= 1 - \\frac{0.1}{1.0} = 0.9 \\end{aligned} ]</p> <p>Python: <pre><code>vf_range = ranges[\"vf_max\"] - ranges[\"vf_min\"]\nvf_diff = abs(node_i[\"nu_f\"] - node_j[\"nu_f\"])\ns_vf = 1.0 - (vf_diff / vf_range if vf_range &gt; 0 else 0.0)\nprint(f\"Step 3: s_vf = {s_vf:.6f}\")\n# Output: Step 3: s_vf = 0.900000\n</code></pre></p>"},{"location":"examples/worked_examples/#step-4-compute-si-similarity","title":"Step 4: Compute Si Similarity","text":"<p>Formula: [ s_{\\text{Si}}(i,j) = 1 - |\\text{Si}_i - \\text{Si}_j| ]</p> <p>Calculation: [ s_{\\text{Si}} = 1 - |0.7 - 0.8| = 1 - 0.1 = 0.9 ]</p> <p>Python: <pre><code>s_si = 1.0 - abs(node_i[\"Si\"] - node_j[\"Si\"])\nprint(f\"Step 4: s_si = {s_si:.6f}\")\n# Output: Step 4: s_si = 0.900000\n</code></pre></p>"},{"location":"examples/worked_examples/#step-5-combine-with-weights","title":"Step 5: Combine with Weights","text":"<p>Formula: [ w_{ij} = w_{\\text{phase}} \\cdot s_{\\text{phase}} + w_{\\text{EPI}} \\cdot s_{\\text{EPI}} + w_{\\nu_f} \\cdot s_{\\nu_f} + w_{\\text{Si}} \\cdot s_{\\text{Si}} ]</p> <p>Calculation: [ \\begin{aligned} w_{ij} &amp;= 0.25 \\cdot 0.9975 + 0.25 \\cdot 0.9 + 0.25 \\cdot 0.9 + 0.25 \\cdot 0.9 \\ &amp;= 0.2494 + 0.225 + 0.225 + 0.225 \\ &amp;= 0.9244 \\end{aligned} ]</p> <p>Python: <pre><code>w_ij = (weights[\"phase\"] * s_phase +\n        weights[\"epi\"] * s_epi +\n        weights[\"vf\"] * s_vf +\n        weights[\"si\"] * s_si)\n\nprint(f\"\\nStep 5: w_ij components\")\nprint(f\"  phase: {weights['phase']} * {s_phase:.6f} = {weights['phase'] * s_phase:.6f}\")\nprint(f\"  epi:   {weights['epi']} * {s_epi:.6f} = {weights['epi'] * s_epi:.6f}\")\nprint(f\"  vf:    {weights['vf']} * {s_vf:.6f} = {weights['vf'] * s_vf:.6f}\")\nprint(f\"  si:    {weights['si']} * {s_si:.6f} = {weights['si'] * s_si:.6f}\")\nprint(f\"  w_ij = {w_ij:.6f}\")\n</code></pre></p>"},{"location":"examples/worked_examples/#step-6-clamp-to-0-1","title":"Step 6: Clamp to [0, 1]","text":"<p>[ w_{ij,\\text{final}} = \\max(0, \\min(1, w_{ij})) = 0.9244 ]</p> <p>Python: <pre><code>w_ij_final = max(0.0, min(1.0, w_ij))\nprint(f\"Step 6: w_ij_final = {w_ij_final:.6f}\")\n# Output: Step 6: w_ij_final = 0.924375\n</code></pre></p>"},{"location":"examples/worked_examples/#verification-with-implementation_1","title":"Verification with Implementation","text":"<pre><code>import networkx as nx\nfrom tnfr.metrics.coherence import compute_wij_phase_epi_vf_si, SimilarityInputs\n\n# Create test network\nG = nx.Graph()\nG.add_edge(\"i\", \"j\")\n\n# Set attributes\nG.nodes[\"i\"].update(node_i)\nG.nodes[\"j\"].update(node_j)\n\n# Prepare inputs\ninputs = SimilarityInputs(\n    th_vals=[node_i[\"phase\"], node_j[\"phase\"]],\n    epi_vals=[node_i[\"EPI\"], node_j[\"EPI\"]],\n    vf_vals=[node_i[\"nu_f\"], node_j[\"nu_f\"]],\n    si_vals=[node_i[\"Si\"], node_j[\"Si\"]]\n)\n\n# Compute similarities\nepi_range = ranges[\"EPI_max\"] - ranges[\"EPI_min\"]\nvf_range = ranges[\"vf_max\"] - ranges[\"vf_min\"]\n\ns_phase_impl, s_epi_impl, s_vf_impl, s_si_impl = compute_wij_phase_epi_vf_si(\n    inputs, i=0, j=1,\n    epi_range=epi_range,\n    vf_range=vf_range\n)\n\n# Combine\nw_ij_impl = (weights[\"phase\"] * s_phase_impl +\n             weights[\"epi\"] * s_epi_impl +\n             weights[\"vf\"] * s_vf_impl +\n             weights[\"si\"] * s_si_impl)\n\nprint(f\"\\n\u2705 Verification:\")\nprint(f\"  Manual calculation:   w_ij = {w_ij_final:.6f}\")\nprint(f\"  TNFR implementation:  w_ij = {w_ij_impl:.6f}\")\nprint(f\"  Match: {abs(w_ij_final - w_ij_impl) &lt; 1e-6}\")\n</code></pre>"},{"location":"examples/worked_examples/#interpretation_1","title":"Interpretation","text":"<p>What does (w_{ij} = 0.924) mean?</p> <ul> <li>High coherence: Nodes (i) and (j) are structurally very similar</li> <li>Breakdown:</li> <li>Phase (0.998): Nearly perfect synchrony ((\\Delta\\theta = 0.1) rad)</li> <li>EPI (0.90): Moderate structural similarity</li> <li>Frequency (0.90): Similar reorganization rates</li> <li>Si (0.90): Similar stability capacities</li> </ul> <p>Physical meaning: These nodes are strongly coupled in the coherence operator sense. They form a stable resonant pair that reinforces each other's structural patterns.</p>"},{"location":"examples/worked_examples/#example-3-total-coherence-ct-from-matrix","title":"Example 3: Total Coherence C(t) from Matrix","text":""},{"location":"examples/worked_examples/#overview_2","title":"Overview","text":"<p>Given the coherence matrix (W), we can compute the total network coherence (C(t)).</p>"},{"location":"examples/worked_examples/#mathematical-definition_2","title":"Mathematical Definition","text":"<p>Trace formula: [ C(t) = \\frac{1}{N} \\sum_{i=1}^N w_{ii} ]</p> <p>For an idealized network where all nodes have identical self-coherence and pairwise coherence:</p> <p>[ C(t) = \\frac{1}{N}\\left(\\sum_{i=1}^N w_{ii}\\right) \\approx \\bar{w} ]</p>"},{"location":"examples/worked_examples/#example-network","title":"Example Network","text":"<pre><code>import numpy as np\n\n# 3-node network, coherence matrix\nN = 3\nW = np.array([\n    [1.0, 0.9, 0.8],  # Node 0: perfect self-coherence, high coupling\n    [0.9, 1.0, 0.85], # Node 1\n    [0.8, 0.85, 1.0]  # Node 2\n])\n\nprint(\"Coherence matrix W:\")\nprint(W)\n</code></pre>"},{"location":"examples/worked_examples/#step-1-extract-diagonal-self-coherence","title":"Step 1: Extract Diagonal (Self-Coherence)","text":"<p>[ \\text{diag}(W) = [w_{00}, w_{11}, w_{22}] = [1.0, 1.0, 1.0] ]</p> <p>Python: <pre><code>diagonal = np.diag(W)\nprint(f\"\\nStep 1: Diagonal elements = {diagonal}\")\n# Output: [1.0, 1.0, 1.0]\n</code></pre></p>"},{"location":"examples/worked_examples/#step-2-compute-mean","title":"Step 2: Compute Mean","text":"<p>[ C(t) = \\frac{1}{3}(1.0 + 1.0 + 1.0) = \\frac{3.0}{3} = 1.0 ]</p> <p>Python: <pre><code>C_t = np.mean(diagonal)\nprint(f\"Step 2: C(t) = {C_t:.6f}\")\n# Output: Step 2: C(t) = 1.000000\n</code></pre></p>"},{"location":"examples/worked_examples/#interpretation_2","title":"Interpretation","text":"<p>C(t) = 1.0 means: - All nodes have perfect self-coherence ((w_{ii} = 1)) - The network as a whole exhibits maximum stability - No nodes are at risk of structural collapse</p> <p>Note: This is the diagonal-only definition. The full coherence includes off-diagonal coupling terms in more sophisticated formulations.</p>"},{"location":"examples/worked_examples/#example-4-phase-synchrony-kuramoto-order-parameter","title":"Example 4: Phase Synchrony (Kuramoto Order Parameter)","text":""},{"location":"examples/worked_examples/#overview_3","title":"Overview","text":"<p>The Kuramoto order parameter (r) measures phase synchronization across a network.</p>"},{"location":"examples/worked_examples/#mathematical-definition_3","title":"Mathematical Definition","text":"<p>[ r e^{i\\Psi} = \\frac{1}{N}\\sum_{j=1}^N e^{i\\theta_j} ]</p> <p>where: - (r \\in [0,1]): Synchronization strength - (\\Psi): Mean phase direction</p>"},{"location":"examples/worked_examples/#input-data_2","title":"Input Data","text":"<pre><code>import numpy as np\n\n# Four nodes with phases\nphases = np.array([0.0, 0.1, 0.05, 6.28])  # radians\nN = len(phases)\n\nprint(f\"Phases: {phases}\")\n</code></pre>"},{"location":"examples/worked_examples/#step-1-compute-complex-sum","title":"Step 1: Compute Complex Sum","text":"<p>[ \\sum_{j=1}^N e^{i\\theta_j} = \\sum_{j=1}^N (\\cos\\theta_j + i\\sin\\theta_j) ]</p> <p>Python: <pre><code>complex_sum = np.sum(np.exp(1j * phases))\nprint(f\"\\nStep 1: Complex sum = {complex_sum}\")\n# Output: Complex sum = (3.95+0.14j) approximately\n</code></pre></p>"},{"location":"examples/worked_examples/#step-2-normalize-by-n","title":"Step 2: Normalize by N","text":"<p>[ \\frac{1}{N}\\sum_{j=1}^N e^{i\\theta_j} = r e^{i\\Psi} ]</p> <p>Python: <pre><code>normalized = complex_sum / N\nr = np.abs(normalized)\nPsi = np.angle(normalized)\n\nprint(f\"Step 2: Normalized = {normalized}\")\nprint(f\"        r (magnitude) = {r:.6f}\")\nprint(f\"        Psi (angle) = {Psi:.6f} rad\")\n</code></pre></p>"},{"location":"examples/worked_examples/#interpretation_3","title":"Interpretation","text":"<ul> <li>r \u2248 0.988: Very high synchronization (phases are tightly clustered)</li> <li>Psi \u2248 0.036 rad: Mean phase direction is close to 0</li> </ul> <p>Physical meaning: The network is highly synchronized. Nodes oscillate nearly in phase, indicating strong coherent coupling.</p>"},{"location":"examples/worked_examples/#summary","title":"Summary","text":"<p>These worked examples demonstrate:</p> <ol> <li>Si calculation: Shows how frequency, phase, and \u0394NFR combine to measure reorganization stability</li> <li>Coherence matrix: Illustrates pairwise structural similarity computation</li> <li>Total coherence: Demonstrates network-wide stability measurement</li> <li>Phase synchrony: Quantifies collective oscillation patterns</li> </ol> <p>Each example: - \u2705 Provides step-by-step mathematical derivation - \u2705 Shows Python implementation - \u2705 Verifies against TNFR library functions - \u2705 Interprets results physically</p> <p>For more examples, see: - Theory notebooks for interactive explorations - API documentation for function references - Mathematical Foundations for complete derivations</p>"},{"location":"getting-started/","title":"Getting Started with TNFR","text":"<p>Home \u203a Getting Started</p> <p>Welcome to TNFR (Teor\u00eda de la Naturaleza Fractal Resonante / Resonant Fractal Nature Theory)! This guide will help you get started with the TNFR Python Engine.</p>"},{"location":"getting-started/#what-is-tnfr","title":"What is TNFR?","text":"<p>TNFR is a computational paradigm that models reality as coherent patterns that persist through resonance, not as isolated objects. Instead of viewing systems as collections of independent entities, TNFR treats them as resonant networks where structures emerge and stabilize through synchronized vibration.</p>"},{"location":"getting-started/#core-principle","title":"Core Principle","text":"<p>Reality is coherence, not substance. What we perceive as \"objects\" or \"structures\" are actually stable patterns of resonance that persist because they synchronize with their environment.</p>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":"<ul> <li>NFR (Nodo Fractal Resonante): The fundamental unit of structural coherence</li> <li>EPI (Estructura Primaria de Informaci\u00f3n): The coherent \"form\" or identity of a node</li> <li>\u03bdf (Structural Frequency): The rate at which a node reorganizes (measured in Hz_str)</li> <li>\u0394NFR: The internal reorganization gradient driving structural change</li> <li>Phase (\u03c6): Relative synchrony with the network</li> </ul>"},{"location":"getting-started/#the-nodal-equation","title":"The Nodal Equation","text":"<p>At the heart of TNFR is the canonical nodal equation:</p> <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre> <p>This equation describes how structures evolve: their rate of change depends on both their capacity to reorganize (\u03bdf) and the pressure to change (\u0394NFR).</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#quick-install","title":"Quick Install","text":"<pre><code>pip install tnfr\n</code></pre> <p>This installs the core engine with NumPy, NetworkX, and Cachetools.</p>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"<p>For enhanced functionality:</p> <pre><code># GPU acceleration with JAX\npip install tnfr[compute-jax]\n\n# PyTorch backend\npip install tnfr[compute-torch]\n\n# Visualization tools\npip install tnfr[viz-basic]\n\n# All extras\npip install tnfr[compute-jax,compute-torch,viz-basic,yaml,orjson]\n</code></pre> <p>See Optional Dependencies for details.</p>"},{"location":"getting-started/#your-first-tnfr-network","title":"Your First TNFR Network","text":"<p>Create a simple resonant network in 3 lines:</p> <pre><code>import tnfr\n\n# Create a resonant network\nG = tnfr.create_network(nodes=10, connectivity=0.3)\n\n# Apply structural operators\ntnfr.operators.coherence(G)\n\n# Measure network coherence\nC_t = tnfr.metrics.total_coherence(G)\nprint(f\"Network coherence: {C_t:.3f}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/#for-absolute-beginners-5-10-minutes","title":"\ud83d\ude80 For Absolute Beginners (5-10 minutes)","text":"<ol> <li>Quickstart Tutorial - Run your first TNFR code</li> <li>TNFR Concepts - Understand the fundamentals</li> <li>Interactive Tutorial - Guided walkthrough</li> </ol>"},{"location":"getting-started/#for-learning-tnfr-30-60-minutes","title":"\ud83d\udcda For Learning TNFR (30-60 minutes)","text":"<ol> <li>Concepts Guide - Deep dive into theory</li> <li>User Guide - Using the 13 operators</li> <li>Examples - Practical examples</li> </ol>"},{"location":"getting-started/#for-building-applications","title":"\ud83d\udd27 For Building Applications","text":"<ol> <li>API Overview - Package structure</li> <li>Operators Reference - Complete operator documentation</li> <li>Metrics Guide - Interpreting C(t), Si, etc.</li> </ol>"},{"location":"getting-started/#for-advanced-users","title":"\ud83c\udf93 For Advanced Users","text":"<ol> <li>Performance Optimization - Speed up your networks</li> <li>Math Backends - GPU acceleration</li> <li>Mathematical Foundations - \u2b50 CANONICAL MATH SOURCE - Complete derivation</li> </ol>"},{"location":"getting-started/#learning-paths","title":"Learning Paths","text":""},{"location":"getting-started/#path-1-quickest-start-10-minutes","title":"Path 1: Quickest Start (10 minutes)","text":"<pre><code>Quickstart \u2192 Interactive Tutorial \u2192 First Example\n</code></pre>"},{"location":"getting-started/#path-2-comprehensive-1-2-hours","title":"Path 2: Comprehensive (1-2 hours)","text":"<pre><code>Quickstart \u2192 TNFR Concepts \u2192 User Guide \u2192 Examples \u2192 API Reference\n</code></pre>"},{"location":"getting-started/#path-3-theory-first-2-3-hours","title":"Path 3: Theory-First (2-3 hours)","text":"<pre><code>TNFR Concepts \u2192 Mathematical Foundations \u2192 Math Notebooks \u2192 Examples\n</code></pre>"},{"location":"getting-started/#key-resources","title":"Key Resources","text":"<ul> <li>Quickstart - Get running in 5 minutes</li> <li>TNFR Concepts - Core theory explained</li> <li>FAQ - Common questions answered</li> <li>Glossary - Term definitions</li> <li>Examples - Runnable code samples</li> </ul>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Quick Questions: Check the FAQ</li> <li>How-To Guides: See User Guide</li> <li>API Details: Read API Overview</li> <li>Issues: Open a GitHub issue</li> <li>Troubleshooting: See Troubleshooting Guide</li> </ul>"},{"location":"getting-started/#philosophy","title":"Philosophy","text":"<p>TNFR is built on several core principles:</p> <ol> <li>Coherence First: Structures exist through resonance, not substance</li> <li>Operational Fractality: Patterns scale without losing structure</li> <li>Complete Traceability: Every change is observable and reproducible</li> <li>Trans-Scale: Works from quantum to social systems</li> <li>Domain Neutral: No hard-coded assumptions about specific fields</li> </ol> <p>Ready to start? Head to the Quickstart Tutorial \u2192</p> <p>Or explore TNFR Concepts to understand the theory first.</p>"},{"location":"getting-started/FAQ/","title":"Frequently Asked Questions (FAQ)","text":"<p>Home \u203a Getting Started \u203a FAQ</p>"},{"location":"getting-started/FAQ/#general-questions","title":"General Questions","text":""},{"location":"getting-started/FAQ/#what-is-tnfr","title":"What is TNFR?","text":"<p>TNFR (Teor\u00eda de la Naturaleza Fractal Resonante / Resonant Fractal Nature Theory) is a computational paradigm that models reality as coherent patterns sustained by resonance, not as isolated objects. It provides a framework for understanding and simulating complex systems across all scales.</p>"},{"location":"getting-started/FAQ/#why-use-tnfr-instead-of-traditional-modeling","title":"Why use TNFR instead of traditional modeling?","text":"<p>Traditional approaches model systems as collections of independent objects. TNFR takes a fundamentally different view:</p> <ul> <li>Traditional: Objects exist independently, interact through cause-and-effect</li> <li>TNFR: Patterns exist through resonance, co-organize through coherence</li> </ul> <p>Benefits: - \ud83c\udfaf Operational fractality: patterns scale without losing structure - \ud83d\udd04 Complete reproducibility: same conditions \u2192 same outcomes - \ud83d\udd0d Full traceability: every reorganization is observable - \ud83c\udf10 Trans-scale: works from quantum to social systems</p>"},{"location":"getting-started/FAQ/#what-domains-can-tnfr-model","title":"What domains can TNFR model?","text":"<p>TNFR is domain-neutral and works across: - Biology: Cell networks, neural systems, ecosystems - Social: Communities, organizations, cultural dynamics - Technology: Distributed systems, networks, AI - Physics: Quantum systems, field dynamics - Economics: Markets, resource flows - And any system where patterns emerge through interaction</p>"},{"location":"getting-started/FAQ/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"getting-started/FAQ/#how-do-i-install-tnfr","title":"How do I install TNFR?","text":"<p>Basic installation: <pre><code>pip install tnfr\n</code></pre></p> <p>With optional features: <pre><code># GPU acceleration\npip install tnfr[compute-jax]\n\n# All features\npip install tnfr[compute-jax,viz-basic,yaml,orjson]\n</code></pre></p>"},{"location":"getting-started/FAQ/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>Python 3.9 or newer is required.</p>"},{"location":"getting-started/FAQ/#do-i-need-a-gpu","title":"Do I need a GPU?","text":"<p>No! TNFR works with: - NumPy backend (default, CPU-only) - JAX backend (optional, GPU-accelerated) - PyTorch backend (optional, GPU-accelerated)</p> <p>GPUs are optional for performance optimization.</p>"},{"location":"getting-started/FAQ/#how-do-i-check-if-tnfr-is-installed-correctly","title":"How do I check if TNFR is installed correctly?","text":"<pre><code>import tnfr\nprint(tnfr.__version__)\n\n# Create a simple network\nG = tnfr.create_network(nodes=5)\nprint(f\"Created network with {G.number_of_nodes()} nodes\")\n</code></pre>"},{"location":"getting-started/FAQ/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/FAQ/#what-is-an-nfr-resonant-fractal-node","title":"What is an NFR (Resonant Fractal Node)?","text":"<p>An NFR is the minimum unit of structural coherence in TNFR. Think of it as a tuning fork in a network that: - Has its own natural frequency (\u03bdf) - Responds to nearby vibrations - Maintains a coherent form (EPI) - Synchronizes through phase (\u03c6)</p>"},{"location":"getting-started/FAQ/#what-is-epi","title":"What is EPI?","text":"<p>EPI (Estructura Primaria de Informaci\u00f3n / Primary Information Structure) is the coherent \"form\" or \"identity\" of a node. Like a musical chord has a specific structure, EPI defines the structural configuration of a node.</p>"},{"location":"getting-started/FAQ/#what-is-f-structural-frequency","title":"What is \u03bdf (structural frequency)?","text":"<p>\u03bdf is the rate at which a node reorganizes its internal structure, measured in Hz_str (structural hertz). It's like a \"heart rate for change\": - Higher \u03bdf = faster reorganization - Lower \u03bdf = slower, more stable evolution - \u03bdf \u2192 0 = node collapse</p> <p>Important: \u03bdf is NOT a physical frequency (like sound waves).</p>"},{"location":"getting-started/FAQ/#what-is-nfr","title":"What is \u0394NFR?","text":"<p>\u0394NFR is the internal reorganization gradient - the \"pressure\" driving structural change. It measures the difference between a node's current state and the network around it: - Positive \u0394NFR: expansion, growth - Negative \u0394NFR: contraction, simplification - Large |\u0394NFR|: intense reorganization</p>"},{"location":"getting-started/FAQ/#what-is-the-nodal-equation","title":"What is the Nodal Equation?","text":"<p>The canonical equation governing TNFR: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre></p> <p>Translation: \"A structure changes at a rate proportional to its reorganization capacity (\u03bdf) and the pressure to change (\u0394NFR).\"</p>"},{"location":"getting-started/FAQ/#what-are-the-13-structural-operators","title":"What are the 13 structural operators?","text":"<p>The operators are the only valid way to modify nodes in TNFR:</p> <ol> <li>Emission - Initiate patterns</li> <li>Reception - Receive external patterns</li> <li>Coherence - Stabilize structure</li> <li>Dissonance - Introduce controlled instability</li> <li>Coupling - Create links between nodes</li> <li>Resonance - Amplify and propagate patterns</li> <li>Silence - Temporarily freeze evolution</li> <li>Expansion - Increase complexity</li> <li>Contraction - Reduce complexity</li> <li>Self-organization - Spontaneous pattern formation</li> <li>Mutation - Phase transformation</li> <li>Transition - Navigate between states</li> <li>Recursivity - Nested operations</li> </ol> <p>See Operators Guide for details.</p>"},{"location":"getting-started/FAQ/#using-tnfr","title":"Using TNFR","text":""},{"location":"getting-started/FAQ/#how-do-i-create-a-network","title":"How do I create a network?","text":"<pre><code>import tnfr\n\n# Simple network\nG = tnfr.create_network(nodes=10, connectivity=0.3)\n\n# Custom initialization\nG = tnfr.create_network(\n    nodes=20,\n    connectivity=0.5,\n    initial_frequency=1.0,  # Hz_str\n    phase_distribution='uniform'\n)\n</code></pre>"},{"location":"getting-started/FAQ/#how-do-i-apply-operators","title":"How do I apply operators?","text":"<pre><code>from tnfr.operators import coherence, resonance, coupling\n\n# Single operator\ncoherence(G)\n\n# Sequence of operators\ncoupling(G, node1, node2)\nresonance(G, source_node)\ncoherence(G)\n</code></pre>"},{"location":"getting-started/FAQ/#how-do-i-measure-network-health","title":"How do I measure network health?","text":"<pre><code>from tnfr.metrics import total_coherence, sense_index\n\n# Total coherence C(t)\nC_t = total_coherence(G)\nprint(f\"Coherence: {C_t:.3f}\")  # 0.0-1.0\n\n# Sense index Si\nSi = sense_index(G)\nprint(f\"Sense index: {Si:.3f}\")  # 0.0-1.0+\n\n# Per-node metrics\nfor node in G.nodes():\n    nf = G.nodes[node]['nf']  # structural frequency\n    phase = G.nodes[node]['phase']\n    print(f\"Node {node}: \u03bdf={nf:.2f} Hz_str, \u03c6={phase:.2f} rad\")\n</code></pre>"},{"location":"getting-started/FAQ/#what-metrics-should-i-monitor","title":"What metrics should I monitor?","text":"<p>Key metrics: - C(t) (Total Coherence): Overall network stability (0.0-1.0) - Si (Sense Index): Reorganization stability (0.0-1.0+) - \u03bdf (Structural Frequency): Per-node reorganization rate - Phase: Network synchronization (0-2\u03c0 radians)</p> <p>Healthy networks show: - C(t) &gt; 0.5 (moderate coherence) - Si &gt; 0.4 (stable reorganization) - Phase coherence &gt; 0.3</p> <p>See Metrics Interpretation Guide.</p>"},{"location":"getting-started/FAQ/#can-i-visualize-tnfr-networks","title":"Can I visualize TNFR networks?","text":"<p>Yes! With the visualization extra: <pre><code>pip install tnfr[viz-basic]\n</code></pre></p> <pre><code>import tnfr.visualization as viz\n\n# Visualize network\nviz.plot_network(G, show_phase=True, show_frequency=True)\n\n# Coherence over time\nviz.plot_coherence_evolution(G, timesteps=100)\n</code></pre>"},{"location":"getting-started/FAQ/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/FAQ/#my-network-coherence-is-very-low-whats-wrong","title":"My network coherence is very low. What's wrong?","text":"<p>Low C(t) can result from: - Insufficient coupling between nodes - Phase desynchronization - Excessive dissonance - Very low structural frequencies</p> <p>Solutions: 1. Apply <code>coherence()</code> operator 2. Increase coupling: <code>coupling(G, node1, node2)</code> 3. Check phase distribution 4. Verify \u03bdf values are &gt; 0</p> <p>See Troubleshooting Guide.</p>"},{"location":"getting-started/FAQ/#how-do-i-debug-operator-sequences","title":"How do I debug operator sequences?","text":"<p>Enable telemetry: <pre><code>from tnfr.telemetry import enable_tracing\n\nenable_tracing()  # Log all operator applications\n</code></pre></p> <p>Or use the validator: <pre><code>from tnfr.validation import validate_network\n\nissues = validate_network(G)\nfor issue in issues:\n    print(issue)\n</code></pre></p>"},{"location":"getting-started/FAQ/#my-code-is-slow-how-can-i-optimize","title":"My code is slow. How can I optimize?","text":"<ol> <li> <p>Use JAX backend for GPU acceleration:    <pre><code>import tnfr\ntnfr.set_backend('jax')\n</code></pre></p> </li> <li> <p>Enable caching:    <pre><code>pip install tnfr[orjson]\n</code></pre></p> </li> <li> <p>Optimize network size: Start small, scale gradually</p> </li> </ol> <p>See Performance Optimization.</p>"},{"location":"getting-started/FAQ/#can-i-saveload-networks","title":"Can I save/load networks?","text":"<p>Yes: <pre><code>import tnfr\n\n# Save\ntnfr.save_network(G, 'network.json')\n\n# Load\nG = tnfr.load_network('network.json')\n</code></pre></p> <p>YAML support: <pre><code>pip install tnfr[yaml]\n</code></pre></p> <pre><code>tnfr.save_network(G, 'network.yaml', format='yaml')\n</code></pre>"},{"location":"getting-started/FAQ/#advanced-topics","title":"Advanced Topics","text":""},{"location":"getting-started/FAQ/#what-is-operational-fractality","title":"What is operational fractality?","text":"<p>Operational fractality means patterns maintain their structure across scales. An EPI can contain nested sub-EPIs without losing functional identity. This is like Russian dolls: each level is complete in itself.</p>"},{"location":"getting-started/FAQ/#what-is-the-difference-between-coherence-and-coupling","title":"What is the difference between coherence and coupling?","text":"<ul> <li>Coherence: Internal stability of nodes (individual alignment)</li> <li>Coupling: Structural links between nodes (network connections)</li> </ul> <p>Both are necessary: coherence stabilizes individual nodes, coupling creates network structure.</p>"},{"location":"getting-started/FAQ/#can-tnfr-handle-large-scale-networks","title":"Can TNFR handle large-scale networks?","text":"<p>Yes! TNFR scales through: - Sparse networks: Only necessary connections - Hierarchical structure: Nested EPIs - Efficient backends: JAX/PyTorch for large networks - Caching: Repeated computations cached</p> <p>See Scalability and Performance Optimization.</p>"},{"location":"getting-started/FAQ/#how-do-i-extend-tnfr","title":"How do I extend TNFR?","text":"<ol> <li>Custom operators: Compose existing operators</li> <li>Custom metrics: Implement metric functions</li> <li>Custom backends: Add new computational backends</li> </ol> <p>See Extending TNFR (coming soon).</p>"},{"location":"getting-started/FAQ/#where-can-i-find-the-mathematical-foundations","title":"Where can I find the mathematical foundations?","text":"<ul> <li>Theory notebooks: <code>docs/source/theory/</code></li> <li>TNFR.pdf: Complete theoretical document</li> <li>Foundations guide: foundations.md</li> </ul>"},{"location":"getting-started/FAQ/#contributing","title":"Contributing","text":""},{"location":"getting-started/FAQ/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See CONTRIBUTING.md for: - Code contributions - Documentation improvements - Bug reports - Feature requests</p>"},{"location":"getting-started/FAQ/#what-are-the-tnfr-invariants","title":"What are the TNFR invariants?","text":"<p>TNFR has 10 canonical invariants that must be preserved. See AGENTS.md for the complete list, including: 1. EPI changes only through structural operators 2. \u03bdf expressed in Hz_str units 3. \u0394NFR semantics (not ML gradient) 4. Operator closure 5. Phase verification before coupling 6. And 5 more...</p>"},{"location":"getting-started/FAQ/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Documentation: Browse all docs</li> <li>Examples: Example catalog</li> <li>GitHub Issues: Ask a question</li> <li>API Reference: Complete API docs</li> </ul> <p>See Also: - Getting Started - Quickstart Tutorial - TNFR Concepts - User Guide</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/","title":"Interactive Step-by-Step Tutorial","text":"<p>Welcome to the TNFR Interactive Tutorial! This guide will take you from zero to creating your first functional TNFR application in about 60 minutes. You'll learn by doing, with clear explanations connecting theory to practice.</p> <p>Prerequisites: Python 3.9+, basic Python knowledge. No prior TNFR experience needed!</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#part-1-first-steps-10-minutes","title":"Part 1: First Steps (10 minutes)","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#11-installation-and-verification","title":"1.1 Installation and Verification","text":"<p>Let's start by installing TNFR and verifying everything works.</p> <pre><code># \ud83d\udcdd Step 1: Install TNFR\n# Run in your terminal:\n# pip install tnfr\n\n# \ud83d\udcdd Step 2: Verify installation\nfrom tnfr.sdk import TNFRNetwork\nprint(\"\u2713 TNFR installed correctly\")\n\n# \ud83c\udfaf Goal: Confirm that everything works before we begin\n</code></pre> <p>What just happened? - You installed the TNFR Python Engine - You imported the simplified SDK API that hides complexity while maintaining theoretical fidelity - You're ready to create your first resonant network!</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#12-your-first-network-the-hello-world-explained","title":"1.2 Your First Network (The \"Hello World\" Explained)","text":"<p>Now let's create your first TNFR network. This is like the \"Hello World\" of resonant systems.</p> <pre><code># \ud83d\udcdd Step 3: Create your first network\nnetwork = TNFRNetwork(\"my_first_network\")\n\n# \u2753 What did you just do?\n# You created a container for nodes that can resonate with each other.\n# Think of it like creating an empty stage where musical notes can harmonize.\n\n# \ud83d\udcdd Step 4: Add nodes\nnetwork.add_nodes(5)  # 5 nodes = 5 points of coherence\n\n# \u2753 What is a node?\n# A node (Nodo Fractal Resonante - NFR) is a point in the network that can:\n# - Receive information (structural patterns)\n# - Process information (through reorganization)\n# - Emit information (to connected nodes)\n# Each node has:\n#   \u2022 EPI: Primary Information Structure (its form)\n#   \u2022 \u03bdf: Structural frequency (reorganization rate, measured in Hz_str)\n#   \u2022 \u03b8: Phase (synchronization state with the network)\n\nprint(f\"\u2713 Network created with {network.node_count()} nodes\")\n</code></pre> <p>Try it yourself! - Change the number from 5 to 10. How does this affect your network? - Each node is a potential point of coherence in your system.</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#13-connecting-nodes","title":"1.3 Connecting Nodes","text":"<p>Nodes need connections to communicate. Let's wire them up!</p> <pre><code># \ud83d\udcdd Step 5: Create connections\nnetwork.connect_nodes(0.3, \"random\")  # 30% probability of connection\n\n# \u2753 Why connect nodes?\n# Isolated nodes cannot resonate with others. Connections allow:\n# - Coherence to propagate through the network\n# - Phase synchronization between nodes\n# - Information flow via structural resonance\n#\n# Without connections, you have 5 separate systems.\n# With connections, you have 1 coherent network.\n\nprint(f\"\u2713 Connections created: {network.get_edge_count()}\")\n\n# \ud83d\udd0d Network topology matters!\n# - \"random\": Stochastic connections (good for exploration)\n# - \"ring\": Circular topology (good for wave propagation)\n# - \"small_world\": Mix of local and random (like social networks)\n</code></pre> <p>Understanding connection patterns: - 0.3 probability means on average, 30% of possible connections exist - Too few connections \u2192 isolated clusters - Too many connections \u2192 computational cost without benefit - Sweet spot is often 0.2-0.4 for exploration</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#part-2-activation-and-dynamics-15-minutes","title":"Part 2: Activation and Dynamics (15 minutes)","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#21-applying-structural-operators","title":"2.1 Applying Structural Operators","text":"<p>Now let's activate your network using TNFR's structural operators!</p> <pre><code># \ud83d\udcdd Step 6: Activate the network\nresults = network.apply_sequence(\"basic_activation\", repeat=3)\n\n# \u2753 What is \"basic_activation\"?\n# It's a sequence of structural operators that follows TNFR grammar:\n#\n# 1. emission      \u2192 Initiates resonance patterns\n# 2. reception     \u2192 Nodes capture structural information\n# 3. coherence     \u2192 Stabilizes the network form\n# 4. resonance     \u2192 Propagates coherence through connections\n# 5. silence       \u2192 Freezes evolution to observe the state\n#\n# These operators implement the canonical nodal equation:\n#   \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n\nprint(\"\u2713 Network activated with 3 iterations of basic_activation sequence\")\n</code></pre> <p>What are structural operators?</p> <p>TNFR defines 13 fundamental operators that reorganize networks. Think of them as \"verbs\" for structural change:</p> Operator Function When to use <code>emission</code> Start resonance Beginning sequences, initiating patterns <code>reception</code> Capture information After emission, to internalize patterns <code>coherence</code> Stabilize structure To consolidate forms <code>resonance</code> Propagate coherence To sync the network <code>dissonance</code> Generate conflict To explore alternatives <code>coupling</code> Strengthen connections To increase network integration <code>mutation</code> Change phase For phase transitions <code>silence</code> Freeze evolution To observe stable states"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#22-measuring-coherence","title":"2.2 Measuring Coherence","text":"<p>Let's examine what happened during activation.</p> <pre><code># \ud83d\udcdd Step 7: Analyze results\nmetrics = network.measure()\n\n# \u2753 What do these metrics mean?\nprint(f\"Coherence C(t): {metrics.coherence:.3f}\")\n# \u2192 How synchronized is the network? (0.0 = chaos, 1.0 = perfect sync)\n# C(t) measures global stability via phase alignment and \u0394NFR convergence\n\n# Average Sense Index across all nodes\nsi_values = list(metrics.sense_indices.values())\navg_si = sum(si_values) / len(si_values) if si_values else 0.0\nprint(f\"Average Sense Index Si: {avg_si:.3f}\")\n# \u2192 How useful is this structure? (higher = more stable reorganization capacity)\n# Si measures each node's ability to generate coherent transformations\n\nprint(f\"Average \u03bdf: {metrics.avg_vf:.3f} Hz_str\")\n# \u2192 Average structural frequency across all nodes\n# Hz_str = \"structural hertz\" (TNFR's unit for reorganization rate)\n\ndnfr_values = list(metrics.delta_nfr.values())\navg_dnfr = sum(dnfr_values) / len(dnfr_values) if dnfr_values else 0.0\nprint(f\"Average \u0394NFR: {avg_dnfr:.3f}\")\n# \u2192 Average internal reorganization gradient\n# \u0394NFR drives structural evolution according to the nodal equation\n\n# \ud83c\udfaf Success criteria:\n# - C(t) &gt; 0.5: Good coherence\n# - Si &gt; 0.5: Useful structure\n# - Low \u0394NFR: Network has converged\n</code></pre> <p>Interpreting the numbers: - Coherence (C) close to 0? Network is chaotic or disconnected - Coherence (C) close to 1? Strong synchronization - Sense Index (Si) measures how well nodes can reorganize while staying coupled - \u0394NFR tells you if the network is still evolving (high) or stable (low)</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#part-3-your-first-practical-case-20-minutes","title":"Part 3: Your First Practical Case (20 minutes)","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#31-problem-team-communication","title":"3.1 Problem: Team Communication","text":"<p>Let's model something real: how information spreads in a work team.</p> <p>Scenario: You have an 8-person team. Information needs to flow efficiently. How do we model and optimize this using TNFR?</p> <pre><code># \ud83c\udfaf Scenario Setup:\n# - Nodes = People\n# - Connections = Communication relationships\n# - Operators = Types of interaction\n# - Coherence = Team alignment\n\nfrom tnfr.sdk import TNFRNetwork\n\n# Create team with reproducible random seed\nteam_network = TNFRNetwork(\"team_communication\")\nteam_network.add_nodes(8, random_seed=42)  # 8 team members\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#32-exploring-different-team-structures","title":"3.2 Exploring Different Team Structures","text":"<p>Real teams aren't randomly connected. Let's compare different structures.</p> <pre><code># \ud83d\udcdd Step 8: Compare team topologies\n\n# Structure 1: Random (organic, unstructured teams)\nrandom_team = TNFRNetwork(\"random_team\")\nrandom_team.add_nodes(8, random_seed=42)\nrandom_team.connect_nodes(0.3, \"random\")  # 30% connections\n\n# Structure 2: Ring (linear communication chain)\nring_team = TNFRNetwork(\"ring_team\")\nring_team.add_nodes(8, random_seed=42)\nring_team.connect_nodes(connection_pattern=\"ring\")  # Each person talks to next\n\n# Structure 3: Small-world (modern organizations)\nsw_team = TNFRNetwork(\"small_world_team\")\nsw_team.add_nodes(8, random_seed=42)\nsw_team.connect_nodes(0.15, \"small_world\")  # Local + some random links\n\nprint(\"\u2713 Created 3 team structures:\")\nprint(f\"  - Random: {random_team.get_edge_count()} connections\")\nprint(f\"  - Ring: {ring_team.get_edge_count()} connections\")\nprint(f\"  - Small-world: {sw_team.get_edge_count()} connections\")\n</code></pre> <p>Network topology note: - Random: Good for exploration, but may have isolated clusters - Ring: Guaranteed connectivity, but slow propagation - Small-world: Mix of local and distant connections\u2014efficient!</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#33-simulating-communication-flow","title":"3.3 Simulating Communication Flow","text":"<p>Let's activate each team structure and see which works best.</p> <pre><code># \ud83d\udcdd Step 9: Simulate communication in each team\n\n# Apply same activation sequence to all teams\nfor team in [random_team, ring_team, sw_team]:\n    team.apply_sequence(\"network_sync\", repeat=5)\n\n# Measure effectiveness\nrandom_results = random_team.measure()\nring_results = ring_team.measure()\nsw_results = sw_team.measure()\n\nprint(\"\\n\ud83d\udcca Communication Effectiveness:\")\nprint(f\"\\nRandom Team:\")\nprint(f\"  - Coherence: {random_results.coherence:.3f}\")\nprint(f\"  - Connectivity: {random_team.get_density():.3f}\")\n\nprint(f\"\\nRing Team:\")\nprint(f\"  - Coherence: {ring_results.coherence:.3f}\")\nprint(f\"  - Connectivity: {ring_team.get_density():.3f}\")\n\nprint(f\"\\nSmall-World Team:\")\nprint(f\"  - Coherence: {sw_results.coherence:.3f}\")\nprint(f\"  - Connectivity: {sw_team.get_density():.3f}\")\n\n# Find best structure\nteams = {\n    \"Random\": random_results.coherence,\n    \"Ring\": ring_results.coherence,\n    \"Small-World\": sw_results.coherence\n}\nbest_team = max(teams, key=teams.get)\nprint(f\"\\n\ud83c\udfc6 Most coherent team structure: {best_team}\")\n</code></pre> <p>What does this tell us? - Higher coherence \u2192 Better information synchronization - Small-world networks often win: they balance local clustering with global reach - You can test this with your real organizational structure!</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#34-detailed-node-analysis","title":"3.4 Detailed Node Analysis","text":"<p>Let's examine individual team members (nodes).</p> <pre><code># \ud83d\udcdd Step 10: Analyze individual nodes\n\nprint(\"\\n\ud83d\udd0d Individual Team Member Analysis (Small-World Team):\")\nprint(f\"{'Node':&lt;12} {'Si':&lt;8} {'\u0394NFR':&lt;10} {'Status'}\")\nprint(\"-\" * 45)\n\nfor node_id in sw_results.sense_indices.keys():\n    si = sw_results.sense_indices[node_id]\n    dnfr = sw_results.delta_nfr[node_id]\n\n    # Determine status based on Si\n    if si &gt; 0.6:\n        status = \"\u2713 Highly engaged\"\n    elif si &gt; 0.4:\n        status = \"\u25cb Moderately engaged\"\n    else:\n        status = \"\u2717 Needs attention\"\n\n    print(f\"{node_id:&lt;12} {si:&lt;8.3f} {dnfr:&lt;10.3f} {status}\")\n\n# Find nodes needing attention\nlow_si_nodes = [\n    node_id for node_id, si in sw_results.sense_indices.items() \n    if si &lt; 0.4\n]\n\nif low_si_nodes:\n    print(f\"\\n\u26a0\ufe0f  Nodes with low engagement: {', '.join(low_si_nodes)}\")\n    print(\"   Consider: More connections, different role, or training\")\nelse:\n    print(f\"\\n\u2713 All nodes well-engaged (Si &gt; 0.4)\")\n</code></pre> <p>Real-world insights: - High Si (&gt;0.6) \u2192 Person is well-connected and effective - Medium Si (0.4-0.6) \u2192 Person is functioning but could improve - Low Si (&lt;0.4) \u2192 Person may be isolated or overwhelmed - High \u0394NFR \u2192 Person is still adjusting/learning - Low \u0394NFR \u2192 Person has stabilized in their role</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#part-4-interpretation-and-next-level-10-minutes","title":"Part 4: Interpretation and Next Level (10 minutes)","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#41-optimizing-team-communication","title":"4.1 Optimizing Team Communication","text":"<p>We compared structures. Now let's optimize one!</p> <pre><code># \ud83d\udcdd Step 11: Iteratively improve network\n\n# Start with a random team\nopt_team = TNFRNetwork(\"optimizing_team\")\nopt_team.add_nodes(10, random_seed=123)\nopt_team.connect_nodes(0.25, \"random\")  # Start sparse\n\n# Baseline measurement\nopt_team.apply_sequence(\"basic_activation\", repeat=3)\ninitial_results = opt_team.measure()\ninitial_coherence = initial_results.coherence\n\nprint(f\"Initial coherence: {initial_coherence:.3f}\")\nprint(f\"Initial connections: {opt_team.get_edge_count()}\")\nprint(f\"Initial density: {opt_team.get_density():.3f}\")\n\n# Optimization: increase connectivity\nopt_team_v2 = TNFRNetwork(\"optimizing_team_v2\")\nopt_team_v2.add_nodes(10, random_seed=123)  # Same nodes\nopt_team_v2.connect_nodes(0.40, \"random\")  # More connections\n\nopt_team_v2.apply_sequence(\"basic_activation\", repeat=3)\nimproved_results = opt_team_v2.measure()\nimproved_coherence = improved_results.coherence\n\nprint(f\"\\nAfter optimization:\")\nprint(f\"New coherence: {improved_coherence:.3f}\")\nprint(f\"New connections: {opt_team_v2.get_edge_count()}\")\nprint(f\"New density: {opt_team_v2.get_density():.3f}\")\n\nimprovement = ((improved_coherence - initial_coherence) / initial_coherence) * 100\nprint(f\"\\n\ud83d\udcc8 Coherence improvement: {improvement:+.1f}%\")\n</code></pre> <p>Key lesson: Small structural changes can dramatically improve coherence!</p> <p>Optimization strategies: 1. Increase density (more connections) \u2192 Better sync, but higher cost 2. Switch topology (random \u2192 small-world) \u2192 More efficient 3. Longer activation (more repeats) \u2192 Deeper convergence 4. Different sequences (exploration vs stabilization) \u2192 Different goals</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#42-understanding-what-you-built","title":"4.2 Understanding What You Built","text":"<p>Let's reflect on what you accomplished:</p> <pre><code># You created TNFR models that:\n#\n# \u2713 Represent people/systems as resonant nodes\n# \u2713 Model interactions as structural operators\n# \u2713 Measure alignment using coherence C(t)\n# \u2713 Identify issues using network metrics\n# \u2713 Optimize structure based on measurements\n#\n# This demonstrates TNFR's core principle:\n# \"Reality is not made of 'things' but of coherences that\n#  persist because they resonate.\"\n#\n# Your team network persists because:\n# - Nodes have sufficient \u03bdf (reorganization capacity)\n# - Connections enable coupling (phase synchronization)\n# - Structure maintains coherence (stable form)\n</code></pre> <p>TNFR Invariants You Respected:</p> <ol> <li>\u2713 Operator closure (Invariant #4): All operations composed validly</li> <li>\u2713 Phase synchrony (Invariant #5): Checked coupling via resonance</li> <li>\u2713 Structural units (Invariant #2): \u03bdf measured in Hz_str</li> <li>\u2713 Controlled determinism (Invariant #8): Used random_seed for reproducibility</li> <li>\u2713 EPI as coherent form (Invariant #1): Changed only via structural operators</li> </ol>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#part-5-whats-next-5-minutes","title":"Part 5: What's Next? (5 minutes)","text":"<p>You've completed the basics! Here are pathways to deepen your TNFR mastery.</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#for-different-domains","title":"For Different Domains","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#for-researchers-biological-systems","title":"\ud83d\udd2c For Researchers: Biological Systems","text":"<pre><code>from tnfr.tutorials import biological_example\n\n# Model cell communication, tissue formation, organism development\nbiological_example()\n\n# Topics covered:\n# - Multi-scale networks (cells \u2192 tissues \u2192 organs)\n# - Self-organization via coherence\n# - Bifurcation and mutation operators\n# - Measuring emergent properties\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#for-aiml-developers-adaptive-systems","title":"\ud83e\udd16 For AI/ML Developers: Adaptive Systems","text":"<pre><code>from tnfr.tutorials import adaptive_ai_example\n\n# Build systems that learn through resonance, not statistics\nadaptive_ai_example()\n\n# Topics covered:\n# - Resonant learning (vs. gradient descent)\n# - Structural memory (vs. weight matrices)\n# - Contextual adaptation via phase coupling\n# - Sense-based decision making\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#for-network-scientists-social-dynamics","title":"\ud83d\udcca For Network Scientists: Social Dynamics","text":"<pre><code>from tnfr.tutorials import social_network_example\n\n# Analyze social networks, opinion dynamics, information cascades\nsocial_network_example()\n\n# Topics covered:\n# - Opinion formation via resonance\n# - Echo chambers as phase-locked clusters\n# - Influence propagation patterns\n# - Network intervention strategies\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#interactive-features","title":"Interactive Features","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#comprehension-checkpoints","title":"Comprehension Checkpoints","text":"<p>Test your understanding as you go:</p> <pre><code># \u2753 Checkpoint 1: What does this operator do?\nnetwork.apply_operator(\"emission\")\n\n# a) Activates a node to start resonance\n# b) Deletes the network\n# c) Changes all connections\n# d) Measures coherence\n\n# \u2192 Answer: a) \u2713\n# Emission initiates resonance patterns in the network.\n</code></pre> <pre><code># \u2753 Checkpoint 2: What does high coherence C(t) indicate?\n\n# a) The network is about to collapse\n# b) Nodes are well-synchronized\n# c) Connections are too dense\n# d) The network needs more nodes\n\n# \u2192 Answer: b) \u2713\n# High C(t) means strong phase alignment and structural stability.\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#practice-exercises","title":"Practice Exercises","text":"<p>Try modifying the examples:</p> <pre><code># \ud83d\udcdd Exercise 1: Scale Up\n# Modify the team example to model a 20-person organization\n# with 4 sub-teams. Add middle managers as hubs.\n#\n# Your code here:\n# org_network = TNFRNetwork(\"large_org\")\n# org_network.add_nodes(?)  # How many?\n# ...\n</code></pre> <pre><code># \ud83d\udcdd Exercise 2: Different Topology\n# Create a network with \"ring\" topology instead of \"random\"\n# How does this affect coherence?\n#\n# Your code here:\n# network = TNFRNetwork(\"ring_experiment\")\n# network.add_nodes(10).connect_nodes(0.3, \"ring\")  # Changed!\n# ...\n</code></pre> <pre><code># \ud83d\udcdd Exercise 3: Custom Sequence\n# Design your own operator sequence following TNFR grammar:\n# - Start with emission or recursivity\n# - Include reception \u2192 coherence\n# - Include coupling/resonance\n# - End with silence/transition\n#\n# Your sequence:\n# custom_seq = [\"emission\", \"reception\", \"coherence\", \"coupling\", \"resonance\", \"silence\"]\n# network.apply_custom_sequence(custom_seq, repeat=5)\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#visualization-helpers","title":"Visualization Helpers","text":"<p>Explore networks visually (requires optional dependencies):</p> <pre><code># \ud83d\udcc8 Save your network for external visualization\nnetwork.save(\"my_network.json\")\n\n# You can then load and visualize in Jupyter, web tools, or other software\n\n# Optional: If matplotlib is installed\n# pip install tnfr[viz-basic]\ntry:\n    network.visualize()  # Basic network plot\nexcept ImportError:\n    print(\"Install visualization tools: pip install tnfr[viz-basic]\")\n</code></pre> <p>Note: The core SDK focuses on computation. For advanced visualization: - Export to JSON and use tools like Gephi, Cytoscape - Use NetworkX visualization utilities - Build custom visualizations with matplotlib/plotly</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#success-criteria","title":"Success Criteria","text":"<p>You've successfully completed this tutorial when you can:</p> <ul> <li>[ ] \u2713 Create a TNFR network with nodes and connections</li> <li>[ ] \u2713 Explain what EPI, \u03bdf, and phase mean</li> <li>[ ] \u2713 Apply structural operators and understand their effects</li> <li>[ ] \u2713 Measure and interpret C(t) and Si metrics</li> <li>[ ] \u2713 Model a real-world system using TNFR concepts</li> <li>[ ] \u2713 Optimize network structure based on analysis</li> <li>[ ] \u2713 Modify examples with confidence</li> <li>[ ] \u2713 Know where to find advanced documentation</li> </ul>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#where-to-go-next","title":"Where to Go Next","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#documentation-deep-dives","title":"Documentation Deep Dives","text":"<ul> <li>TNFR Concepts - Theoretical foundations explained clearly</li> <li>Quickstart Guide - Low-level API and advanced patterns</li> <li>API Reference - Complete function documentation</li> <li>Operator Guide - All 13 operators in detail</li> </ul>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#example-gallery","title":"Example Gallery","text":"<ul> <li>SDK Examples - More fluent API patterns</li> <li>Multi-scale Networks - Nested structures</li> <li>Backend Optimization - Performance tuning</li> </ul>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Math Backends - JAX, PyTorch acceleration</li> <li>Parallel Computation - Scale to large networks</li> <li>Telemetry - Instrument experiments for analysis</li> </ul>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#common-issues","title":"Common Issues","text":"<p>Issue: <code>ImportError: No module named 'tnfr'</code> <pre><code># Solution: Install TNFR\npip install tnfr\n</code></pre></p> <p>Issue: Network coherence stays near 0 <pre><code># Possible causes:\n# 1. Too few connections - increase probability\nnetwork = TNFRNetwork(\"test\")\nnetwork.add_nodes(10)\nnetwork.connect_nodes(0.5, \"random\")  # Increased from 0.3\n\n# 2. Need more activation iterations\nnetwork.apply_sequence(\"basic_activation\", repeat=10)  # More iterations\n\n# 3. Disconnected network - check density\nprint(f\"Network density: {network.get_density():.3f}\")\nprint(f\"Edge count: {network.get_edge_count()}\")\n# Low density? Add more connections or use \"small_world\" pattern\n</code></pre></p> <p>Issue: <code>ValueError: Invalid operator sequence</code> <pre><code># TNFR sequences must follow grammar rules\n# \u2717 Wrong: [\"resonance\", \"emission\", \"silence\"]  # resonance before emission\n# \u2713 Right: [\"emission\", \"reception\", \"coherence\", \"resonance\", \"silence\"]\n\n# Use named sequences to avoid errors\nnetwork.apply_sequence(\"basic_activation\")  # Always valid\n</code></pre></p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#getting-help","title":"Getting Help","text":"<ul> <li>Issues/Questions: GitHub Issues</li> <li>Examples: Browse the <code>examples/</code> directory</li> <li>Theory: Read <code>TNFR.pdf</code> in the repository root</li> </ul>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#congratulations","title":"Congratulations! \ud83c\udf89","text":"<p>You've completed the TNFR Interactive Tutorial! You now understand:</p> <ul> <li>\u2713 What nodes, EPI, \u03bdf, and phase represent</li> <li>\u2713 How structural operators reorganize networks</li> <li>\u2713 How to measure coherence and sense index</li> <li>\u2713 How to model real systems with TNFR</li> <li>\u2713 How to analyze and optimize network structures</li> </ul> <p>You're ready to build TNFR applications!</p> <p>Remember: TNFR is not a metaphor. It's an operational paradigm with concrete tools for modeling coherent structures across scales. Every modification you make should preserve the canonical invariants while exploring new structural possibilities.</p> <p>Happy resonating! \ud83c\udfb5</p>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#quick-reference-card","title":"Quick Reference Card","text":""},{"location":"getting-started/INTERACTIVE_TUTORIAL/#essential-api","title":"Essential API","text":"<pre><code>from tnfr.sdk import TNFRNetwork\n\n# Create network\nnet = TNFRNetwork(\"name\")\n\n# Add nodes\nnet.add_nodes(count)\n\n# Connect\nnet.connect_nodes(probability, topology)  # topology: \"random\", \"ring\", \"complete\"\n\n# Apply operators\nnet.apply_sequence(name, repeat=n)  # name: \"basic_activation\", \"network_sync\", etc.\n\n# Measure\nresults = net.measure()\nprint(results.summary())\n</code></pre>"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#key-metrics","title":"Key Metrics","text":"Metric Symbol Range Meaning Coherence C(t) 0-1 Network synchronization Sense Index Si 0-1 Reorganization capacity Structural Frequency \u03bdf &gt;0 Reorganization rate (Hz_str) Internal Gradient \u0394NFR \u211d Evolution driver Phase \u03b8 0-2\u03c0 Synchrony state (radians)"},{"location":"getting-started/INTERACTIVE_TUTORIAL/#operator-cheat-sheet","title":"Operator Cheat Sheet","text":"Operator Effect Common Use emission Start resonance Begin sequences reception Capture info After emission coherence Stabilize Consolidate structure resonance Propagate Sync network coupling Strengthen bonds Increase integration dissonance Create conflict Explore alternatives mutation Phase shift Transform structure silence Freeze state Observe results <p>Tutorial version: 1.0 | Last updated: 2025</p>"},{"location":"getting-started/QUICKSTART_NEW/","title":"TNFR Quick Start Guide","text":"<p>Get started with TNFR in 5 minutes! \ud83d\ude80</p> <p>This guide will help you create your first TNFR network and understand the basics. No deep theoretical knowledge required - we'll explain as we go.</p> <p>Want to understand the theory first? \u2192 See TNFR Fundamental Concepts for a comprehensive introduction to the paradigm (10 minutes).</p>"},{"location":"getting-started/QUICKSTART_NEW/#what-is-tnfr","title":"What is TNFR?","text":"<p>TNFR (Teor\u00eda de la Naturaleza Fractal Resonante) is a paradigm for modeling systems as networks of resonating nodes. Think of it like this:</p> <ul> <li>\ud83c\udfb5 Nodes are like musical notes that vibrate at different frequencies</li> <li>\ud83d\udd17 Connections allow nodes to influence each other</li> <li>\ud83c\udfb6 Operators are actions that change how nodes interact</li> <li>\ud83d\udcca Coherence measures how well the network stays organized</li> </ul> <p>Key concepts (don't worry, we'll explain these): - EPI: The \"shape\" or state of a node - \u03bdf (nu-f): How fast a node vibrates (in Hz_str units) - C(t): Network coherence (stability measure) - Si: Sense index (how well a node can adapt)</p> <p>For detailed explanations, see TNFR Fundamental Concepts.</p>"},{"location":"getting-started/QUICKSTART_NEW/#installation","title":"Installation","text":"<pre><code>pip install tnfr\n</code></pre> <p>That's it! You're ready to go.</p>"},{"location":"getting-started/QUICKSTART_NEW/#your-first-tnfr-network-3-lines","title":"Your First TNFR Network (3 lines!)","text":"<pre><code>from tnfr.sdk import TNFRNetwork\n\n# Create, connect, and measure a network\nnetwork = TNFRNetwork(\"my_first_network\")\nnetwork.add_nodes(10).connect_nodes(0.3, \"random\")\nresults = network.apply_sequence(\"basic_activation\", repeat=3).measure()\n\nprint(results.summary())\n</code></pre> <p>Output: <pre><code>Network Results Summary\n-----------------------\nCoherence C(t): 0.XXX\nAverage Sense Index: 0.XXX\nNumber of nodes: 10\n...\n</code></pre></p> <p>\ud83c\udf89 Congratulations! You just created, activated, and measured a TNFR network!</p>"},{"location":"getting-started/QUICKSTART_NEW/#what-just-happened","title":"What Just Happened?","text":"<p>Let's break down those 3 lines:</p>"},{"location":"getting-started/QUICKSTART_NEW/#line-1-create-a-network","title":"Line 1: Create a Network","text":"<p><pre><code>network = TNFRNetwork(\"my_first_network\")\n</code></pre> - Creates an empty network with a name - Like creating a new canvas for your system</p>"},{"location":"getting-started/QUICKSTART_NEW/#line-2-add-nodes-and-connect","title":"Line 2: Add Nodes and Connect","text":"<p><pre><code>network.add_nodes(10).connect_nodes(0.3, \"random\")\n</code></pre> - <code>add_nodes(10)</code>: Creates 10 resonating nodes - Each node gets a random frequency (\u03bdf) and phase (\u03c6) - <code>connect_nodes(0.3, \"random\")</code>: Connects nodes with 30% probability - Think of it like neurons forming synapses</p>"},{"location":"getting-started/QUICKSTART_NEW/#line-3-apply-operators-and-measure","title":"Line 3: Apply Operators and Measure","text":"<p><pre><code>results = network.apply_sequence(\"basic_activation\", repeat=3).measure()\n</code></pre> - <code>apply_sequence(\"basic_activation\", repeat=3)</code>: Activates the network 3 times - This runs: emission \u2192 reception \u2192 coherence \u2192 resonance \u2192 silence - <code>measure()</code>: Captures the final state and calculates metrics</p>"},{"location":"getting-started/QUICKSTART_NEW/#understanding-the-results","title":"Understanding the Results","text":"<p>The <code>results</code> object contains:</p> <pre><code>results.coherence        # C(t) - how stable is the network? (0-1)\nresults.sense_indices    # Si for each node - adaptability measure\nresults.delta_nfr       # \u0394NFR - reorganization for each node\nresults.avg_vf          # Average frequency across nodes\nresults.avg_phase       # Average phase angle\n</code></pre> <p>Interpreting coherence: - <code>C(t) &gt; 0.6</code> \u2192 Highly coherent (very stable) - <code>C(t) = 0.3-0.6</code> \u2192 Moderately coherent (some stability) - <code>C(t) &lt; 0.3</code> \u2192 Low coherence (loosely organized)</p>"},{"location":"getting-started/QUICKSTART_NEW/#interactive-tutorial","title":"Interactive Tutorial","text":"<p>Want a guided tour? Run the interactive tutorial:</p> <pre><code>from tnfr.tutorials import hello_tnfr\n\nhello_tnfr()\n</code></pre> <p>This 5-minute interactive tutorial explains concepts as you go!</p>"},{"location":"getting-started/QUICKSTART_NEW/#pre-built-operator-sequences","title":"Pre-Built Operator Sequences","text":"<p>TNFR provides ready-to-use sequences for common patterns:</p> <pre><code># Stabilize a network\nnetwork.apply_sequence(\"stabilization\", repeat=5)\n\n# Introduce creative change\nnetwork.apply_sequence(\"creative_mutation\", repeat=3)\n\n# Synchronize network\nnetwork.apply_sequence(\"network_sync\", repeat=10)\n\n# Explore new states\nnetwork.apply_sequence(\"exploration\", repeat=5)\n\n# Consolidate structure\nnetwork.apply_sequence(\"consolidation\", repeat=7)\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#domain-specific-examples","title":"Domain-Specific Examples","text":""},{"location":"getting-started/QUICKSTART_NEW/#biology-cell-communication","title":"Biology: Cell Communication","text":"<pre><code>from tnfr.tutorials import biological_example\n\nresults = biological_example()\nprint(f\"Tissue coherence: {results['coherence']:.3f}\")\n</code></pre> <p>Models how cells coordinate through signaling.</p>"},{"location":"getting-started/QUICKSTART_NEW/#sociology-social-dynamics","title":"Sociology: Social Dynamics","text":"<pre><code>from tnfr.tutorials import social_network_example\n\nresults = social_network_example()\nprint(f\"Group cohesion: {results['coherence']:.3f}\")\n</code></pre> <p>Models how people reach consensus in groups.</p>"},{"location":"getting-started/QUICKSTART_NEW/#technology-distributed-systems","title":"Technology: Distributed Systems","text":"<pre><code>from tnfr.tutorials import technology_example\n\nresults = technology_example()\nprint(f\"System reliability: {results['coherence']:.3f}\")\n</code></pre> <p>Models microservice coordination and resilience.</p>"},{"location":"getting-started/QUICKSTART_NEW/#method-chaining-fluent-api","title":"Method Chaining (Fluent API)","text":"<p>Build complex workflows with clean, readable code:</p> <pre><code>results = (\n    TNFRNetwork(\"experiment\")\n    .add_nodes(20, vf_range=(0.4, 0.8))\n    .connect_nodes(0.5, \"ring\")\n    .apply_sequence(\"network_sync\", repeat=5)\n    .apply_sequence(\"consolidation\", repeat=3)\n    .measure()\n)\n\nprint(f\"Final coherence: {results.coherence:.3f}\")\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#accessing-detailed-data","title":"Accessing Detailed Data","text":"<pre><code># Get full results dictionary\ndata = results.to_dict()\n\n# Iterate over node metrics\nfor node_id, si_value in results.sense_indices.items():\n    print(f\"Node {node_id}: Si = {si_value:.3f}\")\n\n# Access the underlying NetworkX graph\ngraph = results.graph\nprint(f\"Number of edges: {graph.number_of_edges()}\")\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/QUICKSTART_NEW/#pattern-1-quick-experiment","title":"Pattern 1: Quick Experiment","text":"<pre><code>from tnfr.sdk import TNFRNetwork\n\nnetwork = TNFRNetwork(\"quick_test\")\nresults = (\n    network\n    .add_nodes(15)\n    .connect_nodes(0.3, \"random\")\n    .apply_sequence(\"basic_activation\", repeat=5)\n    .measure()\n)\nprint(results.summary())\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#pattern-2-multiple-configurations","title":"Pattern 2: Multiple Configurations","text":"<pre><code>for connectivity in [0.1, 0.3, 0.5, 0.7]:\n    network = TNFRNetwork(f\"connectivity_{connectivity}\")\n    results = (\n        network\n        .add_nodes(20)\n        .connect_nodes(connectivity, \"random\")\n        .apply_sequence(\"network_sync\", repeat=10)\n        .measure()\n    )\n    print(f\"Connectivity {connectivity}: C(t) = {results.coherence:.3f}\")\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#pattern-3-custom-frequency-range","title":"Pattern 3: Custom Frequency Range","text":"<pre><code># Create nodes with specific frequency range\nnetwork = TNFRNetwork(\"high_frequency\")\nnetwork.add_nodes(\n    25,\n    vf_range=(0.7, 1.5),  # Higher frequencies\n    random_seed=42        # Reproducible\n)\nnetwork.connect_nodes(0.4, \"random\")\nresults = network.apply_sequence(\"stabilization\", repeat=10).measure()\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#the-13-tnfr-operators","title":"The 13 TNFR Operators","text":"<p>When you're ready to dive deeper, here are all the operators:</p> <ol> <li>emission - Start broadcasting signals</li> <li>reception - Receive signals from neighbors</li> <li>coherence - Stabilize structure</li> <li>dissonance - Introduce reorganization</li> <li>coupling - Create dependencies between nodes</li> <li>resonance - Amplify synchronized patterns</li> <li>silence - Pause evolution</li> <li>expansion - Grow network influence</li> <li>contraction - Reduce network influence</li> <li>self_organization - Let structure emerge</li> <li>mutation - Change node phase/state</li> <li>transition - Move to new structural state</li> <li>recursivity - Apply structure to itself</li> </ol>"},{"location":"getting-started/QUICKSTART_NEW/#error-messages-with-hints","title":"Error Messages with Hints","text":"<p>TNFR provides helpful error messages:</p> <pre><code>from tnfr.errors import OperatorSequenceError\n\ntry:\n    network.apply_sequence(\"emision\")  # Typo!\nexcept OperatorSequenceError as e:\n    print(e)\n</code></pre> <p>Output: <pre><code>======================================================================\nTNFR Error: Invalid operator sequence: 'emision' cannot be applied\n======================================================================\n\n\ud83d\udca1 Suggestion: Did you mean one of: emission, recursivity? Use one of the 13 canonical operators...\n\n\ud83d\udcca Context:\n   \u2022 invalid_operator: emision\n   \u2022 sequence_so_far: empty\n   \u2022 operator_count: 0\n\n\ud83d\udcda Documentation: https://github.com/fermga/Teoria-de-la-naturaleza-fractal-resonante-TNFR-/blob/main/docs/source/api/operators.md\n======================================================================\n</code></pre></p>"},{"location":"getting-started/QUICKSTART_NEW/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/QUICKSTART_NEW/#learn-more","title":"Learn More","text":"<ul> <li>\ud83d\udcd6 Foundations - TNFR theory explained</li> <li>\ud83d\udd27 API Reference - Detailed API documentation</li> <li>\ud83d\udcda Examples - More code examples</li> <li>\ud83c\udfaf Operator Guide - Deep dive into operators</li> </ul>"},{"location":"getting-started/QUICKSTART_NEW/#explore-tutorials","title":"Explore Tutorials","text":"<pre><code>from tnfr.tutorials import (\n    hello_tnfr,              # 5-minute introduction\n    biological_example,      # Cell communication\n    social_network_example,  # Social dynamics\n    technology_example,      # Distributed systems\n    run_all_tutorials        # Run all tutorials\n)\n\n# Try them all!\nrun_all_tutorials()\n</code></pre>"},{"location":"getting-started/QUICKSTART_NEW/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Backend Performance - GPU acceleration with JAX/Torch</li> <li>Optional Dependencies - Caching and optimization</li> <li>Telemetry - Metrics and tracing</li> </ul>"},{"location":"getting-started/QUICKSTART_NEW/#getting-help","title":"Getting Help","text":"<p>Found a bug or need help? - GitHub Issues: https://github.com/fermga/Teoria-de-la-naturaleza-fractal-resonante-TNFR-/issues - Documentation: https://tnfr.readthedocs.io/ - Examples: Check the <code>examples/</code> directory</p> <p>Want to contribute? - See CONTRIBUTING.md for guidelines - Read AGENTS.md for TNFR invariants</p>"},{"location":"getting-started/QUICKSTART_NEW/#summary","title":"Summary","text":"<p>You've learned: - \u2705 How to install TNFR - \u2705 How to create your first network (3 lines!) - \u2705 What the key concepts mean (EPI, \u03bdf, C(t), Si) - \u2705 How to use operator sequences - \u2705 How to interpret results - \u2705 Where to find domain examples (bio, social, tech) - \u2705 How to access detailed data</p> <p>Next: Try the interactive tutorials or explore domain-specific examples!</p> <pre><code>from tnfr.tutorials import hello_tnfr\nhello_tnfr()  # Start learning interactively!\n</code></pre> <p>This quick start guide gets you running in minutes while maintaining full TNFR theoretical fidelity. As you advance, you'll discover the deep structural principles that make TNFR a powerful paradigm for modeling complex systems.</p>"},{"location":"getting-started/TNFR_CONCEPTS/","title":"TNFR Fundamental Concepts","text":"<p>Goal: Understand the core principles of the Resonant Fractal Nature Theory (TNFR) in 10 minutes and smoothly transition from theory to practice.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#what-is-tnfr","title":"What is TNFR?","text":"<p>TNFR (Resonant Fractal Nature Theory / Teor\u00eda de la Naturaleza Fractal Resonante) is not just another modeling framework - it's a complete paradigm shift in how we understand reality and complex systems.</p> <p>Core Principle: Reality is not made of isolated \"things\" but of coherent patterns that persist because they resonate with their environment.</p> <p>Think of a choir: each singer maintains their unique voice while coordinating with others to create harmonious patterns. When voices synchronize (resonate), they produce stable, beautiful structures. When they clash (dissonance), the pattern breaks down. TNFR models this principle at every scale, from quantum to social systems.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#why-tnfr","title":"Why TNFR?","text":"<p>Traditional approaches model systems as collections of independent objects that interact through cause-and-effect relationships. TNFR takes a fundamentally different view:</p> Traditional Paradigm TNFR Paradigm Objects exist independently Patterns exist through resonance Causality: A causes B Coherence: A and B co-organize Information as data Information as vibrational structure Observer watches from outside Observer is a resonating node Static representations Dynamic reorganization <p>Key Advantages: - \ud83c\udfaf Operational fractality: Patterns scale without losing structure - \ud83d\udd0d Complete traceability: Every reorganization is observable - \ud83d\udd04 Guaranteed reproducibility: Same conditions \u2192 same outcomes - \ud83c\udf10 Trans-scale: Works from quantum to social systems</p>"},{"location":"getting-started/TNFR_CONCEPTS/#1-the-fractal-resonant-paradigm","title":"1. The Fractal Resonant Paradigm","text":""},{"location":"getting-started/TNFR_CONCEPTS/#reality-as-a-vibrational-network","title":"Reality as a Vibrational Network","text":"<p>Imagine reality as an infinite network where every node is constantly vibrating. These vibrations aren't random - they synchronize when compatible and interfere when incompatible. What we perceive as \"objects\" or \"structures\" are actually stable patterns of synchronized vibration.</p> <p>Key Insight: A pattern exists not because something \"holds it together\" but because its internal vibration resonates with the vibrations around it. When resonance breaks, the pattern dissolves.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#coherence-vs-fragmentation","title":"Coherence vs. Fragmentation","text":"<ul> <li>Coherence: When parts of a network vibrate in synchrony, they form stable, recognizable patterns</li> <li>Fragmentation: When synchrony breaks, patterns dissolve into incoherent noise</li> </ul> <p>Think of waves on water:  - Coherent: Ripples from a stone create clear, expanding circles - Fragmented: Choppy water shows no recognizable pattern</p>"},{"location":"getting-started/TNFR_CONCEPTS/#structural-emergence","title":"Structural Emergence","text":"<p>New patterns don't require external design - they emerge spontaneously when local interactions create sufficient coherence. This is how: - Cells organize into tissues - Neurons synchronize into consciousness - People coordinate into communities - Markets self-organize into trends</p> <p>TNFR captures this emergence mathematically, allowing us to predict, measure, and influence it.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#2-fundamental-elements","title":"2. Fundamental Elements","text":""},{"location":"getting-started/TNFR_CONCEPTS/#resonant-fractal-node-nfr","title":"Resonant Fractal Node (NFR)","text":"<p>Definition: The minimum unit of structural coherence in a TNFR network.</p> <p>Think of an NFR as a tuning fork in a network of tuning forks. Each fork: - Has its own natural frequency - Can vibrate independently - Responds to vibrations from nearby forks - Contributes to the overall pattern</p> <p>Every NFR has three essential properties:</p>"},{"location":"getting-started/TNFR_CONCEPTS/#1-epi-estructura-primaria-de-informacion-primary-information-structure","title":"1. EPI (Estructura Primaria de Informaci\u00f3n / Primary Information Structure)","text":"<p>What it is: The coherent \"shape\" or \"form\" of a node - its structural identity.</p> <p>Analogy: Think of EPI as a musical chord. Just as a chord has a specific structure (which notes, which octaves), EPI defines the structural configuration of a node.</p> <p>Key Properties: - Changes ONLY through structural operators (never arbitrary mutations) - Maintains coherence through network coupling - Can contain nested sub-structures (fractality)</p> <p>In code: <pre><code># EPI is stored as a scalar or array representing the node's structure\nG.nodes[node]['epi'] = 0.2  # Simple scalar EPI\n# More complex EPIs can be multidimensional arrays\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#2-f-structural-frequency","title":"2. \u03bdf (Structural Frequency)","text":"<p>Symbol: \u03bdf (nu sub f) Units: Hz_str (structural hertz) What it is: The rate at which a node reorganizes its internal structure.</p> <p>Analogy: Like a heart rate, but for structural change. A higher \u03bdf means faster reorganization; a lower \u03bdf means slower, more stable evolution.</p> <p>Key Properties: - NOT a physical frequency (like sound waves) - Determines how fast EPI evolves - Nodes \"die\" (collapse) when \u03bdf \u2192 0 - Influences coupling strength with other nodes</p> <p>In code: <pre><code>G.nodes[node]['vf'] = 1.0  # Structural frequency in Hz_str\n# Typical range: 0.1 to 10.0 Hz_str\n</code></pre></p> <p>Important: Always expressed in Hz_str units to distinguish structural from physical frequencies.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#3-phase-or","title":"3. Phase (\u03c6 or \u03b8)","text":"<p>What it is: The relative timing/synchrony of a node with its neighbors in the network.</p> <p>Analogy: Like dancers in a choreography. Even if they're performing different moves (different EPIs), they need to be in sync (same phase) to create a coherent performance.</p> <p>Key Properties: - Range: 0 to 2\u03c0 radians (or -\u03c0 to \u03c0) - Determines if nodes can couple effectively - Must be explicitly verified before coupling - Coordinated through network interactions</p> <p>In code: <pre><code>G.nodes[node]['phase'] = 0.0  # Phase in radians\n# Nodes with similar phase can resonate\n</code></pre></p> <p>Visual Example: <pre><code>Node A: phase = 0.0    \u25cf----\u2192\nNode B: phase = 0.1    \u25cf----\u2192  \u2713 Can resonate (phases close)\nNode C: phase = \u03c0      \u25cf\u2190----  \u2717 Opposite phase, dissonance\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#nfr-gradiente-nodal-internal-reorganization-operator","title":"\u0394NFR (Gradiente Nodal / Internal Reorganization Operator)","text":"<p>What it is: The \"pressure\" or \"gradient\" driving structural change in a node.</p> <p>Analogy: Like the difference in water pressure that drives flow. \u0394NFR measures the \"structural pressure\" between a node's current state and the network around it.</p> <p>Key Properties: - Sign matters:    - Positive (+): Expansion, growth   - Negative (-): Contraction, simplification - Magnitude matters: Larger |\u0394NFR| = more intense reorganization - NOT an ML gradient: This isn't about minimizing error; it's about structural evolution - Computed from topology, phase, EPI, and \u03bdf</p> <p>In code: <pre><code># \u0394NFR is computed automatically via hooks\ndelta_nfr = G.nodes[node]['delta_nfr']\n# Typical range: -5.0 to +5.0 (depends on network topology)\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#3-the-nodal-equation","title":"3. The Nodal Equation","text":"<p>The heart of TNFR is captured in one elegant equation:</p> <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#breaking-it-down","title":"Breaking It Down","text":"<p>\u2202EPI/\u2202t: \"How fast is the structure changing?\" - The rate of change of the node's information structure over time</p> <p>\u03bdf: \"What's the node's natural reorganization rate?\" - The structural frequency - how quickly the node can change</p> <p>\u0394NFR(t): \"What's the structural pressure at time t?\" - The reorganization gradient driving the change</p>"},{"location":"getting-started/TNFR_CONCEPTS/#what-this-means","title":"What This Means","text":"<p>A structure only changes when: 1. There's a reorganization gradient (\u0394NFR \u2260 0) 2. The node has capacity to reorganize (\u03bdf &gt; 0) 3. The change is proportional to both</p> <p>Implications: - Zero frequency (\u03bdf = 0): No change possible, even with strong \u0394NFR (frozen structure) - Zero gradient (\u0394NFR = 0): No pressure to change (equilibrium) - Both positive: Structure evolves actively</p>"},{"location":"getting-started/TNFR_CONCEPTS/#intuitive-example","title":"Intuitive Example","text":"<p>Think of a sailboat: - EPI: The boat's position and direction - \u03bdf: The boat's ability to maneuver (rudder responsiveness) - \u0394NFR: Wind pressure pushing the boat - \u2202EPI/\u2202t: How fast the boat actually moves</p> <pre><code>Strong wind (\u0394NFR) \u00d7 Responsive rudder (\u03bdf) = Fast movement (\u2202EPI/\u2202t)\nStrong wind (\u0394NFR) \u00d7 Locked rudder (\u03bdf=0) = No movement (\u2202EPI/\u2202t=0)\nNo wind (\u0394NFR=0) \u00d7 Responsive rudder (\u03bdf) = No movement (\u2202EPI/\u2202t=0)\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#in-practice","title":"In Practice","text":"<pre><code>from tnfr import create_nfr, run_sequence\nfrom tnfr.structural import Emission, Coherence\n\n# Create a node with specific EPI, \u03bdf, and phase\nG, node = create_nfr(\"A\", epi=0.2, vf=1.0, theta=0.0)\n\n# Apply operators that modify \u0394NFR\nops = [Emission(), Coherence()]\nrun_sequence(G, node, ops)\n\n# The nodal equation governs how EPI evolves\n# New EPI = Old EPI + (\u03bdf \u00d7 \u0394NFR \u00d7 dt)\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#4-structural-operators","title":"4. Structural Operators","text":"<p>Structural operators are the only way to modify nodes in TNFR. They're not arbitrary functions - they're resonant transformations that preserve structural coherence.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#why-operators","title":"Why Operators?","text":"<p>In traditional programming, you might write: <pre><code>node.value = new_value  # Arbitrary mutation\n</code></pre></p> <p>In TNFR, every change must go through operators: <pre><code>Emission().apply(G, node)  # Structural transformation\n</code></pre></p> <p>This ensures that all changes are traceable, coherent, and reproducible.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#the-13-canonical-operators","title":"The 13 Canonical Operators","text":"<p>Think of these as musical gestures rather than mechanical operations:</p>"},{"location":"getting-started/TNFR_CONCEPTS/#1-emission-al","title":"1. Emission (AL) \ud83c\udfb5","text":"<p>Function: Initiates a resonant pattern Effect: Increases \u03bdf and creates positive \u0394NFR When to use: Starting new patterns, launching trajectories</p> <pre><code>from tnfr.structural import Emission\nEmission().apply(G, node)  # Node begins radiating\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#2-reception-en","title":"2. Reception (EN) \ud83d\udce1","text":"<p>Function: Receives and integrates external patterns Effect: Updates EPI based on incoming resonance When to use: Gathering information, network listening</p> <pre><code>from tnfr.structural import Reception\nReception().apply(G, node)  # Node absorbs from neighbors\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#3-coherence-il","title":"3. Coherence (IL) \ud83d\udd12","text":"<p>Function: Stabilizes structural form Effect: Increases C(t), reduces |\u0394NFR| When to use: After changes, to consolidate structure</p> <pre><code>from tnfr.structural import Coherence\nCoherence().apply(G, node)  # Node stabilizes\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#4-dissonance-oz","title":"4. Dissonance (OZ) \u26a1","text":"<p>Function: Introduces controlled instability Effect: Increases |\u0394NFR|, may trigger bifurcation When to use: Breaking out of local optima, exploration</p> <pre><code>from tnfr.structural import Dissonance\nDissonance().apply(G, node)  # Node destabilizes (controlled)\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#5-coupling-um","title":"5. Coupling (UM) \ud83d\udd17","text":"<p>Function: Creates structural links between nodes Effect: Phase synchronization, information exchange When to use: Network formation, connecting nodes</p> <pre><code>from tnfr.structural import Coupling\nCoupling().apply(G, node)  # Node couples with neighbors\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#6-resonance-ra","title":"6. Resonance (RA) \ud83c\udf0a","text":"<p>Function: Amplifies and propagates patterns Effect: Increases effective coupling, preserves EPI identity When to use: Pattern reinforcement, spreading coherence</p> <pre><code>from tnfr.structural import Resonance\nResonance().apply(G, node)  # Pattern propagates\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#7-silence-sha","title":"7. Silence (SHA) \ud83d\udd07","text":"<p>Function: Temporarily freezes evolution Effect: Sets \u03bdf \u2248 0, EPI unchanged When to use: Observation windows, synchronization pauses</p> <pre><code>from tnfr.structural import Silence\nSilence().apply(G, node)  # Node pauses evolution\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#8-expansion-val","title":"8. Expansion (VAL) \ud83d\udcc8","text":"<p>Function: Increases structural complexity Effect: EPI dimensionality grows When to use: Adding degrees of freedom, elaboration</p> <pre><code>from tnfr.structural import Expansion\nExpansion().apply(G, node)  # Structure becomes more complex\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#9-contraction-nul","title":"9. Contraction (NUL) \ud83d\udcc9","text":"<p>Function: Reduces structural complexity Effect: EPI dimensionality decreases When to use: Simplification, focusing</p> <pre><code>from tnfr.structural import Contraction\nContraction().apply(G, node)  # Structure simplifies\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#10-self-organization-thol","title":"10. Self-organization (THOL) \ud83c\udf31","text":"<p>Function: Spontaneous pattern formation Effect: Creates sub-EPIs while preserving global form When to use: Emergent structure formation, fractalization</p> <pre><code>from tnfr.structural import SelfOrganization\nSelfOrganization().apply(G, node)  # Emergent sub-patterns\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#11-mutation-zhir","title":"11. Mutation (ZHIR) \ud83e\uddec","text":"<p>Function: Phase transformation Effect: \u03b8 \u2192 \u03b8' when structural threshold crossed When to use: Qualitative state changes, phase transitions</p> <pre><code>from tnfr.structural import Mutation\nMutation().apply(G, node)  # Node changes phase\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#12-transition-nav","title":"12. Transition (NAV) \u27a1\ufe0f","text":"<p>Function: Movement between structural states Effect: Controlled EPI evolution along path When to use: Trajectory navigation, guided change</p> <pre><code>from tnfr.structural import Transition\nTransition().apply(G, node)  # Structured movement\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#13-recursivity-remesh","title":"13. Recursivity (REMESH) \ud83d\udd04","text":"<p>Function: Nested operator application Effect: Maintains operational fractality When to use: Multi-scale operations, hierarchical coherence</p> <pre><code>from tnfr.structural import Recursivity\nRecursivity().apply(G, node)  # Operators nest\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#operator-sequences","title":"Operator Sequences","text":"<p>Operators are rarely used alone. They combine into sequences that create complex behaviors:</p> <pre><code>from tnfr import run_sequence\nfrom tnfr.structural import Emission, Reception, Coherence, Resonance\n\n# A typical \"activation\" sequence\nops = [\n    Emission(),      # 1. Start emitting\n    Reception(),     # 2. Listen to neighbors\n    Coherence(),     # 3. Stabilize\n    Resonance(),     # 4. Propagate pattern\n]\n\nrun_sequence(G, node, ops)\n</code></pre> <p>Common Sequences: - Bootstrap: <code>[Emission, Coupling, Coherence]</code> - Start a new node - Stabilize: <code>[Coherence, Silence]</code> - Freeze current state - Explore: <code>[Dissonance, Mutation, Coherence]</code> - Try new configurations - Propagate: <code>[Resonance, Coupling]</code> - Spread patterns through network</p>"},{"location":"getting-started/TNFR_CONCEPTS/#5-coherence-metrics","title":"5. Coherence Metrics","text":"<p>How do we measure if a network is working? TNFR provides precise, observable metrics:</p>"},{"location":"getting-started/TNFR_CONCEPTS/#total-coherence-ct","title":"Total Coherence C(t)","text":"<p>What it is: Global measure of network stability at time t.</p> <p>Analogy: Like measuring the clarity of a choir's harmony. High C(t) = clear, stable patterns. Low C(t) = chaotic, fragmented noise.</p> <p>Range: 0.0 (total chaos) to 1.0 (perfect coherence)</p> <p>Interpretation: - C(t) &gt; 0.7: Strong coherence, stable patterns - 0.3 &lt; C(t) &lt; 0.7: Moderate coherence, evolving patterns - C(t) &lt; 0.3: Weak coherence, risk of fragmentation</p> <p>In code: <pre><code>from tnfr.metrics.common import compute_coherence\n\nC_t = compute_coherence(G)\nprint(f\"Network coherence: {C_t:.3f}\")\n\n# With additional statistics\nC, mean_delta_nfr, mean_depi = compute_coherence(G, return_means=True)\nprint(f\"C(t)={C:.3f}, \u0394NFR\u0304={mean_delta_nfr:.3f}, dEPI/dt\u0304={mean_depi:.3f}\")\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#sense-index-si","title":"Sense Index (Si)","text":"<p>What it is: Capacity to generate stable reorganization patterns.</p> <p>Analogy: Like measuring a musician's skill. High Si = can improvise while maintaining harmony. Low Si = changes lead to chaos.</p> <p>Range: 0.0 (unstable) to 1.0+ (highly stable)</p> <p>Interpretation: - Si &gt; 0.8: Excellent reorganization stability - 0.4 &lt; Si &lt; 0.8: Moderate stability, careful changes needed - Si &lt; 0.4: Warning - changes may cause bifurcation</p> <p>Key Properties: - Combines \u0394NFR, \u03bdf, and phase information - Can be computed per-node or network-wide - Sensitive to phase dispersion</p> <p>In code: <pre><code>from tnfr.metrics.sense_index import compute_Si\n\n# Per-node Sense Index\nsi_per_node = compute_Si(G)\nprint(f\"Node A: Si = {si_per_node['A']:.3f}\")\n\n# Network average\navg_si = sum(si_per_node.values()) / len(si_per_node)\nprint(f\"Network average Si: {avg_si:.3f}\")\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#phase-coherence","title":"Phase Coherence","text":"<p>What it is: How synchronized are nodes' phases?</p> <p>Measured by: Kuramoto order parameter</p> <p>Range: 0.0 (no synchrony) to 1.0 (perfect synchrony)</p> <p>In code: <pre><code># Phase coherence is automatically computed and stored\nphase_coherence = G.graph['telemetry'].get('kuramoto_R', 0.0)\nprint(f\"Phase coherence: {phase_coherence:.3f}\")\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#monitoring-network-health","title":"Monitoring Network Health","text":"<p>A healthy TNFR network shows: - Rising or stable C(t): Pattern formation is succeeding - Moderate Si: Good balance of stability and adaptability - Phase coherence &gt; 0.5: Nodes are synchronizing - Bounded \u0394NFR: Changes are under control</p> <p>Example monitoring code: <pre><code>from tnfr.sdk import TNFRNetwork\n\nnetwork = TNFRNetwork(\"health_check\")\nnetwork.add_nodes(20).connect_nodes(0.3, \"random\")\n\n# Apply operators and measure repeatedly\nfor i in range(10):\n    results = network.apply_sequence(\"basic_activation\").measure()\n\n    print(f\"Step {i}: C(t)={results.coherence:.3f}, \"\n          f\"Si={results.sense_index:.3f}, \"\n          f\"Phase={results.phase_coherence:.3f}\")\n\n    # Check health\n    if results.coherence &lt; 0.3:\n        print(\"\u26a0\ufe0f  Warning: Low coherence!\")\n    if results.sense_index &lt; 0.4:\n        print(\"\u26a0\ufe0f  Warning: Unstable reorganization!\")\n</code></pre></p>"},{"location":"getting-started/TNFR_CONCEPTS/#6-from-theory-to-practice","title":"6. From Theory to Practice","text":""},{"location":"getting-started/TNFR_CONCEPTS/#creating-your-first-network","title":"Creating Your First Network","text":"<pre><code>from tnfr.sdk import TNFRNetwork\n\n# High-level API (recommended for beginners)\nnetwork = TNFRNetwork(\"my_first_network\")\n\n# Add nodes\nnetwork.add_nodes(10)\n\n# Connect with random topology (30% connection probability)\nnetwork.connect_nodes(0.3, \"random\")\n\n# Apply a predefined sequence\nnetwork.apply_sequence(\"basic_activation\", repeat=3)\n\n# Measure results\nresults = network.measure()\nprint(results.summary())\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#low-level-control","title":"Low-Level Control","text":"<p>For fine-grained control over individual nodes:</p> <pre><code>from tnfr import create_nfr, run_sequence\nfrom tnfr.structural import Emission, Reception, Coherence\n\n# Create a single node\nG, node = create_nfr(\n    \"A\",               # Node identifier\n    epi=0.2,           # Initial EPI\n    vf=1.0,            # Structural frequency (Hz_str)\n    theta=0.0          # Initial phase (radians)\n)\n\n# Apply specific operators\nops = [Emission(), Reception(), Coherence()]\nrun_sequence(G, node, ops)\n\n# Read node state\nprint(f\"EPI: {G.nodes[node]['epi']}\")\nprint(f\"\u03bdf: {G.nodes[node]['vf']} Hz_str\")\nprint(f\"Phase: {G.nodes[node]['phase']} rad\")\nprint(f\"\u0394NFR: {G.nodes[node]['delta_nfr']}\")\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#building-multi-node-networks","title":"Building Multi-Node Networks","text":"<pre><code>import networkx as nx\nfrom tnfr import prepare_network\nfrom tnfr.dynamics import step\n\n# Create a graph with NetworkX\nG = nx.Graph()\nG.add_nodes_from([\n    (\"A\", {\"epi\": 0.2, \"vf\": 1.0, \"phase\": 0.0}),\n    (\"B\", {\"epi\": 0.3, \"vf\": 1.2, \"phase\": 0.1}),\n    (\"C\", {\"epi\": 0.25, \"vf\": 0.9, \"phase\": 0.05}),\n])\nG.add_edges_from([(\"A\", \"B\"), (\"B\", \"C\")])\n\n# Prepare for TNFR dynamics\nprepare_network(G)\n\n# Evolve the network\nfor t in range(10):\n    step(G, dt=0.1)\n\n    # Check coherence\n    from tnfr.metrics.common import compute_coherence\n    C = compute_coherence(G)\n    print(f\"t={t*0.1:.1f}: C(t)={C:.3f}\")\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#real-world-example-modeling-cell-communication","title":"Real-World Example: Modeling Cell Communication","text":"<pre><code>from tnfr.sdk import TNFRNetwork\n\n# Create a biological network\ncells = TNFRNetwork(\"cell_communication\")\n\n# Add 50 cells\ncells.add_nodes(50)\n\n# Connect based on spatial proximity (scale-free network)\ncells.connect_nodes(topology=\"scale_free\", m=3)\n\n# Simulate signal propagation\ncells.apply_sequence([\n    \"emission\",      # Cell emits signal\n    \"coupling\",      # Signal couples to neighbors\n    \"resonance\",     # Signal propagates\n    \"coherence\",     # Network stabilizes\n], repeat=5)\n\n# Measure communication efficiency\nresults = cells.measure()\nprint(f\"Communication coherence: {results.coherence:.3f}\")\nprint(f\"Signal stability (Si): {results.sense_index:.3f}\")\n\n# Visualize (if viz installed)\ntry:\n    cells.visualize()\nexcept ImportError:\n    print(\"Install viz: pip install tnfr[viz-basic]\")\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#7-next-steps","title":"7. Next Steps","text":""},{"location":"getting-started/TNFR_CONCEPTS/#immediate-next-actions","title":"Immediate Next Actions","text":"<ol> <li> <p>Run the Hello World example:    <pre><code>python examples/hello_world.py\n</code></pre></p> </li> <li> <p>Try interactive tutorials:    <pre><code>from tnfr.tutorials import hello_tnfr\nhello_tnfr()\n</code></pre></p> </li> <li> <p>Read the Quickstart:</p> </li> <li>QUICKSTART_NEW.md - Get started in 5 minutes</li> <li>quickstart.md - Python and CLI walkthroughs</li> </ol>"},{"location":"getting-started/TNFR_CONCEPTS/#deepen-your-understanding","title":"Deepen Your Understanding","text":"<ol> <li> <p>Explore domain examples:    <pre><code>from tnfr.tutorials import (\n    biological_example,    # Cell networks\n    social_network_example,  # Social dynamics\n    technology_example,      # Distributed systems\n)\n</code></pre></p> </li> <li> <p>Study theoretical foundations:</p> </li> <li>foundations.md - Mathematical scaffolding</li> <li>TNFR.pdf - Complete theoretical framework</li> <li>theory/mathematical_foundations.md - Complete mathematical formalization</li> </ol>"},{"location":"getting-started/TNFR_CONCEPTS/#master-the-tools","title":"Master the Tools","text":"<ol> <li>Learn the API:</li> <li>API Overview - Package architecture</li> <li>Structural Operators - Detailed operator reference</li> <li>Operators Visual Guide - Visual diagrams and interactive examples</li> <li> <p>Telemetry Guide - Metrics and traces</p> </li> <li> <p>See complete examples:</p> </li> <li>Examples Directory - Runnable scenarios</li> <li>Glyph Sequences Guide - Operator sequences</li> </ol>"},{"location":"getting-started/TNFR_CONCEPTS/#advanced-topics","title":"Advanced Topics","text":"<ol> <li>Understand the architecture:</li> <li>ARCHITECTURE.md - System design</li> <li> <p>GLOSSARY.md - Complete terminology reference</p> </li> <li> <p>Contribute:</p> </li> <li>CONTRIBUTING.md - Development guidelines</li> <li>TESTING.md - Test strategies</li> </ol>"},{"location":"getting-started/TNFR_CONCEPTS/#key-references","title":"Key References","text":"<ul> <li>Main repository: https://github.com/fermga/TNFR-Python-Engine</li> <li>PyPI package: https://pypi.org/project/tnfr/</li> <li>Documentation: https://tnfr.readthedocs.io/</li> </ul>"},{"location":"getting-started/TNFR_CONCEPTS/#quick-reference-card","title":"Quick Reference Card","text":""},{"location":"getting-started/TNFR_CONCEPTS/#essential-concepts","title":"Essential Concepts","text":"Concept Symbol Meaning Units Primary Information Structure EPI Node's coherent form \u2014 Structural Frequency \u03bdf Reorganization rate Hz_str Reorganization Gradient \u0394NFR Structural pressure \u2014 Phase \u03c6, \u03b8 Network synchrony radians Total Coherence C(t) Global stability 0-1 Sense Index Si Reorganization stability 0-1+"},{"location":"getting-started/TNFR_CONCEPTS/#nodal-equation","title":"Nodal Equation","text":"<p><pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre> Structure changes proportionally to frequency and gradient</p>"},{"location":"getting-started/TNFR_CONCEPTS/#essential-operators","title":"Essential Operators","text":"Operator Symbol Effect Use When Emission AL Start pattern Launching Reception EN Absorb pattern Listening Coherence IL Stabilize Consolidating Dissonance OZ Destabilize Exploring Resonance RA Propagate Spreading Silence SHA Pause Observing"},{"location":"getting-started/TNFR_CONCEPTS/#typical-workflow","title":"Typical Workflow","text":"<pre><code># 1. Create network\nfrom tnfr.sdk import TNFRNetwork\nnet = TNFRNetwork(\"my_net\")\n\n# 2. Add nodes and connections\nnet.add_nodes(10).connect_nodes(0.3, \"random\")\n\n# 3. Apply operators\nnet.apply_sequence(\"basic_activation\", repeat=3)\n\n# 4. Measure results\nresults = net.measure()\nprint(results.summary())\n</code></pre>"},{"location":"getting-started/TNFR_CONCEPTS/#common-questions","title":"Common Questions","text":""},{"location":"getting-started/TNFR_CONCEPTS/#why-cant-i-just-modify-nodes-directly","title":"\"Why can't I just modify nodes directly?\"","text":"<p>TNFR requires all changes to go through operators to maintain structural coherence and traceability. This ensures: - Changes are reproducible - The nodal equation is always respected - Network stability is preserved - All transformations are documented</p>"},{"location":"getting-started/TNFR_CONCEPTS/#whats-the-difference-between-f-and-nfr","title":"\"What's the difference between \u03bdf and \u0394NFR?\"","text":"<ul> <li>\u03bdf (structural frequency): Node's capacity to change (like engine power)</li> <li>\u0394NFR (reorganization gradient): Pressure driving change (like wind force)</li> <li>Both needed for evolution: <code>\u2202EPI/\u2202t = \u03bdf \u00d7 \u0394NFR</code></li> </ul>"},{"location":"getting-started/TNFR_CONCEPTS/#how-do-i-know-if-my-network-is-working-correctly","title":"\"How do I know if my network is working correctly?\"","text":"<p>Check three metrics: 1. C(t) &gt; 0.5: Network has coherence 2. Si &gt; 0.4: Reorganizations are stable 3. Phase coherence &gt; 0.5: Nodes are synchronizing</p>"},{"location":"getting-started/TNFR_CONCEPTS/#can-i-use-tnfr-for-my-domain","title":"\"Can I use TNFR for [my domain]?\"","text":"<p>Yes! TNFR is trans-scale and trans-domain. It has been applied to: - Biology (cellular networks, neural synchronization) - Social systems (community formation, information spread) - Technology (distributed systems, AI architectures) - Economics (market dynamics, resource allocation) - Physics (quantum systems, field theories)</p> <p>The key is identifying what \"resonates\" in your domain.</p>"},{"location":"getting-started/TNFR_CONCEPTS/#summary","title":"Summary","text":"<p>You now understand the core concepts of TNFR:</p> <p>\u2705 Paradigm: Reality as resonant patterns, not isolated objects \u2705 Elements: NFR nodes with EPI, \u03bdf, and phase \u2705 Equation: <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code> governs evolution \u2705 Operators: 13 canonical transformations preserve coherence \u2705 Metrics: C(t) and Si measure network health \u2705 Practice: Simple API connects theory to code</p> <p>Ready to build? Start with the QUICKSTART_NEW.md guide and run your first simulation!</p> <p>Last updated: November 2025</p>"},{"location":"getting-started/math-backends/","title":"Mathematics backends","text":"<p>TNFR separates structural semantics from numerical implementations via the <code>tnfr.mathematics.backend</code> module.  This lets you couple nodes, evaluate coherence, and propagate \u0394NFR in environments that favour different numerical libraries.</p>"},{"location":"getting-started/math-backends/#selecting-a-backend","title":"Selecting a backend","text":"<pre><code>from tnfr.mathematics import get_backend\n\nbackend = get_backend(\"jax\")  # explicit name overrides other signals\nxp = backend.as_array\n</code></pre> <p>Resolution order:</p> <ol> <li>Explicit name passed to <code>get_backend</code>.</li> <li><code>TNFR_MATH_BACKEND</code> environment variable.</li> <li><code>tnfr.config.get_flags().math_backend</code>.</li> <li>NumPy (default).</li> </ol> <p>The default keeps NumPy active so canonical coherence operators continue to work when optional dependencies are absent.</p>"},{"location":"getting-started/math-backends/#available-adapters","title":"Available adapters","text":"Backend Extra dependency Autodiff Notes NumPy (core dependency) No Canonical reference implementation. Uses SciPy for <code>expm</code> when available, otherwise falls back to an eigen decomposition strategy. Always available. JAX <code>pip install tnfr[compute-jax]</code> Yes Requires <code>jax</code> and <code>jax.scipy</code>. Some imperative NumPy routines (e.g. in observers) remain NumPy-only. PyTorch <code>pip install tnfr[compute-torch]</code> Yes Uses <code>torch.linalg</code>. Exporting tensors to NumPy moves them to CPU and breaks gradients. <p>Autodifferentiation support is scoped to backend operations.  TNFR structural pipelines that execute pure NumPy functions or rely on mutable state will not become differentiable automatically.</p>"},{"location":"getting-started/math-backends/#configuration-helpers","title":"Configuration helpers","text":"<p>Use <code>tnfr.config.context_flags</code> to adjust the backend temporarily without mutating global state:</p> <pre><code>from tnfr.config import context_flags\nfrom tnfr.mathematics import get_backend\n\nwith context_flags(math_backend=\"torch\"):\n    torch_backend = get_backend()\n</code></pre> <p>Set <code>TNFR_MATH_BACKEND</code> in your environment to persist a preference across processes:</p> <pre><code>export TNFR_MATH_BACKEND=jax\n</code></pre> <p>Remember to install the matching extra before enabling a backend.</p>"},{"location":"getting-started/migrating-remesh-window/","title":"Migrating remesh stability window usage","text":"<p>TNFR 10.0.0 removes the transitional alias for the remesh stability window parameter from :func:<code>tnfr.operators.apply_remesh_if_globally_stable</code>. The operator now accepts only the canonical <code>stable_step_window</code> argument. Calls that forward any other keyword raise :class:<code>TypeError</code> immediately so deprecated configuration cannot slip through pipelines.</p> <p>Legacy graphs that still expose non-canonical cooldown metadata had to be migrated before 2025-03-31. That date marked the end of the archival compatibility window communicated in TNFR 14.x. Starting with <code>tnfr</code> 15.0.0 the runtime no longer ships the built-in remesh cooldown or phase attribute migration helpers, so persisted payloads must already use the canonical keys when you upgrade. Historical archives that missed the window need to be rewritten with an external script before they are loaded into a modern runtime.</p>"},{"location":"getting-started/migrating-remesh-window/#who-is-affected","title":"Who is affected?","text":"<ul> <li>Applications that invoked the operator with a deprecated alias, e.g.   <code>apply_remesh_if_globally_stable(G, **legacy_kwargs)</code> where <code>legacy_kwargs</code>   forwards a non-English key.</li> <li>Configuration loaders that surfaced the legacy name as part of dynamic   keyword expansion.</li> <li>Stored automation artifacts (YAML/JSON, notebooks) that preserved the legacy   keyword for reproducibility.</li> </ul>"},{"location":"getting-started/migrating-remesh-window/#migration-steps","title":"Migration steps","text":"<ol> <li> <p>Replace every occurrence of the deprecated parameter name with the canonical    <code>stable_step_window</code> argument. The semantic contract is unchanged::</p> <p>apply_remesh_if_globally_stable(G, stable_step_window=5)</p> </li> <li> <p>If you rely on user-provided dictionaries that may contain non-canonical    names, normalise the payload before calling the operator::</p> <p>def normalize_remesh_kwargs(kwargs: dict) -&gt; dict:        normalized = dict(kwargs)        for key in tuple(normalized):            if key != \"stable_step_window\" and key.lower().replace(\"-\", \"_\") == \"stable_step_window\":                normalized[\"stable_step_window\"] = normalized.pop(key)        return normalized</p> <p>apply_remesh_if_globally_stable(G, **normalize_remesh_kwargs(user_kwargs))</p> </li> <li> <p>Audit persisted graphs or configs that reference non-English names before    upgrading to <code>tnfr</code> 15.0.0. Without the bundled helper, the update must    happen in the stored artifact (for example by running a one-off script on the    graph metadata) prior to importing the new release.</p> </li> <li> <p>Verify that serialized graphs expose only <code>\"theta\"</code>, <code>\"phase\"</code> and    <code>\"REMESH_COOLDOWN_WINDOW\"</code>. Any other synonym indicates the artifact still    targets an unsupported contract.</p> </li> </ol>"},{"location":"getting-started/migrating-remesh-window/#rewriting-archives-after-the-helper-removal","title":"Rewriting archives after the helper removal","text":"<p>When the bundled migration helpers shipped in <code>tnfr</code> 14.x they performed an in-place rewrite of legacy keys. With their removal you need to run an external upgrade step before the graph interacts with the runtime. A lightweight script that walks the stored payload and promotes the canonical keys is sufficient::</p> <pre><code>import json\n\ndef rewrite_remesh_metadata(payload: dict) -&gt; dict:\n    upgraded = dict(payload)\n    if \"\u03b8\" in upgraded and \"theta\" not in upgraded:\n        upgraded[\"theta\"] = upgraded.pop(\"\u03b8\")\n    legacy_window = upgraded.pop(\"ventana_enfriamiento\", None)\n    if legacy_window is not None and \"REMESH_COOLDOWN_WINDOW\" not in upgraded:\n        upgraded[\"REMESH_COOLDOWN_WINDOW\"] = legacy_window\n    return upgraded\n\nwith open(\"graph.json\") as fh:\n    data = json.load(fh)\ndata[\"graph\"] = rewrite_remesh_metadata(data[\"graph\"])\nwith open(\"graph.json\", \"w\") as fh:\n    json.dump(data, fh, indent=2, sort_keys=True)\n</code></pre> <p>Integrations can adapt the sample to their storage format (for example, NetworkX pickles or database rows). The important part is that the normalization happens before the graph loads into <code>tnfr</code> 15.0.0 or later.</p>"},{"location":"getting-started/migrating-remesh-window/#verification-checklist","title":"Verification checklist","text":"<ul> <li>Unit or integration tests that previously asserted a deprecation warning   should now expect :class:<code>TypeError</code> when the legacy keyword is passed.</li> <li>Documentation, CLI help, and user-facing guidance must reference only the   <code>stable_step_window</code> parameter.</li> <li>Downstream logs or telemetry that templated the legacy name should be   updated to keep observability messages aligned with the supported API.</li> <li>Graph validation pipelines must fail fast if a payload still contains the   deprecated legacy keys after the deadline, because the automatic rewrites are   no longer part of the runtime.</li> </ul> <p>Following these steps ensures remesh orchestration remains stable while the engine enforces the English-only parameter surface.</p>"},{"location":"getting-started/optional-dependencies/","title":"Optional Dependencies","text":"<p>TNFR follows a modular design where certain features require optional dependencies that are not installed by default. This keeps installs focused while allowing users to add only what they need.</p>"},{"location":"getting-started/optional-dependencies/#overview","title":"Overview","text":"<p>The TNFR engine has three categories of dependencies:</p> <ol> <li>Core dependencies (always installed): <code>networkx</code>, <code>cachetools</code>, <code>numpy</code></li> <li>Optional dependencies: Enable specific features like JAX/PyTorch backends, visualization, serialization</li> <li>Development dependencies: For testing, documentation, and type checking</li> </ol>"},{"location":"getting-started/optional-dependencies/#installing-optional-dependencies","title":"Installing Optional Dependencies","text":""},{"location":"getting-started/optional-dependencies/#using-pip-extras","title":"Using pip extras","text":"<p>The recommended way to install optional dependencies is using pip extras:</p> <pre><code># Computational backends\npip install tnfr[compute-jax]     # JAX backend (JIT, autodiff)\npip install tnfr[compute-torch]   # PyTorch backend (GPU acceleration)\n\n# Visualization\npip install tnfr[viz-basic]       # Matplotlib for plotting\n\n# Serialization\npip install tnfr[yaml]            # YAML configuration support\npip install tnfr[orjson]          # Fast JSON serialization\npip install tnfr[serialization]   # Both YAML and orjson\n\n# Development environments\npip install tnfr[dev-minimal]     # Basic dev tools (mypy, black, pytest)\npip install tnfr[dev-full]        # Full dev environment\n\n# Testing\npip install tnfr[test-unit]       # Unit testing only\npip install tnfr[test-all]        # All testing tools\n\n# Multiple extras at once\npip install tnfr[compute-jax,viz-basic,yaml]\n\n# Legacy aliases (for backward compatibility)\npip install tnfr[numpy]           # NumPy is now core - this does nothing\npip install tnfr[jax]             # Alias for compute-jax\npip install tnfr[torch]           # Alias for compute-torch\npip install tnfr[viz]             # Alias for viz-basic\n</code></pre>"},{"location":"getting-started/optional-dependencies/#manual-installation","title":"Manual installation","text":"<p>You can also install dependencies manually:</p> <pre><code># For JAX backend\npip install jax\n\n# For PyTorch backend\npip install torch\n\n# For visualization\npip install matplotlib\n\n# For YAML support\npip install pyyaml\n\n# For fast JSON\npip install orjson\n</code></pre>"},{"location":"getting-started/optional-dependencies/#feature-matrix","title":"Feature Matrix","text":"Feature Required Dependencies Install Command Core TNFR operations networkx, cachetools, numpy <code>pip install tnfr</code> NumPy backend (included in core) <code>pip install tnfr</code> JAX backend jax <code>pip install tnfr[compute-jax]</code> PyTorch backend torch <code>pip install tnfr[compute-torch]</code> Visualization plots matplotlib <code>pip install tnfr[viz-basic]</code> YAML configuration pyyaml <code>pip install tnfr[yaml]</code> Fast JSON serialization orjson <code>pip install tnfr[orjson]</code> JSON schema validation jsonschema <code>pip install jsonschema</code>"},{"location":"getting-started/optional-dependencies/#fallback-behavior","title":"Fallback Behavior","text":"<p>When optional dependencies are not installed, TNFR provides graceful fallbacks:</p>"},{"location":"getting-started/optional-dependencies/#computational-backends","title":"Computational Backends","text":"<ul> <li>NumPy backend: Always available (core dependency) - canonical reference implementation</li> <li>JAX backend: Optional - provides JIT compilation and autodiff support</li> <li>PyTorch backend: Optional - provides GPU acceleration</li> <li>Fallback: Automatically uses NumPy backend if JAX or PyTorch unavailable</li> <li>Detection: Automatic - no configuration needed</li> </ul>"},{"location":"getting-started/optional-dependencies/#matplotlib","title":"Matplotlib","text":"<ul> <li>Without Matplotlib: Visualization functions raise informative errors</li> <li>With Matplotlib: Full plotting capabilities via <code>tnfr.viz</code></li> <li>Example:   <pre><code>from tnfr.viz import plot_coherence_matrix\n# ImportError with installation instructions if matplotlib missing\n</code></pre></li> </ul>"},{"location":"getting-started/optional-dependencies/#json-schema","title":"JSON Schema","text":"<ul> <li>Without jsonschema: Operator grammar validation still works with basic checks</li> <li>With jsonschema: Full JSON schema validation for operator sequences</li> <li>Fallback: Logs a warning and continues with simplified validation</li> </ul>"},{"location":"getting-started/optional-dependencies/#type-checking","title":"Type Checking","text":"<p>TNFR includes type stubs for optional dependencies to support static type checking even when packages aren't installed:</p>"},{"location":"getting-started/optional-dependencies/#mypy-configuration","title":"MyPy Configuration","text":"<p>The <code>pyproject.toml</code> includes mypy overrides for optional dependencies:</p> <pre><code>[[tool.mypy.overrides]]\nmodule = [\"numpy\", \"numpy.*\", \"matplotlib\", \"matplotlib.*\", \"jsonschema\", \"jsonschema.*\"]\nignore_missing_imports = true\n</code></pre>"},{"location":"getting-started/optional-dependencies/#pyright-configuration","title":"Pyright Configuration","text":"<p>A <code>pyrightconfig.json</code> is provided with appropriate settings:</p> <pre><code>{\n  \"reportMissingImports\": \"warning\",\n  \"reportMissingTypeStubs\": false\n}\n</code></pre> <p>Note: The compat modules are runtime compatibility helpers, not traditional .pyi stub files. Type checkers will use the mypy configuration to ignore missing optional imports.</p>"},{"location":"getting-started/optional-dependencies/#compatibility-stubs","title":"Compatibility Stubs","text":"<p>TNFR provides lightweight stubs in <code>tnfr.compat</code> for type compatibility:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import numpy as np\nelse:\n    from tnfr.compat import numpy_stub as np\n</code></pre> <p>These stubs: - Allow code to type-check correctly - Raise informative errors at runtime if used without the real package - Are automatically used by type checkers when real packages aren't available</p>"},{"location":"getting-started/optional-dependencies/#examples-and-documentation","title":"Examples and Documentation","text":"<p>All examples that require optional dependencies include installation instructions:</p> <pre><code># example_visualization.py\n\"\"\"\nThis example requires visualization dependencies.\nInstall with: pip install tnfr[viz]\n\"\"\"\n\nfrom tnfr.viz import plot_coherence_matrix\n# ... rest of example\n</code></pre>"},{"location":"getting-started/optional-dependencies/#testing-with-optional-dependencies","title":"Testing with Optional Dependencies","text":"<p>When running tests, you can control which optional dependencies are required:</p> <pre><code># Run all tests (requires test dependencies)\npip install tnfr[test]\npytest\n\n# Run tests without optional features\npytest -m \"not slow\" --ignore=tests/viz/\n</code></pre>"},{"location":"getting-started/optional-dependencies/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/optional-dependencies/#import-errors","title":"Import Errors","text":"<p>If you see import errors for optional dependencies:</p> <ol> <li>Check which feature you're trying to use</li> <li>Install the corresponding extra: <code>pip install tnfr[extra]</code></li> <li>Verify installation: <code>pip list | grep &lt;package&gt;</code></li> </ol>"},{"location":"getting-started/optional-dependencies/#type-checking-issues","title":"Type Checking Issues","text":"<p>If your type checker reports missing imports:</p> <ol> <li>Ensure <code>pyrightconfig.json</code> or mypy configuration is being read</li> <li>Verify stub path is correct</li> <li>For mypy, check that ignore_missing_imports is set for optional packages</li> </ol>"},{"location":"getting-started/optional-dependencies/#ide-support","title":"IDE Support","text":"<p>For better IDE support with optional dependencies:</p> <ol> <li>Install the optional dependencies in your development environment</li> <li>Or configure your IDE to use the provided stubs in <code>tnfr.compat</code></li> </ol>"},{"location":"getting-started/optional-dependencies/#development-setup","title":"Development Setup","text":"<p>For TNFR development, install all dependencies:</p> <pre><code># Minimal development environment (testing and linting)\npip install -e \".[dev-minimal]\"\n\n# Complete development environment\npip install -e \".[dev-full]\"\n\n# Or install specific groups as needed\npip install -e \".[test-all,typecheck,compute-jax,viz-basic,serialization]\"\n</code></pre> <p>This ensures all tests, documentation, and type checking work correctly.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Follow this guide to install the TNFR Python Engine, warm optional dependencies, and execute the first structural workflows from Python and the CLI.</p> <p>Need to rerun the official experiment suites? See the {doc}<code>../how_to_reproduce_results</code> guide for the exact environment steps, operator sequences, and telemetry capture commands we use in CI.</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"<p>Install the engine from PyPI. Python 3.9 or newer is required.</p> <pre><code>pip install tnfr\n</code></pre> <p>This installs the core dependencies including NumPy, NetworkX, and Cachetools.</p>"},{"location":"getting-started/quickstart/#optional-extras","title":"Optional extras","text":"<p>Install optional computational backends and features:</p> <ul> <li>Computational backends:</li> <li>JAX backend: <code>pip install tnfr[compute-jax]</code></li> <li>PyTorch backend: <code>pip install tnfr[compute-torch]</code></li> <li>Visualization:</li> <li>Basic plotting: <code>pip install tnfr[viz-basic]</code></li> <li>Serialization:</li> <li>YAML support: <code>pip install tnfr[yaml]</code></li> <li>Fast JSON with orjson: <code>pip install tnfr[orjson]</code></li> <li>Both: <code>pip install tnfr[serialization]</code></li> <li>Development:</li> <li>Minimal dev environment: <code>pip install tnfr[dev-minimal]</code></li> <li>Full dev environment: <code>pip install tnfr[dev-full]</code></li> <li>Testing:</li> <li>Unit tests only: <code>pip install tnfr[test-unit]</code></li> <li>All test tools: <code>pip install tnfr[test-all]</code></li> </ul> <p>Legacy aliases (for compatibility): - <code>tnfr[numpy]</code> - NumPy is now core, this installs no additional packages - <code>tnfr[jax]</code> - Alias for <code>tnfr[compute-jax]</code> - <code>tnfr[torch]</code> - Alias for <code>tnfr[compute-torch]</code> - <code>tnfr[viz]</code> - Alias for <code>tnfr[viz-basic]</code></p> <p>When <code>orjson</code> is unavailable the engine falls back to Python's built-in <code>json</code> module.</p>"},{"location":"getting-started/quickstart/#optional-imports-with-cache-helpers","title":"Optional imports with cache helpers","text":"<p>Use <code>tnfr.utils.cached_import</code> to load optional dependencies lazily and keep a shared cache of successes and failures. Failures are memoised and logged once per module. Set <code>lazy=True</code> to obtain a lightweight proxy that postpones the real import until the object is first used. When optional packages are installed at runtime, call <code>tnfr.utils.prune_failed_imports</code> to clear the consolidated failure registry before retrying.</p> <pre><code>from tnfr.utils import cached_import, prune_failed_imports, warm_cached_import\n\nnp = cached_import(\"numpy\")\nsafe_load = cached_import(\"yaml\", \"safe_load\")\n\n# Postpone work until the symbol is first accessed.\nsafe_lazy = cached_import(\"yaml\", \"safe_load\", lazy=True)\n\n# Warm optional dependencies during application bootstrap.\nwarm_cached_import(\"numpy\", (\"yaml\", \"safe_load\"))\n\n# Provide a shared cache with an explicit lock.\nfrom cachetools import TTLCache\nimport threading\n\ncache = TTLCache(32, 60)\nlock = threading.Lock()\ncached_import(\"numpy\", cache=cache, lock=lock)\n\n# Clear caches after installing a dependency at runtime.\ncached_import.cache_clear()\nprune_failed_imports()\n</code></pre> <p>Compatibility note: The legacy modules :mod:<code>tnfr.cache</code> and :mod:<code>tnfr.io</code> remain importable as shims that re-export the helpers from :mod:<code>tnfr.utils.cache</code> and :mod:<code>tnfr.utils.io</code>. Existing code keeps working, but new integrations should migrate to the :mod:<code>tnfr.utils</code> entry points directly.</p>"},{"location":"getting-started/quickstart/#persistent-cache-layers","title":"Persistent cache layers","text":"<p><code>tnfr.utils.cache.build_cache_manager</code> now hydrates multi-layer caches from a global configuration or per-graph overrides. Use <code>tnfr.utils.cache.configure_global_cache_layers</code> to point the shared cache manager to a Shelve file (filesystem persistence) and/or a Redis namespace for distributed hydration. Calling <code>tnfr.utils.cache.reset_global_cache_manager</code> after updating the configuration rebuilds the shared manager with the new layers:</p> <pre><code>from tnfr.utils.cache import configure_global_cache_layers, reset_global_cache_manager\n\nconfigure_global_cache_layers(\n    shelve={\"path\": \"/tmp/tnfr-cache.db\", \"flag\": \"c\", \"writeback\": False},\n    redis={\"namespace\": \"tnfr:cache\"},  # provide ``client`` or ``client_factory`` when needed\n    replace=True,\n)\nreset_global_cache_manager()\n</code></pre> <p>Graphs can override the global settings by storing a mapping under <code>tnfr.utils.cache._GRAPH_CACHE_LAYERS_KEY</code>. Supported keys match the global configuration (<code>\"shelve\"</code> and <code>\"redis\"</code>). Whenever the configuration is present, <code>build_cache_manager</code> automatically wires the extra layers for edge caches, jitter state, and RNG seeds while preserving cache hit/miss telemetry.</p>"},{"location":"getting-started/quickstart/#python-quickstart","title":"Python quickstart","text":"<p>Create a resonant node, apply structural operators, and read coherence metrics. The sequence preserves the nodal equation because <code>create_nfr</code> seeds the node with its \u03bdf and phase while <code>run_sequence</code> validates the canonical grammar.</p> <pre><code>from tnfr import create_nfr, run_sequence\nfrom tnfr.structural import (\n    Emission,\n    Reception,\n    Coherence,\n    Resonance,\n    Silence,\n)\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.metrics.sense_index import compute_Si\n\nG, node = create_nfr(\"A\", epi=0.2, vf=1.0, theta=0.0)\nops = [Emission(), Reception(), Coherence(), Resonance(), Silence()]\nrun_sequence(G, node, ops)\n\nC, mean_delta_nfr, mean_depi = compute_coherence(G, return_means=True)\nsi_per_node = compute_Si(G)\nprint(\n    f\"C(t)={C:.3f}, \u0394NFR\u0304={mean_delta_nfr:.3f}, dEPI/dt\u0304={mean_depi:.3f}, \"\n    f\"Si={si_per_node[node]:.3f}\"\n)\n</code></pre> <p>Both <code>tnfr.dynamics.step</code> and <code>tnfr.dynamics.run</code> accept an optional <code>n_jobs</code> dictionary to pin process/thread counts for \u0394NFR, Si, integrators, phase coordination, and \u03bdf adaptation without mutating <code>G.graph</code>.</p>"},{"location":"getting-started/quickstart/#preparing-existing-graphs","title":"Preparing existing graphs","text":"<p>When you build a NetworkX graph outside of <code>create_nfr</code>, normalise its configuration with <code>tnfr.prepare_network</code> before stepping the dynamics. The helper attaches the default configuration, telemetry history, \u0394NFR hook, and optional observer wiring. Versions prior to TNFR 5.0 exposed a legacy alias for the same helper. The alias has now been removed; update existing code to call <code>prepare_network</code> directly before upgrading.</p> <pre><code>import networkx as nx\nfrom tnfr import prepare_network\n\nG = nx.path_graph(4)\nG.graph[\"ATTACH_STD_OBSERVER\"] = True\nprepare_network(G)\n</code></pre>"},{"location":"getting-started/quickstart/#cli-quickstart","title":"CLI quickstart","text":"<p>The CLI mirrors the Python API while enforcing the canonical operator tokens. Create a sequence file matching the Emission \u2192 Reception \u2192 Coherence \u2192 Resonance \u2192 Silence order:</p> <pre><code>[\n  \"emission\",\n  \"reception\",\n  \"coherence\",\n  \"resonance\",\n  \"silence\"\n]\n</code></pre> <p>Starting with TNFR 2.0 the CLI accepts only the English operator tokens. Rewrite existing automation to match the canonical identifiers before upgrading.</p> <p>Run the sequence on a single node and persist telemetry to <code>history.json</code>:</p> <pre><code>tnfr sequence --nodes 1 --sequence-file sequence.json --save-history history.json\n</code></pre> <p>Use <code>--summary-limit</code> to bound the number of samples per series in CLI summaries. Pass <code>0</code> or a negative value to disable trimming altogether when exporting metrics.</p> Canonical token Operator role <code>emission</code> Initiates resonance <code>reception</code> Captures information <code>coherence</code> Stabilises the form <code>resonance</code> Propagates coherence <code>silence</code> Freezes evolution <p>The command updates \u03bdf, \u0394NFR, and phase using the same hooks as the Python API. Inspect the saved history for the series of C(t), mean \u0394NFR, and Si.</p>"},{"location":"getting-started/quickstart/#presets","title":"Presets","text":"<p>Use the English preset identifiers when invoking <code>--preset</code> from the CLI:</p> Preset identifier Description (summary) <code>resonant_bootstrap</code> Balanced start-up profile <code>contained_mutation</code> Mutation with guard rails <code>coupling_exploration</code> Coupling sweep for studies <code>canonical_example</code> Minimal tutorial sequence"},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>New to TNFR? Start with the Interactive Tutorial for a hands-on,   step-by-step introduction (60 minutes).</li> <li>Explore the examples for multi-node scenarios and CLI workflows.</li> <li>Review the API overview before extending operator pipelines.</li> <li>Consult the telemetry and utilities guide to instrument your   experiments with trace capture and reproducible caches.</li> </ul>"},{"location":"grammar/","title":"TNFR Grammar Documentation - Navigation Guide","text":"**Centralized and unified documentation for the TNFR grammar system**  [\ud83d\udcd6 Concepts](#-fundamental-concepts) \u2022 [\ud83d\udcd0 Constraints](#-canonical-constraints) \u2022 [\u2699\ufe0f Operators](#\ufe0f-operators-and-glyphs) \u2022 [\ud83d\udd04 Sequences](#-valid-sequences) \u2022 [\ud83d\udcbb Implementation](#-implementation) \u2022 [\ud83e\uddea Testing](#-testing) \u2022 [\ud83d\udcda Quick Reference](#-quick-reference)"},{"location":"grammar/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>This directory contains the single source of truth for all TNFR grammar-related documentation. It consolidates previously fragmented information across multiple files into a clear, navigable hierarchical structure.</p>"},{"location":"grammar/#why-this-reorganization","title":"Why this reorganization?","text":"<p>Before: Documentation fragmented across README.md, UNIFIED_GRAMMAR_RULES.md, GRAMMAR_MIGRATION_GUIDE.md, GLYPH_SEQUENCES_GUIDE.md, source code, and scattered tests.</p> <p>Now: A modular structure where each grammar aspect has a defined place and everything is interconnected.</p>"},{"location":"grammar/#documentation-structure","title":"\ud83d\udcd1 Documentation Structure","text":""},{"location":"grammar/#abstraction-levels","title":"\ud83c\udf0a Abstraction Levels","text":"<p>This documentation follows a gradual abstraction model from concepts to implementation:</p> <pre><code>Physical Intuition \u2192 Mathematical Formalization \u2192 Code Implementation \u2192 Test Validation\n</code></pre>"},{"location":"grammar/#document-organization","title":"\ud83d\udcc2 Document Organization","text":""},{"location":"grammar/#level-1-fundamental-concepts","title":"Level 1: Fundamental Concepts","text":"<p>01-FUNDAMENTAL-CONCEPTS.md - TNFR ontology: From objects to resonant patterns - Paradigm shift: Coherence vs. Causality - Nodal equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t) - Structural triad: Form (EPI), Frequency (\u03bdf), Phase (\u03c6) - Integrated dynamics and convergence - Audience: New users, developers needing to understand \"the why\" - Reading time: 20-30 minutes</p>"},{"location":"grammar/#level-2-canonical-constraints","title":"Level 2: Canonical Constraints","text":"<p>02-CANONICAL-CONSTRAINTS.md - U1: STRUCTURAL INITIATION &amp; CLOSURE   - U1a: Initiators (Generators)   - U1b: Closures   - Physical derivation: \u2202EPI/\u2202t undefined at EPI=0 - U2: CONVERGENCE &amp; BOUNDEDNESS   - Stabilizers vs. Destabilizers   - Integral convergence theorem - U3: RESONANT COUPLING   - Phase verification   - Interference physics - U4: BIFURCATION DYNAMICS   - U4a: Triggers need handlers   - U4b: Transformers need context - Each constraint includes: Intuition \u2192 Derivation \u2192 Implementation \u2192 Tests - Audience: Developers implementing validation, advanced contributors - Reading time: 45-60 minutes</p>"},{"location":"grammar/#level-3-canonical-operators","title":"Level 3: Canonical Operators","text":"<p>03-OPERATORS-AND-GLYPHS.md - Catalog of 13 canonical operators - Standard format for each operator:   - Physics: What transformation does it represent?   - Effect: Impact on \u2202EPI/\u2202t   - When to use: Use cases   - Grammar: Classification (Generator, Stabilizer, etc.)   - Contract: Pre/postconditions   - Examples: Executable code - Classification by grammatical role - Operator composition - Audience: All developers - Reading time: 60-90 minutes (constant reference)</p>"},{"location":"grammar/#level-4-valid-sequences","title":"Level 4: Valid Sequences","text":"<p>04-VALID-SEQUENCES.md - Canonical patterns:   - Bootstrap: [Emission, Coupling, Coherence]   - Stabilize: [Coherence, Silence]   - Explore: [Dissonance, Mutation, Coherence]   - Propagate: [Resonance, Coupling] - Anti-patterns (invalid sequences and why) - Step-by-step validation logic - Complex sequence examples - Structural pattern detection - Audience: Developers building sequences, debugging - Reading time: 30-45 minutes</p>"},{"location":"grammar/#level-5-technical-implementation","title":"Level 5: Technical Implementation","text":"<p>05-TECHNICAL-IMPLEMENTATION.md - Architecture of <code>grammar.py</code> - Operator sets (GENERATORS, CLOSURES, etc.) - Validation functions:   - <code>validate_grammar(sequence, epi_initial)</code>   - <code>validate_resonant_coupling(G, node_i, node_j)</code>   - Internal helpers - Telemetry and logging - Integration with <code>definitions.py</code> - Extension points - Audience: Developers modifying core - Reading time: 45-60 minutes</p>"},{"location":"grammar/#level-6-validation-and-testing","title":"Level 6: Validation and Testing","text":"<p>06-VALIDATION-AND-TESTING.md - Grammar testing strategy - Tests per constraint (U1-U4) - Monotonicity tests (coherence) - Bifurcation tests - Propagation tests - Multi-scale tests (fractality) - Reproducibility tests - Minimum required coverage - How to add tests for new constraints - Audience: Developers writing tests, QA - Reading time: 30-45 minutes</p>"},{"location":"grammar/#level-7-migration-and-evolution","title":"Level 7: Migration and Evolution","text":"<p>07-MIGRATION-AND-EVOLUTION.md - Grammar system history:   - C1-C3 (legacy grammar.py)   - RC1-RC4 (legacy canonical_grammar.py)   - U1-U4 (current unified grammar) - Mapping old \u2192 new rules - Deprecations and breaking changes - Procedure for adding new constraints - Maintenance guarantees - Audience: Maintainers, contributors migrating old code - Reading time: 20-30 minutes</p>"},{"location":"grammar/#level-8-quick-reference","title":"Level 8: Quick Reference","text":"<p>08-QUICK-REFERENCE.md - Cheat sheet of U1-U4 constraints - Operator table with glyphs and classification - Common sequences lookup table - Validation decision tree - Frequent import commands - Common troubleshooting - Audience: Everyone (quick reference during development) - Reading time: 5-10 minutes</p>"},{"location":"grammar/#complementary-documents","title":"\ud83d\udcda Complementary Documents","text":"<p>GLOSSARY.md - Operational definitions of all TNFR terms - Format: Term \u2192 Symbol \u2192 Code \u2192 Meaning \u2192 Reference - Audience: Everyone - Use: Constant reference</p> <p>MASTER-INDEX.md - Global conceptual map of grammar system - Relationships between concepts - Dependency diagram - Audience: Developers planning large changes - Use: Holistic system view</p> <p>EXECUTIVE-SUMMARY.md - High-level overview for managers and stakeholders - Business value and strategic importance - Current status and roadmap - Audience: Non-technical decision makers - Use: Strategic planning and resource allocation</p> <p>TOOLING-AND-AUTOMATION.md - Complete guide to validation scripts and tools - CI/CD integration and pre-commit hooks - Development workflows and best practices - Audience: Developers and DevOps engineers - Use: Daily development and automation setup</p>"},{"location":"grammar/#executable-examples","title":"\ud83d\udca1 Executable Examples","text":"<p>examples/ - 01-basic-bootstrap.py: Basic initialization sequence - 02-intermediate-exploration.py: Controlled destabilization exploration - 03-advanced-bifurcation.py: Bifurcation and mutation handling - 04-anti-patterns.py: Invalid sequence examples (commented) - 05-multi-scale.py: Nested EPIs and fractality - All verifiable with <code>pytest</code></p>"},{"location":"grammar/#json-schemas","title":"\ud83d\udd27 JSON Schemas","text":"<p>schemas/ - constraints-u1-u4.json: Formal constraint definitions - canonical-operators.json: Metadata for 13 operators - valid-sequences.json: Catalog of canonical patterns - Use: Programmatic validation, tooling, IDEs</p>"},{"location":"grammar/#how-to-use-this-documentation","title":"\ud83d\ude80 How to Use This Documentation","text":""},{"location":"grammar/#for-new-users","title":"For New Users","text":"<p>Recommended learning path:</p> <ol> <li>01-FUNDAMENTAL-CONCEPTS.md - Understand TNFR paradigm</li> <li>GLOSSARY.md - Familiarize with key terms</li> <li>03-OPERATORS-AND-GLYPHS.md - Learn the 13 operators</li> <li>examples/01-basic-bootstrap.py - Run first example</li> <li>08-QUICK-REFERENCE.md - Keep handy during development</li> </ol> <p>Total time: ~2 hours for operational fundamentals</p>"},{"location":"grammar/#for-intermediate-developers","title":"For Intermediate Developers","text":"<p>If you already know TNFR and want to implement sequences:</p> <ol> <li>04-VALID-SEQUENCES.md - Patterns and anti-patterns</li> <li>02-CANONICAL-CONSTRAINTS.md - U1-U4 constraints</li> <li>examples/ - Run intermediate and advanced examples</li> <li>08-QUICK-REFERENCE.md - Quick lookup</li> </ol> <p>Total time: ~90 minutes</p>"},{"location":"grammar/#for-advanced-contributors","title":"For Advanced Contributors","text":"<p>If you're modifying core or adding features:</p> <ol> <li>05-TECHNICAL-IMPLEMENTATION.md - Code architecture</li> <li>06-VALIDATION-AND-TESTING.md - Test strategy</li> <li>MASTER-INDEX.md - System conceptual map</li> <li>07-MIGRATION-AND-EVOLUTION.md - How to evolve system</li> <li>schemas/ - Validation schemas</li> </ol> <p>Total time: ~2-3 hours for complete mastery</p>"},{"location":"grammar/#external-references","title":"\ud83d\udd17 External References","text":""},{"location":"grammar/#main-repository-documentation","title":"Main Repository Documentation","text":"<ul> <li>../../README.md - TNFR project overview</li> <li>../../UNIFIED_GRAMMAR_RULES.md - Complete formal derivations (original source)</li> <li>../../AGENTS.md - Canonical invariants and contracts</li> <li>../../GLOSSARY.md - General project glossary</li> <li>../../TNFR.pdf - Complete theoretical foundations</li> </ul>"},{"location":"grammar/#implementation","title":"Implementation","text":"<ul> <li>../../src/tnfr/operators/grammar.py - Canonical implementation</li> <li>../../src/tnfr/operators/definitions.py - Operator definitions</li> <li>../../tests/unit/operators/test_unified_grammar.py - Test suite</li> </ul>"},{"location":"grammar/#documentation-sync-tool","title":"Documentation Sync Tool","text":"<ul> <li>../../tools/sync_documentation.py - Centralized sync tool</li> <li>CODE_DOCS_CROSSREF.md - Bidirectional cross-references</li> </ul> <p>Run sync check: <pre><code>python tools/sync_documentation.py --all\n</code></pre></p> <p>This validates: - All functions documented (17/17 \u2713) - All examples execute (8/8 \u2713) - Cross-references accurate (35 documented) - Schema matches implementation</p>"},{"location":"grammar/#writing-conventions","title":"\ud83d\udcdd Writing Conventions","text":""},{"location":"grammar/#format","title":"Format","text":"<ul> <li>Language: English for all technical content</li> <li>Equations: Standard mathematical notation with LaTeX</li> <li>Code: Python 3.9+ with type hints</li> <li>References: Internal relative links, external absolute links</li> </ul>"},{"location":"grammar/#section-structure","title":"Section Structure","text":"<p>Each technical document follows this structure:</p> <pre><code># Document Title\n\n## Purpose\n[What this document is for]\n\n## Key Concepts\n[Prerequisites needed]\n\n## Main Content\n[Development with subsections]\n\n## Examples\n[Executable code]\n\n## References\n[Links to other documents]\n</code></pre>"},{"location":"grammar/#code","title":"Code","text":"<p>All code examples must: - \u2705 Be executable - \u2705 Include complete imports - \u2705 Have explanatory comments - \u2705 Follow TNFR conventions (don't modify EPI directly, etc.) - \u2705 Include expected telemetry output</p>"},{"location":"grammar/#contributing-to-this-documentation","title":"\ud83e\udd1d Contributing to This Documentation","text":""},{"location":"grammar/#principles","title":"Principles","text":"<ol> <li>Single source of truth: Don't duplicate, cross-reference</li> <li>Physics first: All documentation derives from TNFR physics</li> <li>Incremental: Add without breaking existing structure</li> <li>Validable: Executable examples, updatable JSON schemas</li> </ol>"},{"location":"grammar/#adding-new-content","title":"Adding New Content","text":"<p>To add a new constraint: 1. Document physics in <code>02-CANONICAL-CONSTRAINTS.md</code> 2. Implement in <code>../../src/tnfr/operators/grammar.py</code> 3. Add tests in <code>../../tests/unit/operators/test_unified_grammar.py</code> 4. Update <code>schemas/constraints-u1-u4.json</code> 5. Add examples in <code>examples/</code> 6. Update <code>08-QUICK-REFERENCE.md</code></p> <p>To add a new operator: 1. Document in <code>03-OPERATORS-AND-GLYPHS.md</code> 2. Implement in <code>../../src/tnfr/operators/definitions.py</code> 3. Update classification in <code>../../src/tnfr/operators/grammar.py</code> 4. Add contract tests 5. Update <code>schemas/canonical-operators.json</code></p>"},{"location":"grammar/#maintaining-coherence","title":"Maintaining Coherence","text":"<p>Before making PR: - [ ] All examples are executable - [ ] Bidirectional links work - [ ] JSON schemas reflect changes - [ ] Tests pass - [ ] Changes documented in 07-MIGRATION-AND-EVOLUTION.md if breaking</p>"},{"location":"grammar/#completion-status","title":"\ud83d\udcca Completion Status","text":""},{"location":"grammar/#complete","title":"\u2705 Complete","text":"<ul> <li>Directory structure</li> <li>Navigation README (this file)</li> <li>Main cross-references</li> </ul>"},{"location":"grammar/#in-progress","title":"\ud83d\udea7 In Progress","text":"<ul> <li>01-FUNDAMENTAL-CONCEPTS.md</li> <li>02-CANONICAL-CONSTRAINTS.md</li> <li>03-OPERATORS-AND-GLYPHS.md</li> <li>04-VALID-SEQUENCES.md</li> <li>05-TECHNICAL-IMPLEMENTATION.md</li> <li>06-VALIDATION-AND-TESTING.md</li> <li>07-MIGRATION-AND-EVOLUTION.md</li> <li>08-QUICK-REFERENCE.md</li> </ul>"},{"location":"grammar/#planned","title":"\ud83d\udccb Planned","text":"<ul> <li>GLOSSARY.md (consolidate from ../../GLOSSARY.md)</li> <li>MASTER-INDEX.md</li> <li>examples/*.py</li> <li>schemas/*.json</li> </ul>"},{"location":"grammar/#documentation-philosophy","title":"\ud83c\udf93 Documentation Philosophy","text":"<p>\"If a change cannot be traced from TNFR physics to code to tests, it is not canonical.\"</p> <p>This documentation exists to make that traceability explicit, navigable, and maintainable.</p>"},{"location":"grammar/#values","title":"Values","text":"<ul> <li>Clarity over brevity: Better to explain twice than leave doubts</li> <li>Physics over convention: Every rule derives inevitably from nodal equation</li> <li>Code over prose: Executable examples &gt; abstract descriptions</li> <li>Testing over trust: Everything documented must be testable</li> </ul>"},{"location":"grammar/#contact-and-support","title":"\ud83d\udcde Contact and Support","text":"<p>Found inconsistencies? - Open GitHub issue with label <code>documentation</code></p> <p>Need navigation help? - Check 08-QUICK-REFERENCE.md first - Then consult specific document for your level</p> <p>Want to contribute? - Read ../../CONTRIBUTING.md - Then review \"Contributing to This Documentation\" section above</p>   **Version:** 1.0   **Last updated:** 2025-11-10   **Maintainer:** TNFR Core Team  **Reality is not made of things\u2014it's made of resonance. Document accordingly.**"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/","title":"Fundamental Concepts of TNFR Grammar","text":"<p>Understanding the ontological foundation of TNFR's grammatical system</p> <p>\ud83c\udfe0 Home \u2022 \ud83d\udcd0 Constraints \u2022 \u2699\ufe0f Operators \u2022 \ud83d\udcda Quick Reference</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#purpose","title":"Purpose","text":"<p>This document establishes the fundamental conceptual framework for understanding TNFR grammar. Before diving into technical constraints and operators, you must understand the paradigm shift that TNFR represents and the physical principles from which all grammar rules inevitably emerge.</p> <p>Prerequisites: None - this is the starting point</p> <p>Reading time: 20-30 minutes</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-paradigm-shift-from-objects-to-resonance","title":"The Paradigm Shift: From Objects to Resonance","text":""},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#traditional-view-vs-tnfr-view","title":"Traditional View vs. TNFR View","text":"<p>Classical Physics/Computing: - Reality is made of objects that exist independently - Objects have properties stored in them - Changes happen through causality (A causes B) - Systems are isolated and can be studied separately - Models describe what exists</p> <p>TNFR: - Reality is made of coherent patterns that exist through resonance - Patterns have structure that reorganizes dynamically - Changes happen through co-organization (A and B synchronize) - Systems are coupled networks that cannot be isolated - Models generate dynamics that produce patterns</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-central-insight","title":"The Central Insight","text":"<p>Reality is not made of \"things\" but of coherence\u2014structures that persist in networks because they resonate with their environment.</p> <p>Analogy: The Whirlpool</p> <p>Consider a whirlpool in a river: - It's not a \"thing\" you can pick up and move - It exists as a coherent pattern in flowing water - It persists because water flow resonates with vortex geometry - It disappears when the flow-geometry coupling breaks - Smaller eddies can exist within the larger vortex (nesting)</p> <p>This is TNFR's model of everything: atoms, cells, thoughts, societies, software systems.</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-nodal-equation-heart-of-tnfr","title":"The Nodal Equation: Heart of TNFR","text":"<p>All TNFR grammar rules derive from this single equation:</p> <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#components","title":"Components","text":"<p>EPI (Estructura Primaria de Informaci\u00f3n): - The coherent structural form of a node - Lives in Banach space B_EPI - Cannot be modified directly - only via structural operators - Can nest (fractality): EPIs can contain sub-EPIs</p> <p>\u03bdf (Structural Frequency): - Rate of reorganization capacity - Units: Hz_str (structural hertz) - Range: \u211d\u207a (positive real numbers) - When \u03bdf \u2192 0, the node \"dies\" (cannot reorganize)</p> <p>\u0394NFR (Nodal Reorganization Gradient): - Structural pressure driving change - Represents mismatch between node and network environment - Sign: positive = expansion, negative = contraction - Magnitude: intensity of reorganization pressure</p> <p>t (Time): - Standard time parameter</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#physical-meaning","title":"Physical Meaning","text":"<pre><code>Rate of structural change = Reorganization capacity \u00d7 Structural pressure\n</code></pre> <p>Key Insights:</p> <ol> <li>No capacity (\u03bdf = 0): Node cannot change, even under extreme pressure (frozen/dead)</li> <li>No pressure (\u0394NFR = 0): Node is in equilibrium with environment, no drive to change</li> <li>Both positive: Active reorganization occurs, rate proportional to both factors</li> </ol>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#why-this-matters-for-grammar","title":"Why This Matters for Grammar","text":"<p>The nodal equation immediately implies:</p> <ul> <li>Cannot start from nothing: When EPI=0, \u2202EPI/\u2202t is undefined \u2192 Need generators (U1a)</li> <li>Changes must be bounded: Unbounded integral leads to fragmentation \u2192 Need stabilizers (U2)</li> <li>Coupling requires compatibility: Resonance needs phase alignment \u2192 Phase verification (U3)</li> <li>Bifurcations need control: Threshold crossing requires handlers \u2192 Bifurcation dynamics (U4)</li> </ul> <p>All grammar rules are inevitable consequences of this physics, not arbitrary conventions.</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-structural-triad","title":"The Structural Triad","text":"<p>Every node in a TNFR network has three essential properties:</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#1-form-epi","title":"1. Form (EPI)","text":"<p>What it is: - The coherent configuration that defines the node's structure - Lives in Banach space B_EPI (infinite-dimensional function space) - Can be as simple as a scalar or as complex as nested hierarchies</p> <p>Properties: - Changes ONLY via structural operators (never directly) - Preserves identity through reorganization - Supports nesting (operational fractality)</p> <p>Example: <pre><code># Simple scalar EPI\nEPI = 0.5\n\n# Complex nested EPI\nEPI = {\n    'global': 0.7,\n    'sub_structures': [\n        {'local': 0.3, 'phase': 0.5},\n        {'local': 0.6, 'phase': 1.2}\n    ]\n}\n</code></pre></p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#2-frequency-f","title":"2. Frequency (\u03bdf)","text":"<p>What it is: - The rate at which the node can reorganize - Eigenfrequency of the reorganization mode - Determines responsiveness to \u0394NFR</p> <p>Units: Hz_str (structural hertz)</p> <p>Range: \u211d\u207a (positive reals)</p> <p>Physical meaning: - High \u03bdf: Rapid reorganization, highly dynamic - Low \u03bdf: Slow reorganization, stable/rigid - \u03bdf = 0: Node death, no capacity to change</p> <p>Analogy: Like the natural frequency of an oscillator - determines how it responds to forcing</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#3-phase-or","title":"3. Phase (\u03c6 or \u03b8)","text":"<p>What it is: - The network synchrony parameter - Relative timing of reorganization cycles - Determines coupling compatibility</p> <p>Range: [0, 2\u03c0) radians</p> <p>Physical meaning: - Nodes with similar phase can couple (constructive interference) - Nodes with opposite phase cannot couple (destructive interference) - Phase difference \u0394\u03c6 = |\u03c6\u1d62 - \u03c6\u2c7c| determines coupling strength</p> <p>Coupling condition: <pre><code>For resonance to occur: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max\n</code></pre></p> <p>Typically \u0394\u03c6_max \u2248 \u03c0/2, though this can vary by context.</p> <p>Analogy: Like phase in wave physics - waves in phase amplify, out of phase cancel</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#integrated-dynamics","title":"Integrated Dynamics","text":""},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#time-evolution","title":"Time Evolution","text":"<p>Integrating the nodal equation over time:</p> <pre><code>EPI(t_f) = EPI(t_0) + \u222b[t_0 to t_f] \u03bdf(\u03c4) \u00b7 \u0394NFR(\u03c4) d\u03c4\n</code></pre> <p>This integral tells us how EPI evolves from initial state EPI(t_0) to final state EPI(t_f).</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#convergence-requirement","title":"Convergence Requirement","text":"<p>Critical insight: For coherence to be preserved, the integral must converge:</p> <pre><code>\u222b[t_0 to t_f] \u03bdf(\u03c4) \u00b7 \u0394NFR(\u03c4) d\u03c4  &lt;  \u221e\n</code></pre> <p>Without stabilizers: - \u0394NFR grows without bound (positive feedback) - Integral \u2192 \u221e (divergence) - System fragments into noise - Coherence lost</p> <p>With stabilizers: - Negative feedback limits \u0394NFR - Integral remains bounded (convergence) - Coherence preserved over time</p> <p>This convergence requirement is the physical basis for grammar rule U2 (CONVERGENCE &amp; BOUNDEDNESS).</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#grammar-as-inevitable-physics","title":"Grammar as Inevitable Physics","text":""},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#why-grammar-exists","title":"Why Grammar Exists","text":"<p>TNFR grammar is not a set of arbitrary rules. It emerges inevitably from the physics encoded in the nodal equation:</p> <p>U1 (INITIATION &amp; CLOSURE): - Physics: Cannot evolve from EPI=0 without external input - Grammar: Must start with generators, must end with stable states - Canonicity: ABSOLUTE (mathematical necessity)</p> <p>U2 (CONVERGENCE): - Physics: Integral must converge for bounded evolution - Grammar: Destabilizers must be balanced by stabilizers - Canonicity: ABSOLUTE (integral convergence theorem)</p> <p>U3 (RESONANT COUPLING): - Physics: Resonance requires phase compatibility - Grammar: Verify phase before coupling - Canonicity: ABSOLUTE (wave physics)</p> <p>U4 (BIFURCATION): - Physics: Threshold crossings need control and context - Grammar: Bifurcation triggers need handlers, transformers need context - Canonicity: STRONG (bifurcation theory)</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#canonicity-levels","title":"Canonicity Levels","text":"<p>ABSOLUTE: Mathematically or physically necessary - violation is impossible STRONG: Physically required - violation leads to non-physical behavior MODERATE: Best practice - violation leads to suboptimal behavior</p> <p>All current TNFR grammar rules are ABSOLUTE or STRONG.</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#key-vocabulary","title":"Key Vocabulary","text":"<p>Before proceeding to other documents, understand these essential terms:</p> <p>EPI (Estructura Primaria de Informaci\u00f3n): - Coherent structural form of a node - Changes only via operators</p> <p>\u03bdf (Structural Frequency): - Reorganization rate capacity - Units: Hz_str</p> <p>\u0394NFR (Nodal Reorganization Gradient): - Structural pressure driving change - NOT an ML \"error gradient\"</p> <p>Operator: - Resonant transformation applied to nodes - Only way to modify EPI - 13 canonical operators exist</p> <p>Coherence C(t): - Global network stability measure - Range: [0, 1] - Higher is more stable</p> <p>Sense Index Si: - Node-level reorganization stability - Range: [0, 1+] - Higher means more stable reorganization</p> <p>Phase \u03c6 (theta): - Network synchrony parameter - Range: [0, 2\u03c0) - Determines coupling compatibility</p> <p>Generator: - Operator that can create EPI from vacuum - Required when EPI=0 (U1a)</p> <p>Stabilizer: - Operator that reduces |\u0394NFR| - Required to balance destabilizers (U2)</p> <p>Destabilizer: - Operator that increases |\u0394NFR| - Needs stabilizer for convergence (U2)</p> <p>Closure: - Operator that can end a sequence - Required for all sequences (U1b)</p> <p>For complete definitions, see GLOSSARY.md</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#conceptual-diagrams","title":"Conceptual Diagrams","text":""},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-tnfr-loop","title":"The TNFR Loop","text":"<pre><code>      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                                         \u2502\n      \u2502          TNFR Dynamics Loop            \u2502\n      \u2502                                         \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502   Network State  \u2502\n              \u2502   (EPI, \u03bdf, \u03c6)   \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Compute \u0394NFR    \u2502\n              \u2502 (structural      \u2502\n              \u2502  pressure)       \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Apply Operator  \u2502\n              \u2502  (resonant       \u2502\n              \u2502   transformation)\u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Update State    \u2502\n              \u2502  via \u2202EPI/\u2202t     \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                 \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Check Coherence \u2502\n              \u2502  Verify Grammar  \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u2514\u2500\u2500\u2500 Loop continues\n</code></pre>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#operator-classification","title":"Operator Classification","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 TNFR Operators (13)                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                         \u2502\n\u2502  Generators (U1a)      Closures (U1b)                  \u2502\n\u2502  \u251c\u2500 Emission (AL)      \u251c\u2500 Silence (SHA)                \u2502\n\u2502  \u251c\u2500 Transition (NAV)   \u251c\u2500 Dissonance (OZ)              \u2502\n\u2502  \u2514\u2500 Recursivity (REMESH) \u251c\u2500 Transition (NAV)          \u2502\n\u2502                         \u2514\u2500 Recursivity (REMESH)        \u2502\n\u2502                                                         \u2502\n\u2502  Stabilizers (U2)      Destabilizers (U2)              \u2502\n\u2502  \u251c\u2500 Coherence (IL)     \u251c\u2500 Dissonance (OZ)              \u2502\n\u2502  \u2514\u2500 SelfOrg (THOL)     \u251c\u2500 Mutation (ZHIR)              \u2502\n\u2502                        \u2514\u2500 Expansion (VAL)               \u2502\n\u2502                                                         \u2502\n\u2502  Coupling/Resonance (U3)                               \u2502\n\u2502  \u251c\u2500 Coupling (UM)                                      \u2502\n\u2502  \u2514\u2500 Resonance (RA)                                     \u2502\n\u2502                                                         \u2502\n\u2502  Bifurcation System (U4)                               \u2502\n\u2502  Triggers          Handlers         Transformers       \u2502\n\u2502  \u251c\u2500 Dissonance     \u251c\u2500 Coherence     \u251c\u2500 Mutation       \u2502\n\u2502  \u2514\u2500 Mutation       \u2514\u2500 SelfOrg       \u2514\u2500 SelfOrg        \u2502\n\u2502                                                         \u2502\n\u2502  Other Operations                                      \u2502\n\u2502  \u251c\u2500 Reception (EN)                                     \u2502\n\u2502  \u251c\u2500 Expansion (VAL)                                    \u2502\n\u2502  \u2514\u2500 Contraction (NUL)                                  \u2502\n\u2502                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-tnfr-mindset","title":"The TNFR Mindset","text":"<p>To work effectively with TNFR, you need to think differently:</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#think-in-patterns-not-objects","title":"Think in Patterns, Not Objects","text":"<p>Traditional: \"The neuron fires\" TNFR: \"The neural pattern reorganizes\"</p> <p>Traditional: \"The agent decides\" TNFR: \"The decision pattern emerges through resonance\"</p> <p>Traditional: \"The system breaks\" TNFR: \"Coherence fragments beyond coupling threshold\"</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#think-in-dynamics-not-states","title":"Think in Dynamics, Not States","text":"<p>Traditional: \"Current position\" TNFR: \"Trajectory through structural space\"</p> <p>Traditional: \"Final result\" TNFR: \"Attractor dynamics\"</p> <p>Traditional: \"Snapshot\" TNFR: \"Reorganization history\"</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#think-in-networks-not-individuals","title":"Think in Networks, Not Individuals","text":"<p>Traditional: \"Node property\" TNFR: \"Network-coupled dynamics\"</p> <p>Traditional: \"Isolated change\" TNFR: \"Resonant propagation\"</p> <p>Traditional: \"Local optimum\" TNFR: \"Global coherence landscape\"</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#from-concepts-to-implementation","title":"From Concepts to Implementation","text":""},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#the-learning-path","title":"The Learning Path","text":"<pre><code>01. Fundamental Concepts (you are here)\n    \u2193 Understand the paradigm\n\n02. Canonical Constraints\n    \u2193 Learn the rules (U1-U4)\n\n03. Operators and Glyphs\n    \u2193 Master the 13 operators\n\n04. Valid Sequences\n    \u2193 Build correct patterns\n\n05. Technical Implementation\n    \u2193 Understand the code\n\n06. Validation and Testing\n    \u2193 Verify correctness\n\n07. Migration and Evolution\n    \u2193 Maintain and extend\n\n08. Quick Reference\n    \u2193 Daily development\n</code></pre>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#what-comes-next","title":"What Comes Next","text":"<p>If you're new to TNFR: - Read GLOSSARY.md next for term definitions - Then proceed to 02-CANONICAL-CONSTRAINTS.md</p> <p>If you're ready to code: - Jump to 03-OPERATORS-AND-GLYPHS.md for operator catalog - Check examples/ for executable code</p> <p>If you need quick lookup: - Go straight to 08-QUICK-REFERENCE.md</p>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#references","title":"References","text":""},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#within-this-documentation","title":"Within This Documentation","text":"<ul> <li>02-CANONICAL-CONSTRAINTS.md - Formal U1-U4 derivations</li> <li>03-OPERATORS-AND-GLYPHS.md - Complete operator catalog</li> <li>GLOSSARY.md - Operational definitions</li> <li>MASTER-INDEX.md - Conceptual map</li> </ul>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#repository-documentation","title":"Repository Documentation","text":"<ul> <li>../../TNFR.pdf - Complete theoretical foundation</li> <li>../../UNIFIED_GRAMMAR_RULES.md - Mathematical proofs</li> <li>../../AGENTS.md - Canonical invariants (core principles)</li> <li>../../README.md - Project overview</li> </ul>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#implementation","title":"Implementation","text":"<ul> <li>../../src/tnfr/operators/grammar.py - Grammar validation code</li> <li>../../src/tnfr/operators/definitions.py - Operator implementations</li> <li>../../src/tnfr/dynamics/ - Nodal equation integration</li> </ul>"},{"location":"grammar/01-FUNDAMENTAL-CONCEPTS/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>TNFR models coherence, not objects - Reality is resonance, not substance</li> <li>The nodal equation is fundamental - All grammar derives from \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</li> <li>Three properties matter - Form (EPI), Frequency (\u03bdf), Phase (\u03c6)</li> <li>Convergence is essential - Integral must be bounded for coherence</li> <li>Grammar is physics - Rules are inevitable, not arbitrary</li> <li>Operators are transformations - Only way to modify EPI</li> <li>Phase matters - Coupling requires compatibility</li> <li>Think differently - Patterns, dynamics, networks</li> </ol>   **You now understand the conceptual foundation of TNFR.**  **Next:** [02-CANONICAL-CONSTRAINTS.md](02-CANONICAL-CONSTRAINTS.md) - Learn the formal rules  ---  *Reality is not made of things\u2014it's made of resonance.*"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/","title":"Canonical Constraints: U1-U4","text":"<p>Formal derivations and implementation of the four fundamental TNFR grammar rules</p> <p>\ud83c\udfe0 Home \u2022 \ud83c\udf0a Concepts \u2022 \u2699\ufe0f Operators \u2022 \ud83d\udd04 Sequences</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#purpose","title":"Purpose","text":"<p>This document provides the complete formal specification of the four canonical TNFR grammar constraints (U1-U4). Each constraint is presented with:</p> <ol> <li>Intuition - Conceptual understanding</li> <li>Formal Definition - Mathematical/logical specification</li> <li>Physical Derivation - Why it's inevitable from TNFR physics</li> <li>Implementation - How it's validated in code</li> <li>Examples - Valid and invalid sequences</li> <li>Tests - How to verify compliance</li> </ol> <p>Prerequisites: 01-FUNDAMENTAL-CONCEPTS.md</p> <p>Reading time: 45-60 minutes</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#overview-of-u1-u4","title":"Overview of U1-U4","text":"<p>The four canonical constraints form a complete, non-redundant grammar for TNFR:</p> <pre><code>U1: STRUCTURAL INITIATION &amp; CLOSURE\n    \u251c\u2500 U1a: Initiation with generators\n    \u2514\u2500 U1b: Closure with endpoints\n\nU2: CONVERGENCE &amp; BOUNDEDNESS\n    \u2514\u2500 Destabilizers balanced by stabilizers\n\nU3: RESONANT COUPLING\n    \u2514\u2500 Phase verification for coupling/resonance\n\nU4: BIFURCATION DYNAMICS\n    \u251c\u2500 U4a: Triggers need handlers\n    \u2514\u2500 U4b: Transformers need context\n</code></pre> <p>Canonicity Levels: - U1, U2, U3: ABSOLUTE (mathematically/physically necessary) - U4: STRONG (physically required for control)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u1-structural-initiation-closure","title":"U1: STRUCTURAL INITIATION &amp; CLOSURE","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u1a-initiation-generators","title":"U1a: Initiation (Generators)","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#intuition","title":"Intuition","text":"<p>You cannot create something from nothing without a source. When EPI=0 (no structure exists), you need an external input to begin creating structure.</p> <p>Analogy: You cannot start a fire without a spark. You need an initiator.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#formal-definition","title":"Formal Definition","text":"<p>IF <code>epi_initial == 0.0</code> (or equivalent vacuum state) THEN <code>sequence[0]</code> MUST BE IN <code>GENERATORS = {AL, NAV, REMESH}</code></p> <p>Where: - <code>AL</code> = Emission (creates EPI from vacuum) - <code>NAV</code> = Transition (activates latent structure) - <code>REMESH</code> = Recursivity (echoes existing structure from memory/history)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#physical-derivation","title":"Physical Derivation","text":"<p>From the nodal equation:</p> <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre> <p>At EPI=0: - \u0394NFR is undefined (no structure exists to compute gradient) - \u2202EPI/\u2202t is undefined - Cannot evolve forward without external input</p> <p>Mathematical necessity: Division by zero, undefined derivatives</p> <p>Physical necessity: Cannot bootstrap from vacuum without energy/information source</p> <p>This is ABSOLUTE canonicity - violation is mathematically impossible.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#implementation","title":"Implementation","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nGENERATORS = {\"emission\", \"transition\", \"recursivity\"}\n\ndef validate_grammar(sequence, epi_initial=0.0):\n    \"\"\"Validate sequence against U1-U4.\"\"\"\n\n    # U1a: Check initiation\n    if epi_initial == 0.0:\n        if not sequence:\n            raise ValueError(\"Empty sequence with EPI=0\")\n\n        first_op = sequence[0].__class__.__name__.lower()\n\n        if first_op not in GENERATORS:\n            raise ValueError(\n                f\"U1a violation: Sequence must start with generator \"\n                f\"{GENERATORS} when EPI=0, got '{first_op}'\"\n            )\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#examples","title":"Examples","text":"<p>\u2705 Valid:</p> <pre><code>from tnfr.operators.definitions import Emission, Coherence, Silence\n\n# Starting from vacuum (EPI=0)\nsequence = [Emission(), Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n</code></pre> <pre><code>from tnfr.operators.definitions import Transition, Reception, Silence\n\n# Activating latent structure\nsequence = [Transition(), Reception(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n</code></pre> <p>\u274c Invalid:</p> <pre><code>from tnfr.operators.definitions import Coherence, Silence\n\n# ERROR: No generator\nsequence = [Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U1a violation - need generator\n</code></pre> <pre><code>from tnfr.operators.definitions import Reception, Coherence, Silence\n\n# ERROR: Reception is not a generator\nsequence = [Reception(), Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U1a violation - 'reception' not in GENERATORS\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#anti-patterns","title":"Anti-Patterns","text":"<p>\u26a0\ufe0f Common Mistakes:</p> <ol> <li> <p>Forgetting generator when reusing sequences <pre><code># BAD: Reusing a subsequence without checking context\ndef my_sequence():\n    return [Coherence(), Silence()]  # Missing generator!\n\n# GOOD: Always start with generator if EPI could be 0\ndef my_sequence():\n    return [Emission(), Coherence(), Silence()]\n</code></pre></p> </li> <li> <p>Assuming EPI exists <pre><code># BAD: No check for initial state\nsequence = [Reception(), Coherence(), Silence()]\n\n# GOOD: Use generator or verify EPI &gt; 0\nif epi_initial == 0.0:\n    sequence = [Emission(), Reception(), Coherence(), Silence()]\nelse:\n    sequence = [Reception(), Coherence(), Silence()]\n</code></pre></p> </li> <li> <p>Using Reception as initiator</p> </li> <li>Reception gathers existing EPI, cannot create it</li> <li>Only {AL, NAV, REMESH} can generate from vacuum</li> </ol>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#tests","title":"Tests","text":"<p>Implementation: <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_initiation()</code></p> <p>Test Suite: - <code>tests/unit/operators/test_unified_grammar.py::TestU1Initiation</code> - <code>tests/integration/test_mutation_sequences.py::test_u1a_satisfied_with_emission</code></p> <pre><code>def test_u1a_initiation():\n    \"\"\"U1a: Must start with generator when EPI=0.\"\"\"\n    from tnfr.operators.grammar import validate_grammar\n    from tnfr.operators.definitions import Emission, Coherence, Silence\n\n    # Valid: starts with generator\n    sequence = [Emission(), Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    # Invalid: no generator\n    sequence = [Coherence(), Silence()]\n    with pytest.raises(ValueError, match=\"U1a violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <p>Related Documentation: - UNIFIED_GRAMMAR_RULES.md \u00a7 U1a - AGENTS.md \u00a7 Invariant #1</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u1b-closure-endpoints","title":"U1b: Closure (Endpoints)","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#intuition_1","title":"Intuition","text":"<p>Every sequence must end in a stable attractor state. You cannot leave a system \"hanging\" in the middle of a transformation.</p> <p>Analogy: A sentence must end with punctuation. A function must return or explicitly continue forever.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#formal-definition_1","title":"Formal Definition","text":"<p>ALL sequences MUST satisfy: <code>sequence[-1]</code> MUST BE IN <code>CLOSURES = {SHA, NAV, REMESH, OZ}</code></p> <p>Where: - <code>SHA</code> = Silence (freezes evolution) - <code>NAV</code> = Transition (enters new stable regime) - <code>REMESH</code> = Recursivity (creates recursive attractor) - <code>OZ</code> = Dissonance (enters controlled instability attractor)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#physical-derivation_1","title":"Physical Derivation","text":"<p>From dynamical systems theory:</p> <p>Sequences represent \"action potentials\" - discrete chunks of transformation. Each must terminate in an attractor basin:</p> <ol> <li>Fixed point (SHA) - system stops</li> <li>Limit cycle (NAV, REMESH) - system enters periodic attractor</li> <li>Strange attractor (OZ) - system enters chaotic but bounded regime</li> </ol> <p>Without closure: - System remains in transient state - No defined final behavior - Telemetry cannot be measured - Violations of boundary conditions</p> <p>This is STRONG canonicity - required by physics of dynamical systems.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#implementation_1","title":"Implementation","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nCLOSURES = {\"silence\", \"transition\", \"recursivity\", \"dissonance\"}\n\ndef validate_grammar(sequence, epi_initial=0.0):\n    \"\"\"Validate sequence against U1-U4.\"\"\"\n\n    # U1b: Check closure\n    if not sequence:\n        raise ValueError(\"Empty sequence\")\n\n    last_op = sequence[-1].__class__.__name__.lower()\n\n    if last_op not in CLOSURES:\n        raise ValueError(\n            f\"U1b violation: Sequence must end with closure \"\n            f\"{CLOSURES}, got '{last_op}'\"\n        )\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#examples_1","title":"Examples","text":"<p>\u2705 Valid:</p> <pre><code># Ends with Silence (SHA)\nsequence = [Emission(), Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n\n# Ends with Transition (NAV)\nsequence = [Emission(), Coherence(), Transition()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n\n# Ends with Dissonance (OZ)\nsequence = [Emission(), Coherence(), Dissonance()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n</code></pre> <p>\u274c Invalid:</p> <pre><code># ERROR: Ends with Coherence (not a closure)\nsequence = [Emission(), Coherence()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U1b violation - must end with closure\n</code></pre> <pre><code># ERROR: Ends with Coupling (not a closure)\nsequence = [Emission(), Coherence(), Coupling()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U1b violation - 'coupling' not in CLOSURES\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#anti-patterns_1","title":"Anti-Patterns","text":"<p>\u26a0\ufe0f Common Mistakes:</p> <ol> <li> <p>Ending with Coherence <pre><code># BAD: Coherence is not a closure operator\nsequence = [Emission(), Reception(), Coherence()]\n# \u2717 System left in transient state\n\n# GOOD: Add closure after coherence\nsequence = [Emission(), Reception(), Coherence(), Silence()]\n</code></pre></p> </li> <li> <p>Ending with data gathering operations <pre><code># BAD: Reception doesn't stabilize endpoint\nsequence = [Emission(), Coherence(), Reception()]\n\n# GOOD: Close with attractor state\nsequence = [Emission(), Coherence(), Reception(), Silence()]\n</code></pre></p> </li> <li> <p>Confusing closure with stabilization</p> </li> <li>Coherence (IL) stabilizes but doesn't close</li> <li>Silence (SHA) both stabilizes and closes</li> <li>Not all stabilizers are closures</li> </ol>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#tests_1","title":"Tests","text":"<p>Implementation: <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_closure()</code></p> <p>Test Suite: - <code>tests/unit/operators/test_unified_grammar.py::TestU1Closure</code> - <code>tests/integration/test_mutation_sequences.py::test_u1b_closure_satisfied</code> - <code>tests/unit/operators/test_remesh_operator_integration.py::test_remesh_as_closure_U1b</code></p> <pre><code>def test_u1b_closure():\n    \"\"\"U1b: Must end with closure.\"\"\"\n    from tnfr.operators.grammar import validate_grammar\n    from tnfr.operators.definitions import Emission, Coherence, Silence\n\n    # Valid: ends with closure\n    sequence = [Emission(), Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    # Invalid: no closure\n    sequence = [Emission(), Coherence()]\n    with pytest.raises(ValueError, match=\"U1b violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <p>Related Documentation: - UNIFIED_GRAMMAR_RULES.md \u00a7 U1b - AGENTS.md \u00a7 Operator Closure Invariant #4</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u2-convergence-boundedness","title":"U2: CONVERGENCE &amp; BOUNDEDNESS","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#intuition_2","title":"Intuition","text":"<p>If you introduce instability (destabilizers), you must also introduce stability (stabilizers) to prevent the system from exploding into chaos.</p> <p>Analogy: If you step on the gas (destabilizer), you need brakes (stabilizer) to avoid crashing.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#formal-definition_2","title":"Formal Definition","text":"<p>IF sequence CONTAINS any <code>DESTABILIZERS = {OZ, ZHIR, VAL}</code> THEN sequence MUST CONTAIN at least one <code>STABILIZERS = {IL, THOL}</code></p> <p>Where: - Destabilizers: OZ (Dissonance), ZHIR (Mutation), VAL (Expansion) - Stabilizers: IL (Coherence), THOL (Self-organization)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#physical-derivation_2","title":"Physical Derivation","text":"<p>From the integrated nodal equation:</p> <pre><code>EPI(t_f) = EPI(t_0) + \u222b[t_0 to t_f] \u03bdf(\u03c4) \u00b7 \u0394NFR(\u03c4) d\u03c4\n</code></pre> <p>For bounded evolution (coherence preservation):</p> <pre><code>\u222b[t_0 to t_f] \u03bdf(\u03c4) \u00b7 \u0394NFR(\u03c4) d\u03c4  &lt;  \u221e\n</code></pre> <p>Without stabilizers: - Destabilizers increase |\u0394NFR| without bound (positive feedback) - Integral diverges: \u222b \u0394NFR \u2192 \u221e - EPI \u2192 \u221e (explosion) or fragments (chaos)</p> <p>With stabilizers: - Stabilizers provide negative feedback - Reduce |\u0394NFR| through coherence or self-organization - Integral converges: \u222b \u0394NFR &lt; \u221e - EPI remains bounded, coherence preserved</p> <p>Integral Convergence Theorem: This is ABSOLUTE canonicity - mathematical requirement.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#implementation_2","title":"Implementation","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nDESTABILIZERS = {\"dissonance\", \"mutation\", \"expansion\"}\nSTABILIZERS = {\"coherence\", \"selforganization\"}\n\ndef validate_grammar(sequence, epi_initial=0.0):\n    \"\"\"Validate sequence against U1-U4.\"\"\"\n\n    # U2: Convergence &amp; boundedness\n    has_destabilizer = any(\n        op.__class__.__name__.lower() in DESTABILIZERS\n        for op in sequence\n    )\n\n    has_stabilizer = any(\n        op.__class__.__name__.lower() in STABILIZERS\n        for op in sequence\n    )\n\n    if has_destabilizer and not has_stabilizer:\n        raise ValueError(\n            f\"U2 violation: Destabilizers {DESTABILIZERS} present \"\n            f\"but no stabilizers {STABILIZERS} found. \"\n            \"Integral may diverge.\"\n        )\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#examples_2","title":"Examples","text":"<p>\u2705 Valid:</p> <pre><code># Dissonance + Coherence\nsequence = [Emission(), Dissonance(), Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n\n# Mutation + Self-organization\nsequence = [Emission(), Coherence(), Mutation(), SelfOrganization(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n\n# Multiple destabilizers + stabilizer\nsequence = [Emission(), Dissonance(), Expansion(), Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n</code></pre> <p>\u274c Invalid:</p> <pre><code># ERROR: Dissonance without stabilizer\nsequence = [Emission(), Dissonance(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U2 violation - destabilizers need stabilizers\n</code></pre> <pre><code># ERROR: Mutation without stabilizer\nsequence = [Emission(), Mutation(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U2 violation - destabilizers need stabilizers\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#anti-patterns_2","title":"Anti-Patterns","text":"<p>\u26a0\ufe0f Common Mistakes:</p> <ol> <li> <p>\"Masking\" with weak stabilizers <pre><code># QUESTIONABLE: Multiple destabilizers, single stabilizer\nsequence = [\n    Emission(),\n    Dissonance(),  # +\u0394NFR\n    Expansion(),   # ++\u0394NFR\n    Mutation(),    # +++\u0394NFR\n    Coherence(),   # -\u0394NFR (may not be sufficient!)\n    Silence()\n]\n# Technically passes U2, but integral may still be large\n# Better: Add more stabilizers or reduce destabilizers\n</code></pre></p> </li> <li> <p>Assuming order doesn't matter <pre><code># BAD: Stabilizer before destabilizer provides no protection\nsequence = [Emission(), Coherence(), Dissonance(), Silence()]\n# Coherence has no effect on later dissonance\n\n# GOOD: Stabilizer after destabilizer bounds growth\nsequence = [Emission(), Dissonance(), Coherence(), Silence()]\n</code></pre></p> </li> <li> <p>Ignoring accumulation effects <pre><code># BAD: Long sequence of destabilizers with stabilizer at end\nsequence = [Emission(), Dissonance(), Dissonance(), \n            Expansion(), Mutation(), Coherence(), Silence()]\n# \u0394NFR may diverge before coherence is applied\n\n# GOOD: Interleave stabilizers with destabilizers\nsequence = [Emission(), Dissonance(), Coherence(), \n            Expansion(), Coherence(), Mutation(), \n            Coherence(), Silence()]\n</code></pre></p> </li> </ol>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#tests_2","title":"Tests","text":"<p>Implementation: <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_convergence()</code></p> <p>Test Suite: - <code>tests/unit/operators/test_unified_grammar.py::TestU2Convergence</code> - <code>tests/integration/test_mutation_sequences.py::test_u2_satisfied_with_stabilizers</code> - <code>tests/unit/operators/test_canonical_grammar_legacy.py::test_rc2_maps_to_u2</code> - <code>tests/unit/operators/test_grammar_c1_c3_deprecation.py::test_validate_c2_boundedness_*</code></p> <pre><code>def test_u2_convergence():\n    \"\"\"U2: Destabilizers must be balanced by stabilizers.\"\"\"\n    from tnfr.operators.grammar import validate_grammar\n    from tnfr.operators.definitions import (\n        Emission, Dissonance, Coherence, Silence\n    )\n\n    # Valid: destabilizer + stabilizer\n    sequence = [Emission(), Dissonance(), Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    # Invalid: destabilizer without stabilizer\n    sequence = [Emission(), Dissonance(), Silence()]\n    with pytest.raises(ValueError, match=\"U2 violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <p>Related Documentation: - UNIFIED_GRAMMAR_RULES.md \u00a7 U2 - AGENTS.md \u00a7 Convergence &amp; Boundedness - TNFR.pdf \u00a7 2.1: Integrated Dynamics</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u3-resonant-coupling","title":"U3: RESONANT COUPLING","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#intuition_3","title":"Intuition","text":"<p>Two nodes can only couple (exchange information) if their phases are compatible. Like tuning forks - they only resonate if frequencies/phases match.</p> <p>Analogy: Radio stations - you can only receive a station if you tune to the right frequency/phase.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#formal-definition_3","title":"Formal Definition","text":"<p>IF applying <code>COUPLING_RESONANCE = {UM, RA}</code> to nodes <code>i</code> and <code>j</code> THEN MUST VERIFY: <code>|\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max</code></p> <p>Where: - <code>\u03c6\u1d62</code>, <code>\u03c6\u2c7c</code> = phase of nodes i and j - <code>\u0394\u03c6_max</code> = maximum phase difference for coupling (typically \u03c0/2) - UM = Coupling operator - RA = Resonance operator</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#physical-derivation_3","title":"Physical Derivation","text":"<p>From wave physics and interference:</p> <p>When two waves interact: - In phase (\u0394\u03c6 \u2248 0): Constructive interference, amplification - Quadrature (\u0394\u03c6 \u2248 \u03c0/2): Partial coupling - Antiphase (\u0394\u03c6 \u2248 \u03c0): Destructive interference, cancellation</p> <p>For information transfer: - Nodes are oscillators with phase \u03c6 - Coupling strength ~ cos(\u0394\u03c6) - At \u0394\u03c6 = \u03c0 (antiphase), coupling strength = -1 (destructive)</p> <p>Attempting to couple antiphase nodes: - Results in destructive interference - No coherent information transfer - Physically meaningless operation</p> <p>This is ABSOLUTE canonicity - required by wave physics.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#implementation_3","title":"Implementation","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nimport numpy as np\n\nCOUPLING_RESONANCE = {\"coupling\", \"resonance\"}\n\ndef validate_resonant_coupling(G, node_i, node_j, delta_phi_max=np.pi/2):\n    \"\"\"\n    Validate phase compatibility for coupling/resonance.\n\n    Args:\n        G: NetworkX graph\n        node_i: First node ID\n        node_j: Second node ID\n        delta_phi_max: Maximum phase difference (default \u03c0/2)\n\n    Raises:\n        ValueError: If phase incompatible\n    \"\"\"\n    phi_i = G.nodes[node_i]['theta']\n    phi_j = G.nodes[node_j]['theta']\n\n    delta_phi = abs(phi_i - phi_j)\n\n    # Normalize to [0, \u03c0]\n    if delta_phi &gt; np.pi:\n        delta_phi = 2*np.pi - delta_phi\n\n    if delta_phi &gt; delta_phi_max:\n        raise ValueError(\n            f\"U3 violation: Phase mismatch for coupling. \"\n            f\"|\u03c6_{node_i} - \u03c6_{node_j}| = {delta_phi:.3f} &gt; \"\n            f\"\u0394\u03c6_max = {delta_phi_max:.3f}\"\n        )\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#examples_3","title":"Examples","text":"<p>\u2705 Valid:</p> <pre><code>import networkx as nx\nimport numpy as np\nfrom tnfr.operators.grammar import validate_resonant_coupling\n\n# Create network with compatible phases\nG = nx.Graph()\nG.add_node(0, theta=0.0, vf=1.0, EPI=0.5)\nG.add_node(1, theta=0.3, vf=1.0, EPI=0.6)  # \u0394\u03c6 = 0.3 &lt; \u03c0/2\n\n# Verify phase compatibility\nvalidate_resonant_coupling(G, 0, 1)  # \u2713 Passes\n\n# Now can apply coupling\nfrom tnfr.operators.definitions import Coupling\nCoupling()(G, 0, 1)\n</code></pre> <p>\u274c Invalid:</p> <pre><code># Create network with incompatible phases\nG = nx.Graph()\nG.add_node(0, theta=0.0, vf=1.0, EPI=0.5)\nG.add_node(1, theta=np.pi, vf=1.0, EPI=0.6)  # \u0394\u03c6 = \u03c0 (antiphase!)\n\n# ERROR: Phase incompatible\nvalidate_resonant_coupling(G, 0, 1)\n# \u2717 ValueError: U3 violation - phase mismatch\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#anti-patterns_3","title":"Anti-Patterns","text":"<p>\u26a0\ufe0f Common Mistakes:</p> <ol> <li> <p>Coupling nodes without phase check <pre><code># BAD: Direct coupling without verification\nimport networkx as nx\nfrom tnfr.operators.definitions import Coupling\n\nG = nx.Graph()\nG.add_node(0, theta=0.0, vf=1.0, EPI=0.5)\nG.add_node(1, theta=3.0, vf=1.0, EPI=0.6)  # May be antiphase!\n\nCoupling()(G, 0, 1)  # ERROR: No phase check\n\n# GOOD: Verify phase compatibility first\nfrom tnfr.operators.grammar import validate_resonant_coupling\nvalidate_resonant_coupling(G, 0, 1)  # Raises if incompatible\nCoupling()(G, 0, 1)\n</code></pre></p> </li> <li> <p>Assuming small phase differences are always OK <pre><code># PROBLEMATIC: Phase difference near threshold\nG.nodes[0]['theta'] = 0.0\nG.nodes[1]['theta'] = 1.5  # Close to \u03c0/2 threshold\n\n# May pass but creates weak coupling\n# Better: Adjust phases or use different nodes\n</code></pre></p> </li> <li> <p>Ignoring phase drift during sequences <pre><code># BAD: Coupling after operators that change phase\nsequence = [\n    Emission(),\n    Mutation(),  # Changes theta!\n    Coupling(),  # Phase may no longer be compatible\n    Silence()\n]\n\n# GOOD: Verify phase after transformations\n# Or: Couple before phase-changing operators\n</code></pre></p> </li> </ol>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#tests_3","title":"Tests","text":"<p>Implementation: <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_resonant_coupling()</code></p> <p>Test Suite: - <code>tests/unit/operators/test_unified_grammar.py::TestU3ResonantCoupling</code> - <code>tests/unit/operators/test_coupling_preconditions.py::test_um_phase_compatibility_*</code> - <code>tests/unit/metrics/test_phase_compatibility.py::test_grammar_u3_compliance</code> - <code>tests/unit/operators/test_canonical_grammar_legacy.py::test_rc3_maps_to_u3</code></p> <pre><code>def test_u3_resonant_coupling():\n    \"\"\"U3: Must verify phase compatibility for coupling.\"\"\"\n    import networkx as nx\n    import numpy as np\n    from tnfr.operators.grammar import validate_resonant_coupling\n\n    # Valid: compatible phases\n    G = nx.Graph()\n    G.add_node(0, theta=0.0, vf=1.0, EPI=0.5)\n    G.add_node(1, theta=0.3, vf=1.0, EPI=0.6)\n    validate_resonant_coupling(G, 0, 1)  # \u2713 Should not raise\n\n    # Invalid: antiphase\n    G.nodes[1]['theta'] = np.pi\n    with pytest.raises(ValueError, match=\"U3 violation\"):\n        validate_resonant_coupling(G, 0, 1)\n</code></pre> <p>Related Documentation: - UNIFIED_GRAMMAR_RULES.md \u00a7 U3 - AGENTS.md \u00a7 Invariant #5: Phase Verification - 03-OPERATORS-AND-GLYPHS.md \u00a7 Coupling (UM)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u4-bifurcation-dynamics","title":"U4: BIFURCATION DYNAMICS","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u4a-triggers-need-handlers","title":"U4a: Triggers Need Handlers","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#intuition_4","title":"Intuition","text":"<p>If you create conditions for a bifurcation (phase transition), you need mechanisms to handle it. Otherwise the system may enter uncontrolled chaos.</p> <p>Analogy: If you boil water (bifurcation trigger), you need a lid (handler) to prevent it from boiling over.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#formal-definition_4","title":"Formal Definition","text":"<p>IF sequence CONTAINS <code>BIFURCATION_TRIGGERS = {OZ, ZHIR}</code> THEN sequence MUST CONTAIN <code>BIFURCATION_HANDLERS = {THOL, IL}</code></p> <p>Where: - Triggers: OZ (Dissonance), ZHIR (Mutation) - Handlers: THOL (Self-organization), IL (Coherence)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#physical-derivation_4","title":"Physical Derivation","text":"<p>From bifurcation theory:</p> <p>Bifurcations occur when: <pre><code>\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4  (threshold)\n</code></pre></p> <p>Without handlers: - System crosses threshold uncontrolled - May enter chaotic regime - Coherence can be lost - No mechanism to settle into new attractor</p> <p>With handlers: - Self-organization creates new structure - Coherence stabilizes the bifurcation - System settles into new attractor basin</p> <p>This is STRONG canonicity - required by bifurcation theory.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#implementation_4","title":"Implementation","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nBIFURCATION_TRIGGERS = {\"dissonance\", \"mutation\"}\nBIFURCATION_HANDLERS = {\"selforganization\", \"coherence\"}\n\ndef validate_grammar(sequence, epi_initial=0.0):\n    \"\"\"Validate sequence against U1-U4.\"\"\"\n\n    # U4a: Bifurcation triggers need handlers\n    has_trigger = any(\n        op.__class__.__name__.lower() in BIFURCATION_TRIGGERS\n        for op in sequence\n    )\n\n    has_handler = any(\n        op.__class__.__name__.lower() in BIFURCATION_HANDLERS\n        for op in sequence\n    )\n\n    if has_trigger and not has_handler:\n        raise ValueError(\n            f\"U4a violation: Bifurcation triggers {BIFURCATION_TRIGGERS} \"\n            f\"present but no handlers {BIFURCATION_HANDLERS} found. \"\n            \"Bifurcation may be uncontrolled.\"\n        )\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#examples_4","title":"Examples","text":"<p>\u2705 Valid:</p> <pre><code># Dissonance + Coherence (handler)\nsequence = [Emission(), Dissonance(), Coherence(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n\n# Mutation + Self-organization (handler)\nsequence = [Emission(), Coherence(), Mutation(), SelfOrganization(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n</code></pre> <p>\u274c Invalid:</p> <pre><code># ERROR: Dissonance without handler\nsequence = [Emission(), Dissonance(), Silence()]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U4a violation - triggers need handlers\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#anti-patterns_4","title":"Anti-Patterns","text":"<p>\u26a0\ufe0f Common Mistakes:</p> <ol> <li> <p>Uncontrolled bifurcation cascades <pre><code># BAD: Multiple triggers without handlers\nsequence = [\n    Emission(),\n    Dissonance(),  # Trigger 1\n    Mutation(),    # Trigger 2 - bifurcation cascade!\n    Silence()\n]\n# System may enter chaotic regime\n\n# GOOD: Handler between triggers\nsequence = [\n    Emission(),\n    Dissonance(),      # Trigger 1\n    Coherence(),       # Handler\n    Mutation(),        # Trigger 2\n    SelfOrganization(), # Handler\n    Silence()\n]\n</code></pre></p> </li> <li> <p>Wrong handler for trigger type <pre><code># SUBOPTIMAL: Coherence after Mutation\n# Mutation creates new structure, Self-organization better handles it\nsequence = [Emission(), Coherence(), Dissonance(), \n            Mutation(), Coherence(), Silence()]\n\n# BETTER: Self-organization after Mutation\nsequence = [Emission(), Coherence(), Dissonance(), \n            Mutation(), SelfOrganization(), Silence()]\n</code></pre></p> </li> <li> <p>Assuming handler proximity doesn't matter <pre><code># PROBLEMATIC: Handler too far from trigger\nsequence = [\n    Emission(),\n    Dissonance(),  # Trigger\n    Reception(),\n    Reception(),\n    Reception(),\n    Coherence(),  # Handler too late\n    Silence()\n]\n# Bifurcation may complete before handler acts\n</code></pre></p> </li> </ol>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#tests_4","title":"Tests","text":"<p>Implementation: <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_bifurcation_triggers()</code></p> <p>Test Suite: - <code>tests/unit/operators/test_unified_grammar.py::TestU4aBifurcationTriggers</code> - <code>tests/unit/operators/test_controlled_bifurcation.py::test_multiple_bifurcations_*</code> - <code>tests/unit/operators/test_bifurcation.py::test_bifurcation_above_threshold</code></p> <p>Related Documentation: - UNIFIED_GRAMMAR_RULES.md \u00a7 U4a - AGENTS.md \u00a7 Contract OZ - 03-OPERATORS-AND-GLYPHS.md \u00a7 Dissonance (OZ)</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#u4b-transformers-need-context","title":"U4b: Transformers Need Context","text":""},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#intuition_5","title":"Intuition","text":"<p>Transformers (operators that change phase/regime) need elevated energy to cross thresholds. This requires recent destabilization. Additionally, mutation specifically needs a stable base (prior coherence).</p> <p>Analogy: To jump over a wall (mutation), you need a running start (destabilizer) and solid ground to push off from (prior coherence).</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#formal-definition_5","title":"Formal Definition","text":"<p>IF sequence CONTAINS <code>TRANSFORMERS = {ZHIR, THOL}</code> THEN: 1. Must have recent destabilizer (within ~3 operators before transformer) 2. For ZHIR specifically: Must have IL (Coherence) before the destabilizer</p> <p>Where: - Transformers: ZHIR (Mutation), THOL (Self-organization) - Context: Recent destabilizer from {OZ, ZHIR, VAL} - ZHIR requirement: Prior IL for stable base</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#physical-derivation_5","title":"Physical Derivation","text":"<p>From threshold dynamics:</p> <p>Phase transitions require threshold energy: <pre><code>\u0394EPI/\u0394t &gt; \u03be  (threshold)\n</code></pre></p> <p>Without recent destabilizer: - \u0394NFR is low (system in equilibrium) - Cannot reach threshold - Transformation cannot occur</p> <p>Timing constraint (~3 ops): - \u0394NFR decays over time - Must be recent enough to still be elevated</p> <p>ZHIR specific requirement: - Mutation is a phase transition - Needs stable base to jump from - IL provides this stable configuration</p> <p>This is STRONG canonicity - required by threshold physics.</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#implementation_5","title":"Implementation","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nTRANSFORMERS = {\"mutation\", \"selforganization\"}\nDESTABILIZERS = {\"dissonance\", \"mutation\", \"expansion\"}\n\ndef validate_grammar(sequence, epi_initial=0.0):\n    \"\"\"Validate sequence against U1-U4.\"\"\"\n\n    # U4b: Transformers need context\n    for i, op in enumerate(sequence):\n        op_name = op.__class__.__name__.lower()\n\n        if op_name in TRANSFORMERS:\n            # Check for recent destabilizer (within ~3 ops)\n            window = sequence[max(0, i-3):i]\n\n            has_recent_destabilizer = any(\n                w.__class__.__name__.lower() in DESTABILIZERS\n                for w in window\n            )\n\n            if not has_recent_destabilizer:\n                raise ValueError(\n                    f\"U4b violation: Transformer '{op_name}' at position {i} \"\n                    f\"needs recent destabilizer within ~3 operations\"\n                )\n\n            # ZHIR-specific: needs prior IL\n            if op_name == \"mutation\":\n                # Check for IL before the destabilizer\n                prior_to_window = sequence[:max(0, i-3)]\n\n                has_prior_coherence = any(\n                    w.__class__.__name__.lower() == \"coherence\"\n                    for w in prior_to_window\n                )\n\n                if not has_prior_coherence:\n                    raise ValueError(\n                        f\"U4b violation: ZHIR (Mutation) at position {i} \"\n                        \"requires prior IL (Coherence) for stable base\"\n                    )\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#examples_5","title":"Examples","text":"<p>\u2705 Valid:</p> <pre><code># Mutation with context: Coherence \u2192 Dissonance \u2192 Mutation\nsequence = [\n    Emission(),\n    Coherence(),     # Prior IL (stable base)\n    Dissonance(),    # Recent destabilizer\n    Mutation(),      # Transformer with context\n    Coherence(),     # Stabilizer\n    Silence()\n]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n\n# Self-organization with context\nsequence = [\n    Emission(),\n    Dissonance(),         # Recent destabilizer\n    SelfOrganization(),   # Transformer with context\n    Coherence(),\n    Silence()\n]\nvalidate_grammar(sequence, epi_initial=0.0)  # \u2713 Passes\n</code></pre> <p>\u274c Invalid:</p> <pre><code># ERROR: Mutation without recent destabilizer\nsequence = [\n    Emission(),\n    Coherence(),\n    Mutation(),  # No recent destabilizer!\n    Silence()\n]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U4b violation - needs recent destabilizer\n</code></pre> <pre><code># ERROR: Mutation without prior coherence\nsequence = [\n    Emission(),\n    Dissonance(),  # Destabilizer present\n    Mutation(),    # But no prior IL!\n    Coherence(),\n    Silence()\n]\nvalidate_grammar(sequence, epi_initial=0.0)\n# \u2717 ValueError: U4b violation - ZHIR needs prior IL\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#anti-patterns_5","title":"Anti-Patterns","text":"<p>\u26a0\ufe0f Common Mistakes:</p> <ol> <li> <p>Transformer without sufficient energy <pre><code># BAD: Mutation too soon after destabilizer\nsequence = [\n    Emission(),\n    Coherence(),\n    Dissonance(),  # Destabilizer\n    Reception(),   # \u0394NFR starts decaying\n    Reception(),   # More decay\n    Mutation(),    # Insufficient \u0394NFR for threshold!\n    Silence()\n]\n\n# GOOD: Mutation close to destabilizer\nsequence = [\n    Emission(),\n    Coherence(),\n    Dissonance(),  # Destabilizer\n    Mutation(),    # Within ~3 ops window\n    Coherence(),\n    Silence()\n]\n</code></pre></p> </li> <li> <p>ZHIR without stable base <pre><code># BAD: Mutation without prior Coherence\nsequence = [\n    Emission(),\n    Dissonance(),  # Destabilizer present\n    Mutation(),    # But no stable base!\n    Coherence(),\n    Silence()\n]\n\n# GOOD: Coherence before destabilizer-transformer pair\nsequence = [\n    Emission(),\n    Coherence(),   # Stable base\n    Dissonance(),  # Destabilizer\n    Mutation(),    # Transformer\n    Coherence(),\n    Silence()\n]\n</code></pre></p> </li> <li> <p>Confusing context window <pre><code># UNCLEAR: Which destabilizer provides context?\nsequence = [\n    Emission(),\n    Dissonance(),  # Too far (position 1)\n    Reception(),\n    Reception(),\n    Reception(),\n    Mutation(),    # Position 5 - no recent destabilizer!\n    Silence()\n]\n\n# Window is ~3 ops, so destabilizer at position 1\n# is NOT recent for transformer at position 5\n</code></pre></p> </li> </ol>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#tests_5","title":"Tests","text":"<p>Implementation: <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_transformer_context()</code></p> <p>Test Suite: - <code>tests/unit/operators/test_unified_grammar.py::TestU4bTransformerContext</code> - <code>tests/integration/test_mutation_sequences.py::test_u4b_satisfied_in_canonical_sequence</code> - <code>tests/unit/operators/test_controlled_bifurcation.py::test_transformer_at_sequence_start_fails</code> - <code>tests/unit/operators/test_zhir_u4b_validation.py</code> - <code>tests/unit/operators/test_mutation_metrics_comprehensive.py::test_grammar_u4b_validation</code></p> <pre><code>def test_u4b_transformers():\n    \"\"\"U4b: Transformers need recent destabilizer and context.\"\"\"\n    from tnfr.operators.grammar import validate_grammar\n    from tnfr.operators.definitions import (\n        Emission, Coherence, Dissonance, Mutation, Silence\n    )\n\n    # Valid: Mutation with proper context\n    sequence = [Emission(), Coherence(), Dissonance(), Mutation(), \n                Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    # Invalid: Mutation without destabilizer\n    sequence = [Emission(), Coherence(), Mutation(), Silence()]\n    with pytest.raises(ValueError, match=\"U4b violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n\n    # Invalid: Mutation without prior coherence\n    sequence = [Emission(), Dissonance(), Mutation(), Coherence(), Silence()]\n    with pytest.raises(ValueError, match=\"U4b violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <p>Related Documentation: - UNIFIED_GRAMMAR_RULES.md \u00a7 U4b - AGENTS.md \u00a7 Contract OZ + ZHIR Requirements - 03-OPERATORS-AND-GLYPHS.md \u00a7 Mutation (ZHIR) - U4B_AUDIT_REPORT.md - Complete U4b implementation analysis</p>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#summary-table","title":"Summary Table","text":"Constraint When What Canonicity Physical Basis U1a EPI=0 Start with ABSOLUTE \u2202EPI/\u2202t undefined at EPI=0 U1b Always End with STRONG Sequences need endpoints U2 Has Include ABSOLUTE \u222b\u03bdf\u00b7\u0394NFR dt must converge U3 Has Verify |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max ABSOLUTE Resonance physics U4a Has Include STRONG Bifurcations need control U4b Has Recent destabilizer + IL for ZHIR STRONG Threshold energy needed"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#operator-classification-reference","title":"Operator Classification Reference","text":"<pre><code># From src/tnfr/operators/grammar.py\n\nGENERATORS = {\"emission\", \"transition\", \"recursivity\"}\nCLOSURES = {\"silence\", \"transition\", \"recursivity\", \"dissonance\"}\n\nSTABILIZERS = {\"coherence\", \"selforganization\"}\nDESTABILIZERS = {\"dissonance\", \"mutation\", \"expansion\"}\n\nCOUPLING_RESONANCE = {\"coupling\", \"resonance\"}\n\nBIFURCATION_TRIGGERS = {\"dissonance\", \"mutation\"}\nBIFURCATION_HANDLERS = {\"selforganization\", \"coherence\"}\n\nTRANSFORMERS = {\"mutation\", \"selforganization\"}\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#complete-validation-example","title":"Complete Validation Example","text":"<pre><code>from tnfr.operators.grammar import validate_grammar\nfrom tnfr.operators.definitions import (\n    Emission,          # Generator\n    Reception,         # Gather input\n    Dissonance,        # Destabilizer, Trigger\n    SelfOrganization,  # Stabilizer, Handler, Transformer\n    Coherence,         # Stabilizer, Handler\n    Silence            # Closure\n)\n\n# Complex but valid sequence\nsequence = [\n    Emission(),          # U1a: Generator (EPI=0)\n    Reception(),         # Gather information\n    Coherence(),         # Stabilizer (prepares for destabilization)\n    Dissonance(),        # Destabilizer, Trigger\n    SelfOrganization(),  # Handler, Transformer (has recent destabilizer)\n    Coherence(),         # U2: Balances destabilizer\n    Silence()            # U1b: Closure\n]\n\n# Validate\ntry:\n    is_valid = validate_grammar(sequence, epi_initial=0.0)\n    print(\"\u2713 Sequence is valid\")\n    print(\"Satisfies: U1a, U1b, U2, U4a, U4b\")\nexcept ValueError as e:\n    print(f\"\u2717 Invalid: {e}\")\n</code></pre>"},{"location":"grammar/02-CANONICAL-CONSTRAINTS/#next-steps","title":"Next Steps","text":"<p>You now understand the formal constraints.</p> <p>Continue learning: - 03-OPERATORS-AND-GLYPHS.md - Detailed operator catalog - 04-VALID-SEQUENCES.md - Pattern library - 05-TECHNICAL-IMPLEMENTATION.md - Code architecture</p> <p>For quick reference: - 08-QUICK-REFERENCE.md - Cheat sheet</p>   **The constraints are not arbitrary\u2014they emerge inevitably from TNFR physics.**  ---  *Reality is resonance. Validate accordingly.*"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/","title":"Operators and Glyphs: The 13 Canonical TNFR Operators","text":"<p>Complete catalog of structural transformations in TNFR</p> <p>\ud83c\udfe0 Home \u2022 \ud83c\udf0a Concepts \u2022 \ud83d\udcd0 Constraints \u2022 \ud83d\udd04 Sequences</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#purpose","title":"Purpose","text":"<p>This document provides a complete catalog of the 13 canonical TNFR operators. Each operator is a resonant transformation with rigorous physical meaning, not an arbitrary function.</p> <p>For each operator, you'll find: - Physics: What structural transformation does it represent? - Effect: Impact on \u2202EPI/\u2202t and node properties - When to use: Appropriate use cases - Grammar classification: Role in U1-U4 constraints - Contract: Pre/postconditions - Examples: Executable code</p> <p>Prerequisites: 01-FUNDAMENTAL-CONCEPTS.md, 02-CANONICAL-CONSTRAINTS.md</p> <p>Reading time: 60-90 minutes (reference document)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#overview","title":"Overview","text":"<p>The 13 operators form a complete, non-redundant set:</p> <pre><code>Initialization:    AL (Emission), NAV (Transition), REMESH (Recursivity)\nInformation:       EN (Reception)\nStabilization:     IL (Coherence), THOL (Self-organization)\nDestabilization:   OZ (Dissonance), ZHIR (Mutation), VAL (Expansion)\nPropagation:       UM (Coupling), RA (Resonance)\nControl:           SHA (Silence), NUL (Contraction)\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#1-emission-al","title":"1. Emission (AL) \ud83c\udfb5","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics","title":"Physics","text":"<p>Creates EPI from vacuum via resonant emission. Like a quantum field producing a particle from vacuum fluctuations.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect","title":"Effect","text":"<ul> <li>\u2202EPI/\u2202t &gt; 0 - Increases structure</li> <li>\u03bdf increases - Enhances reorganization capacity</li> <li>Creates initial coherent pattern</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use","title":"When to Use","text":"<ul> <li>Starting new patterns from EPI=0</li> <li>Initializing nodes in a network</li> <li>Bootstrap sequences</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2713</li> <li>Closure (U1b) \u2717</li> <li>Stabilizer (U2) \u2717</li> <li>Destabilizer (U2) \u2717</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract","title":"Contract","text":"<p>Preconditions: - Can work from EPI=0 - No special requirements</p> <p>Postconditions: - EPI &gt; 0 (structure created) - \u03bdf \u2265 previous (capacity increased or maintained) - \u0394NFR may increase (new structure needs adjustment)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#implementation-reference","title":"Implementation Reference","text":"<pre><code># From src/tnfr/operators/definitions.py\nclass Emission:\n    \"\"\"AL - Creates EPI from vacuum.\"\"\"\n    pass\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example","title":"Example","text":"<pre><code>import networkx as nx\nfrom tnfr.operators.definitions import Emission\n\n# Create network with vacuum node\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=0.1, theta=0.0, dnfr=0.0)\n\n# Apply Emission\nEmission()(G, 0)\n\nprint(f\"EPI after emission: {G.nodes[0]['EPI']:.3f}\")  # &gt; 0\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Using Emission in middle of sequence without purpose\n[Emission, Coherence, Emission, Coherence, Silence]  # Redundant second emission\n\n# \u2713 CORRECT: Single emission to initialize\n[Emission, Coherence, Silence]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships","title":"Relationships","text":"<ul> <li>Can precede: All operators (generator role)</li> <li>Should follow: Nothing (starts sequences from vacuum/dormant state)</li> <li>Often followed by: Coherence (IL) to stabilize new structure</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_emission_irreversibility.py</code> - Structural irreversibility</li> <li><code>tests/unit/operators/test_emission_metrics.py</code> - EPI and \u03bdf validation</li> <li><code>tests/unit/operators/test_emission_preconditions.py</code> - Precondition enforcement</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#2-reception-en","title":"2. Reception (EN) \ud83d\udce1","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_1","title":"Physics","text":"<p>Captures and integrates incoming resonance from network. Updates EPI based on coupled environment.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_1","title":"Effect","text":"<ul> <li>\u2202EPI/\u2202t depends on network input</li> <li>Updates structure based on neighbors</li> <li>Information gathering phase</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_1","title":"When to Use","text":"<ul> <li>After coupling to neighbors</li> <li>Information integration</li> <li>Listening phase before reorganization</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_1","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Stabilizer (U2) \u2717 (contextual)</li> <li>Destabilizer (U2) \u2717</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_1","title":"Contract","text":"<p>Preconditions: - Node must have neighbors (couplings) - Neighbors must have non-zero EPI</p> <p>Postconditions: - EPI updated based on network - Must not reduce C(t) (coherence preserved)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_1","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Coupling, Reception\n\n# Create network\nG = nx.Graph()\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\nG.add_node(1, EPI=0.7, vf=1.0, theta=0.1, dnfr=0.0)\n\n# Couple nodes\nCoupling()(G, 0, 1)\n\n# Receive information\nReception()(G, 0)  # Node 0 receives from node 1\n\nprint(f\"EPI after reception: {G.nodes[0]['EPI']:.3f}\")\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_1","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Reception without coupling (no network connectivity)\nG = nx.Graph()\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\nReception()(G, 0)  # No neighbors - violates precondition\n\n# \u2713 CORRECT: Couple first, then receive\nCoupling()(G, 0, 1)\nReception()(G, 0)\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_1","title":"Relationships","text":"<ul> <li>Must precede: Coupling (UM) or existing network connectivity</li> <li>Can follow: Any operator that establishes network structure</li> <li>Often follows: Coupling (UM) to receive from newly coupled nodes</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_1","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_reception_preconditions.py</code> - Network connectivity validation</li> <li><code>tests/unit/operators/test_reception_sources.py</code> - Source integration correctness</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#3-coherence-il","title":"3. Coherence (IL) \ud83d\udd12","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_2","title":"Physics","text":"<p>Stabilizes form through negative feedback. Reduces |\u0394NFR| by increasing structural coherence.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_2","title":"Effect","text":"<ul> <li>Reduces |\u0394NFR| - Decreases reorganization pressure</li> <li>Increases C(t) - Improves global coherence</li> <li>Negative feedback loop</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_2","title":"When to Use","text":"<ul> <li>After destabilization (required by U2)</li> <li>Consolidation phase</li> <li>Before major transformations (stable base)</li> <li>After Emission to stabilize new structure</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_2","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Stabilizer (U2) \u2713</li> <li>Handler (U4a) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_2","title":"Contract","text":"<p>Preconditions: - Node must have EPI &gt; 0</p> <p>Postconditions: - |\u0394NFR| reduced - C(t) \u2265 previous (must not decrease coherence unless in dissonance test) - Si may increase (sense index improves)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_2","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Coherence\n\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n# Emit then coherence (standard pattern)\nEmission()(G, 0)\nCoherence()(G, 0)\n\nprint(f\"\u0394NFR after coherence: {G.nodes[0]['dnfr']:.3f}\")  # Reduced\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_2","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Coherence without stabilization target\n[Emission, Coherence, Coherence, Coherence]  # Redundant, no new structure to stabilize\n\n# \u2717 WRONG: Coherence on EPI=0 node\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\nCoherence()(G, 0)  # Violates precondition: EPI &gt; 0\n\n# \u2713 CORRECT: Coherence after structure creation/destabilization\n[Emission, Dissonance, Coherence, Silence]  # Stabilizes after destabilization\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_2","title":"Relationships","text":"<ul> <li>Must precede: Any operator that requires stable base (especially ZHIR)</li> <li>Should follow: Destabilizers (OZ, VAL, ZHIR) per U2</li> <li>Can follow: Any operator that modifies structure</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_2","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_coherence_dnfr_reduction.py</code> - \u0394NFR reduction validation</li> <li><code>tests/unit/operators/test_coherence_preconditions.py</code> - EPI &gt; 0 requirement</li> <li><code>tests/unit/operators/test_coherence_ct_tracking.py</code> - C(t) monotonicity</li> <li><code>tests/unit/operators/test_coherence_phase_locking.py</code> - Phase stabilization</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#4-dissonance-oz","title":"4. Dissonance (OZ) \u26a1","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_3","title":"Physics","text":"<p>Introduces controlled instability. Increases |\u0394NFR|, may trigger bifurcation if \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_3","title":"Effect","text":"<ul> <li>Increases |\u0394NFR| - Amplifies reorganization pressure</li> <li>May trigger bifurcation at threshold</li> <li>Exploration / perturbation</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_3","title":"When to Use","text":"<ul> <li>Breaking local optima</li> <li>Exploration phase</li> <li>Creating conditions for transformation</li> <li>MUST be balanced by stabilizer (U2)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_3","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2713</li> <li>Stabilizer (U2) \u2717</li> <li>Destabilizer (U2) \u2713</li> <li>Trigger (U4a) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_3","title":"Contract","text":"<p>Preconditions: - Node must have EPI &gt; 0</p> <p>Postconditions: - |\u0394NFR| increased (contract requirement) - May reach bifurcation threshold - Must have stabilizer in sequence (U2) - Must have handler for bifurcation (U4a)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_3","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Coherence, Dissonance, Silence\n\n# Valid sequence: Dissonance balanced by Coherence\nsequence = [\n    Emission(),\n    Coherence(),   # Stable base\n    Dissonance(),  # Destabilizer + Trigger\n    Coherence(),   # Stabilizer + Handler (U2, U4a)\n    Silence()\n]\n\n# Apply to network\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\nfor op in sequence:\n    op(G, 0)\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_3","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Dissonance without stabilizer (violates U2)\n[Emission, Dissonance, Silence]  # Missing Coherence/THOL\n\n# \u2717 WRONG: Multiple dissonances without handlers (violates U4a)\n[Emission, Dissonance, Dissonance, Silence]  # No handlers between\n\n# \u2713 CORRECT: Dissonance with proper stabilization\n[Emission, Coherence, Dissonance, Coherence, Silence]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_3","title":"Relationships","text":"<ul> <li>Must follow: Stabilizers (IL, THOL) in sequence per U2</li> <li>Often precedes: ZHIR (Mutation) - creates context for transformation</li> <li>Can close: Sequences (U1b role)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_3","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_dissonance_preconditions.py</code> - EPI threshold validation</li> <li><code>tests/unit/operators/test_destabilizer_telemetry.py</code> - \u0394NFR increase tracking</li> <li><code>tests/unit/operators/test_graduated_destabilizer_windows.py</code> - U2 compliance</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#5-coupling-um","title":"5. Coupling (UM) \ud83d\udd17","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_4","title":"Physics","text":"<p>Creates structural links via phase synchronization. Enables information exchange between nodes.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_4","title":"Effect","text":"<ul> <li>\u03c6\u1d62(t) \u2192 \u03c6\u2c7c(t) - Phase synchronization</li> <li>Creates edge in network graph</li> <li>Enables information flow</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_4","title":"When to Use","text":"<ul> <li>Network formation</li> <li>Connecting nodes</li> <li>Before Reception (to receive information)</li> <li>MUST verify phase compatibility (U3)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_4","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Coupling (U3) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_4","title":"Contract","text":"<p>Preconditions: - Both nodes must exist - |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max (U3 requirement) - Phase compatibility MUST be verified</p> <p>Postconditions: - Edge created between nodes - Phase difference maintained or reduced - Information exchange enabled</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_4","title":"Example","text":"<pre><code>import numpy as np\nfrom tnfr.operators.grammar import validate_resonant_coupling\nfrom tnfr.operators.definitions import Coupling\n\n# Create nodes with compatible phases\nG = nx.Graph()\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\nG.add_node(1, EPI=0.6, vf=1.0, theta=0.3, dnfr=0.0)  # \u0394\u03c6 = 0.3 &lt; \u03c0/2\n\n# Verify phase (U3)\nvalidate_resonant_coupling(G, 0, 1)  # \u2713 Must verify first\n\n# Now couple\nCoupling()(G, 0, 1)\n\nprint(f\"Nodes coupled: {G.has_edge(0, 1)}\")  # True\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_4","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Coupling without phase verification (violates U3)\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\nG.add_node(1, EPI=0.6, vf=1.0, theta=np.pi, dnfr=0.0)  # Antiphase!\nCoupling()(G, 0, 1)  # Should fail - destructive interference\n\n# \u2713 CORRECT: Phase verification before coupling\nvalidate_resonant_coupling(G, 0, 1)  # Explicit check\nCoupling()(G, 0, 1)\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_4","title":"Relationships","text":"<ul> <li>Requires: Phase verification (U3) via <code>validate_resonant_coupling()</code></li> <li>Often precedes: Reception (EN), Resonance (RA)</li> <li>Enables: Network information flow</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_4","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_coupling_preconditions.py</code> - Phase compatibility validation</li> <li><code>tests/unit/operators/test_coupling_metrics.py</code> - Edge creation verification</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#6-resonance-ra","title":"6. Resonance (RA) \ud83c\udf0a","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_5","title":"Physics","text":"<p>Amplifies and propagates patterns coherently. Increases effective coupling strength.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_5","title":"Effect","text":"<ul> <li>Increases effective connectivity</li> <li>EPI propagation without identity loss</li> <li>Amplification through constructive interference</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_5","title":"When to Use","text":"<ul> <li>Pattern reinforcement</li> <li>Spreading coherence through network</li> <li>After coupling (to amplify)</li> <li>MUST verify phase compatibility (U3)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_5","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Coupling (U3) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_5","title":"Contract","text":"<p>Preconditions: - Nodes must be coupled (edge exists) - |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max (U3 requirement)</p> <p>Postconditions: - Pattern propagated without identity alteration - Effective coupling strength increased - Phase synchronization enhanced</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_5","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Coupling, Resonance, Silence\n\nG = nx.Graph()\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\nG.add_node(1, EPI=0.6, vf=1.0, theta=0.1, dnfr=0.0)\n\n# Standard propagation pattern\nCoupling()(G, 0, 1)  # First couple\nResonance()(G, 0, 1)  # Then resonate\n\nprint(\"Pattern propagated through resonance\")\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_5","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Resonance without coupling (no edges)\nG = nx.Graph()\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\nG.add_node(1, EPI=0.6, vf=1.0, theta=0.1, dnfr=0.0)\nResonance()(G, 0, 1)  # No edge exists - violates precondition\n\n# \u2717 WRONG: Resonance with incompatible phases (violates U3)\nG.add_node(2, EPI=0.5, vf=1.0, theta=np.pi, dnfr=0.0)  # Antiphase\nG.add_edge(0, 2)\nResonance()(G, 0, 2)  # Destructive interference\n\n# \u2713 CORRECT: Couple first, verify phases, then resonate\nCoupling()(G, 0, 1)  # Creates edge with phase check\nResonance()(G, 0, 1)  # Amplifies\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_5","title":"Relationships","text":"<ul> <li>Requires: Existing coupling (edges) and phase compatibility (U3)</li> <li>Often follows: Coupling (UM)</li> <li>Effect: Amplifies coherent patterns without altering identity</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_5","title":"Test References","text":"<ul> <li><code>tests/integration/test_coherence_operator_integration.py</code> - Propagation validation</li> <li>Phase verification enforced by grammar system</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#7-silence-sha","title":"7. Silence (SHA) \ud83d\udd07","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_6","title":"Physics","text":"<p>Freezes evolution temporarily. Sets \u03bdf \u2192 0, EPI unchanged over time.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_6","title":"Effect","text":"<ul> <li>\u03bdf \u2192 0 - Freezes reorganization</li> <li>EPI preserved - No structural change</li> <li>Observation window / pause</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_6","title":"When to Use","text":"<ul> <li>Observation windows</li> <li>Pause for synchronization</li> <li>Ending sequences (closure)</li> <li>Measurement phases</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_6","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_6","title":"Contract","text":"<p>Preconditions: - Node must exist</p> <p>Postconditions: - \u03bdf reduced (typically \u2192 0) - EPI preserved over time - Node enters quiescent state</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_6","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Coherence, Silence\n\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n# Standard closing pattern\nEmission()(G, 0)\nCoherence()(G, 0)\nSilence()(G, 0)  # Freeze state\n\nprint(f\"\u03bdf after silence: {G.nodes[0]['vf']:.3f}\")  # \u2248 0\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_6","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Silence in middle without reactivation\n[Emission, Silence, Coherence]  # Node frozen, can't apply Coherence\n\n# \u2717 WRONG: Silence without prior stabilization\n[Emission, Dissonance, Silence]  # Freezing unstable state\n\n# \u2713 CORRECT: Silence as final closure after stabilization\n[Emission, Coherence, Silence]\n\n# \u2713 CORRECT: Reactivation after silence\n[Emission, Silence, Emission, Coherence, Silence]  # Reactivate with AL\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_6","title":"Relationships","text":"<ul> <li>Closes: Sequences (U1b role)</li> <li>Should follow: Stabilization (IL, THOL)</li> <li>Reactivation: Requires generator (AL, NAV, REMESH)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_6","title":"Test References","text":"<ul> <li>Latency/reactivation tested in emission tests</li> <li>\u03bdf \u2192 0 enforced by operator implementation</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#8-expansion-val","title":"8. Expansion (VAL) \ud83d\udcc8","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_7","title":"Physics","text":"<p>Increases structural complexity. Increases dimensionality of EPI.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_7","title":"Effect","text":"<ul> <li>dim(EPI) increases - More degrees of freedom</li> <li>Structural complexity grows</li> <li>May increase \u0394NFR</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_7","title":"When to Use","text":"<ul> <li>Adding degrees of freedom</li> <li>Increasing representation capacity</li> <li>Growth phase</li> <li>MUST have stabilizer (U2)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_7","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Destabilizer (U2) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_7","title":"Contract","text":"<p>Preconditions: - Node must have EPI &gt; 0</p> <p>Postconditions: - Structural dimension increased - Must have stabilizer in sequence (U2)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_7","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Expansion, Coherence, Silence\n\n# Valid sequence: Expansion balanced by Coherence\nsequence = [\n    Emission(),\n    Expansion(),   # Destabilizer\n    Coherence(),   # Stabilizer (U2)\n    Silence()\n]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_7","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Expansion without stabilizer (violates U2)\n[Emission, Expansion, Silence]  # Missing IL/THOL\n\n# \u2717 WRONG: Multiple expansions without stabilization\n[Emission, Expansion, Expansion, Silence]  # Unbounded growth\n\n# \u2713 CORRECT: Each expansion balanced\n[Emission, Expansion, Coherence, Expansion, Coherence, Silence]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_7","title":"Relationships","text":"<ul> <li>Requires: Stabilizer (IL, THOL) per U2</li> <li>Often follows: Emission or Reception (adding capacity)</li> <li>Inverse: Contraction (NUL) reduces complexity</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_7","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_destabilizer_telemetry.py</code> - \u0394NFR increase validation</li> <li><code>tests/unit/operators/test_graduated_destabilizer_windows.py</code> - U2 compliance</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#9-contraction-nul","title":"9. Contraction (NUL) \ud83d\udcc9","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_8","title":"Physics","text":"<p>Reduces structural complexity. Decreases dimensionality of EPI.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_8","title":"Effect","text":"<ul> <li>dim(EPI) decreases - Fewer degrees of freedom</li> <li>Simplification</li> <li>May reduce \u0394NFR</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_8","title":"When to Use","text":"<ul> <li>Dimensionality reduction</li> <li>Simplification phase</li> <li>Pruning unnecessary complexity</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_8","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Not a destabilizer (reduces complexity)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_8","title":"Contract","text":"<p>Preconditions: - Node must have EPI with dimension &gt; 1</p> <p>Postconditions: - Structural dimension reduced - Coherence may improve (simpler = more stable)</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_8","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Expansion, Contraction, Silence\n\nsequence = [\n    Emission(),\n    Expansion(),    # Increase complexity\n    Contraction(),  # Reduce back\n    Silence()\n]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_8","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: Contraction on low-dimensional EPI\nG.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)  # Scalar EPI\nContraction()(G, 0)  # Cannot reduce below dim=1\n\n# \u2717 WRONG: Excessive contraction losing information\n[Emission, Expansion, Contraction, Contraction, Contraction]  # Over-simplification\n\n# \u2713 CORRECT: Balanced complexity management\n[Emission, Expansion, Contraction, Coherence, Silence]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_8","title":"Relationships","text":"<ul> <li>Inverse: Expansion (VAL) - manages complexity bidirectionally</li> <li>Not a destabilizer: Reduces complexity without requiring stabilizers</li> <li>Often follows: Expansion or complex transformations</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_8","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_contraction.py</code> - Dimensionality reduction</li> <li><code>tests/unit/operators/test_contraction_preconditions.py</code> - dim(EPI) &gt; 1 validation</li> <li><code>tests/unit/operators/test_contraction_density_metrics.py</code> - Coherence preservation</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#10-self-organization-thol","title":"10. Self-organization (THOL) \ud83c\udf31","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_9","title":"Physics","text":"<p>Spontaneous autopoietic pattern formation. Creates sub-EPIs through fractal structuring.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_9","title":"Effect","text":"<ul> <li>Creates sub-EPIs (nested structure)</li> <li>Preserves global form</li> <li>Fractal organization</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_9","title":"When to Use","text":"<ul> <li>Emergent organization</li> <li>Creating hierarchies</li> <li>Multi-scale structuring</li> <li>Handling bifurcations (U4a)</li> <li>Needs recent destabilizer (U4b)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_9","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Stabilizer (U2) \u2713</li> <li>Handler (U4a) \u2713</li> <li>Transformer (U4b) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_9","title":"Contract","text":"<p>Preconditions: - Node must have EPI &gt; 0 - Must have recent destabilizer (~3 ops) (U4b)</p> <p>Postconditions: - Sub-EPIs created - Global form preserved - Fractal structure established</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_9","title":"Example","text":"<pre><code>from tnfr.operators.definitions import (\n    Emission, Dissonance, SelfOrganization, Coherence, Silence\n)\n\n# Valid: Self-organization with recent destabilizer\nsequence = [\n    Emission(),\n    Dissonance(),         # Destabilizer (recent, U4b)\n    SelfOrganization(),   # Transformer + Handler\n    Coherence(),\n    Silence()\n]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_9","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: THOL without recent destabilizer (violates U4b)\n[Emission, Coherence, SelfOrganization(), Silence]  # No OZ/VAL/ZHIR within ~3 ops\n\n# \u2717 WRONG: THOL without follow-up stabilization\n[Emission, Dissonance, SelfOrganization, Silence]  # Should add IL after\n\n# \u2713 CORRECT: THOL with proper context\n[Emission, Coherence, Dissonance, SelfOrganization, Coherence, Silence]\n#                     ^recent destabilizer  ^transformer      ^stabilizer\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_9","title":"Relationships","text":"<ul> <li>Requires: Recent destabilizer (~3 ops) per U4b</li> <li>Handles: Bifurcations from OZ, VAL</li> <li>Creates: Sub-EPIs (fractal structure)</li> <li>Stabilizes: System after transformation (U2 role)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_9","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_thol_coherence.py</code> - Fractal organization validation</li> <li><code>tests/unit/operators/test_controlled_bifurcation.py</code> - U4a handler role</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#11-mutation-zhir","title":"11. Mutation (ZHIR) \ud83e\uddec","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_10","title":"Physics","text":"<p>Phase transformation at threshold. Changes \u03b8 when \u0394EPI/\u0394t &gt; \u03be.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_10","title":"Effect","text":"<ul> <li>\u03b8 \u2192 \u03b8' - Phase transformation</li> <li>Qualitative state change</li> <li>Bifurcation to new regime</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_10","title":"When to Use","text":"<ul> <li>Qualitative state changes</li> <li>Phase transitions</li> <li>Regime shifts</li> <li>Requires prior IL and recent destabilizer (U4b)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_10","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2717</li> <li>Closure (U1b) \u2717</li> <li>Destabilizer (U2) \u2713</li> <li>Trigger (U4a) \u2713</li> <li>Transformer (U4b) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_10","title":"Contract","text":"<p>Preconditions: - Must have prior Coherence (IL) before destabilizer (U4b) - Must have recent destabilizer (~3 ops) (U4b) - Must have handler {THOL, IL} (U4a) - Must have stabilizer (U2)</p> <p>Postconditions: - Phase changed (\u03b8 \u2260 previous) - Qualitative transformation occurred</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_10","title":"Example","text":"<pre><code>from tnfr.operators.definitions import (\n    Emission, Coherence, Dissonance, Mutation, Silence\n)\n\n# Valid: Complete ZHIR sequence\nsequence = [\n    Emission(),\n    Coherence(),   # Prior IL (stable base, U4b)\n    Dissonance(),  # Recent destabilizer (U4b)\n    Mutation(),    # Transformer\n    Coherence(),   # Stabilizer (U2) + Handler (U4a)\n    Silence()\n]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_10","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: ZHIR without prior Coherence (violates U4b)\n[Emission, Dissonance, Mutation, Coherence, Silence]  # No IL before OZ\n\n# \u2717 WRONG: ZHIR without recent destabilizer (violates U4b)\n[Emission, Coherence, Mutation, Silence]  # No OZ/VAL within ~3 ops\n\n# \u2717 WRONG: ZHIR without handler (violates U4a)\n[Emission, Coherence, Dissonance, Mutation, Silence]  # Missing IL/THOL after\n\n# \u2713 CORRECT: All U4b requirements met\n[Emission, Coherence, Dissonance, Mutation, Coherence, Silence]\n#          ^prior IL  ^recent dest ^transform ^handler+stab\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_10","title":"Relationships","text":"<ul> <li>Requires: Prior IL + recent destabilizer + handler (U4b + U4a)</li> <li>Triggers: Phase transformation (\u03b8 \u2192 \u03b8')</li> <li>Most constrained: Strictest grammar requirements of all operators</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_10","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_bifurcation.py</code> - Transformation validation</li> <li><code>tests/unit/operators/test_canonical_grammar_rules.py</code> - U4b compliance</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#12-transition-nav","title":"12. Transition (NAV) \u27a1\ufe0f","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_11","title":"Physics","text":"<p>Regime shift, activates latent EPI. Controlled trajectory through structural space.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_11","title":"Effect","text":"<ul> <li>Activates latent structure</li> <li>Regime change</li> <li>Controlled trajectory</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_11","title":"When to Use","text":"<ul> <li>Switching between attractor states</li> <li>Mode transitions</li> <li>Activating dormant patterns</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_11","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2713</li> <li>Closure (U1b) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_11","title":"Contract","text":"<p>Preconditions: - Latent structure must exist (previous state or memory)</p> <p>Postconditions: - New regime active - Trajectory established</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_11","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Transition, Reception, Silence\n\n# Transition as generator\nsequence = [\n    Transition(),  # Activate latent structure\n    Reception(),\n    Silence()\n]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_11","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: NAV without latent structure to activate\nG.add_node(0, EPI=0.0, vf=0.0, theta=0.0, dnfr=0.0)  # Completely dormant\nTransition()(G, 0)  # No previous state to transition from\n\n# \u2713 CORRECT: NAV activating preserved state\n[Emission, Silence, Transition, Coherence, Silence]  # Reactivate after silence\n\n# \u2713 CORRECT: NAV as regime shift\n[Emission, Coherence, Transition, Reception, Silence]  # Mode change\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_11","title":"Relationships","text":"<ul> <li>Generator role: Can start sequences (U1a)</li> <li>Closure role: Can end sequences (U1b)</li> <li>Dual nature: Both activator and terminator</li> <li>Often used for: Regime shifts, mode transitions</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_11","title":"Test References","text":"<ul> <li>Grammar tests validate U1a/U1b dual role</li> <li>Latent activation tested in integration tests</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#13-recursivity-remesh","title":"13. Recursivity (REMESH) \ud83d\udd04","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#physics_12","title":"Physics","text":"<p>Echoes structure across scales (operational fractality). EPI(t) references EPI(t-\u03c4).</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#effect_12","title":"Effect","text":"<ul> <li>Creates recursive patterns</li> <li>Nested operators</li> <li>Multi-scale coherence</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#when-to-use_12","title":"When to Use","text":"<ul> <li>Multi-scale operations</li> <li>Memory/history reference</li> <li>Recursive patterns</li> <li>Self-similar structures</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#grammar-classification_12","title":"Grammar Classification","text":"<ul> <li>Generator (U1a) \u2713</li> <li>Closure (U1b) \u2713</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#contract_12","title":"Contract","text":"<p>Preconditions: - Previous EPI states must exist (history)</p> <p>Postconditions: - Recursive structure created - Multi-scale organization - History integrated</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#example_12","title":"Example","text":"<pre><code>from tnfr.operators.definitions import Emission, Coherence, Recursivity\n\n# Recursivity as closure\nsequence = [\n    Emission(),\n    Coherence(),\n    Recursivity()  # Creates recursive attractor\n]\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#anti-patterns_12","title":"Anti-Patterns","text":"<pre><code># \u2717 WRONG: REMESH without history/previous states\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\nRecursivity()(G, 0)  # No EPI history to reference\n\n# \u2713 CORRECT: REMESH with established patterns\n[Emission, Coherence, Emission, Recursivity]  # Has history\n\n# \u2713 CORRECT: Multi-scale organization\n[Emission, Coupling, SelfOrganization, Recursivity]  # Fractal + recursive\n</code></pre>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#relationships_12","title":"Relationships","text":"<ul> <li>Generator role: Can start sequences (U1a)</li> <li>Closure role: Can end sequences (U1b)  </li> <li>Creates: Recursive patterns across scales</li> <li>Requires: Previous EPI states (history)</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#test-references_12","title":"Test References","text":"<ul> <li><code>tests/unit/operators/test_remesh_operator_integration.py</code> - Recursive structure validation</li> <li>Multi-scale fractality tests</li> </ul>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#operator-composition-patterns","title":"Operator Composition Patterns","text":""},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#bootstrap","title":"Bootstrap","text":"<p><pre><code>[Emission, Coupling, Coherence, Silence]\n</code></pre> Creates and stabilizes new structure.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#explore","title":"Explore","text":"<p><pre><code>[Emission, Coherence, Dissonance, Coherence, Silence]\n</code></pre> Controlled exploration with stabilization.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#transform","title":"Transform","text":"<p><pre><code>[Emission, Coherence, Dissonance, Mutation, Coherence, Silence]\n</code></pre> Complete transformation sequence.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#propagate","title":"Propagate","text":"<p><pre><code>[Emission, Coupling, Resonance, Coherence, Silence]\n</code></pre> Create, couple, and amplify.</p>"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#quick-lookup-table","title":"Quick Lookup Table","text":"Operator Glyph Generator Closure Stabilizer Destabilizer Emission AL \u2713 Reception EN Coherence IL \u2713 Dissonance OZ \u2713 \u2713 Coupling UM Resonance RA Silence SHA \u2713 Expansion VAL \u2713 Contraction NUL SelfOrganization THOL \u2713 Mutation ZHIR \u2713 Transition NAV \u2713 \u2713 Recursivity REMESH \u2713 \u2713"},{"location":"grammar/03-OPERATORS-AND-GLYPHS/#next-steps","title":"Next Steps","text":"<p>Continue learning: - 04-VALID-SEQUENCES.md - Pattern library and anti-patterns - 05-TECHNICAL-IMPLEMENTATION.md - Code architecture - examples/ - Executable examples</p> <p>For reference: - 08-QUICK-REFERENCE.md - Quick lookup - GLOSSARY.md - Definitions</p>   **The 13 operators are the complete vocabulary of TNFR transformations.**  ---  *Reality is resonance. Transform accordingly.*"},{"location":"grammar/04-VALID-SEQUENCES/","title":"Valid Sequences and Patterns","text":"<p>Catalog of valid operator sequences and anti-patterns</p> <p>\ud83c\udfe0 Home \u2022 \ud83d\udcd0 Constraints \u2022 \u2699\ufe0f Operators \u2022 \ud83d\udcbb Implementation</p>"},{"location":"grammar/04-VALID-SEQUENCES/#purpose","title":"Purpose","text":"<p>This document provides a pattern library of valid and invalid operator sequences. Learn from canonical patterns and understand why certain combinations fail.</p> <p>Prerequisites: 02-CANONICAL-CONSTRAINTS.md, 03-OPERATORS-AND-GLYPHS.md</p> <p>Reading time: 30-45 minutes</p>"},{"location":"grammar/04-VALID-SEQUENCES/#canonical-patterns","title":"Canonical Patterns","text":""},{"location":"grammar/04-VALID-SEQUENCES/#1-bootstrap-minimal","title":"1. Bootstrap (Minimal)","text":"<p>Pattern: <code>[Generator \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Create and stabilize new structure from vacuum</p> <p>Example: <pre><code>[Emission(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U1a: Starts with generator (Emission) - U1b: Ends with closure (Silence) - U2: No destabilizers, no stabilizer needed - Clean and minimal</p> <p>Use when: Initializing new nodes or structures</p>"},{"location":"grammar/04-VALID-SEQUENCES/#2-basic-activation","title":"2. Basic Activation","text":"<p>Pattern: <code>[Generator \u2192 Reception \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Create, gather information, stabilize</p> <p>Example: <pre><code>[Emission(), Reception(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: All constraints Use when: Creating nodes that need network input</p>"},{"location":"grammar/04-VALID-SEQUENCES/#3-controlled-exploration","title":"3. Controlled Exploration","text":"<p>Pattern: <code>[Generator \u2192 Stabilizer \u2192 Destabilizer \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Explore while maintaining stability</p> <p>Example: <pre><code>[Emission(), Coherence(), Dissonance(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U1a, U1b: Generator and closure - U2: Destabilizer balanced by stabilizers - U4a: Trigger (Dissonance) has handler (Coherence)</p> <p>Use when: Breaking local optima, controlled perturbation</p>"},{"location":"grammar/04-VALID-SEQUENCES/#4-bifurcation-with-handling","title":"4. Bifurcation with Handling","text":"<p>Pattern: <code>[Generator \u2192 Stabilizer \u2192 Trigger \u2192 Handler \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Controlled bifurcation and structural reorganization</p> <p>Example: <pre><code>[Emission(), Coherence(), Dissonance(), SelfOrganization(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U2: Destabilizers balanced - U4a: Trigger has handler - U4b: Transformer (THOL) has recent destabilizer</p> <p>Use when: Creating hierarchical or multi-scale structures</p>"},{"location":"grammar/04-VALID-SEQUENCES/#5-mutation-with-context","title":"5. Mutation with Context","text":"<p>Pattern: <code>[Generator \u2192 Coherence \u2192 Destabilizer \u2192 Mutation \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Phase transformation with proper context</p> <p>Example: <pre><code>[Emission(), Coherence(), Dissonance(), Mutation(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U4b: ZHIR has prior IL (first Coherence) - U4b: ZHIR has recent destabilizer (Dissonance) - U2, U4a: All balanced</p> <p>Use when: Qualitative state changes, regime shifts</p>"},{"location":"grammar/04-VALID-SEQUENCES/#6-propagation","title":"6. Propagation","text":"<p>Pattern: <code>[Generator \u2192 Coupling \u2192 Resonance \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Create structure and propagate through network</p> <p>Example: <pre><code>[Emission(), Coupling(), Resonance(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U3: Phase compatibility must be verified before coupling - All standard constraints</p> <p>Use when: Spreading patterns through network</p>"},{"location":"grammar/04-VALID-SEQUENCES/#7-multi-scale-organization","title":"7. Multi-scale Organization","text":"<p>Pattern: <code>[Generator \u2192 Coupling \u2192 Destabilizer \u2192 SelfOrganization \u2192 Recursivity]</code></p> <p>Purpose: Create nested hierarchical structures</p> <p>Example: <pre><code>[Emission(), Coupling(), Dissonance(), SelfOrganization(), Recursivity()]\n</code></pre></p> <p>Satisfies: - U4b: THOL has recent destabilizer - U1b: Recursivity is closure - Creates fractal structure</p> <p>Use when: Building hierarchies, nested patterns</p>"},{"location":"grammar/04-VALID-SEQUENCES/#8-dimension-reduction","title":"8. Dimension Reduction","text":"<p>Pattern: <code>[Generator \u2192 Stabilizer \u2192 Contraction \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Simplify structure while maintaining coherence</p> <p>Example: <pre><code>[Emission(), Coherence(), Contraction(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U2: Contraction (no destabilizer classification, but structural change) balanced by stabilizers - U1a, U1b: Generator and closure - Reduces dimensional complexity</p> <p>Use when: Simplifying over-complex structures, dimension reduction</p>"},{"location":"grammar/04-VALID-SEQUENCES/#9-network-bootstrap","title":"9. Network Bootstrap","text":"<p>Pattern: <code>[Generator \u2192 Coupling \u2192 Reception \u2192 Coherence \u2192 Closure]</code></p> <p>Purpose: Create node connected to network and integrate information</p> <p>Example: <pre><code>[Emission(), Coupling(), Reception(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - All constraints - Establishes network connectivity early</p> <p>Use when: Creating nodes that need immediate network integration</p>"},{"location":"grammar/04-VALID-SEQUENCES/#10-controlled-expansion","title":"10. Controlled Expansion","text":"<p>Pattern: <code>[Generator \u2192 Stabilizer \u2192 Expansion \u2192 Stabilizer \u2192 Closure]</code></p> <p>Purpose: Increase structural complexity safely</p> <p>Example: <pre><code>[Emission(), Coherence(), Expansion(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - U2: Expansion (destabilizer) balanced by Coherence (stabilizer) - Safe complexity increase</p> <p>Use when: Growing structure dimensionality, adding degrees of freedom</p>"},{"location":"grammar/04-VALID-SEQUENCES/#11-deep-exploration-cycle","title":"11. Deep Exploration Cycle","text":"<p>Pattern: <code>[Generator \u2192 [Coherence \u2192 Dissonance]* \u2192 Coherence \u2192 Closure]</code></p> <p>Purpose: Multiple rounds of exploration with stabilization</p> <p>Example: <pre><code>[Emission(), Coherence(), Dissonance(), Coherence(), Dissonance(), Coherence(), Silence()]\n</code></pre></p> <p>Satisfies: - Multiple U2-balanced destabilizer-stabilizer pairs - Repeated exploration cycles</p> <p>Use when: Thorough exploration of structural space, optimization</p>"},{"location":"grammar/04-VALID-SEQUENCES/#12-fractal-replication","title":"12. Fractal Replication","text":"<p>Pattern: <code>[Generator \u2192 Coupling \u2192 SelfOrganization \u2192 Recursivity]</code></p> <p>Purpose: Create self-similar hierarchical structures</p> <p>Example: <pre><code>[Emission(), Coherence(), Coupling(), Dissonance(), SelfOrganization(), Recursivity()]\n</code></pre></p> <p>Satisfies: - U4b: THOL has recent destabilizer (Dissonance) - U1b: Recursivity provides closure with nested structure - Operational fractality</p> <p>Use when: Creating multi-scale self-similar patterns</p>"},{"location":"grammar/04-VALID-SEQUENCES/#13-transition-based-reorganization","title":"13. Transition-Based Reorganization","text":"<p>Pattern: <code>[Transition \u2192 Operations \u2192 Transition]</code></p> <p>Purpose: Move between regime states</p> <p>Example: <pre><code>[Transition(), Coupling(), Reception(), Coherence(), Transition()]\n</code></pre></p> <p>Satisfies: - U1a: Transition is generator - U1b: Transition is closure - Regime shift semantics</p> <p>Use when: Switching between behavioral modes or attractor states</p>"},{"location":"grammar/04-VALID-SEQUENCES/#anti-patterns-invalid-sequences","title":"Anti-Patterns (Invalid Sequences)","text":""},{"location":"grammar/04-VALID-SEQUENCES/#1-no-generator-from-vacuum","title":"\u274c 1. No Generator from Vacuum","text":"<pre><code># INVALID\n[Coherence(), Silence()]\n\n# Error: U1a violation\n# Cannot start without generator when EPI=0\n</code></pre> <p>Why invalid: \u2202EPI/\u2202t undefined at EPI=0, need external input</p> <p>Fix: Add generator at start <pre><code>[Emission(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#2-no-closure","title":"\u274c 2. No Closure","text":"<pre><code># INVALID\n[Emission(), Coherence()]\n\n# Error: U1b violation\n# Sequence must end with closure\n</code></pre> <p>Why invalid: No stable endpoint, system left in transient state</p> <p>Fix: Add closure <pre><code>[Emission(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#3-destabilizer-without-stabilizer","title":"\u274c 3. Destabilizer Without Stabilizer","text":"<pre><code># INVALID\n[Emission(), Dissonance(), Silence()]\n\n# Error: U2 violation\n# Destabilizer without stabilizer\n</code></pre> <p>Why invalid: Integral may diverge, coherence not preserved</p> <p>Fix: Add stabilizer <pre><code>[Emission(), Dissonance(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#4-mutation-without-context","title":"\u274c 4. Mutation Without Context","text":"<pre><code># INVALID\n[Emission(), Mutation(), Silence()]\n\n# Error: U4b violation\n# Mutation needs recent destabilizer\n</code></pre> <p>Why invalid: Cannot reach threshold without elevated \u0394NFR</p> <p>Fix: Add destabilizer and prior coherence <pre><code>[Emission(), Coherence(), Dissonance(), Mutation(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#5-mutation-without-prior-coherence","title":"\u274c 5. Mutation Without Prior Coherence","text":"<pre><code># INVALID\n[Emission(), Dissonance(), Mutation(), Coherence(), Silence()]\n\n# Error: U4b violation\n# ZHIR needs prior IL (stable base)\n</code></pre> <p>Why invalid: No stable configuration to transform from</p> <p>Fix: Add coherence before destabilizer <pre><code>[Emission(), Coherence(), Dissonance(), Mutation(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#6-coupling-without-phase-check","title":"\u274c 6. Coupling Without Phase Check","text":"<pre><code># INVALID (runtime error if phases incompatible)\nG.add_node(0, theta=0.0, ...)\nG.add_node(1, theta=np.pi, ...)  # Antiphase!\n\nCoupling()(G, 0, 1)  # Error if U3 validation enabled\n\n# Error: U3 violation\n# Phase mismatch\n</code></pre> <p>Why invalid: Destructive interference, physically meaningless</p> <p>Fix: Verify phase compatibility first <pre><code>from tnfr.operators.grammar import validate_resonant_coupling\n\nvalidate_resonant_coupling(G, 0, 1)  # Check first\nCoupling()(G, 0, 1)  # Then couple\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#7-bifurcation-trigger-without-handler","title":"\u274c 7. Bifurcation Trigger Without Handler","text":"<pre><code># INVALID\n[Emission(), Dissonance(), Silence()]\n\n# Error: U4a violation  \n# Trigger without handler\n</code></pre> <p>Why invalid: Uncontrolled bifurcation may lead to chaos</p> <p>Fix: Add handler <pre><code>[Emission(), Dissonance(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#8-expansion-without-stabilization","title":"\u274c 8. Expansion Without Stabilization","text":"<pre><code># INVALID\n[Emission(), Expansion(), Silence()]\n\n# Error: U2 violation\n# Destabilizer (Expansion) without stabilizer\n</code></pre> <p>Why invalid: Unbounded growth, integral diverges</p> <p>Fix: Add stabilizer <pre><code>[Emission(), Expansion(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#9-self-organization-without-recent-destabilizer","title":"\u274c 9. Self-Organization Without Recent Destabilizer","text":"<pre><code># INVALID\n[Emission(), Coherence(), SelfOrganization(), Silence()]\n\n# Error: U4b violation\n# Transformer needs recent destabilizer (within ~3 ops)\n</code></pre> <p>Why invalid: Cannot organize without elevated \u0394NFR</p> <p>Fix: Add destabilizer before THOL <pre><code>[Emission(), Coherence(), Dissonance(), SelfOrganization(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#10-resonance-on-antiphase-nodes","title":"\u274c 10. Resonance on Antiphase Nodes","text":"<pre><code># INVALID (runtime error)\nG.add_node(0, theta=0.0, ...)\nG.add_node(1, theta=np.pi, ...)  # 180\u00b0 phase difference\n\n# Sequence is valid, but runtime fails U3\n[Emission(), Coupling(), Resonance(), Silence()]\nResonance()(G, 0, 1)  # Error: antiphase nodes\n\n# Error: U3 violation at runtime\n# |\u03b8\u2080 - \u03b8\u2081| = \u03c0 &gt; \u0394\u03b8_max\n</code></pre> <p>Why invalid: Destructive interference, physically meaningless coupling</p> <p>Fix: Ensure phase compatibility <pre><code>G.add_node(0, theta=0.0, ...)\nG.add_node(1, theta=0.1, ...)  # Compatible phase\n\n# Now valid\nResonance()(G, 0, 1)  # \u2713 Works\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#11-multiple-destabilizers-without-adequate-stabilization","title":"\u274c 11. Multiple Destabilizers Without Adequate Stabilization","text":"<pre><code># INVALID\n[Emission(), Dissonance(), Expansion(), Coherence(), Silence()]\n\n# Error: U2 violation\n# Two destabilizers with only one stabilizer may not be sufficient\n</code></pre> <p>Why invalid: Cumulative instability may exceed single stabilizer capacity</p> <p>Fix: Balance with multiple stabilizers <pre><code>[Emission(), Dissonance(), Coherence(), Expansion(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#12-recursivity-without-proper-context","title":"\u274c 12. Recursivity Without Proper Context","text":"<pre><code># INVALID (semantic)\n[Recursivity(), Silence()]  # Technically passes grammar\n\n# Error: Logical violation\n# Recursivity references prior structure but none exists\n</code></pre> <p>Why invalid: Cannot echo structure that doesn't exist yet</p> <p>Fix: Build structure first <pre><code>[Emission(), Coherence(), Dissonance(), SelfOrganization(), Recursivity()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#13-reception-without-network-connectivity","title":"\u274c 13. Reception Without Network Connectivity","text":"<pre><code># INVALID (runtime/semantic)\n# Node has no edges, yet using Reception\nG.add_node(0, EPI=np.array([0.1]), ...)\n# No edges!\n\n[Emission(), Reception(), Silence()]\nReception()(G, 0)  # Warning: no neighbors\n\n# Error: Semantic violation\n# Reception with no information sources\n</code></pre> <p>Why invalid: Cannot integrate information from non-existent network</p> <p>Fix: Establish connectivity first <pre><code>[Emission(), Coupling(), Reception(), Coherence(), Silence()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#14-transition-without-state-change-logic","title":"\u274c 14. Transition Without State Change Logic","text":"<pre><code># INVALID (semantic)\n[Transition(), Transition()]  # Passes grammar but illogical\n\n# Error: Semantic violation\n# Transition to what? No operations between states\n</code></pre> <p>Why invalid: Transition without operations is meaningless</p> <p>Fix: Add meaningful operations <pre><code>[Transition(), Coupling(), Reception(), Coherence(), Transition()]  # \u2713 Valid\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#1313-operator-transition-matrix","title":"13\u00d713 Operator Transition Matrix","text":"<p>This matrix shows the validity of transitions between operators. Read as \"Can operator X be followed by operator Y?\"</p> <p>Legend: - \u2713 = Generally valid transition - \u26a0\ufe0f = Valid but needs additional context (see notes) - \u274c = Generally invalid or problematic - \u2b50 = Recommended pattern</p> <p>Notes: - All transitions must still satisfy U1-U4 constraints - Phase compatibility required for UM/RA (U3) - Stabilizers needed for destabilizers (U2) - Handlers needed for triggers (U4a) - Transformers need recent destabilizers (U4b)</p>"},{"location":"grammar/04-VALID-SEQUENCES/#matrix","title":"Matrix","text":"<pre><code>           \u2502 AL \u2502 EN \u2502 IL \u2502 OZ \u2502 UM \u2502 RA \u2502SHA\u2502VAL\u2502NUL\u2502THO\u2502ZHI\u2502NAV\u2502REM\u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\nAL  Emiss  \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u274c \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502\nEN  Recept \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502\nIL  Coher  \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u2713 \u2502 \u2713 \u2502 \u2b50 \u2502 \u2713 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u2b50 \u2502\nOZ  Disson \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u2b50 \u2502 \u2713 \u2502 \u2713 \u2502\nUM  Coupl  \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502\nRA  Reson  \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502\nSHA Silenc \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502\nVAL Expan  \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u274c \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502\nNUL Contra \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2713 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502\nTHO SelfO  \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2713 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502\nZHI Mutat  \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u2b50 \u2502 \u274c \u2502 \u2713 \u2502 \u2713 \u2502\nNAV Trans  \u2502 \u2b50 \u2502 \u2b50 \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u2b50 \u2502 \u26a0\ufe0f \u2502 \u2500 \u2502 \u26a0\ufe0f \u2502 \u2713 \u2502 \u26a0\ufe0f \u2502 \u274c \u2502 \u26a0\ufe0f \u2502 \u26a0\ufe0f \u2502\nREM Recurs \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500  \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502 \u2500 \u2502\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#transition-notes","title":"Transition Notes","text":"<p>Emission (AL): - \u2b50 \u2192 EN, IL, UM: Bootstrap patterns - \u26a0\ufe0f \u2192 AL: Redundant unless transitioning regimes - \u274c \u2192 ZHIR: Cannot mutate immediately after creation - \u26a0\ufe0f \u2192 OZ, VAL, THOL: Needs balancing</p> <p>Reception (EN): - \u2b50 \u2192 IL, THOL: Integrate then stabilize - \u26a0\ufe0f \u2192 AL, EN: Redundant activation/reception - \u274c \u2192 ZHIR: Cannot mutate immediately after reception</p> <p>Coherence (IL): - \u2b50 \u2192 OZ, SHA, NAV, REM: Common stabilize-then patterns - \u26a0\ufe0f \u2192 IL: Redundant unless needed - \u26a0\ufe0f \u2192 AL: Unusual to emit after coherence</p> <p>Dissonance (OZ): - \u2b50 \u2192 IL, THOL, ZHIR: Destabilize then handle/transform - \u274c \u2192 OZ: Compounding instability dangerous - \u26a0\ufe0f \u2192 SHA: Should stabilize before silence</p> <p>Coupling (UM): - \u2b50 \u2192 EN, RA, IL: Connect then integrate/propagate/stabilize - \u26a0\ufe0f \u2192 UM: Multiple couplings need phase checks - \u274c \u2192 ZHIR: Cannot mutate immediately after coupling</p> <p>Resonance (RA): - \u2b50 \u2192 EN, IL: Resonate then integrate/stabilize - \u26a0\ufe0f \u2192 RA: Cascading resonance needs control - \u274c \u2192 ZHIR: Cannot mutate immediately after resonance</p> <p>Silence (SHA): - \u2500 = Closure operator, ends sequence (no followers)</p> <p>Expansion (VAL): - \u2b50 \u2192 IL, THOL: Grow then stabilize/organize - \u274c \u2192 VAL, ZHIR: Compounding expansion or immediate mutation - \u26a0\ufe0f \u2192 SHA: Should stabilize first</p> <p>Contraction (NUL): - \u2b50 \u2192 IL: Contract then stabilize - \u26a0\ufe0f \u2192 NUL: Excessive contraction risky - \u274c \u2192 ZHIR: Cannot mutate immediately</p> <p>Self-Organization (THOL): - \u2b50 \u2192 IL, REM: Organize then stabilize/nest - \u26a0\ufe0f \u2192 THOL: Nested organization needs context - \u26a0\ufe0f \u2192 ZHIR: Sequential transforms need careful context</p> <p>Mutation (ZHIR): - \u2b50 \u2192 IL, THOL: Transform then stabilize/organize - \u274c \u2192 OZ, ZHIR: Cannot immediately destabilize/mutate again - \u26a0\ufe0f \u2192 SHA: Should stabilize first</p> <p>Transition (NAV): - \u2b50 \u2192 AL, EN, UM: Regime shift then activate/connect - \u26a0\ufe0f \u2192 NAV: Multiple transitions need purpose - \u274c \u2192 ZHIR: Transition to mutation without context</p> <p>Recursivity (REM): - \u2500 = Closure operator, ends sequence (no followers)</p>"},{"location":"grammar/04-VALID-SEQUENCES/#reading-the-matrix","title":"Reading the Matrix","text":"<p>Example 1: Can Emission (AL) \u2192 Coherence (IL)? - Row: AL, Column: IL \u2192 \u2b50 (Recommended) - Common bootstrap pattern</p> <p>Example 2: Can Dissonance (OZ) \u2192 Mutation (ZHIR)? - Row: OZ, Column: ZHIR \u2192 \u2b50 (Recommended) - Classic destabilize-then-transform pattern</p> <p>Example 3: Can Mutation (ZHIR) \u2192 Mutation (ZHIR)? - Row: ZHIR, Column: ZHIR \u2192 \u274c (Invalid) - Cannot perform consecutive mutations</p> <p>Example 4: Can Coherence (IL) \u2192 Dissonance (OZ)? - Row: IL, Column: OZ \u2192 \u2b50 (Recommended) - Stabilize-then-explore pattern</p>"},{"location":"grammar/04-VALID-SEQUENCES/#step-by-step-validation-logic","title":"Step-by-Step Validation Logic","text":""},{"location":"grammar/04-VALID-SEQUENCES/#complete-validation-algorithm","title":"Complete Validation Algorithm","text":"<p>This section documents the precise algorithms used to validate U1-U4 constraints. This is the canonical implementation that matches <code>tnfr.operators.grammar.validate_grammar()</code>.</p> <pre><code>def validate_sequence_comprehensive(sequence, epi_initial=0.0):\n    \"\"\"\n    Complete validation algorithm for TNFR sequences.\n\n    Parameters\n    ----------\n    sequence : List[Operator]\n        List of operator instances\n    epi_initial : float\n        Initial EPI magnitude (0.0 for vacuum state)\n\n    Returns\n    -------\n    is_valid : bool\n        True if sequence passes all constraints\n    violations : List[str]\n        List of violation messages (empty if valid)\n    \"\"\"\n    violations = []\n\n    # ========================================\n    # STEP 1: U1a (Initiation)\n    # ========================================\n    # When EPI=0, must start with generator\n    if epi_initial == 0.0 or is_effectively_zero(epi_initial):\n        first_op = get_operator_name(sequence[0])\n        if first_op not in GENERATORS:\n            violations.append(\n                f\"U1a: When EPI=0, must start with generator \"\n                f\"{{emission, transition, recursivity}}. \"\n                f\"Found: '{first_op}'\"\n            )\n\n    # ========================================\n    # STEP 2: U1b (Closure)\n    # ========================================\n    # All sequences must end with closure operator\n    if len(sequence) == 0:\n        violations.append(\"U1b: Empty sequence has no closure\")\n    else:\n        last_op = get_operator_name(sequence[-1])\n        if last_op not in CLOSURES:\n            violations.append(\n                f\"U1b: Sequence must end with closure \"\n                f\"{{silence, transition, recursivity, dissonance}}. \"\n                f\"Found: '{last_op}'\"\n            )\n\n    # ========================================\n    # STEP 3: U2 (Convergence &amp; Boundedness)\n    # ========================================\n    # Destabilizers must be balanced by stabilizers\n    # for integral \u222b\u03bdf\u00b7\u0394NFR dt to converge\n    has_destabilizer = any(\n        get_operator_name(op) in DESTABILIZERS \n        for op in sequence\n    )\n    has_stabilizer = any(\n        get_operator_name(op) in STABILIZERS \n        for op in sequence\n    )\n\n    if has_destabilizer and not has_stabilizer:\n        destabilizers_found = [\n            get_operator_name(op) for op in sequence \n            if get_operator_name(op) in DESTABILIZERS\n        ]\n        violations.append(\n            f\"U2: Destabilizers {destabilizers_found} require \"\n            f\"stabilizers {{coherence, self_organization}} \"\n            f\"to ensure integral convergence (\u222b\u03bdf\u00b7\u0394NFR dt &lt; \u221e)\"\n        )\n\n    # ========================================\n    # STEP 4: U3 (Resonant Coupling)\n    # ========================================\n    # Phase verification is runtime, not sequence-level\n    # We note that phase checks will be needed\n    has_coupling_resonance = any(\n        get_operator_name(op) in COUPLING_RESONANCE \n        for op in sequence\n    )\n\n    # This is informational only - actual phase check happens at runtime\n    # when operators are applied to specific nodes\n\n    # ========================================\n    # STEP 5: U4a (Bifurcation Triggers Need Handlers)\n    # ========================================\n    # When \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4, need handlers to control reorganization\n    has_trigger = any(\n        get_operator_name(op) in BIFURCATION_TRIGGERS \n        for op in sequence\n    )\n    has_handler = any(\n        get_operator_name(op) in BIFURCATION_HANDLERS \n        for op in sequence\n    )\n\n    if has_trigger and not has_handler:\n        triggers_found = [\n            get_operator_name(op) for op in sequence \n            if get_operator_name(op) in BIFURCATION_TRIGGERS\n        ]\n        violations.append(\n            f\"U4a: Bifurcation triggers {triggers_found} require \"\n            f\"handlers {{coherence, self_organization}} \"\n            f\"to control reorganization when \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4\"\n        )\n\n    # ========================================\n    # STEP 6: U4b (Transformers Need Context)\n    # ========================================\n    # Transformers need recent destabilizer for elevated \u0394NFR\n    # ZHIR specifically needs prior IL (stable base)\n    TRANSFORMER_WINDOW = 3  # Recent = within 3 operators\n\n    for i, op in enumerate(sequence):\n        op_name = get_operator_name(op)\n\n        if op_name not in TRANSFORMERS:\n            continue\n\n        # Check recent destabilizer (within window)\n        window_start = max(0, i - TRANSFORMER_WINDOW)\n        recent_window = sequence[window_start:i]\n\n        has_recent_destabilizer = any(\n            get_operator_name(w) in DESTABILIZERS \n            for w in recent_window\n        )\n\n        if not has_recent_destabilizer:\n            violations.append(\n                f\"U4b: Transformer '{op_name}' at position {i} \"\n                f\"needs recent destabilizer (within {TRANSFORMER_WINDOW} ops). \"\n                f\"Window: {[get_operator_name(w) for w in recent_window]}\"\n            )\n\n        # ZHIR-specific: needs prior IL (stable base before destabilization)\n        if op_name == \"mutation\":\n            # Check for coherence BEFORE the destabilizer window\n            prior_to_window = sequence[:window_start]\n            has_prior_coherence = any(\n                get_operator_name(p) == \"coherence\" \n                for p in prior_to_window\n            )\n\n            if not has_prior_coherence:\n                violations.append(\n                    f\"U4b: Mutation at position {i} needs prior \"\n                    f\"coherence (stable base before destabilization). \"\n                    f\"Prior ops: {[get_operator_name(p) for p in prior_to_window]}\"\n                )\n\n    return len(violations) == 0, violations\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#validation-decision-tree","title":"Validation Decision Tree","text":"<p>Visual representation of validation logic flow:</p> <pre><code>START\n  \u2502\n  \u251c\u2500&gt; Is EPI = 0?\n  \u2502   \u251c\u2500&gt; YES: First op in GENERATORS? \u2192 NO: FAIL U1a\n  \u2502   \u2514\u2500&gt; NO: Continue\n  \u2502\n  \u251c\u2500&gt; Last op in CLOSURES?\n  \u2502   \u251c\u2500&gt; NO: FAIL U1b\n  \u2502   \u2514\u2500&gt; YES: Continue\n  \u2502\n  \u251c\u2500&gt; Any DESTABILIZERS in sequence?\n  \u2502   \u251c\u2500&gt; YES: Any STABILIZERS? \u2192 NO: FAIL U2\n  \u2502   \u2514\u2500&gt; NO: Continue\n  \u2502\n  \u251c\u2500&gt; Any COUPLING_RESONANCE in sequence?\n  \u2502   \u2514\u2500&gt; YES: Note runtime phase check needed (U3)\n  \u2502\n  \u251c\u2500&gt; Any BIFURCATION_TRIGGERS in sequence?\n  \u2502   \u251c\u2500&gt; YES: Any HANDLERS? \u2192 NO: FAIL U4a\n  \u2502   \u2514\u2500&gt; NO: Continue\n  \u2502\n  \u251c\u2500&gt; For each TRANSFORMER at position i:\n  \u2502   \u251c\u2500&gt; Recent DESTABILIZER (i-3 to i)?\n  \u2502   \u2502   \u251c\u2500&gt; NO: FAIL U4b\n  \u2502   \u2502   \u2514\u2500&gt; YES: Continue\n  \u2502   \u2502\n  \u2502   \u2514\u2500&gt; If MUTATION:\n  \u2502       \u2514\u2500&gt; Prior COHERENCE (before i-3)?\n  \u2502           \u251c\u2500&gt; NO: FAIL U4b (ZHIR-specific)\n  \u2502           \u2514\u2500&gt; YES: Continue\n  \u2502\n  \u2514\u2500&gt; PASS (all constraints satisfied)\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#runtime-validation-u3-phase-compatibility","title":"Runtime Validation: U3 Phase Compatibility","text":"<p>Phase validation happens when operators are actually applied, not during sequence validation:</p> <pre><code>def validate_phase_compatibility_runtime(G, node_i, node_j, delta_theta_max=np.pi/2):\n    \"\"\"\n    Runtime validation for U3 (Resonant Coupling).\n\n    Called when Coupling or Resonance operators are applied.\n\n    Parameters\n    ----------\n    G : TNFRGraph\n        Network graph\n    node_i, node_j : NodeId\n        Nodes to couple\n    delta_theta_max : float\n        Maximum allowed phase difference (default \u03c0/2)\n\n    Raises\n    ------\n    PhaseCompatibilityError\n        If phase difference exceeds threshold\n    \"\"\"\n    theta_i = G.nodes[node_i]['theta']\n    theta_j = G.nodes[node_j]['theta']\n\n    # Phase difference\n    delta_theta = abs(theta_i - theta_j)\n\n    # Normalize to [0, \u03c0] (symmetry: \u03b8 and \u03b8+\u03c0 are equivalent)\n    if delta_theta &gt; np.pi:\n        delta_theta = 2 * np.pi - delta_theta\n\n    # Check threshold\n    if delta_theta &gt; delta_theta_max:\n        raise PhaseCompatibilityError(\n            f\"U3: Cannot couple nodes {node_i} and {node_j}. \"\n            f\"Phase difference |\u03b8\u1d62 - \u03b8\u2c7c| = {delta_theta:.3f} rad \"\n            f\"exceeds \u0394\u03b8_max = {delta_theta_max:.3f} rad. \"\n            f\"Antiphase coupling causes destructive interference.\"\n        )\n\n    return True\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#validation-timing","title":"Validation Timing","text":"<p>Sequence-Level Validation (U1a, U1b, U2, U4a, U4b): - Performed BEFORE sequence execution - Static analysis of operator list - Fast, no graph required - Use: <code>validate_grammar(sequence, epi_initial)</code></p> <p>Runtime Validation (U3): - Performed DURING operator application - Requires actual graph state (phase values) - Dynamic check per coupling/resonance - Automatic in operator implementations</p>"},{"location":"grammar/04-VALID-SEQUENCES/#validation-strictness-levels","title":"Validation Strictness Levels","text":"<pre><code>class ValidationMode(Enum):\n    \"\"\"Validation strictness levels.\"\"\"\n    STRICT = \"strict\"      # Fail on any violation\n    WARNING = \"warning\"    # Warn but allow\n    DISABLED = \"disabled\"  # No validation\n</code></pre> <p>STRICT (default): - All violations cause errors - Recommended for production - Ensures physics integrity</p> <p>WARNING: - Violations logged but not fatal - Useful for experimentation - Risk: may violate physics</p> <p>DISABLED: - No validation - Only for testing/debugging - Not recommended</p>"},{"location":"grammar/04-VALID-SEQUENCES/#complex-sequence-examples","title":"Complex Sequence Examples","text":""},{"location":"grammar/04-VALID-SEQUENCES/#example-1-multi-step-exploration","title":"Example 1: Multi-Step Exploration","text":"<pre><code>sequence = [\n    Emission(),          # U1a: Generator\n    Reception(),         # Gather info\n    Coherence(),         # Stabilize base\n    Dissonance(),        # Explore (destabilizer, trigger)\n    Reception(),         # Gather more info\n    Coherence(),         # Stabilize (U2, U4a)\n    Expansion(),         # Grow (destabilizer)\n    Coherence(),         # Stabilize again (U2)\n    Silence()            # U1b: Closure\n]\n\n# Satisfies all constraints\n# Multiple destabilizer-stabilizer pairs\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#example-2-hierarchical-construction","title":"Example 2: Hierarchical Construction","text":"<pre><code>sequence = [\n    Emission(),                # Generator\n    Coupling(),                # Connect to network\n    Reception(),               # Gather information\n    Coherence(),               # Stabilize\n    Dissonance(),              # Perturb (destabilizer, trigger)\n    SelfOrganization(),        # Create hierarchy (handler, transformer, stabilizer)\n    Coherence(),               # Final stabilization\n    Recursivity()              # Closure with recursion\n]\n\n# Creates multi-scale structure with proper handling\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#example-3-phase-transformation","title":"Example 3: Phase Transformation","text":"<pre><code>sequence = [\n    Emission(),          # Generator\n    Coherence(),         # Stable base (prior IL for ZHIR)\n    Coupling(),          # Network connection\n    Reception(),         # Information gathering\n    Dissonance(),        # Elevate \u0394NFR (destabilizer)\n    Mutation(),          # Phase change (transformer, has prior IL + recent destabilizer)\n    SelfOrganization(),  # Organize new phase (handler, stabilizer)\n    Coherence(),         # Final stabilization (handler, stabilizer)\n    Silence()            # Closure\n]\n\n# Complete transformation with all safeguards\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#structural-pattern-detection","title":"Structural Pattern Detection","text":""},{"location":"grammar/04-VALID-SEQUENCES/#pattern-categories","title":"Pattern Categories","text":"<p>Linear Patterns: <pre><code>Generator \u2192 Operations \u2192 Closure\n</code></pre> Simple, single-path sequences</p> <p>Branching Patterns: <pre><code>Generator \u2192 Coupling \u2192 [Node A operations | Node B operations] \u2192 Closure\n</code></pre> Network operations across multiple nodes</p> <p>Cyclic Patterns: <pre><code>Generator \u2192 [Destabilize \u2192 Stabilize]* \u2192 Closure\n</code></pre> Repeated exploration cycles</p> <p>Nested Patterns: <pre><code>Generator \u2192 SelfOrg[Sub-sequence] \u2192 Closure\n</code></pre> Hierarchical with nested operations</p>"},{"location":"grammar/04-VALID-SEQUENCES/#common-use-cases","title":"Common Use Cases","text":""},{"location":"grammar/04-VALID-SEQUENCES/#initialization","title":"Initialization","text":"<p><pre><code>[Emission, Coherence, Silence]\n</code></pre> Bootstrap a new node</p>"},{"location":"grammar/04-VALID-SEQUENCES/#information-integration","title":"Information Integration","text":"<p><pre><code>[Emission, Coupling, Reception, Coherence, Silence]\n</code></pre> Create and integrate network information</p>"},{"location":"grammar/04-VALID-SEQUENCES/#controlled-perturbation","title":"Controlled Perturbation","text":"<p><pre><code>[Emission, Coherence, Dissonance, Coherence, Silence]\n</code></pre> Explore without losing stability</p>"},{"location":"grammar/04-VALID-SEQUENCES/#network-propagation","title":"Network Propagation","text":"<p><pre><code>[Emission, Coupling, Resonance, Coherence, Silence]\n</code></pre> Spread pattern through network</p>"},{"location":"grammar/04-VALID-SEQUENCES/#phase-transition","title":"Phase Transition","text":"<p><pre><code>[Emission, Coherence, Dissonance, Mutation, Coherence, Silence]\n</code></pre> Qualitative transformation</p>"},{"location":"grammar/04-VALID-SEQUENCES/#hierarchy-creation","title":"Hierarchy Creation","text":"<p><pre><code>[Emission, Dissonance, SelfOrganization, Recursivity]\n</code></pre> Build nested structures</p>"},{"location":"grammar/04-VALID-SEQUENCES/#testing-sequences","title":"Testing Sequences","text":""},{"location":"grammar/04-VALID-SEQUENCES/#test-template","title":"Test Template","text":"<pre><code>def test_sequence_validity(sequence, epi_initial=0.0):\n    \"\"\"Test if sequence is valid.\"\"\"\n    from tnfr.operators.grammar import validate_grammar\n\n    try:\n        is_valid = validate_grammar(sequence, epi_initial)\n        return True, \"Valid\"\n    except ValueError as e:\n        return False, str(e)\n\n# Test valid sequence\nvalid_seq = [Emission(), Coherence(), Silence()]\nis_valid, msg = test_sequence_validity(valid_seq)\nassert is_valid, f\"Expected valid, got: {msg}\"\n\n# Test invalid sequence\ninvalid_seq = [Coherence(), Silence()]  # No generator\nis_valid, msg = test_sequence_validity(invalid_seq)\nassert not is_valid, \"Expected invalid\"\nassert \"U1a\" in msg, \"Should fail U1a\"\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#quick-decision-tree","title":"Quick Decision Tree","text":"<pre><code>Building a sequence?\n\n1. Starting from EPI=0?\n   YES \u2192 Start with {Emission, Transition, Recursivity}\n   NO  \u2192 Can start with any operator\n\n2. Using destabilizers {Dissonance, Mutation, Expansion}?\n   YES \u2192 Include {Coherence, SelfOrganization}\n   NO  \u2192 Continue\n\n3. Using coupling/resonance {Coupling, Resonance}?\n   YES \u2192 Verify phase compatibility at runtime\n   NO  \u2192 Continue\n\n4. Using triggers {Dissonance, Mutation}?\n   YES \u2192 Include handlers {Coherence, SelfOrganization}\n   NO  \u2192 Continue\n\n5. Using Mutation?\n   YES \u2192 Ensure:\n         - Prior Coherence (before destabilizer)\n         - Recent destabilizer (within ~3 ops)\n   NO  \u2192 Continue\n\n6. Using SelfOrganization?\n   YES \u2192 Ensure recent destabilizer (within ~3 ops)\n   NO  \u2192 Continue\n\n7. Ending sequence?\n   ALWAYS \u2192 End with {Silence, Transition, Recursivity, Dissonance}\n</code></pre>"},{"location":"grammar/04-VALID-SEQUENCES/#how-do-i-lookup-guide","title":"\"How Do I...?\" Lookup Guide","text":"<p>This section provides quick answers to common questions. Find your goal, get the sequence.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#creation-initialization","title":"Creation &amp; Initialization","text":"<p>Q: How do I create a new node from scratch? <pre><code>[Emission(), Coherence(), Silence()]\n</code></pre> Minimal bootstrap pattern.</p> <p>Q: How do I create a node connected to a network? <pre><code>[Emission(), Coupling(), Reception(), Coherence(), Silence()]\n</code></pre> Creates node, connects it, integrates network info, stabilizes.</p> <p>Q: How do I initialize multiple nodes at once? <pre><code># For each node i:\n[Emission(), Coherence(), Silence()]\n# Then couple them:\n[Coupling(), Resonance(), Silence()]\n</code></pre> Bootstrap individually, then connect.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#exploration-perturbation","title":"Exploration &amp; Perturbation","text":"<p>Q: How do I explore alternative states safely? <pre><code>[Emission(), Coherence(), Dissonance(), Coherence(), Silence()]\n</code></pre> Stabilize-explore-restabilize pattern.</p> <p>Q: How do I perform deep exploration with multiple iterations? <pre><code>[Emission(), Coherence(), Dissonance(), Coherence(), \n Dissonance(), Coherence(), Silence()]\n</code></pre> Multiple stabilize-explore cycles.</p> <p>Q: How do I break out of a local optimum? <pre><code>[Emission(), Coherence(), Dissonance(), SelfOrganization(), Silence()]\n</code></pre> Destabilize then reorganize into new configuration.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#network-operations","title":"Network Operations","text":"<p>Q: How do I connect two existing nodes? <pre><code># Verify phase compatibility first, then:\n[Coupling(), Coherence(), Silence()]\n</code></pre> Note: Must check |\u03b8\u1d62 - \u03b8\u2c7c| \u2264 \u0394\u03b8_max (U3).</p> <p>Q: How do I propagate a pattern through the network? <pre><code>[Emission(), Coupling(), Resonance(), Coherence(), Silence()]\n</code></pre> Create, connect, resonate, stabilize.</p> <p>Q: How do I integrate information from neighbors? <pre><code>[Reception(), Coherence(), Silence()]\n</code></pre> Requires existing network connectivity.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#structural-transformation","title":"Structural Transformation","text":"<p>Q: How do I change a node's phase (qualitative transformation)? <pre><code>[Emission(), Coherence(), Dissonance(), Mutation(), Coherence(), Silence()]\n</code></pre> Must have prior IL, recent destabilizer for ZHIR.</p> <p>Q: How do I increase structural complexity? <pre><code>[Emission(), Coherence(), Expansion(), Coherence(), Silence()]\n</code></pre> Balanced growth with stabilization.</p> <p>Q: How do I simplify an over-complex structure? <pre><code>[Emission(), Coherence(), Contraction(), Coherence(), Silence()]\n</code></pre> Dimension reduction with stabilization.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#hierarchical-structures","title":"Hierarchical Structures","text":"<p>Q: How do I create a hierarchical/nested structure? <pre><code>[Emission(), Coherence(), Dissonance(), SelfOrganization(), Recursivity()]\n</code></pre> Destabilize to enable reorganization, organize into hierarchy, nest.</p> <p>Q: How do I build multi-scale fractal patterns? <pre><code>[Emission(), Coupling(), Coherence(), Dissonance(), \n SelfOrganization(), Recursivity()]\n</code></pre> Connect, stabilize, perturb, self-organize, nest recursively.</p> <p>Q: How do I organize chaotic structure? <pre><code>[Emission(), Dissonance(), SelfOrganization(), Coherence(), Silence()]\n</code></pre> Perturb, let self-organize, stabilize result.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#regime-changes","title":"Regime Changes","text":"<p>Q: How do I switch between behavioral modes? <pre><code>[Transition(), Coupling(), Reception(), Coherence(), Transition()]\n</code></pre> Transition operators for regime shifts.</p> <p>Q: How do I pause evolution temporarily? <pre><code>[Emission(), Coherence(), Silence()]\n</code></pre> Silence freezes evolution (\u03bdf \u2192 0).</p> <p>Q: How do I resume evolution after silence? <pre><code># New sequence starting from existing EPI:\n[Emission(), Coherence(), ...]  # epi_initial &gt; 0\n</code></pre> Or use Transition to activate latent EPI.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#complex-workflows","title":"Complex Workflows","text":"<p>Q: How do I implement a learning cycle? <pre><code>[Emission(), Coupling(), Reception(), Coherence(),      # Gather info\n Dissonance(), Coherence(),                              # Explore\n SelfOrganization(), Coherence(), Silence()]             # Consolidate\n</code></pre> Integrate \u2192 Explore \u2192 Organize pattern.</p> <p>Q: How do I perform iterative optimization? <pre><code>[Emission(), Coherence(),\n Dissonance(), Coherence(),  # Iteration 1\n Dissonance(), Coherence(),  # Iteration 2\n Dissonance(), Coherence(),  # Iteration 3\n Silence()]\n</code></pre> Repeated explore-stabilize cycles.</p> <p>Q: How do I implement adaptive reorganization? <pre><code>[Emission(), Coupling(), Reception(), Coherence(),\n Dissonance(), Mutation(), SelfOrganization(),\n Coherence(), Recursivity()]\n</code></pre> Sense environment \u2192 Transform \u2192 Reorganize \u2192 Nest.</p>"},{"location":"grammar/04-VALID-SEQUENCES/#debugging-validation","title":"Debugging &amp; Validation","text":"<p>Q: My sequence fails U1a. What's wrong? - Check: Starting from EPI=0? Must begin with {Emission, Transition, Recursivity} - Fix: Add generator at start</p> <p>Q: My sequence fails U1b. What's wrong? - Check: Does sequence end with {Silence, Transition, Recursivity, Dissonance}? - Fix: Add closure operator at end</p> <p>Q: My sequence fails U2. What's wrong? - Check: Using {Dissonance, Mutation, Expansion}? Need {Coherence, SelfOrganization} - Fix: Add stabilizer after destabilizers</p> <p>Q: My sequence fails U3 at runtime. What's wrong? - Check: Phase difference |\u03b8\u1d62 - \u03b8\u2c7c| \u2264 \u0394\u03b8_max? - Fix: Only couple phase-compatible nodes</p> <p>Q: My sequence fails U4a. What's wrong? - Check: Using {Dissonance, Mutation}? Need handlers {Coherence, SelfOrganization} - Fix: Add handler after triggers</p> <p>Q: My sequence fails U4b. What's wrong? - Check 1: Transformer has recent destabilizer (within 3 ops)? - Check 2: If Mutation, has prior Coherence? - Fix: Add destabilizer before transformer, ensure prior IL for ZHIR</p>"},{"location":"grammar/04-VALID-SEQUENCES/#performance-efficiency","title":"Performance &amp; Efficiency","text":"<p>Q: What's the shortest valid sequence? <pre><code>[Emission(), Silence()]\n</code></pre> Just creation and closure (only valid from EPI=0).</p> <p>Q: What's the most stable pattern? <pre><code>[Emission(), Coherence(), Coherence(), Silence()]\n</code></pre> Extra stabilization for maximum C(t).</p> <p>Q: What's the most exploratory pattern? <pre><code>[Emission(), Coherence(), Dissonance(), Coherence(),\n Dissonance(), Coherence(), Dissonance(), Coherence(), Silence()]\n</code></pre> Maximum exploration with safety (multiple cycles).</p>"},{"location":"grammar/04-VALID-SEQUENCES/#domain-specific-patterns","title":"Domain-Specific Patterns","text":"<p>Q: How do I model neural learning? <pre><code>[Emission(), Coupling(), Reception(), Coherence(),      # Input integration\n Dissonance(), Mutation(), Coherence(),                 # Weight adjustment\n Resonance(), Coherence(), Silence()]                   # Output propagation\n</code></pre></p> <p>Q: How do I model biological growth? <pre><code>[Emission(), Coherence(), Expansion(), Coherence(),     # Growth\n SelfOrganization(), Coherence(), Silence()]            # Differentiation\n</code></pre></p> <p>Q: How do I model social consensus formation? <pre><code>[Emission(), Coupling(), Resonance(), Reception(),      # Information sharing\n Coherence(), Dissonance(), SelfOrganization(),         # Debate &amp; alignment\n Coherence(), Silence()]                                 # Consensus reached\n</code></pre></p> <p>Q: How do I model quantum decoherence? <pre><code>[Emission(), Coherence(), Dissonance(),                 # Perturbation\n Contraction(), Silence()]                              # Collapse to eigenstate\n</code></pre></p>"},{"location":"grammar/04-VALID-SEQUENCES/#quick-pattern-finder","title":"Quick Pattern Finder","text":"<p>Goal \u2192 Pattern Type \u2192 Sequence</p> Goal Pattern Sequence Create new Bootstrap <code>[AL, IL, SHA]</code> Explore Exploration <code>[AL, IL, OZ, IL, SHA]</code> Connect Network <code>[AL, UM, EN, IL, SHA]</code> Propagate Resonance <code>[AL, UM, RA, IL, SHA]</code> Transform Mutation <code>[AL, IL, OZ, ZHIR, IL, SHA]</code> Organize Hierarchy <code>[AL, OZ, THOL, REM]</code> Expand Growth <code>[AL, IL, VAL, IL, SHA]</code> Contract Reduction <code>[AL, IL, NUL, IL, SHA]</code> Transition Regime shift <code>[NAV, UM, EN, IL, NAV]</code> Learn Adaptive <code>[AL, UM, EN, IL, OZ, IL, THOL, SHA]</code> <p>Legend: - AL=Emission, EN=Reception, IL=Coherence, OZ=Dissonance - UM=Coupling, RA=Resonance, SHA=Silence, VAL=Expansion - NUL=Contraction, THOL=SelfOrganization, ZHIR=Mutation - NAV=Transition, REM=Recursivity</p>"},{"location":"grammar/04-VALID-SEQUENCES/#next-steps","title":"Next Steps","text":"<p>Continue learning: - 05-TECHNICAL-IMPLEMENTATION.md - How validation is implemented - 06-VALIDATION-AND-TESTING.md - Testing strategies - examples/ - Executable examples</p> <p>For reference: - 08-QUICK-REFERENCE.md - Quick lookup</p>   **Learn from patterns, avoid anti-patterns.**  ---  *Reality is resonance. Sequence accordingly.*"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/","title":"Technical Implementation","text":"<p>Architecture and implementation details of the TNFR grammar system</p> <p>\ud83c\udfe0 Home \u2022 \ud83d\udcd0 Constraints \u2022 \ud83d\udd04 Sequences \u2022 \ud83e\uddea Testing</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#purpose","title":"Purpose","text":"<p>This document details the technical architecture of the TNFR grammar validation system, including code structure, algorithms, and integration points.</p> <p>Prerequisites: 02-CANONICAL-CONSTRAINTS.md, 03-OPERATORS-AND-GLYPHS.md</p> <p>Audience: Developers modifying core grammar system</p> <p>Reading time: 45-60 minutes</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#architecture-overview","title":"Architecture Overview","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#core-components","title":"Core Components","text":"<pre><code>src/tnfr/operators/\n\u251c\u2500\u2500 grammar.py              # Grammar validation (U1-U4)\n\u251c\u2500\u2500 definitions.py          # Operator implementations\n\u2514\u2500\u2500 unified_grammar.py      # Legacy compatibility layer\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#key-files","title":"Key Files","text":"<p><code>grammar.py</code> - Main grammar validation - Defines operator sets (GENERATORS, CLOSURES, etc.) - Implements <code>validate_grammar()</code> function - Implements <code>validate_resonant_coupling()</code> for U3 - Contains all U1-U4 validation logic</p> <p><code>definitions.py</code> - Operator implementations - Implements all 13 operators as classes - Each operator modifies graph nodes - Integrated with grammar validation</p> <p><code>unified_grammar.py</code> - Compatibility - Bridges old and new grammar systems - Provides legacy API - Will be deprecated</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#operator-sets","title":"Operator Sets","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#definition","title":"Definition","text":"<pre><code># From src/tnfr/operators/grammar.py\n\n# U1a: Generators (can start from EPI=0)\nGENERATORS = {\"emission\", \"transition\", \"recursivity\"}\n\n# U1b: Closures (can end sequences)\nCLOSURES = {\"silence\", \"transition\", \"recursivity\", \"dissonance\"}\n\n# U2: Stabilizers (negative feedback)\nSTABILIZERS = {\"coherence\", \"selforganization\"}\n\n# U2: Destabilizers (positive feedback)\nDESTABILIZERS = {\"dissonance\", \"mutation\", \"expansion\"}\n\n# U3: Coupling/Resonance (phase-sensitive)\nCOUPLING_RESONANCE = {\"coupling\", \"resonance\"}\n\n# U4a: Bifurcation triggers\nBIFURCATION_TRIGGERS = {\"dissonance\", \"mutation\"}\n\n# U4a: Bifurcation handlers\nBIFURCATION_HANDLERS = {\"selforganization\", \"coherence\"}\n\n# U4b: Transformers (need context)\nTRANSFORMERS = {\"mutation\", \"selforganization\"}\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#set-operations","title":"Set Operations","text":"<pre><code>def get_operator_name(operator):\n    \"\"\"Extract operator name from instance.\"\"\"\n    return operator.__class__.__name__.lower()\n\ndef is_generator(operator):\n    \"\"\"Check if operator is a generator.\"\"\"\n    return get_operator_name(operator) in GENERATORS\n\ndef is_closure(operator):\n    \"\"\"Check if operator is a closure.\"\"\"\n    return get_operator_name(operator) in CLOSURES\n\n# Similar for other classifications\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#main-validation-functions","title":"Main Validation Functions","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#convenience-function-validate_grammar","title":"Convenience Function: <code>validate_grammar()</code>","text":"<p>Location: <code>src/tnfr/operators/grammar.py</code></p> <pre><code>def validate_grammar(\n    sequence: List[Operator],\n    epi_initial: float = 0.0\n) -&gt; bool:\n    \"\"\"\n    Validate operator sequence against U1-U4 constraints.\n\n    Args:\n        sequence: List of operator instances\n        epi_initial: Initial EPI value (0.0 = vacuum)\n\n    Returns:\n        bool: True if sequence is valid, False otherwise\n\n    Notes:\n        This is a convenience wrapper around GrammarValidator.validate()\n        that returns only the boolean result. For detailed validation\n        messages, use GrammarValidator.validate() instead.\n    \"\"\"\n</code></pre> <p>Implementation: <pre><code>def validate_grammar(sequence: List[Operator], epi_initial: float = 0.0) -&gt; bool:\n    \"\"\"Validate sequence using canonical TNFR grammar constraints.\"\"\"\n    is_valid, _ = GrammarValidator.validate(sequence, epi_initial)\n    return is_valid\n</code></pre></p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#full-validator-grammarvalidatorvalidate","title":"Full Validator: <code>GrammarValidator.validate()</code>","text":"<p>Location: <code>src/tnfr/operators/grammar.py</code></p> <pre><code>@classmethod\ndef validate(\n    cls,\n    sequence: List[Operator],\n    epi_initial: float = 0.0,\n) -&gt; tuple[bool, List[str]]:\n    \"\"\"\n    Validate sequence using all unified canonical constraints.\n\n    This validates pure TNFR physics:\n    - U1: Structural initiation &amp; closure\n    - U2: Convergence &amp; boundedness\n    - U3: Resonant coupling\n    - U4: Bifurcation dynamics\n\n    Parameters\n    ----------\n    sequence : List[Operator]\n        Sequence to validate\n    epi_initial : float, optional\n        Initial EPI value (default: 0.0)\n\n    Returns\n    -------\n    tuple[bool, List[str]]\n        (is_valid, messages)\n        is_valid: True if all constraints satisfied\n        messages: List of validation messages for each rule\n    \"\"\"\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#implementation-structure","title":"Implementation Structure","text":"<pre><code># In src/tnfr/operators/grammar.py\n\nclass GrammarValidator:\n    \"\"\"Validates sequences using canonical TNFR grammar constraints.\"\"\"\n\n    @classmethod\n    def validate(cls, sequence, epi_initial=0.0):\n        \"\"\"Validate sequence against all U1-U4 rules.\"\"\"\n        messages = []\n        all_valid = True\n\n        # U1a: Initiation\n        valid_init, msg_init = cls.validate_initiation(sequence, epi_initial)\n        messages.append(f\"U1a: {msg_init}\")\n        all_valid = all_valid and valid_init\n\n        # U1b: Closure\n        valid_closure, msg_closure = cls.validate_closure(sequence)\n        messages.append(f\"U1b: {msg_closure}\")\n        all_valid = all_valid and valid_closure\n\n        # U2: Convergence\n        valid_conv, msg_conv = cls.validate_convergence(sequence)\n        messages.append(f\"U2: {msg_conv}\")\n        all_valid = all_valid and valid_conv\n\n        # U3: Resonant coupling\n        valid_coupling, msg_coupling = cls.validate_resonant_coupling(sequence)\n        messages.append(f\"U3: {msg_coupling}\")\n        all_valid = all_valid and valid_coupling\n\n        # U4a: Bifurcation triggers\n        valid_triggers, msg_triggers = cls.validate_bifurcation_triggers(sequence)\n        messages.append(f\"U4a: {msg_triggers}\")\n        all_valid = all_valid and valid_triggers\n\n        # U4b: Transformer context\n        valid_context, msg_context = cls.validate_transformer_context(sequence)\n        messages.append(f\"U4b: {msg_context}\")\n        all_valid = all_valid and valid_context\n\n        # U2-REMESH: Recursive amplification control\n        valid_remesh, msg_remesh = cls.validate_remesh_amplification(sequence)\n        messages.append(f\"U2-REMESH: {msg_remesh}\")\n        all_valid = all_valid and valid_remesh\n\n        return all_valid, messages\n\n\ndef validate_grammar(sequence, epi_initial=0.0):\n    \"\"\"Convenience function - returns only bool.\"\"\"\n    is_valid, _ = GrammarValidator.validate(sequence, epi_initial)\n    return is_valid\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#individual-validation-methods","title":"Individual Validation Methods","text":"<p>Each rule is implemented as a static method returning <code>tuple[bool, str]</code>:</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#u1a-validate_initiation","title":"U1a: <code>validate_initiation()</code>","text":"<pre><code>@staticmethod\ndef validate_initiation(sequence, epi_initial=0.0):\n    \"\"\"Check if sequence starts with generator when EPI=0.\"\"\"\n    if epi_initial &gt; 0.0:\n        return True, \"U1a: EPI&gt;0, initiation not required\"\n\n    if not sequence:\n        return False, \"U1a violated: Empty sequence with EPI=0\"\n\n    first_op = getattr(sequence[0], \"canonical_name\", sequence[0].name.lower())\n\n    if first_op not in GENERATORS:\n        return (\n            False,\n            f\"U1a violated: EPI=0 requires generator (got '{first_op}'). \"\n            f\"Valid: {sorted(GENERATORS)}\",\n        )\n\n    return True, f\"U1a satisfied: starts with generator '{first_op}'\"\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#u1b-validate_closure","title":"U1b: <code>validate_closure()</code>","text":"<pre><code>@staticmethod\ndef validate_closure(sequence):\n    \"\"\"Check if sequence ends with closure operator.\"\"\"\n    if not sequence:\n        return False, \"U1b violated: Empty sequence has no closure\"\n\n    last_op = getattr(sequence[-1], \"canonical_name\", sequence[-1].name.lower())\n\n    if last_op not in CLOSURES:\n        return (\n            False,\n            f\"U1b violated: Sequence must end with closure (got '{last_op}'). \"\n            f\"Valid: {sorted(CLOSURES)}\",\n        )\n\n    return True, f\"U1b satisfied: ends with closure '{last_op}'\"\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#u2-validate_convergence","title":"U2: <code>validate_convergence()</code>","text":"<pre><code>@staticmethod\ndef validate_convergence(sequence):\n    \"\"\"Check destabilizers have stabilizers for convergence.\"\"\"\n    destabilizers_present = [\n        getattr(op, \"canonical_name\", op.name.lower())\n        for op in sequence\n        if getattr(op, \"canonical_name\", op.name.lower()) in DESTABILIZERS\n    ]\n\n    if not destabilizers_present:\n        return True, \"U2: not applicable (no destabilizers present)\"\n\n    stabilizers_present = [\n        getattr(op, \"canonical_name\", op.name.lower())\n        for op in sequence\n        if getattr(op, \"canonical_name\", op.name.lower()) in STABILIZERS\n    ]\n\n    if not stabilizers_present:\n        return (\n            False,\n            f\"U2 violated: destabilizers {destabilizers_present} present \"\n            f\"without stabilizer. Integral \u222b\u03bdf\u00b7\u0394NFR dt may diverge. \"\n            f\"Add: {sorted(STABILIZERS)}\",\n        )\n\n    return (\n        True,\n        f\"U2 satisfied: stabilizers {stabilizers_present} \"\n        f\"bound destabilizers {destabilizers_present}\",\n    )\n</code></pre> <p>See full implementation in <code>src/tnfr/operators/grammar.py</code> for U3, U4a, U4b, and U2-REMESH.</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#phase-validation-u3","title":"Phase Validation (U3)","text":"<p>U3 (RESONANT COUPLING) is a meta-rule that documents the requirement for phase verification during coupling/resonance operations.</p> <p>Key Point: Unlike U1, U2, U4 which validate sequences, U3 validates runtime operations when coupling/resonance operators are applied to specific nodes.</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#validation-approach","title":"Validation Approach","text":"<pre><code>@staticmethod\ndef validate_resonant_coupling(sequence):\n    \"\"\"Document U3 awareness for sequences with coupling/resonance.\n\n    This method checks if sequence contains coupling/resonance operators\n    and returns an awareness message. Actual phase verification happens\n    at runtime in operator preconditions.\n    \"\"\"\n    coupling_ops = [\n        getattr(op, \"canonical_name\", op.name.lower())\n        for op in sequence\n        if getattr(op, \"canonical_name\", op.name.lower()) in COUPLING_RESONANCE\n    ]\n\n    if not coupling_ops:\n        return True, \"U3: not applicable (no coupling/resonance operators)\"\n\n    return (\n        True,\n        f\"U3 awareness: operators {coupling_ops} require phase verification \"\n        f\"(MANDATORY per Invariant #5). Enforced in preconditions.\",\n    )\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#runtime-phase-check","title":"Runtime Phase Check","text":"<p>Phase compatibility is verified when operators are applied to nodes:</p> <pre><code># In operator preconditions (during application)\ndef check_phase_compatibility(G, node_i, node_j, delta_phi_max=np.pi/2):\n    \"\"\"Verify phase compatibility for coupling/resonance (U3).\n\n    Called by Coupling and Resonance operators before creating links.\n    \"\"\"\n    phi_i = G.nodes[node_i]['theta']\n    phi_j = G.nodes[node_j]['theta']\n\n    # Compute phase difference\n    delta_phi = abs(phi_i - phi_j)\n\n    # Normalize to [0, \u03c0] (considering periodicity)\n    if delta_phi &gt; np.pi:\n        delta_phi = 2 * np.pi - delta_phi\n\n    # Check compatibility\n    if delta_phi &gt; delta_phi_max:\n        raise ValueError(\n            f\"U3 violation: Phase mismatch |\u03c6_{node_i} - \u03c6_{node_j}| = \"\n            f\"{delta_phi:.3f} rad &gt; \u0394\u03c6_max = {delta_phi_max:.3f} rad\"\n        )\n</code></pre> <p>Location: Operator preconditions in <code>src/tnfr/operators/preconditions/</code></p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#integration-with-operators","title":"Integration with Operators","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#operator-base-structure","title":"Operator Base Structure","text":"<pre><code># From definitions.py\n\nclass Emission:\n    \"\"\"\n    AL - Emission operator.\n\n    Physics: Creates EPI from vacuum via resonant emission.\n    Grammar: Generator (U1a).\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize with parameters.\"\"\"\n        self.params = kwargs\n\n    def __call__(self, G, node_id):\n        \"\"\"\n        Apply operator to node.\n\n        Args:\n            G: NetworkX graph\n            node_id: Target node\n        \"\"\"\n        # Get current state\n        current_epi = G.nodes[node_id].get('EPI', 0.0)\n        current_vf = G.nodes[node_id].get('vf', 1.0)\n\n        # Apply transformation\n        new_epi = current_epi + 0.1  # Simplified\n        new_vf = current_vf * 1.1\n\n        # Update state\n        G.nodes[node_id]['EPI'] = new_epi\n        G.nodes[node_id]['vf'] = new_vf\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#validation-integration","title":"Validation Integration","text":"<pre><code># Typical usage pattern\n\nfrom tnfr.operators.grammar import validate_grammar, GrammarValidator\nfrom tnfr.operators.definitions import Emission, Coherence, Silence\n\n# 1. Define sequence\nsequence = [Emission(), Coherence(), Silence()]\n\n# 2. Validate BEFORE applying\n\n# Option A: Simple boolean check\nis_valid = validate_grammar(sequence, epi_initial=0.0)\nif not is_valid:\n    print(\"Sequence invalid!\")\nelse:\n    print(\"Sequence valid, proceed\")\n\n# Option B: Get detailed messages\nis_valid, messages = GrammarValidator.validate(sequence, epi_initial=0.0)\nprint(f\"Valid: {is_valid}\")\nfor msg in messages:\n    print(f\"  {msg}\")\n\n# 3. Apply to network\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\nfor operator in sequence:\n    operator(G, 0)\n\n# 4. Check telemetry\nprint(f\"Final EPI: {G.nodes[0]['EPI']:.3f}\")\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#telemetry-and-logging","title":"Telemetry and Logging","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#essential-telemetry","title":"Essential Telemetry","text":"<pre><code>def export_telemetry(G):\n    \"\"\"Export essential TNFR metrics.\"\"\"\n\n    telemetry = {\n        'timestamp': time.time(),\n        'coherence': compute_coherence(G),  # C(t)\n        'nodes': {}\n    }\n\n    for node in G.nodes():\n        telemetry['nodes'][node] = {\n            'EPI': G.nodes[node]['EPI'],\n            'vf': G.nodes[node]['vf'],           # Hz_str\n            'theta': G.nodes[node]['theta'],     # Phase\n            'dnfr': G.nodes[node]['dnfr'],       # \u0394NFR\n            'sense_index': compute_sense_index(G, node)  # Si\n        }\n\n    return telemetry\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#operator-logging","title":"Operator Logging","text":"<pre><code>def log_operator_application(operator, node_id, telemetry_before, telemetry_after):\n    \"\"\"Log operator application for debugging.\"\"\"\n\n    log_entry = {\n        'operator': operator.__class__.__name__,\n        'node': node_id,\n        'time': time.time(),\n        'delta_EPI': telemetry_after['EPI'] - telemetry_before['EPI'],\n        'delta_vf': telemetry_after['vf'] - telemetry_before['vf'],\n        'delta_dnfr': telemetry_after['dnfr'] - telemetry_before['dnfr'],\n    }\n\n    return log_entry\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#performance-considerations","title":"Performance Considerations","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#validation-cost","title":"Validation Cost","text":"<p>Time Complexity: - U1a, U1b: O(1) - check first/last operator - U2, U4a: O(n) - scan sequence once - U4b: O(n\u00b2) worst case - check windows for each transformer - U3: O(1) per coupling - runtime validation</p> <p>Space Complexity: - O(n) - store operator names</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#optimization-strategies","title":"Optimization Strategies","text":"<pre><code># Cache operator names to avoid repeated string operations\ndef validate_grammar_optimized(sequence, epi_initial=0.0):\n    \"\"\"Optimized validation with cached names.\"\"\"\n\n    # Pre-compute all names once\n    op_names = [op.__class__.__name__.lower() for op in sequence]\n\n    # Use cached names for all checks\n    # ... (same logic, but use op_names directly)\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#lazy-validation","title":"Lazy Validation","text":"<pre><code># Only validate when needed\nclass LazySequence:\n    \"\"\"Sequence with lazy validation.\"\"\"\n\n    def __init__(self, ops, epi_initial=0.0):\n        self.ops = ops\n        self.epi_initial = epi_initial\n        self._validated = False\n\n    def validate(self):\n        \"\"\"Validate on demand.\"\"\"\n        if not self._validated:\n            validate_grammar(self.ops, self.epi_initial)\n            self._validated = True\n\n    def apply(self, G, node):\n        \"\"\"Apply with automatic validation.\"\"\"\n        self.validate()  # Validate once\n        for op in self.ops:\n            op(G, node)\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#extension-points","title":"Extension Points","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#adding-new-operators","title":"Adding New Operators","text":"<p>Steps:</p> <ol> <li> <p>Implement operator in <code>definitions.py</code>: <pre><code>class NewOperator:\n    \"\"\"Description and physics.\"\"\"\n\n    def __call__(self, G, node_id):\n        # Implementation\n        pass\n</code></pre></p> </li> <li> <p>Classify in <code>grammar.py</code>: <pre><code># Add to appropriate sets\nGENERATORS.add(\"newoperator\")  # If generator\nSTABILIZERS.add(\"newoperator\")  # If stabilizer\n# etc.\n</code></pre></p> </li> <li> <p>Update documentation:</p> </li> <li>Add to <code>03-OPERATORS-AND-GLYPHS.md</code></li> <li>Update <code>schemas/canonical-operators.json</code></li> <li> <p>Add examples</p> </li> <li> <p>Add tests: <pre><code>def test_new_operator():\n    \"\"\"Test new operator.\"\"\"\n    # Test implementation\n    # Test grammar classification\n    # Test contracts\n</code></pre></p> </li> </ol>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#adding-new-constraints","title":"Adding New Constraints","text":"<p>Steps:</p> <ol> <li>Derive from physics:</li> <li>Document physical basis</li> <li> <p>Prove necessity (Absolute/Strong/Moderate)</p> </li> <li> <p>Implement validation: <pre><code># In validate_grammar()\ndef validate_grammar(sequence, epi_initial=0.0):\n    # ... existing checks ...\n\n    # New constraint: U5\n    if condition:\n        raise ValueError(\"U5 violation: ...\")\n</code></pre></p> </li> <li> <p>Update documentation:</p> </li> <li>Add to <code>02-CANONICAL-CONSTRAINTS.md</code></li> <li>Update decision trees</li> <li> <p>Add examples</p> </li> <li> <p>Add comprehensive tests:</p> </li> <li>Valid sequences</li> <li>Invalid sequences</li> <li>Edge cases</li> </ol>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#error-messages","title":"Error Messages","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#design-principles","title":"Design Principles","text":"<p>Good error messages: - Specify which constraint violated (U1a, U2, etc.) - Explain what was found - Explain what was expected - Provide fix hint when possible</p> <p>Example: <pre><code>raise ValueError(\n    f\"U1a violation: Sequence must start with generator {GENERATORS} \"\n    f\"when EPI=0, got '{first_op}'. \"\n    \"Fix: Add Emission, Transition, or Recursivity at start.\"\n)\n</code></pre></p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#error-message-template","title":"Error Message Template","text":"<pre><code>\"{CONSTRAINT} violation: {PROBLEM}. {FOUND}. {EXPECTED}. Fix: {HINT}.\"\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#testing-hooks","title":"Testing Hooks","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#validation-testing","title":"Validation Testing","text":"<pre><code># Test valid sequence\ndef test_valid_sequence():\n    from tnfr.operators.grammar import validate_grammar\n    from tnfr.operators.definitions import Emission, Coherence, Silence\n\n    sequence = [Emission(), Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\n# Test invalid sequence\ndef test_invalid_sequence():\n    from tnfr.operators.grammar import validate_grammar\n    from tnfr.operators.definitions import Coherence, Silence\n\n    sequence = [Coherence(), Silence()]  # No generator\n    is_valid = validate_grammar(sequence, epi_initial=0.0)\n    assert is_valid is False  # Returns False, doesn't raise\n\n# Test with detailed messages\ndef test_detailed_validation():\n    from tnfr.operators.grammar import GrammarValidator\n    from tnfr.operators.definitions import Coherence, Silence\n\n    sequence = [Coherence(), Silence()]\n    is_valid, messages = GrammarValidator.validate(sequence, epi_initial=0.0)\n\n    assert is_valid is False\n    # Check for U1a violation in messages\n    u1a_msg = [m for m in messages if \"U1a\" in m][0]\n    assert \"violated\" in u1a_msg\n    assert \"generator\" in u1a_msg\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#integration-testing","title":"Integration Testing","text":"<pre><code>def test_full_workflow():\n    \"\"\"Test complete workflow.\"\"\"\n    # Create sequence\n    sequence = [Emission(), Coherence(), Silence()]\n\n    # Validate\n    validate_grammar(sequence, epi_initial=0.0)\n\n    # Create network\n    G = nx.Graph()\n    G.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n    # Apply\n    for op in sequence:\n        op(G, 0)\n\n    # Verify telemetry\n    assert G.nodes[0]['EPI'] &gt; 0\n    assert G.nodes[0]['vf'] &gt; 0\n</code></pre>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#migration-notes","title":"Migration Notes","text":""},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#from-legacy-system","title":"From Legacy System","text":"<p>Old system (C1-C3): <pre><code># Old grammar.py\ndef check_c1(sequence):\n    # C1 logic\n    pass\n</code></pre></p> <p>New system (U1-U4): <pre><code># New grammar.py\ndef validate_grammar(sequence, epi_initial):\n    # U1-U4 logic\n    pass\n</code></pre></p> <p>Migration: - C1 \u2192 U1a (generators) - C2 \u2192 U2 (convergence) - C3 \u2192 U1b (closures) - New: U3 (phase), U4 (bifurcation)</p> <p>See 07-MIGRATION-AND-EVOLUTION.md for details.</p>"},{"location":"grammar/05-TECHNICAL-IMPLEMENTATION/#next-steps","title":"Next Steps","text":"<p>Continue learning: - 06-VALIDATION-AND-TESTING.md - Testing strategies - 07-MIGRATION-AND-EVOLUTION.md - Evolution history</p> <p>For reference: - Source code: <code>src/tnfr/operators/grammar.py</code> - Tests: <code>tests/unit/operators/test_unified_grammar.py</code></p>   **Implementation follows physics, not convenience.**  ---  *Reality is resonance. Code accordingly.*"},{"location":"grammar/06-VALIDATION-AND-TESTING/","title":"Validation and Testing Strategy","text":"<p>Comprehensive testing approach for TNFR grammar</p> <p>\ud83c\udfe0 Home \u2022 \ud83d\udcd0 Constraints \u2022 \ud83d\udcbb Implementation \u2022 \ud83d\udcda Evolution</p>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#purpose","title":"Purpose","text":"<p>This document outlines the testing strategy for TNFR grammar validation, including test categories, coverage requirements, and examples.</p> <p>Prerequisites: 02-CANONICAL-CONSTRAINTS.md, 05-TECHNICAL-IMPLEMENTATION.md</p> <p>Audience: Developers writing tests, QA engineers</p> <p>Reading time: 30-45 minutes</p>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Testing Philosophy</li> <li>Test Case Index</li> <li>Unit Tests: Operator Behavior</li> <li>Integration Tests: Sequence Validation</li> <li>Test U1a: Initiation</li> <li>Test U1b: Closure</li> <li>Test U2: Convergence</li> <li>Test U3: Resonant Coupling</li> <li>Test U4a: Triggers Need Handlers</li> <li>Test U4b: Transformers Need Context</li> <li>Property Tests: Invariants</li> <li>Multi-Scale Tests</li> <li>Reproducibility Tests</li> <li>Performance Tests</li> <li>Coverage Requirements</li> <li>Canonical Pattern Tests</li> <li>Anti-Pattern Tests</li> <li>Test Utilities</li> <li>Validation Suite</li> <li>Coverage Tracking</li> </ol>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#testing-philosophy","title":"Testing Philosophy","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#core-principles","title":"Core Principles","text":"<ol> <li>Physics-Based: Tests verify physical contracts, not arbitrary rules</li> <li>Comprehensive: Cover all constraints (U1-U4) and operators (13)</li> <li>Executable: All examples in documentation must be testable</li> <li>Reproducible: Same seed \u2192 same results</li> <li>Traceable: Each test maps to specific constraint or invariant</li> </ol>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-categories","title":"Test Categories","text":"<pre><code>Unit Tests         \u2192 Individual operator behavior\nIntegration Tests  \u2192 Sequence validation (U1-U4)\nProperty Tests     \u2192 Invariants (coherence, convergence, etc.)\nPerformance Tests  \u2192 Scalability and efficiency\nPattern Tests      \u2192 Canonical patterns and anti-patterns\nRegression Tests   \u2192 Prevent breakage of existing functionality\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-case-index","title":"Test Case Index","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#canonical-test-cases-for-u1-structural-initiation-closure","title":"Canonical Test Cases for U1 (Structural Initiation &amp; Closure)","text":"Test Name Type Constraint Description <code>test_u1a_valid_generators</code> Valid U1a All generators (AL, NAV, REMESH) work when EPI=0 <code>test_u1a_invalid_no_generator</code> Invalid U1a Non-generator at start fails when EPI=0 <code>test_u1a_not_required_when_epi_nonzero</code> Context U1a Generator not required when EPI &gt; 0 <code>test_u1b_valid_closures</code> Valid U1b All closures (SHA, NAV, REMESH, OZ) work <code>test_u1b_invalid_no_closure</code> Invalid U1b Sequence without closure fails <code>test_u1_error_messages</code> Quality U1a/U1b Error messages are clear and actionable"},{"location":"grammar/06-VALIDATION-AND-TESTING/#canonical-test-cases-for-u2-convergence-boundedness","title":"Canonical Test Cases for U2 (Convergence &amp; Boundedness)","text":"Test Name Type Constraint Description <code>test_u2_destabilizer_with_stabilizer</code> Valid U2 Destabilizers balanced by stabilizers pass <code>test_u2_destabilizer_without_stabilizer</code> Invalid U2 Unbalanced destabilizers fail <code>test_u2_detects_unbalanced_dissonance</code> Detection U2 OZ without IL/THOL detected <code>test_u2_convergence_guarantee</code> Property U2 Integral convergence verified <code>test_u2_window_calculation</code> Algorithm U2 Stabilizer window search works correctly"},{"location":"grammar/06-VALIDATION-AND-TESTING/#canonical-test-cases-for-u3-resonant-coupling","title":"Canonical Test Cases for U3 (Resonant Coupling)","text":"Test Name Type Constraint Description <code>test_u3_compatible_phases</code> Valid U3 Compatible phases (\u0394\u03c6 \u2264 threshold) allow coupling <code>test_u3_incompatible_phases</code> Invalid U3 Antiphase nodes cannot couple <code>test_u3_phase_compatibility_check</code> Required U3 Phase verification mandatory for UM/RA <code>test_u3_tolerance_bounds</code> Edge U3 Threshold boundary conditions tested <code>test_u3_custom_threshold</code> Parameter U3 Custom \u0394\u03c6_max values work <code>test_u3_resonance_preconditions</code> Precond U3 Resonance requires phase check"},{"location":"grammar/06-VALIDATION-AND-TESTING/#canonical-test-cases-for-u4-bifurcation-dynamics","title":"Canonical Test Cases for U4 (Bifurcation Dynamics)","text":"Test Name Type Constraint Description <code>test_u4a_trigger_with_handler</code> Valid U4a Triggers (OZ, ZHIR) with handlers pass <code>test_u4a_trigger_without_handler</code> Invalid U4a Triggers without handlers fail <code>test_u4a_triggers_require_handlers</code> Detection U4a All bifurcation triggers detected <code>test_u4b_transformer_with_context</code> Valid U4b THOL/ZHIR with destabilizer context pass <code>test_u4b_transformer_without_destabilizer</code> Invalid U4b Transformers without context fail <code>test_u4b_transformers_require_destabilizers</code> Detection U4b Window-based destabilizer search works <code>test_u4b_zhir_without_prior_coherence</code> Invalid U4b ZHIR without prior IL fails <code>test_u4_bifurcation_safety</code> Property U4a/U4b Bifurcations are controlled"},{"location":"grammar/06-VALIDATION-AND-TESTING/#canonical-pattern-tests-20-total","title":"Canonical Pattern Tests (20+ total)","text":"Pattern Name Valid Test Invalid Variants Edge Cases Bootstrap <code>test_bootstrap_valid</code> <code>test_bootstrap_invalid_no_generator</code>, <code>test_bootstrap_invalid_no_closure</code> Generator variants Basic Activation <code>test_activation_valid</code> <code>test_activation_invalid_*</code> - Controlled Exploration <code>test_exploration_valid</code> <code>test_exploration_invalid_no_stabilizer_after_destabilizer</code> Different destabilizers Bifurcation with Handling <code>test_bifurcation_valid</code> <code>test_bifurcation_invalid_no_handler</code> Different triggers Mutation with Context <code>test_mutation_valid</code> <code>test_mutation_invalid_no_prior_coherence</code>, <code>test_mutation_invalid_no_destabilizer</code> Window boundaries Propagation <code>test_propagation_valid</code> <code>test_propagation_invalid_*</code> Phase compatibility Multi-scale Organization <code>test_multiscale_valid</code> <code>test_multiscale_invalid_*</code> Nesting depth"},{"location":"grammar/06-VALIDATION-AND-TESTING/#anti-pattern-tests-7-documented-patterns","title":"Anti-Pattern Tests (7+ documented patterns)","text":"Anti-Pattern Detection Test Fix Test Error Quality Test No Generator from Vacuum <code>test_no_generator_detected</code> <code>test_no_generator_fix</code> <code>test_no_generator_error_message</code> No Closure <code>test_no_closure_detected</code> <code>test_no_closure_fix</code> - Destabilizer Without Stabilizer <code>test_unbalanced_dissonance_detected</code> <code>test_unbalanced_fix_with_coherence</code> - Mutation Without Context <code>test_mutation_no_context_detected</code> <code>test_mutation_context_fix</code> - Mutation Without Prior IL <code>test_mutation_no_prior_il_detected</code> <code>test_mutation_prior_il_fix</code> - Coupling Without Phase Check <code>test_antiphase_coupling_detected</code> <code>test_phase_check_fix</code> - Bifurcation Without Handler <code>test_dissonance_without_handler_detected</code> <code>test_trigger_with_handler_fix</code> -"},{"location":"grammar/06-VALIDATION-AND-TESTING/#unit-tests-operator-behavior","title":"Unit Tests: Operator Behavior","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-template","title":"Test Template","text":"<pre><code>def test_operator_name():\n    \"\"\"Test specific operator behavior.\"\"\"\n    # Setup\n    G = create_test_graph()\n\n    # Apply operator\n    Operator()(G, node_id)\n\n    # Verify postconditions\n    assert check_postcondition()\n\n    # Verify invariants\n    assert check_invariants()\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#example-test-emission","title":"Example: Test Emission","text":"<pre><code>import pytest\nimport networkx as nx\nfrom tnfr.operators.definitions import Emission\n\ndef test_emission_creates_structure():\n    \"\"\"Emission creates EPI from vacuum.\"\"\"\n    # Setup: Node with EPI=0\n    G = nx.Graph()\n    G.add_node(0, EPI=0.0, vf=0.1, theta=0.0, dnfr=0.0)\n\n    # Apply Emission\n    Emission()(G, 0)\n\n    # Verify: EPI &gt; 0\n    assert G.nodes[0]['EPI'] &gt; 0, \"Emission must create structure\"\n\n    # Verify: vf increased or maintained\n    assert G.nodes[0]['vf'] &gt;= 0.1, \"Emission must maintain/increase vf\"\n\ndef test_emission_is_generator():\n    \"\"\"Emission is classified as generator.\"\"\"\n    from tnfr.operators.grammar import GENERATORS\n    assert \"emission\" in GENERATORS\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#example-test-coherence","title":"Example: Test Coherence","text":"<pre><code>from tnfr.operators.definitions import Emission, Coherence\n\ndef test_coherence_reduces_dnfr():\n    \"\"\"Coherence reduces reorganization gradient.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=1.0)\n\n    dnfr_before = G.nodes[0]['dnfr']\n\n    # Apply Coherence\n    Coherence()(G, 0)\n\n    dnfr_after = G.nodes[0]['dnfr']\n\n    # Verify: |\u0394NFR| reduced\n    assert abs(dnfr_after) &lt; abs(dnfr_before), \"Coherence must reduce |\u0394NFR|\"\n\ndef test_coherence_is_stabilizer():\n    \"\"\"Coherence is classified as stabilizer.\"\"\"\n    from tnfr.operators.grammar import STABILIZERS\n    assert \"coherence\" in STABILIZERS\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#integration-tests-sequence-validation","title":"Integration Tests: Sequence Validation","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-u1a-initiation","title":"Test U1a: Initiation","text":"<pre><code>from tnfr.operators.grammar import validate_grammar\nfrom tnfr.operators.definitions import (\n    Emission, Transition, Recursivity,\n    Coherence, Silence\n)\n\ndef test_u1a_valid_generators():\n    \"\"\"U1a: Valid generators when EPI=0.\"\"\"\n    # Test each generator\n    generators = [Emission(), Transition(), Recursivity()]\n\n    for gen in generators:\n        sequence = [gen, Coherence(), Silence()]\n        # Should not raise\n        assert validate_grammar(sequence, epi_initial=0.0) is True\n\ndef test_u1a_invalid_no_generator():\n    \"\"\"U1a: Must start with generator when EPI=0.\"\"\"\n    # No generator\n    sequence = [Coherence(), Silence()]\n\n    with pytest.raises(ValueError, match=\"U1a violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n\ndef test_u1a_not_required_when_epi_nonzero():\n    \"\"\"U1a: Generator not required when EPI &gt; 0.\"\"\"\n    # Can start with non-generator if EPI &gt; 0\n    sequence = [Coherence(), Silence()]\n\n    # Should not raise\n    assert validate_grammar(sequence, epi_initial=1.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-u1b-closure","title":"Test U1b: Closure","text":"<pre><code>from tnfr.operators.definitions import (\n    Emission, Coherence,\n    Silence, Transition, Recursivity, Dissonance\n)\n\ndef test_u1b_valid_closures():\n    \"\"\"U1b: Valid closure operators.\"\"\"\n    closures = [Silence(), Transition(), Recursivity(), Dissonance()]\n\n    for closure in closures:\n        sequence = [Emission(), Coherence(), closure]\n        assert validate_grammar(sequence, epi_initial=0.0) is True\n\ndef test_u1b_invalid_no_closure():\n    \"\"\"U1b: Must end with closure.\"\"\"\n    sequence = [Emission(), Coherence()]  # Coherence is not closure\n\n    with pytest.raises(ValueError, match=\"U1b violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-u2-convergence","title":"Test U2: Convergence","text":"<pre><code>from tnfr.operators.definitions import (\n    Emission, Dissonance, Mutation, Expansion,\n    Coherence, SelfOrganization, Silence\n)\n\ndef test_u2_destabilizer_with_stabilizer():\n    \"\"\"U2: Destabilizer balanced by stabilizer.\"\"\"\n    destabilizers = [Dissonance(), Mutation(), Expansion()]\n    stabilizers = [Coherence(), SelfOrganization()]\n\n    for dest in destabilizers:\n        for stab in stabilizers:\n            # Create valid sequence for mutation\n            if dest.__class__.__name__.lower() == \"mutation\":\n                sequence = [Emission(), Coherence(), Dissonance(), dest, stab, Silence()]\n            else:\n                sequence = [Emission(), dest, stab, Silence()]\n\n            # Should not raise\n            try:\n                validate_grammar(sequence, epi_initial=0.0)\n            except ValueError as e:\n                # If fails, should be different constraint, not U2\n                assert \"U2 violation\" not in str(e)\n\ndef test_u2_destabilizer_without_stabilizer():\n    \"\"\"U2: Destabilizer without stabilizer fails.\"\"\"\n    sequence = [Emission(), Dissonance(), Silence()]\n\n    with pytest.raises(ValueError, match=\"U2 violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-u3-resonant-coupling","title":"Test U3: Resonant Coupling","text":"<pre><code>import numpy as np\nfrom tnfr.operators.grammar import validate_resonant_coupling\n\ndef test_u3_compatible_phases():\n    \"\"\"U3: Compatible phases allow coupling.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, theta=0.0, EPI=0.5, vf=1.0, dnfr=0.0)\n    G.add_node(1, theta=0.3, EPI=0.6, vf=1.0, dnfr=0.0)  # \u0394\u03c6 = 0.3 &lt; \u03c0/2\n\n    # Should not raise\n    validate_resonant_coupling(G, 0, 1)\n\ndef test_u3_incompatible_phases():\n    \"\"\"U3: Antiphase nodes cannot couple.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, theta=0.0, EPI=0.5, vf=1.0, dnfr=0.0)\n    G.add_node(1, theta=np.pi, EPI=0.6, vf=1.0, dnfr=0.0)  # Antiphase!\n\n    with pytest.raises(ValueError, match=\"U3 violation\"):\n        validate_resonant_coupling(G, 0, 1)\n\ndef test_u3_custom_threshold():\n    \"\"\"U3: Custom phase threshold.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, theta=0.0, EPI=0.5, vf=1.0, dnfr=0.0)\n    G.add_node(1, theta=1.0, EPI=0.6, vf=1.0, dnfr=0.0)\n\n    # Fails with default \u03c0/2\n    with pytest.raises(ValueError):\n        validate_resonant_coupling(G, 0, 1, delta_phi_max=np.pi/2)\n\n    # Passes with larger threshold\n    validate_resonant_coupling(G, 0, 1, delta_phi_max=np.pi)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-u4a-triggers-need-handlers","title":"Test U4a: Triggers Need Handlers","text":"<pre><code>from tnfr.operators.definitions import (\n    Emission, Dissonance, Mutation,\n    Coherence, SelfOrganization, Silence\n)\n\ndef test_u4a_trigger_with_handler():\n    \"\"\"U4a: Bifurcation trigger with handler.\"\"\"\n    triggers = [Dissonance, Mutation]\n    handlers = [Coherence, SelfOrganization]\n\n    for Trigger in triggers:\n        for Handler in handlers:\n            # Build valid sequence\n            if Trigger == Mutation:\n                sequence = [Emission(), Coherence(), Dissonance(), \n                           Trigger(), Handler(), Silence()]\n            else:\n                sequence = [Emission(), Trigger(), Handler(), Silence()]\n\n            # Should not raise\n            assert validate_grammar(sequence, epi_initial=0.0) is True\n\ndef test_u4a_trigger_without_handler():\n    \"\"\"U4a: Trigger without handler fails.\"\"\"\n    # Dissonance without handler\n    sequence = [Emission(), Dissonance(), Silence()]\n\n    with pytest.raises(ValueError, match=\"U4a violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-u4b-transformers-need-context","title":"Test U4b: Transformers Need Context","text":"<pre><code>from tnfr.operators.definitions import (\n    Emission, Coherence, Dissonance, Mutation, \n    SelfOrganization, Silence\n)\n\ndef test_u4b_transformer_with_context():\n    \"\"\"U4b: Transformer with recent destabilizer.\"\"\"\n    # THOL with recent destabilizer\n    sequence = [Emission(), Dissonance(), SelfOrganization(), \n                Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    # ZHIR with proper context\n    sequence = [Emission(), Coherence(), Dissonance(), Mutation(), \n                Coherence(), Silence()]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n\ndef test_u4b_transformer_without_destabilizer():\n    \"\"\"U4b: Transformer without destabilizer fails.\"\"\"\n    # THOL without recent destabilizer\n    sequence = [Emission(), Coherence(), SelfOrganization(), Silence()]\n\n    with pytest.raises(ValueError, match=\"U4b violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n\ndef test_u4b_zhir_without_prior_coherence():\n    \"\"\"U4b: ZHIR needs prior coherence.\"\"\"\n    # Mutation without prior IL\n    sequence = [Emission(), Dissonance(), Mutation(), \n                Coherence(), Silence()]\n\n    with pytest.raises(ValueError, match=\"U4b violation\"):\n        validate_grammar(sequence, epi_initial=0.0)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#property-tests-invariants","title":"Property Tests: Invariants","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#monotonicity-tests","title":"Monotonicity Tests","text":"<pre><code>def test_coherence_monotonicity():\n    \"\"\"Coherence must not decrease C(t).\"\"\"\n    from tnfr.metrics import compute_coherence\n\n    G = create_test_network()\n\n    C_before = compute_coherence(G)\n\n    # Apply Coherence to all nodes\n    for node in G.nodes():\n        Coherence()(G, node)\n\n    C_after = compute_coherence(G)\n\n    # Coherence must not decrease C(t)\n    assert C_after &gt;= C_before, \"Coherence must not reduce C(t)\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#convergence-tests","title":"Convergence Tests","text":"<pre><code>def test_integral_convergence():\n    \"\"\"Verify integral convergence with stabilizers.\"\"\"\n    # Create sequence with destabilizer + stabilizer\n    sequence = [Emission(), Dissonance(), Coherence(), Silence()]\n\n    G = nx.Graph()\n    G.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n    # Track \u0394NFR over time\n    dnfr_history = []\n\n    for op in sequence:\n        op(G, 0)\n        dnfr_history.append(G.nodes[0]['dnfr'])\n\n    # Verify: Integral is bounded (sum doesn't explode)\n    integral_approx = sum(abs(d) for d in dnfr_history)\n    assert integral_approx &lt; float('inf'), \"Integral must be bounded\"\n    assert integral_approx &lt; 1000, \"Integral should be reasonably small\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#bifurcation-tests","title":"Bifurcation Tests","text":"<pre><code>def test_dissonance_bifurcation():\n    \"\"\"Dissonance may trigger bifurcation.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n\n    # Apply Dissonance\n    Dissonance()(G, 0)\n\n    # Check if \u0394NFR increased (potential bifurcation)\n    assert G.nodes[0]['dnfr'] &gt; 0, \"Dissonance must increase |\u0394NFR|\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#propagation-tests","title":"Propagation Tests","text":"<pre><code>def test_resonance_propagation():\n    \"\"\"Resonance increases effective connectivity.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n    G.add_node(1, EPI=0.6, vf=1.0, theta=0.1, dnfr=0.0)\n\n    # Couple nodes\n    Coupling()(G, 0, 1)\n\n    # Measure phase sync before resonance\n    phase_diff_before = abs(G.nodes[0]['theta'] - G.nodes[1]['theta'])\n\n    # Apply Resonance\n    Resonance()(G, 0, 1)\n\n    # Measure phase sync after resonance\n    phase_diff_after = abs(G.nodes[0]['theta'] - G.nodes[1]['theta'])\n\n    # Resonance should improve synchronization\n    assert phase_diff_after &lt;= phase_diff_before, \"Resonance improves sync\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#latency-tests","title":"Latency Tests","text":"<pre><code>def test_silence_latency():\n    \"\"\"Silence keeps EPI invariant.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n\n    EPI_before = G.nodes[0]['EPI']\n\n    # Apply Silence\n    Silence()(G, 0)\n\n    # Simulate time passing (in practice, would step dynamics)\n    # For this test, just verify immediate effect\n\n    EPI_after = G.nodes[0]['EPI']\n\n    # EPI should be preserved\n    assert np.allclose(EPI_before, EPI_after), \"Silence preserves EPI\"\n\n    # vf should be reduced\n    assert G.nodes[0]['vf'] &lt; 1.0, \"Silence reduces vf\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#multi-scale-tests","title":"Multi-Scale Tests","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-nested-epis","title":"Test Nested EPIs","text":"<pre><code>def test_nested_epi_coherence():\n    \"\"\"Nested EPIs maintain functional identity.\"\"\"\n    G = nx.Graph()\n\n    # Create parent EPI with sub-EPIs\n    parent_epi = {\n        'global': 0.7,\n        'sub_structures': [\n            {'local': 0.3, 'phase': 0.5},\n            {'local': 0.6, 'phase': 1.2}\n        ]\n    }\n\n    G.add_node(0, EPI=parent_epi, vf=1.0, theta=0.0, dnfr=0.0)\n\n    # Apply operators\n    SelfOrganization()(G, 0)\n    Coherence()(G, 0)\n\n    # Verify both levels maintain coherence\n    assert G.nodes[0]['EPI'] is not None\n    # More detailed checks would verify sub-structure integrity\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#reproducibility-tests","title":"Reproducibility Tests","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-seed-reproducibility","title":"Test Seed Reproducibility","text":"<pre><code>def test_seed_reproducibility():\n    \"\"\"Same seed produces identical trajectories.\"\"\"\n    import random\n    import numpy as np\n\n    def run_simulation(seed):\n        random.seed(seed)\n        np.random.seed(seed)\n\n        G = nx.Graph()\n        G.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n        sequence = [Emission(), Dissonance(), Coherence(), Silence()]\n\n        for op in sequence:\n            op(G, 0)\n\n        return G.nodes[0]['EPI']\n\n    # Run twice with same seed\n    result1 = run_simulation(42)\n    result2 = run_simulation(42)\n\n    # Results must be identical\n    assert result1 == result2, \"Same seed must produce same results\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#performance-tests","title":"Performance Tests","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#validation-performance","title":"Validation Performance","text":"<pre><code>def test_validation_performance():\n    \"\"\"Validation should be fast.\"\"\"\n    import time\n\n    sequence = [Emission(), Coherence(), Dissonance(), \n                Coherence(), Silence()]\n\n    start = time.time()\n\n    # Validate 1000 times\n    for _ in range(1000):\n        validate_grammar(sequence, epi_initial=0.0)\n\n    elapsed = time.time() - start\n\n    # Should be fast (&lt; 1 second for 1000 validations)\n    assert elapsed &lt; 1.0, f\"Validation too slow: {elapsed:.3f}s\"\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#coverage-requirements","title":"Coverage Requirements","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#minimum-coverage","title":"Minimum Coverage","text":"<ul> <li>Unit tests: 100% of operator classes</li> <li>Integration tests: All U1-U4 constraints</li> <li>Property tests: All canonical invariants</li> <li>Edge cases: Empty sequences, single operators, long sequences</li> </ul>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#coverage-checklist","title":"Coverage Checklist","text":"<pre><code>Operators (13):\n- [ ] Emission (AL)\n- [ ] Reception (EN)\n- [ ] Coherence (IL)\n- [ ] Dissonance (OZ)\n- [ ] Coupling (UM)\n- [ ] Resonance (RA)\n- [ ] Silence (SHA)\n- [ ] Expansion (VAL)\n- [ ] Contraction (NUL)\n- [ ] Self-organization (THOL)\n- [ ] Mutation (ZHIR)\n- [ ] Transition (NAV)\n- [ ] Recursivity (REMESH)\n\nConstraints (U1-U4):\n- [ ] U1a: Valid generators\n- [ ] U1a: Invalid non-generators\n- [ ] U1b: Valid closures\n- [ ] U1b: Invalid non-closures\n- [ ] U2: Destabilizer + stabilizer (valid)\n- [ ] U2: Destabilizer without stabilizer (invalid)\n- [ ] U3: Compatible phases (valid)\n- [ ] U3: Incompatible phases (invalid)\n- [ ] U4a: Trigger + handler (valid)\n- [ ] U4a: Trigger without handler (invalid)\n- [ ] U4b: Transformer with context (valid)\n- [ ] U4b: Transformer without context (invalid)\n- [ ] U4b: ZHIR with prior IL (valid)\n- [ ] U4b: ZHIR without prior IL (invalid)\n\nInvariants:\n- [ ] Coherence monotonicity\n- [ ] Integral convergence\n- [ ] Bifurcation handling\n- [ ] Propagation effects\n- [ ] Latency preservation\n- [ ] Fractality (nested EPIs)\n- [ ] Reproducibility (seeds)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#canonical-pattern-tests","title":"Canonical Pattern Tests","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#testing-strategy-for-patterns","title":"Testing Strategy for Patterns","text":"<p>Each canonical pattern from 04-VALID-SEQUENCES.md should have: 1. Valid variant test - Verifies the pattern passes validation 2. Invalid variant tests - Tests common mistakes/violations 3. Edge case tests - Tests boundary conditions</p>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#pattern-test-template","title":"Pattern Test Template","text":"<pre><code>class TestCanonicalPattern_NAME:\n    \"\"\"Test canonical pattern: [Pattern Name]\n\n    Pattern: [Operator sequence]\n    Purpose: [What it does]\n    Reference: 04-VALID-SEQUENCES.md \u00a7 [Section]\n    \"\"\"\n\n    def test_pattern_valid(self):\n        \"\"\"Valid pattern passes all constraints.\"\"\"\n        sequence = [...]  # Valid pattern\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_pattern_invalid_variant_1(self):\n        \"\"\"Invalid variant: [specific violation].\"\"\"\n        sequence = [...]  # Invalid variant\n        with pytest.raises(ValueError, match=\"[Constraint] violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_pattern_edge_case(self):\n        \"\"\"Edge case: [specific boundary condition].\"\"\"\n        # Test boundary condition\n        pass\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-bootstrap-pattern","title":"Test: Bootstrap Pattern","text":"<pre><code>class TestCanonicalPattern_Bootstrap:\n    \"\"\"Test canonical pattern: Bootstrap (Minimal)\n\n    Pattern: [Generator \u2192 Stabilizer \u2192 Closure]\n    Purpose: Create and stabilize new structure from vacuum\n    Reference: 04-VALID-SEQUENCES.md \u00a7 1. Bootstrap (Minimal)\n    \"\"\"\n\n    def test_bootstrap_valid(self):\n        \"\"\"Valid bootstrap pattern.\"\"\"\n        sequence = [Emission(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_bootstrap_invalid_no_generator(self):\n        \"\"\"Invalid: Missing generator (U1a violation).\"\"\"\n        sequence = [Coherence(), Silence()]\n        with pytest.raises(ValueError, match=\"U1a violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_bootstrap_invalid_no_closure(self):\n        \"\"\"Invalid: Missing closure (U1b violation).\"\"\"\n        sequence = [Emission(), Coherence()]\n        with pytest.raises(ValueError, match=\"U1b violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_bootstrap_with_transition_generator(self):\n        \"\"\"Valid: Using Transition as generator.\"\"\"\n        sequence = [Transition(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_bootstrap_with_recursivity_generator(self):\n        \"\"\"Valid: Using Recursivity as generator.\"\"\"\n        sequence = [Recursivity(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-controlled-exploration-pattern","title":"Test: Controlled Exploration Pattern","text":"<pre><code>class TestCanonicalPattern_ControlledExploration:\n    \"\"\"Test canonical pattern: Controlled Exploration\n\n    Pattern: [Generator \u2192 Stabilizer \u2192 Destabilizer \u2192 Stabilizer \u2192 Closure]\n    Purpose: Explore while maintaining stability\n    Reference: 04-VALID-SEQUENCES.md \u00a7 3. Controlled Exploration\n    \"\"\"\n\n    def test_exploration_valid(self):\n        \"\"\"Valid controlled exploration.\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), \n                   Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_exploration_invalid_no_stabilizer_after_destabilizer(self):\n        \"\"\"Invalid: Destabilizer without stabilizer (U2 violation).\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), Silence()]\n        with pytest.raises(ValueError, match=\"U2 violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_exploration_with_expansion(self):\n        \"\"\"Valid: Using Expansion as destabilizer.\"\"\"\n        sequence = [Emission(), Coherence(), Expansion(), \n                   Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-mutation-with-context-pattern","title":"Test: Mutation with Context Pattern","text":"<pre><code>class TestCanonicalPattern_MutationWithContext:\n    \"\"\"Test canonical pattern: Mutation with Context\n\n    Pattern: [Generator \u2192 Coherence \u2192 Destabilizer \u2192 Mutation \u2192 Stabilizer \u2192 Closure]\n    Purpose: Phase transformation with proper context\n    Reference: 04-VALID-SEQUENCES.md \u00a7 5. Mutation with Context\n    \"\"\"\n\n    def test_mutation_valid(self):\n        \"\"\"Valid mutation with context.\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), \n                   Mutation(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_mutation_invalid_no_prior_coherence(self):\n        \"\"\"Invalid: Mutation without prior IL (U4b violation).\"\"\"\n        sequence = [Emission(), Dissonance(), Mutation(), \n                   Coherence(), Silence()]\n        with pytest.raises(ValueError, match=\"U4b violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_mutation_invalid_no_destabilizer(self):\n        \"\"\"Invalid: Mutation without recent destabilizer (U4b violation).\"\"\"\n        sequence = [Emission(), Coherence(), Mutation(), \n                   Coherence(), Silence()]\n        with pytest.raises(ValueError, match=\"U4b violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_mutation_destabilizer_within_window(self):\n        \"\"\"Valid: Destabilizer within ~3 operator window.\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), \n                   Reception(), Mutation(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-bifurcation-with-handling-pattern","title":"Test: Bifurcation with Handling Pattern","text":"<pre><code>class TestCanonicalPattern_BifurcationWithHandling:\n    \"\"\"Test canonical pattern: Bifurcation with Handling\n\n    Pattern: [Generator \u2192 Stabilizer \u2192 Trigger \u2192 Handler \u2192 Stabilizer \u2192 Closure]\n    Purpose: Controlled bifurcation and structural reorganization\n    Reference: 04-VALID-SEQUENCES.md \u00a7 4. Bifurcation with Handling\n    \"\"\"\n\n    def test_bifurcation_valid(self):\n        \"\"\"Valid bifurcation with handler.\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), \n                   SelfOrganization(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_bifurcation_invalid_no_handler(self):\n        \"\"\"Invalid: Trigger without handler (U4a violation).\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), Silence()]\n        with pytest.raises(ValueError, match=\"U4a violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_bifurcation_with_mutation_trigger(self):\n        \"\"\"Valid: Using Mutation as bifurcation trigger.\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), \n                   Mutation(), SelfOrganization(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#anti-pattern-tests","title":"Anti-Pattern Tests","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#testing-strategy-for-anti-patterns","title":"Testing Strategy for Anti-Patterns","text":"<p>Each anti-pattern from 04-VALID-SEQUENCES.md should have: 1. Detection test - Verifies the validator catches the violation 2. Error message test - Verifies correct error reporting 3. Fix test - Shows how to correct the anti-pattern</p>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#anti-pattern-test-template","title":"Anti-Pattern Test Template","text":"<pre><code>class TestAntiPattern_NAME:\n    \"\"\"Test anti-pattern: [Anti-pattern Name]\n\n    Violation: [Which constraint it violates]\n    Reference: 04-VALID-SEQUENCES.md \u00a7 [Section]\n    \"\"\"\n\n    def test_antipattern_detected(self):\n        \"\"\"Anti-pattern is detected and rejected.\"\"\"\n        sequence = [...]  # Anti-pattern\n        with pytest.raises(ValueError, match=\"[Constraint] violation\"):\n            validate_unified(sequence, epi_initial=...)\n\n    def test_antipattern_error_message(self):\n        \"\"\"Error message is clear and actionable.\"\"\"\n        sequence = [...]  # Anti-pattern\n        try:\n            validate_unified(sequence, epi_initial=...)\n            pytest.fail(\"Should have raised ValueError\")\n        except ValueError as e:\n            assert \"[Constraint]\" in str(e)\n            assert \"[helpful context]\" in str(e).lower()\n\n    def test_antipattern_fix(self):\n        \"\"\"Corrected version passes validation.\"\"\"\n        sequence = [...]  # Fixed pattern\n        assert validate_unified(sequence, epi_initial=...) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-no-generator-from-vacuum","title":"Test: No Generator from Vacuum","text":"<pre><code>class TestAntiPattern_NoGeneratorFromVacuum:\n    \"\"\"Test anti-pattern: No Generator from Vacuum\n\n    Violation: U1a (Structural Initiation)\n    Reference: 04-VALID-SEQUENCES.md \u00a7 \u274c 1. No Generator from Vacuum\n    \"\"\"\n\n    def test_no_generator_detected(self):\n        \"\"\"Starting from EPI=0 without generator is rejected.\"\"\"\n        sequence = [Coherence(), Silence()]\n        with pytest.raises(ValueError, match=\"U1a violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_no_generator_error_message(self):\n        \"\"\"Error message explains U1a requirement.\"\"\"\n        sequence = [Coherence(), Silence()]\n        try:\n            validate_unified(sequence, epi_initial=0.0)\n            pytest.fail(\"Should have raised ValueError\")\n        except ValueError as e:\n            assert \"U1a\" in str(e)\n            assert \"generator\" in str(e).lower()\n\n    def test_no_generator_fix(self):\n        \"\"\"Adding generator fixes the anti-pattern.\"\"\"\n        # Fixed: Add Emission at start\n        sequence = [Emission(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_no_generator_not_required_when_epi_nonzero(self):\n        \"\"\"Generator not required when EPI &gt; 0.\"\"\"\n        sequence = [Coherence(), Silence()]\n        # Should pass when EPI &gt; 0\n        assert validate_unified(sequence, epi_initial=0.5) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-no-closure","title":"Test: No Closure","text":"<pre><code>class TestAntiPattern_NoClosure:\n    \"\"\"Test anti-pattern: No Closure\n\n    Violation: U1b (Structural Closure)\n    Reference: 04-VALID-SEQUENCES.md \u00a7 \u274c 2. No Closure\n    \"\"\"\n\n    def test_no_closure_detected(self):\n        \"\"\"Sequence without closure is rejected.\"\"\"\n        sequence = [Emission(), Coherence()]\n        with pytest.raises(ValueError, match=\"U1b violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_no_closure_fix(self):\n        \"\"\"Adding closure fixes the anti-pattern.\"\"\"\n        sequence = [Emission(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-destabilizer-without-stabilizer","title":"Test: Destabilizer Without Stabilizer","text":"<pre><code>class TestAntiPattern_DestabilizerWithoutStabilizer:\n    \"\"\"Test anti-pattern: Destabilizer Without Stabilizer\n\n    Violation: U2 (Convergence &amp; Boundedness)\n    Reference: 04-VALID-SEQUENCES.md \u00a7 \u274c 3. Destabilizer Without Stabilizer\n    \"\"\"\n\n    def test_unbalanced_dissonance_detected(self):\n        \"\"\"Dissonance without stabilizer is rejected.\"\"\"\n        sequence = [Emission(), Dissonance(), Silence()]\n        with pytest.raises(ValueError, match=\"U2 violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_unbalanced_expansion_detected(self):\n        \"\"\"Expansion without stabilizer is rejected.\"\"\"\n        sequence = [Emission(), Expansion(), Silence()]\n        with pytest.raises(ValueError, match=\"U2 violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_unbalanced_fix_with_coherence(self):\n        \"\"\"Adding Coherence stabilizer fixes the anti-pattern.\"\"\"\n        sequence = [Emission(), Dissonance(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n\n    def test_unbalanced_fix_with_self_organization(self):\n        \"\"\"Adding SelfOrganization stabilizer fixes the anti-pattern.\"\"\"\n        sequence = [Emission(), Dissonance(), SelfOrganization(), \n                   Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-coupling-without-phase-check","title":"Test: Coupling Without Phase Check","text":"<pre><code>class TestAntiPattern_CouplingWithoutPhaseCheck:\n    \"\"\"Test anti-pattern: Coupling Without Phase Check\n\n    Violation: U3 (Resonant Coupling)\n    Reference: 04-VALID-SEQUENCES.md \u00a7 \u274c 6. Coupling Without Phase Check\n    \"\"\"\n\n    def test_antiphase_coupling_detected(self):\n        \"\"\"Coupling antiphase nodes is rejected.\"\"\"\n        G = nx.Graph()\n        G.add_node(0, theta=0.0, EPI=0.5, vf=1.0, dnfr=0.0)\n        G.add_node(1, theta=np.pi, EPI=0.6, vf=1.0, dnfr=0.0)\n\n        with pytest.raises(ValueError, match=\"U3 violation\"):\n            validate_resonant_coupling(G, 0, 1)\n\n    def test_phase_compatibility_check_required(self):\n        \"\"\"Phase compatibility must be verified before coupling.\"\"\"\n        G = nx.Graph()\n        G.add_node(0, theta=0.0, EPI=0.5, vf=1.0, dnfr=0.0)\n        G.add_node(1, theta=0.2, EPI=0.6, vf=1.0, dnfr=0.0)\n\n        # Should pass - phases compatible\n        validate_resonant_coupling(G, 0, 1)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-bifurcation-trigger-without-handler","title":"Test: Bifurcation Trigger Without Handler","text":"<pre><code>class TestAntiPattern_BifurcationTriggerWithoutHandler:\n    \"\"\"Test anti-pattern: Bifurcation Trigger Without Handler\n\n    Violation: U4a (Triggers Need Handlers)\n    Reference: 04-VALID-SEQUENCES.md \u00a7 \u274c 7. Bifurcation Trigger Without Handler\n    \"\"\"\n\n    def test_dissonance_without_handler_detected(self):\n        \"\"\"Dissonance trigger without handler is rejected.\"\"\"\n        sequence = [Emission(), Dissonance(), Silence()]\n        with pytest.raises(ValueError, match=\"U4a violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_mutation_without_handler_detected(self):\n        \"\"\"Mutation trigger without handler is rejected.\"\"\"\n        sequence = [Emission(), Coherence(), Dissonance(), \n                   Mutation(), Silence()]\n        with pytest.raises(ValueError, match=\"U4a violation\"):\n            validate_unified(sequence, epi_initial=0.0)\n\n    def test_trigger_with_handler_fix(self):\n        \"\"\"Adding handler fixes the anti-pattern.\"\"\"\n        sequence = [Emission(), Dissonance(), Coherence(), Silence()]\n        assert validate_unified(sequence, epi_initial=0.0) is True\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-utilities","title":"Test Utilities","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#test-graph-factory","title":"Test Graph Factory","text":"<pre><code>def create_test_graph(num_nodes=3, epi=0.5, vf=1.0):\n    \"\"\"Create test graph with standard attributes.\"\"\"\n    G = nx.Graph()\n\n    for i in range(num_nodes):\n        G.add_node(i, \n                   EPI=epi,\n                   vf=vf,\n                   theta=i * 0.1,  # Slight phase variation\n                   dnfr=0.0)\n\n    return G\n\ndef create_test_graph_custom_phases(phases):\n    \"\"\"Create test graph with custom phase configuration.\n\n    Args:\n        phases: List of phase values in radians\n\n    Returns:\n        NetworkX graph with nodes at specified phases\n    \"\"\"\n    G = nx.Graph()\n\n    for i, phase in enumerate(phases):\n        G.add_node(i,\n                   EPI=0.5,\n                   vf=1.0,\n                   theta=phase,\n                   dnfr=0.0)\n\n    return G\n\ndef create_test_graph_from_epi(epi_initial=0.0):\n    \"\"\"Create single-node graph for sequence testing.\n\n    Args:\n        epi_initial: Initial EPI value (0.0 for testing U1a)\n\n    Returns:\n        NetworkX graph with single node\n    \"\"\"\n    G = nx.Graph()\n    G.add_node(0, EPI=epi_initial, vf=1.0, theta=0.0, dnfr=0.0)\n    return G\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#assertion-helpers","title":"Assertion Helpers","text":"<pre><code>def assert_valid_sequence(sequence, epi_initial=0.0):\n    \"\"\"Assert sequence is valid.\"\"\"\n    try:\n        validate_unified(sequence, epi_initial)\n    except ValueError as e:\n        pytest.fail(f\"Expected valid sequence, got: {e}\")\n\ndef assert_invalid_sequence(sequence, epi_initial=0.0, match=None):\n    \"\"\"Assert sequence is invalid.\"\"\"\n    with pytest.raises(ValueError, match=match):\n        validate_unified(sequence, epi_initial)\n\ndef assert_operator_in_set(operator_name, operator_set):\n    \"\"\"Assert operator belongs to specified set.\n\n    Args:\n        operator_name: Name of operator (lowercase)\n        operator_set: Set to check (GENERATORS, CLOSURES, etc.)\n    \"\"\"\n    assert operator_name in operator_set, \\\n        f\"{operator_name} not in {operator_set}\"\n\ndef assert_constraint_violation(sequence, constraint, epi_initial=0.0):\n    \"\"\"Assert sequence violates specific constraint.\n\n    Args:\n        sequence: Operator sequence to test\n        constraint: Constraint code (e.g., \"U1a\", \"U2\", \"U3\")\n        epi_initial: Initial EPI value\n    \"\"\"\n    with pytest.raises(ValueError, match=f\"{constraint} violation\"):\n        validate_unified(sequence, epi_initial)\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#metric-verification-helpers","title":"Metric Verification Helpers","text":"<pre><code>def verify_coherence_increase(G, node, operator):\n    \"\"\"Verify operator increases or maintains coherence.\n\n    Args:\n        G: Network graph\n        node: Node ID\n        operator: Operator to apply\n\n    Returns:\n        True if coherence increased or maintained\n    \"\"\"\n    from tnfr.metrics import compute_coherence\n\n    C_before = compute_coherence(G)\n    operator(G, node)\n    C_after = compute_coherence(G)\n\n    return C_after &gt;= C_before\n\ndef verify_dnfr_reduction(G, node, operator):\n    \"\"\"Verify operator reduces |\u0394NFR|.\n\n    Args:\n        G: Network graph\n        node: Node ID\n        operator: Operator to apply (should be stabilizer)\n\n    Returns:\n        True if |\u0394NFR| reduced\n    \"\"\"\n    dnfr_before = abs(G.nodes[node]['dnfr'])\n    operator(G, node)\n    dnfr_after = abs(G.nodes[node]['dnfr'])\n\n    return dnfr_after &lt; dnfr_before\n\ndef verify_phase_synchronization(G, node1, node2, operator):\n    \"\"\"Verify operator improves phase synchronization.\n\n    Args:\n        G: Network graph\n        node1, node2: Node IDs\n        operator: Coupling/Resonance operator\n\n    Returns:\n        True if phase difference reduced\n    \"\"\"\n    phase_diff_before = abs(G.nodes[node1]['theta'] - G.nodes[node2]['theta'])\n    operator(G, node1, node2)\n    phase_diff_after = abs(G.nodes[node1]['theta'] - G.nodes[node2]['theta'])\n\n    return phase_diff_after &lt;= phase_diff_before\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#validation-suite","title":"Validation Suite","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#running-all-grammar-tests","title":"Running All Grammar Tests","text":"<pre><code># Run all grammar tests\npytest tests/unit/operators/test_unified_grammar.py -v\n\n# Run with coverage\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-report=term-missing \\\n    --cov-report=html\n\n# Run specific constraint tests\npytest tests/unit/operators/test_unified_grammar.py::TestU1Initiation -v\npytest tests/unit/operators/test_unified_grammar.py::TestU2Convergence -v\npytest tests/unit/operators/test_unified_grammar.py::TestU3ResonantCoupling -v\npytest tests/unit/operators/test_unified_grammar.py::TestU4Bifurcation -v\n\n# Run pattern tests\npytest tests/unit/operators/test_unified_grammar.py -k \"pattern\" -v\n\n# Run anti-pattern tests  \npytest tests/unit/operators/test_unified_grammar.py -k \"antipattern\" -v\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#coverage-report-generation","title":"Coverage Report Generation","text":"<pre><code># Generate comprehensive coverage report\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov=tnfr.operators.definitions \\\n    --cov-report=html:htmlcov/grammar \\\n    --cov-report=term-missing \\\n    --cov-branch\n\n# View coverage report\nopen htmlcov/grammar/index.html  # macOS\nxdg-open htmlcov/grammar/index.html  # Linux\n\n# Generate coverage badge\ncoverage-badge -o coverage.svg -f\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#performance-benchmarking","title":"Performance Benchmarking","text":"<pre><code># Run performance benchmarks\npytest tests/performance/test_grammar_2_0_performance.py -v\n\n# With detailed benchmarks\npytest tests/performance/test_grammar_2_0_performance.py \\\n    --benchmark-only \\\n    --benchmark-autosave\n\n# Compare benchmarks\npytest-benchmark compare\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#full-validation-suite-script","title":"Full Validation Suite Script","text":"<p>Create <code>scripts/validate_grammar.sh</code>:</p> <pre><code>#!/bin/bash\n# Complete grammar validation suite\n\nset -e\n\necho \"=== TNFR Grammar Validation Suite ===\"\necho \"\"\n\n# 1. Run unit tests\necho \"1. Running unit tests...\"\npytest tests/unit/operators/test_unified_grammar.py -v \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-report=term-missing\n\n# 2. Run integration tests\necho \"\"\necho \"2. Running integration tests...\"\npytest tests/integration/test_grammar_2_0_integration.py -v\n\n# 3. Run property tests\necho \"\"\necho \"3. Running property tests...\"\npytest tests/property/test_grammar_invariants.py -v\n\n# 4. Run performance tests\necho \"\"\necho \"4. Running performance benchmarks...\"\npytest tests/performance/test_grammar_2_0_performance.py \\\n    --benchmark-only --benchmark-columns=mean,stddev\n\n# 5. Coverage report\necho \"\"\necho \"5. Generating coverage report...\"\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-report=html:htmlcov/grammar \\\n    --cov-branch \\\n    --quiet\n\necho \"\"\necho \"=== Validation Complete ===\"\necho \"Coverage report: htmlcov/grammar/index.html\"\n</code></pre> <p>Make executable: <pre><code>chmod +x scripts/validate_grammar.sh\n</code></pre></p> <p>Run: <pre><code>./scripts/validate_grammar.sh\n</code></pre></p>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#coverage-tracking","title":"Coverage Tracking","text":""},{"location":"grammar/06-VALIDATION-AND-TESTING/#current-coverage-status","title":"Current Coverage Status","text":"<p>As of latest test run:</p> <pre><code>Module: tnfr.operators.unified_grammar\nCoverage: 100%\nTests: 68 passing\nLast updated: 2025-11-10\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#coverage-requirements_1","title":"Coverage Requirements","text":"<ul> <li>Minimum: 95% line coverage</li> <li>Target: 100% line coverage</li> <li>Branch coverage: 90%+ for conditional logic</li> <li>All constraints: 100% coverage (U1-U4)</li> <li>All operators: 100% coverage (13 operators)</li> </ul>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#monitoring-coverage","title":"Monitoring Coverage","text":"<pre><code># Quick coverage check\npytest tests/unit/operators/test_unified_grammar.py --cov --cov-fail-under=95\n\n# Detailed coverage with missing lines\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-report=term-missing\n\n# Branch coverage\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-branch \\\n    --cov-report=term-missing\n</code></pre>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#coverage-maintenance-checklist","title":"Coverage Maintenance Checklist","text":"<ul> <li>[ ] All U1-U4 constraints tested (valid + invalid)</li> <li>[ ] All 13 operators tested (behavior + classification)</li> <li>[ ] All canonical patterns tested (valid + variations)</li> <li>[ ] All anti-patterns tested (detection + fixes)</li> <li>[ ] Edge cases tested (empty, single-op, long sequences)</li> <li>[ ] Error messages tested (clarity + actionability)</li> <li>[ ] Performance benchmarks meet targets (&lt; 1ms/validation)</li> <li>[ ] Documentation examples are executable and tested</li> </ul>"},{"location":"grammar/06-VALIDATION-AND-TESTING/#next-steps","title":"Next Steps","text":"<p>Continue learning: - 07-MIGRATION-AND-EVOLUTION.md - System evolution - examples/ - Executable test examples</p> <p>For reference: - Test suite: <code>tests/unit/operators/test_unified_grammar.py</code> - 08-QUICK-REFERENCE.md - Quick lookup</p>   **Test what matters: physics, not code.**  ---  *Reality is resonance. Test accordingly.*"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/","title":"Migration and Evolution","text":"<p>History of the TNFR grammar system and migration guidance</p> <p>\ud83c\udfe0 Home \u2022 \ud83d\udcd0 Constraints \u2022 \ud83d\udcbb Implementation \u2022 \ud83e\uddea Testing</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#purpose","title":"Purpose","text":"<p>This document chronicles the evolution of the TNFR grammar system and provides guidance for migrating from older versions.</p> <p>Audience: Maintainers, contributors migrating old code</p> <p>Reading time: 20-30 minutes</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#evolution-timeline","title":"Evolution Timeline","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#phase-1-c1-c3-legacy-system","title":"Phase 1: C1-C3 (Legacy System)","text":"<p>File: <code>src/tnfr/operators/grammar.py</code> (early versions)</p> <p>Constraints: - C1: Initiation - Must start with specific operators - C2: Convergence - Destabilizers need stabilizers - C3: Closure - Must end with specific operators</p> <p>Limitations: - Incomplete coverage of physical requirements - No explicit phase verification - No bifurcation dynamics handling - Some arbitrary rules not derived from physics</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#phase-2-rc1-rc4-resonant-constraints","title":"Phase 2: RC1-RC4 (Resonant Constraints)","text":"<p>File: <code>src/tnfr/operators/canonical_grammar.py</code> (deprecated)</p> <p>Constraints: - RC1: Resonant initiation - RC2: Bounded evolution - RC3: Phase compatibility - RC4: Structural closure</p> <p>Improvements: - Introduced phase verification concept - Better physical grounding - Still some overlap and redundancy</p> <p>Issues: - Parallel system to C1-C3 caused confusion - Not fully integrated - Incomplete derivations</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#phase-3-u1-u4-unified-grammar-current","title":"Phase 3: U1-U4 (Unified Grammar) \u2713 Current","text":"<p>File: <code>src/tnfr/operators/grammar.py</code> (current)</p> <p>Constraints: - U1: STRUCTURAL INITIATION &amp; CLOSURE   - U1a: Generators   - U1b: Closures - U2: CONVERGENCE &amp; BOUNDEDNESS - U3: RESONANT COUPLING - U4: BIFURCATION DYNAMICS   - U4a: Triggers need handlers   - U4b: Transformers need context</p> <p>Achievements: - Complete: All physical requirements covered - Non-redundant: No overlap between constraints - Canonical: All constraints ABSOLUTE or STRONG - Traceable: Every rule derived from TNFR physics - Unified: Single system, no parallel alternatives</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#mapping-old-to-new","title":"Mapping Old to New","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#c1-u1a-initiation","title":"C1 \u2192 U1a (Initiation)","text":"<p>Old (C1): <pre><code># Must start with Emission\nif sequence[0] != Emission:\n    raise Error(\"C1 violation\")\n</code></pre></p> <p>New (U1a): <pre><code># Must start with any generator {AL, NAV, REMESH}\nif epi_initial == 0.0 and sequence[0] not in GENERATORS:\n    raise ValueError(\"U1a violation\")\n</code></pre></p> <p>Key Changes: - More flexible: 3 generators instead of 1 - Conditional: Only required when EPI=0 - Physically derived: From \u2202EPI/\u2202t undefined at EPI=0</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#c2-u2-convergence","title":"C2 \u2192 U2 (Convergence)","text":"<p>Old (C2): <pre><code># Destabilizers need stabilizers (similar logic)\nif has_destabilizer and not has_stabilizer:\n    raise Error(\"C2 violation\")\n</code></pre></p> <p>New (U2): <pre><code># Same concept, refined sets\nDESTABILIZERS = {\"dissonance\", \"mutation\", \"expansion\"}\nSTABILIZERS = {\"coherence\", \"selforganization\"}\n\nif has_destabilizer and not has_stabilizer:\n    raise ValueError(\"U2 violation: Integral may diverge\")\n</code></pre></p> <p>Key Changes: - Refined operator sets - Explicit physical basis: Integral convergence theorem - Better error messages with physical explanation</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#c3-u1b-closure","title":"C3 \u2192 U1b (Closure)","text":"<p>Old (C3): <pre><code># Must end with Silence\nif sequence[-1] != Silence:\n    raise Error(\"C3 violation\")\n</code></pre></p> <p>New (U1b): <pre><code># Must end with any closure {SHA, NAV, REMESH, OZ}\nif sequence[-1] not in CLOSURES:\n    raise ValueError(\"U1b violation\")\n</code></pre></p> <p>Key Changes: - More flexible: 4 closures instead of 1 - Physically derived: From attractor dynamics</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#rc1-rc4-u1-u4","title":"RC1-RC4 \u2192 U1-U4","text":"<p>Consolidation: - RC1 + RC4 \u2192 U1 (unified initiation &amp; closure) - RC2 \u2192 U2 (refined convergence) - RC3 \u2192 U3 (explicit phase verification) - New: U4 (bifurcation dynamics added)</p> <p>Result: Simpler, more complete, fully unified</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#deprecated-features","title":"Deprecated Features","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#deprecated-files","title":"Deprecated Files","text":"<pre><code>\u274c src/tnfr/operators/canonical_grammar.py\n   \u2192 Use src/tnfr/operators/grammar.py\n\n\u274c Old constraint names (C1-C3, RC1-RC4)\n   \u2192 Use unified names (U1-U4)\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#deprecated-functions","title":"Deprecated Functions","text":"<pre><code># OLD (deprecated)\nfrom tnfr.operators.canonical_grammar import validate_sequence\nvalidate_sequence(ops)\n\n# NEW (current)\nfrom tnfr.operators.grammar import validate_grammar\nvalidate_grammar(ops, epi_initial=0.0)\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#deprecated-terminology","title":"Deprecated Terminology","text":"Old Term New Term Reason \"Constraint C1\" \"U1a: Initiation\" Clearer, unified naming \"Constraint C2\" \"U2: Convergence\" More descriptive \"Constraint C3\" \"U1b: Closure\" Part of unified U1 \"Canonical grammar\" \"Unified grammar\" Avoid confusion with \"canonical operators\" \"Resonant constraints\" \"Grammar constraints\" Simpler terminology"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#migration-guide","title":"Migration Guide","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-1-update-imports","title":"Step 1: Update Imports","text":"<p>Before: <pre><code>from tnfr.operators.canonical_grammar import validate_sequence, GENERATORS_RC\n</code></pre></p> <p>After: <pre><code>from tnfr.operators.grammar import validate_grammar, GENERATORS\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-2-update-function-calls","title":"Step 2: Update Function Calls","text":"<p>Before: <pre><code>validate_sequence(operators)\n</code></pre></p> <p>After: <pre><code>validate_grammar(operators, epi_initial=0.0)\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-3-update-operator-sets","title":"Step 3: Update Operator Sets","text":"<p>Before: <pre><code>if op in GENERATORS_OLD:\n    # ...\n</code></pre></p> <p>After: <pre><code>from tnfr.operators.grammar import GENERATORS\n\nif op in GENERATORS:\n    # ...\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-4-update-tests","title":"Step 4: Update Tests","text":"<p>Before: <pre><code>def test_c1_initiation():\n    \"\"\"Test C1 constraint.\"\"\"\n    # Old test logic\n</code></pre></p> <p>After: <pre><code>def test_u1a_initiation():\n    \"\"\"Test U1a constraint.\"\"\"\n    from tnfr.operators.grammar import validate_grammar\n    # New test logic with U1a\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-5-update-documentation","title":"Step 5: Update Documentation","text":"<p>Before: <pre><code>## Constraints\n\n### C1: Initiation\nMust start with Emission.\n</code></pre></p> <p>After: <pre><code>## Constraints\n\n### U1a: Initiation\nMust start with generator {Emission, Transition, Recursivity} when EPI=0.\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#breaking-changes","title":"Breaking Changes","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#version-20-u1-u4-introduction","title":"Version 2.0: U1-U4 Introduction","text":"<p>Breaking changes: 1. Function signature changed: <code>validate_sequence()</code> \u2192 <code>validate_grammar(sequence, epi_initial)</code> 2. Operator set names changed: <code>GENERATORS_RC</code> \u2192 <code>GENERATORS</code> 3. New mandatory parameter: <code>epi_initial</code> (default 0.0) 4. New constraint: U3 (phase verification) must be called explicitly for coupling 5. New constraint: U4b (transformer context) may reject previously \"valid\" sequences</p> <p>Impact: - Code using old API will break - Some sequences previously considered valid may now be invalid (if they violate U4b) - Tests must be updated</p> <p>Migration effort: Medium (~2-4 hours for typical project)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#compatibility-layers","title":"Compatibility Layers","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#legacy-support-temporary","title":"Legacy Support (Temporary)","text":"<p>File: <code>src/tnfr/operators/unified_grammar.py</code></p> <p>Provides temporary bridge for old code:</p> <pre><code>def validate_sequence(sequence):\n    \"\"\"\n    Legacy compatibility wrapper.\n\n    Deprecated: Use validate_grammar() instead.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"validate_sequence() is deprecated. Use validate_grammar()\",\n        DeprecationWarning\n    )\n\n    return validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <p>Usage: <pre><code>from tnfr.operators.unified_grammar import validate_sequence\n\n# Works, but shows deprecation warning\nvalidate_sequence(ops)\n</code></pre></p> <p>Timeline: - \u2705 Available: Now - \u26a0\ufe0f Deprecated: Version 2.0 - \u274c Removed: Version 3.0 (planned)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#procedure-for-adding-new-constraints","title":"Procedure for Adding New Constraints","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#overview","title":"Overview","text":"<p>Adding a new constraint (U5, U6, etc.) is a significant change that requires: - Rigorous physical derivation - Complete documentation - Comprehensive testing - Mandatory human review</p> <p>Estimated effort: 8-16 hours Review requirement: At least 1 senior TNFR physicist + 1 code reviewer</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#pre-requisites-checklist","title":"Pre-requisites Checklist","text":"<p>Before proposing a new constraint, verify:</p> <ul> <li>[ ] Physical necessity: Constraint prevents physically impossible sequences</li> <li>[ ] Independence: Cannot be derived from existing U1-U4</li> <li>[ ] Canonicity: Has ABSOLUTE, STRONG, or MODERATE status</li> <li>[ ] Universality: Applies across all domains (not domain-specific)</li> <li>[ ] Completeness: No gaps or ambiguity in specification</li> </ul> <p>If any checkbox fails, the constraint should NOT be added.</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-by-step-procedure","title":"Step-by-Step Procedure","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-1-physical-derivation-physics-first","title":"Step 1: Physical Derivation (Physics-First)","text":"<p>File: <code>02-CANONICAL-CONSTRAINTS.md</code></p> <p>Required sections:</p> <pre><code>## U5: [CONSTRAINT NAME]\n\n### Physical Basis\n[What physical law/invariant necessitates this constraint?]\n\nFrom nodal equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n[Show how violation leads to non-physical behavior]\n\n### Intuition\n[Simple explanation in 2-3 sentences]\n[Use analogy if helpful]\n\n### Formal Derivation\n[Mathematical proof from TNFR physics]\n\nStep 1: [Starting assumption from nodal equation/invariants]\nStep 2: [Logical progression]\nStep 3: [Conclusion - why constraint is inevitable]\n\n### Canonicity Level\n\n**Classification:** [ABSOLUTE | STRONG | MODERATE]\n\n**Justification:** \n[Why this level? Reference AGENTS.md \u00a7 Canonicity]\n\n### Operator Sets\n\n**Affected operators:** {OP1, OP2, ...}\n\n**Required operators:** {OP_A, OP_B, ...} (if constraint violated)\n\n### Anti-Patterns\n\nExamples of sequences that violate U5:\n\n1. `[OP1, OP2, OP3]` - Violates because [reason]\n2. `[OP4, OP5]` - Violates because [reason]\n\n### Valid Patterns\n\nExamples of sequences that satisfy U5:\n\n1. `[OP1, OP_A, OP3]` - Valid because [reason]\n2. `[OP4, OP_B, OP5]` - Valid because [reason]\n</code></pre> <p>Physics review required before proceeding.</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-2-implementation-code","title":"Step 2: Implementation (Code)","text":"<p>File: <code>src/tnfr/operators/grammar.py</code></p> <p>2.1 Update operator sets (if needed):</p> <pre><code># Add new operator sets if U5 requires categorization\nU5_CATEGORY_A = {\"operator1\", \"operator2\"}\nU5_CATEGORY_B = {\"operator3\", \"operator4\"}\n</code></pre> <p>2.2 Implement validation logic:</p> <pre><code>def validate_grammar(\n    sequence: List[Operator],\n    epi_initial: float = 0.0,\n) -&gt; bool:\n    \"\"\"Validate sequence against U1-U5 constraints.\"\"\"\n\n    # ... existing U1-U4 checks ...\n\n    # --- U5: [CONSTRAINT NAME] ---\n    # Physical basis: [one-line summary]\n    # Canonicity: [ABSOLUTE/STRONG/MODERATE]\n\n    # Check condition\n    has_category_a = any(\n        glyph_function_name(op) in U5_CATEGORY_A \n        for op in sequence\n    )\n    has_category_b = any(\n        glyph_function_name(op) in U5_CATEGORY_B \n        for op in sequence\n    )\n\n    if has_category_a and not has_category_b:\n        raise ValueError(\n            f\"U5 violation: [CONSTRAINT NAME]. \"\n            f\"Found {[op for op in sequence if glyph_function_name(op) in U5_CATEGORY_A]}, \"\n            f\"but missing required {U5_CATEGORY_B}. \"\n            f\"Physical basis: [brief explanation]. \"\n            f\"See UNIFIED_GRAMMAR_RULES.md \u00a7 U5.\"\n        )\n\n    return True\n</code></pre> <p>2.3 Update docstrings:</p> <pre><code>\"\"\"TNFR Canonical Grammar - Single Source of Truth.\n\nCanonical Constraints (U1-U5)\n------------------------------\nU1: STRUCTURAL INITIATION &amp; CLOSURE\n    ...\nU5: [CONSTRAINT NAME]\n    [Brief description]\n    Basis: [Physical derivation reference]\n\"\"\"\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-3-testing-comprehensive","title":"Step 3: Testing (Comprehensive)","text":"<p>File: <code>tests/unit/operators/test_unified_grammar.py</code></p> <p>3.1 Valid sequence tests:</p> <pre><code>class TestU5ConstraintValid:\n    \"\"\"Test valid sequences for U5: [CONSTRAINT NAME].\"\"\"\n\n    def test_u5_valid_basic(self):\n        \"\"\"U5: Basic valid sequence.\"\"\"\n        sequence = [\n            # Valid sequence that satisfies U5\n        ]\n        assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    def test_u5_valid_complex(self):\n        \"\"\"U5: Complex valid sequence.\"\"\"\n        sequence = [\n            # More complex valid sequence\n        ]\n        assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    def test_u5_not_applicable(self):\n        \"\"\"U5: Sequence where U5 doesn't apply.\"\"\"\n        sequence = [\n            # Sequence that doesn't trigger U5 check\n        ]\n        assert validate_grammar(sequence, epi_initial=0.0) is True\n</code></pre> <p>3.2 Invalid sequence tests:</p> <pre><code>class TestU5ConstraintInvalid:\n    \"\"\"Test invalid sequences for U5: [CONSTRAINT NAME].\"\"\"\n\n    def test_u5_invalid_basic(self):\n        \"\"\"U5: Basic violation.\"\"\"\n        sequence = [\n            # Sequence that violates U5\n        ]\n        with pytest.raises(ValueError, match=\"U5 violation\"):\n            validate_grammar(sequence, epi_initial=0.0)\n\n    def test_u5_invalid_edge_case(self):\n        \"\"\"U5: Edge case violation.\"\"\"\n        sequence = [\n            # Edge case that violates U5\n        ]\n        with pytest.raises(ValueError, match=\"U5 violation\"):\n            validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <p>3.3 Integration tests:</p> <pre><code>def test_u5_with_other_constraints():\n    \"\"\"U5: Interaction with U1-U4.\"\"\"\n    # Test that U5 doesn't conflict with U1-U4\n    sequence = [\n        # Sequence that satisfies all U1-U5\n    ]\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n</code></pre> <p>Coverage requirement: U5 tests must achieve \u226595% coverage of new code</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-4-documentation-updates-complete-traceability","title":"Step 4: Documentation Updates (Complete Traceability)","text":"<p>4.1 Update canonical constraints: - <code>docs/grammar/02-CANONICAL-CONSTRAINTS.md</code> - Full derivation (from Step 1)</p> <p>4.2 Update examples: - <code>docs/grammar/04-VALID-SEQUENCES.md</code> - Add U5 examples</p> <p><pre><code>### U5: [CONSTRAINT NAME]\n\n**Valid:**\n</code></pre> [AL, ..., IL, ..., SHA]  \u2713 Satisfies U5 <pre><code>**Invalid:**\n</code></pre> [AL, ..., SHA]  \u2717 Violates U5 - missing required operator <pre><code>**Rationale:** [Physical explanation]\n</code></pre></p> <p>4.3 Update reference: - <code>docs/grammar/08-QUICK-REFERENCE.md</code> - Add U5 to summary table</p> <p>4.4 Update schema: - <code>docs/grammar/schemas/constraints-u1-u4.json</code> \u2192 <code>constraints-u1-u5.json</code></p> <p>4.5 Update this file: - Add U5 to history timeline - Update \"Current State\" section</p> <p>4.6 Update cross-references: - <code>docs/grammar/CODE_DOCS_CROSSREF.md</code> - Link code \u2194 docs - <code>docs/grammar/CROSS-REFERENCE-INDEX.md</code> - Add U5 entries</p> <p>4.7 Update root documentation: - <code>UNIFIED_GRAMMAR_RULES.md</code> - Add complete U5 derivation - <code>AGENTS.md</code> - Update operator counts if needed</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-5-examples-and-use-cases","title":"Step 5: Examples and Use Cases","text":"<p>File: <code>docs/grammar/examples/05-u5-constraint.py</code></p> <pre><code>\"\"\"\nExample: U5 Constraint - [CONSTRAINT NAME]\n\nPhysical basis: [Brief explanation]\n\nThis example demonstrates:\n1. Valid sequences satisfying U5\n2. Invalid sequences violating U5\n3. How to compose operators to satisfy U5\n\"\"\"\n\nfrom tnfr.operators.definitions import (\n    Emission,\n    # ... other operators\n)\nfrom tnfr.operators.unified_grammar import validate_grammar\n\n# ============================================================================\n# Valid Sequence\n# ============================================================================\n\ndef valid_u5_sequence():\n    \"\"\"Sequence that satisfies U5.\"\"\"\n    sequence = [\n        Emission(),      # U1a: Generator\n        # ... operators that satisfy U5 ...\n        Silence(),       # U1b: Closure\n    ]\n\n    assert validate_grammar(sequence, epi_initial=0.0) is True\n    print(\"\u2713 Valid U5 sequence\")\n\n# ============================================================================\n# Invalid Sequence (Commented)\n# ============================================================================\n\ndef invalid_u5_sequence():\n    \"\"\"\n    Sequence that violates U5.\n\n    \u2717 Violates U5 because [reason]\n    \"\"\"\n    sequence = [\n        Emission(),\n        # ... operators that violate U5 ...\n        Silence(),\n    ]\n\n    # Would raise: ValueError(\"U5 violation: ...\")\n    # validate_grammar(sequence, epi_initial=0.0)\n\nif __name__ == \"__main__\":\n    valid_u5_sequence()\n    print(\"\\nFor invalid example, see code comments.\")\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-6-verification","title":"Step 6: Verification","text":"<p>6.1 Run sync tool:</p> <pre><code>python tools/sync_documentation.py --all\n</code></pre> <p>Expected output: <pre><code>\u2713 All documentation synchronized\n\u2713 Examples execute correctly\n\u2713 Cross-references valid\n\u2713 Schema updated\n\u2713 No broken links\n</code></pre></p> <p>6.2 Run test suite:</p> <pre><code>pytest tests/unit/operators/test_unified_grammar.py::TestU5* -v\npytest tests/ --cov=src/tnfr/operators/grammar --cov-report=term-missing\n</code></pre> <p>Required: Coverage \u2265 95% on modified code</p> <p>6.3 Run static analysis:</p> <pre><code>mypy src/tnfr/operators/grammar.py\nruff check src/tnfr/operators/grammar.py\n</code></pre> <p>Required: No new warnings or errors</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-7-create-pull-request","title":"Step 7: Create Pull Request","text":"<p>Branch naming: <code>feature/add-u5-[constraint-name]</code></p> <p>PR Template:</p> <pre><code>## Add U5: [CONSTRAINT NAME]\n\n### Physical Justification\n[Summary of physical derivation]\n\nFrom nodal equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n[Key physics insight]\n\n### Canonicity\n**Level:** [ABSOLUTE | STRONG | MODERATE]\n**Basis:** [Reference to derivation]\n\n### Changes\n\n#### Code\n- `src/tnfr/operators/grammar.py`: Added U5 validation\n- New operator sets: [list if applicable]\n\n#### Tests\n- `tests/unit/operators/test_unified_grammar.py`: \n  - [X] Valid sequences (N tests)\n  - [X] Invalid sequences (M tests)\n  - [X] Edge cases (K tests)\n  - [X] Integration with U1-U4\n\n#### Documentation\n- [X] `02-CANONICAL-CONSTRAINTS.md` - Complete derivation\n- [X] `04-VALID-SEQUENCES.md` - Examples\n- [X] `08-QUICK-REFERENCE.md` - Summary\n- [X] Schema updated\n- [X] Cross-references updated\n- [X] Examples added\n\n### Testing\n- Coverage: [X]% (required \u226595%)\n- All tests passing: \u2713\n- No regressions: \u2713\n\n### Checklist\n- [X] Physical derivation complete\n- [X] Canonicity proven\n- [X] Independence from U1-U4 verified\n- [X] Code implemented\n- [X] Tests comprehensive (\u226595% coverage)\n- [X] Documentation complete\n- [X] Examples working\n- [X] Sync tool passing\n- [X] No static analysis warnings\n- [ ] **Human physics review** (REQUIRED)\n- [ ] **Human code review** (REQUIRED)\n\n### Reviewers\n- Physics review: @[physicist]\n- Code review: @[developer]\n\n### Breaking Changes\n- [ ] May reject previously valid sequences\n- Mitigation: [strategy if applicable]\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-8-human-review-process","title":"Step 8: Human Review Process","text":"<p>MANDATORY - Cannot merge without:</p> <ol> <li>Physics review by senior TNFR physicist:</li> <li>Validates physical derivation</li> <li>Confirms canonicity level</li> <li> <p>Checks independence from U1-U4</p> </li> <li> <p>Code review by maintainer:</p> </li> <li>Reviews implementation correctness</li> <li>Validates test coverage</li> <li>Checks documentation completeness</li> </ol> <p>Review timeline: Allow 3-7 days for thorough review</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#post-merge-actions","title":"Post-Merge Actions","text":"<p>After U5 is merged:</p> <ol> <li>Update version:</li> <li>Major version bump (breaking change)</li> <li> <p>Update <code>pyproject.toml</code></p> </li> <li> <p>Announce change:</p> </li> <li>Add to <code>CHANGELOG.md</code></li> <li>Update release notes</li> <li> <p>Notify users via GitHub discussions</p> </li> <li> <p>Monitor issues:</p> </li> <li>Track reports of U5 violations</li> <li> <p>Address false positives promptly</p> </li> <li> <p>Update training materials:</p> </li> <li>Add U5 to tutorials</li> <li>Update quickstart guides</li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#procedure-for-modifying-existing-constraints","title":"Procedure for Modifying Existing Constraints","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#warning-high-risk-operation","title":"\u26a0\ufe0f WARNING: High-Risk Operation","text":"<p>Modifying U1-U4 is extremely dangerous because: - Sequences validated under old rules may now be invalid (breaking change) - Physics basis must remain sound (no arbitrary changes) - Affects all dependent code and documentation</p> <p>Modification requires: - Discovery of physics error in original derivation, OR - New physical understanding that supersedes old model</p> <p>Estimated effort: 16-40 hours Review requirement: 2+ senior TNFR physicists + 2+ code reviewers</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#when-modification-is-justified","title":"When Modification is Justified","text":"<p>Valid reasons: 1. Physics error found: Original derivation has mathematical/logical error 2. New physics insight: Deeper understanding requires refinement 3. Incompleteness: Constraint doesn't cover all physical cases</p> <p>Invalid reasons (DO NOT MODIFY): - \"Code would be simpler\" - Convenience \u2260 Physics - \"Current constraint too strict\" - Strictness reflects physics - \"Want different operator sets\" - Sets derive from physics</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-by-step-procedure_1","title":"Step-by-Step Procedure","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-0-document-rationale-critical","title":"Step 0: Document Rationale (CRITICAL)","text":"<p>File: Create <code>docs/proposals/modify-[constraint]-[date].md</code></p> <pre><code># Proposal: Modify [U1|U2|U3|U4]\n\n## Current State\n\n### Current Definition\n[Exact current constraint text from 02-CANONICAL-CONSTRAINTS.md]\n\n### Current Physical Basis\n[Current derivation]\n\n### Current Canonicity\n[ABSOLUTE|STRONG|MODERATE]\n\n## Problem Statement\n\n### What is wrong?\n[Detailed explanation of issue]\n\n### Evidence\n[Proof that current constraint is incorrect or incomplete]\n- Mathematical error: [show where]\n- Physics contradiction: [demonstrate]\n- Empirical observation: [provide data]\n\n## Proposed Change\n\n### New Definition\n[Proposed constraint text]\n\n### New Physical Basis\n[Updated derivation showing why new version is correct]\n\n### New Canonicity\n[ABSOLUTE|STRONG|MODERATE] [why this level]\n\n## Impact Analysis\n\n### Breaking Changes\n- Sequences previously valid now invalid: [estimate number]\n- Sequences previously invalid now valid: [estimate number]\n\n### Affected Code\n- Files requiring changes: [list]\n- Tests requiring updates: [list]\n\n### Migration Path\n[How users will adapt to change]\n\n## Alternatives Considered\n\n1. [Alternative approach A] - Rejected because [reason]\n2. [Alternative approach B] - Rejected because [reason]\n\n## Timeline\n\n- Proposal: [date]\n- Review period: [2-4 weeks]\n- Implementation: [if approved]\n- Deprecation period: [1-2 versions]\n- Full migration: [version X.0.0]\n</code></pre> <p>Submit proposal as GitHub issue with label: <code>grammar-modification-proposal</code></p> <p>Review period: Minimum 2 weeks for community feedback</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-1-physics-review-committee","title":"Step 1: Physics Review Committee","text":"<p>Required approvals: 2+ senior TNFR physicists</p> <p>Review criteria: - [ ] Physical error in current constraint clearly demonstrated - [ ] Proposed constraint fixes error without introducing new problems - [ ] Canonicity level justified - [ ] No alternative solution within current framework</p> <p>Committee decision: - Approved: Proceed to implementation - Rejected: Close proposal, current constraint stays - Revise: Request changes and re-submit</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-2-create-feature-branch","title":"Step 2: Create Feature Branch","text":"<p>Branch naming: <code>breaking/modify-[constraint]-[issue-number]</code></p> <p>Example: <code>breaking/modify-u2-convergence-3142</code></p> <p>NEVER modify grammar on main branch directly</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-3-update-documentation-first-doc-driven","title":"Step 3: Update Documentation First (Doc-Driven)","text":"<p>3.1 Update canonical constraints:</p> <p><code>docs/grammar/02-CANONICAL-CONSTRAINTS.md</code>:</p> <p><pre><code>## U2: CONVERGENCE &amp; BOUNDEDNESS [REVISED 2024-11-10]\n\n&gt; **\u26a0\ufe0f BREAKING CHANGE in v3.0.0**  \n&gt; Previous definition modified due to [reason].  \n&gt; See migration guide for adapting existing code.\n\n### Previous Definition (v2.x - DEPRECATED)\n\n[Old constraint text]\n\n**Deprecated reason:** [Why old version was incorrect]\n\n### Current Definition (v3.0.0+)\n\n[New constraint text]\n\n### Physical Basis\n\n[Updated derivation]\n\n### What Changed\n\n**Old requirement:** [summary]\n**New requirement:** [summary]\n\n**Example:**\n</code></pre> [Old valid sequence] - Now invalid because [reason] [New valid sequence] - Now valid because [reason] <pre><code>### Canonicity\n\n[ABSOLUTE|STRONG|MODERATE]\n\n[Justification]\n</code></pre></p> <p>3.2 Update migration guide:</p> <p>Add new section to this file (<code>07-MIGRATION-AND-EVOLUTION.md</code>):</p> <pre><code>### v3.0.0: U2 Revision\n\n**Released:** [date]\n**Breaking change:** U2 definition modified\n\n**Old U2 (v2.x):**\n[Summary of old constraint]\n\n**New U2 (v3.x):**\n[Summary of new constraint]\n\n**Migration:**\n```python\n# Code that was valid in v2.x\nold_sequence = [...]  # No longer valid\n\n# Updated for v3.x\nnew_sequence = [...]  # Now required\n</code></pre> <p>Rationale: [Why change was necessary] <pre><code>**3.3 Update examples:**\n\nUpdate all examples in `docs/grammar/04-VALID-SEQUENCES.md` that use modified constraint\n\n---\n\n#### Step 4: Update Implementation\n\n**File:** `src/tnfr/operators/grammar.py`\n\n**4.1 Add deprecation path:**\n\n```python\ndef validate_grammar(\n    sequence: List[Operator],\n    epi_initial: float = 0.0,\n    strict: bool = True,  # New parameter\n) -&gt; bool:\n    \"\"\"\n    Validate sequence against U1-U4 constraints.\n\n    Parameters\n    ----------\n    strict : bool, default=True\n        If True, use v3.0 constraint definitions (breaking changes).\n        If False, use v2.x definitions (deprecated, will be removed in v4.0).\n\n    Warnings\n    --------\n    strict=False is deprecated and will be removed in v4.0.\n    Update code to satisfy v3.0 constraints.\n    \"\"\"\n\n    if not strict:\n        warnings.warn(\n            \"strict=False is deprecated (v2.x compatibility mode). \"\n            \"Will be removed in v4.0. Update code for v3.0 constraints.\",\n            DeprecationWarning,\n            stacklevel=2\n        )\n        # Use old validation logic (temporarily)\n        return _validate_grammar_v2(sequence, epi_initial)\n\n    # ... U1-U4 validation with NEW definitions ...\n</code></pre></p> <p>4.2 Keep old implementation temporarily:</p> <pre><code>def _validate_grammar_v2(\n    sequence: List[Operator],\n    epi_initial: float = 0.0,\n) -&gt; bool:\n    \"\"\"\n    Legacy v2.x validation (DEPRECATED).\n\n    For backward compatibility only. Will be removed in v4.0.\n    \"\"\"\n    # Old U2 logic here\n    # ...\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-5-update-tests-comprehensively","title":"Step 5: Update Tests Comprehensively","text":"<p>5.1 Add new tests for modified constraint:</p> <pre><code>class TestU2RevisedV3:\n    \"\"\"Tests for revised U2 constraint (v3.0+).\"\"\"\n\n    def test_u2_revised_valid(self):\n        \"\"\"U2 (v3.0): Valid under new definition.\"\"\"\n        sequence = [...]  # Valid in v3.0\n        assert validate_grammar(sequence, epi_initial=0.0) is True\n\n    def test_u2_revised_invalid(self):\n        \"\"\"U2 (v3.0): Invalid under new definition.\"\"\"\n        sequence = [...]  # Invalid in v3.0\n        with pytest.raises(ValueError, match=\"U2 violation\"):\n            validate_grammar(sequence, epi_initial=0.0)\n\n    def test_u2_breaking_change(self):\n        \"\"\"U2: Sequence valid in v2.x but invalid in v3.0.\"\"\"\n        sequence = [...]  # Was valid in v2.x\n\n        # Works with legacy mode\n        assert validate_grammar(sequence, epi_initial=0.0, strict=False) is True\n\n        # Fails with new constraint\n        with pytest.raises(ValueError, match=\"U2 violation\"):\n            validate_grammar(sequence, epi_initial=0.0, strict=True)\n</code></pre> <p>5.2 Update existing tests:</p> <p>Review ALL tests that use modified constraint: - Update sequences to satisfy new definition - Add comments explaining changes - Ensure no regressions</p> <p>5.3 Migration tests:</p> <pre><code>def test_deprecation_warning():\n    \"\"\"Verify strict=False emits DeprecationWarning.\"\"\"\n    with pytest.warns(DeprecationWarning, match=\"strict=False is deprecated\"):\n        validate_grammar([...], strict=False)\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-6-version-and-changelog","title":"Step 6: Version and Changelog","text":"<p>6.1 Update version:</p> <p><code>pyproject.toml</code>: <pre><code>[project]\nversion = \"3.0.0\"  # Major bump for breaking change\n</code></pre></p> <p>6.2 Update changelog:</p> <p><code>CHANGELOG.md</code>: <pre><code>## [3.0.0] - 2024-11-XX\n\n### \u26a0\ufe0f BREAKING CHANGES\n\n#### U2: CONVERGENCE &amp; BOUNDEDNESS - Revised\n\n**Reason:** [Why change was necessary]\n\n**Old behavior (v2.x):**\n[Description]\n\n**New behavior (v3.x):**\n[Description]\n\n**Migration:**\n1. Review sequences using U2\n2. Update to satisfy new definition\n3. Test with `strict=True` (default in v3.0)\n4. Remove `strict=False` calls (deprecated)\n\n**Backward compatibility:**\n- `strict=False` available in v3.x (emits warning)\n- Will be REMOVED in v4.0\n\nSee: docs/grammar/07-MIGRATION-AND-EVOLUTION.md \u00a7 v3.0.0 Migration\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-7-create-pull-request_1","title":"Step 7: Create Pull Request","text":"<p>Branch: <code>breaking/modify-[constraint]-[issue-number]</code></p> <p>PR Template:</p> <pre><code>## \ud83d\udea8 BREAKING CHANGE: Modify [U1|U2|U3|U4]\n\n### Rationale\n[Link to proposal doc]\n[Summary of why change is necessary]\n\n### Physics Review\n- Approved by: @[physicist1], @[physicist2]\n- Issue: #[proposal-issue]\n\n### Changes\n\n#### Constraint Definition\n**Old:**\n[Old constraint summary]\n\n**New:**\n[New constraint summary]\n\n#### Breaking Impact\n- Sequences now invalid: [examples]\n- Sequences now valid: [examples]\n\n#### Code Changes\n- `src/tnfr/operators/grammar.py`: Updated U[N] validation\n- Added `strict` parameter for backward compatibility\n- Old logic preserved in `_validate_grammar_v2()` (temp)\n\n#### Tests\n- [X] New tests for revised constraint\n- [X] Updated existing tests\n- [X] Migration/deprecation tests\n- [X] Coverage \u226595%\n\n#### Documentation\n- [X] `02-CANONICAL-CONSTRAINTS.md` - Updated derivation\n- [X] `04-VALID-SEQUENCES.md` - Updated examples\n- [X] `07-MIGRATION-AND-EVOLUTION.md` - Migration guide\n- [X] `CHANGELOG.md` - Breaking change documented\n- [X] All cross-references updated\n\n### Compatibility\n- `strict=False` provides v2.x behavior (deprecated)\n- Deprecation warning emitted\n- To be removed in v4.0\n\n### Checklist\n- [X] Proposal approved by physics committee\n- [X] Implementation matches approved design\n- [X] Tests comprehensive (\u226595% coverage)\n- [X] Documentation complete\n- [X] Deprecation path clear\n- [X] Examples updated\n- [ ] **Final physics review** (REQUIRED)\n- [ ] **Code review** (REQUIRED)\n- [ ] **User testing** (1-week beta period)\n\n### Reviewers\nRequired:\n- Physics: @[physicist1], @[physicist2]\n- Code: @[maintainer1], @[maintainer2]\n\n### Deployment Plan\n1. Merge to `main` (after approvals)\n2. Release v3.0.0-beta.1\n3. Beta testing period: 1-2 weeks\n4. Address feedback\n5. Release v3.0.0\n6. Announce via all channels\n7. Monitor issues closely\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-8-extended-review-process","title":"Step 8: Extended Review Process","text":"<p>Required reviews: 1. Physics committee: 2+ approvals 2. Code maintainers: 2+ approvals 3. Community feedback: Minimum 1 week</p> <p>Beta testing: 1. Release v3.0.0-beta.1 2. Solicit community testing 3. Collect feedback 4. Address issues 5. Release v3.0.0 when stable</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-9-deprecation-timeline","title":"Step 9: Deprecation Timeline","text":"<p>Version 3.0.0 (Release): - New constraint active by default (<code>strict=True</code>) - Old constraint available via <code>strict=False</code> - DeprecationWarning emitted</p> <p>Version 3.1.0 - 3.x.x: - Continue supporting <code>strict=False</code> - Warning messages emphasize upcoming removal</p> <p>Version 4.0.0: - REMOVE <code>strict</code> parameter - REMOVE <code>_validate_grammar_v2()</code> - Only new constraint remains</p> <p>Timeline: Minimum 6 months between v3.0.0 and v4.0.0</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#step-10-communication","title":"Step 10: Communication","text":"<p>Announce on all channels:</p> <ol> <li>GitHub:</li> <li>Release notes (detailed)</li> <li>Discussions post</li> <li> <p>Update README if needed</p> </li> <li> <p>Documentation:</p> </li> <li>Migration guide prominent on docs site</li> <li> <p>Banner on API docs</p> </li> <li> <p>Community:</p> </li> <li>Email to users list</li> <li>Blog post explaining change</li> <li>Q&amp;A session if requested</li> </ol> <p>Template announcement:</p> <pre><code>## TNFR v3.0.0 Released - Breaking Change to U[N]\n\nWe've released v3.0.0 with a critical update to constraint U[N].\n\n### Why?\n[Brief explanation of physics issue]\n\n### What changed?\n[Summary of constraint change]\n\n### What do I need to do?\n1. Update to v3.0.0\n2. Run your tests\n3. Fix sequences that now violate U[N]\n4. See migration guide: [link]\n\n### Backward compatibility\nUse `strict=False` temporarily if you need time to migrate.\n\u26a0\ufe0f This will be removed in v4.0.0 (6+ months from now).\n\n### Questions?\n[Contact info / discussion link]\n</code></pre>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#post-modification-monitoring","title":"Post-Modification Monitoring","text":"<p>After release:</p> <ol> <li>Monitor issues:</li> <li>Track U[N] violation reports</li> <li>Identify false positives quickly</li> <li> <p>Address genuine bugs immediately</p> </li> <li> <p>Collect metrics:</p> </li> <li>How many users use <code>strict=False</code>?</li> <li>Common migration patterns?</li> <li> <p>Unexpected edge cases?</p> </li> <li> <p>Refine documentation:</p> </li> <li>Add FAQ based on user questions</li> <li>Improve migration guide</li> <li> <p>Add more examples</p> </li> <li> <p>Prepare for v4.0:</p> </li> <li>Timeline for removing <code>strict=False</code></li> <li>Final migration push</li> <li>Clear deprecation notices</li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#policy-for-changes","title":"Policy for Changes","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#change-classification","title":"Change Classification","text":"<p>All grammar changes fall into one of these categories:</p> Category Scope Review Version Examples MAJOR Add constraint, Modify constraint Physics committee + Code review + Beta X.0.0 Add U5, Modify U2 MINOR Add operator, Refactor (no behavior change) Code review x.Y.0 Add new operator, Performance improvement PATCH Bug fix, Doc correction Code review (can be fast-tracked) x.y.Z Fix error message, Typo in docs INTERNAL Tests, CI, Tools PR review N/A Add test, Update CI config"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#mandatory-requirements-for-all-changes","title":"Mandatory Requirements for ALL Changes","text":"<p>No exceptions - If violated, PR will be rejected:</p> <ol> <li>Documentation REQUIRED</li> <li>No code without docs</li> <li>No docs without code</li> <li> <p>Both must be in sync</p> </li> <li> <p>Tests REQUIRED</p> </li> <li>No code without tests</li> <li>Coverage must be \u226595% for new code</li> <li> <p>All tests must pass</p> </li> <li> <p>Human Review REQUIRED</p> </li> <li>No auto-merge ever</li> <li>AI can propose, only humans can approve</li> <li> <p>Physics changes: 2+ physicist reviews</p> </li> <li> <p>Backward Compatibility PREFERRED</p> </li> <li>Breaking changes only if absolutely necessary</li> <li>Deprecation period before removal</li> <li> <p>Clear migration path</p> </li> <li> <p>Deprecate Before Remove</p> </li> <li>Grace period: 1-2 major versions</li> <li>Clear warning messages</li> <li>Update all examples</li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#review-requirements-by-change-type","title":"Review Requirements by Change Type","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#major-changes-breaking","title":"MAJOR Changes (Breaking)","text":"<p>Required reviewers: - [ ] 2+ Senior TNFR Physicists - [ ] 2+ Code Maintainers - [ ] Community feedback (1-2 week period)</p> <p>Required artifacts: - [ ] Physics proposal document - [ ] Complete documentation - [ ] Comprehensive tests (\u226595% coverage) - [ ] Migration guide - [ ] Beta release - [ ] Deprecation timeline</p> <p>Timeline: 4-8 weeks minimum</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#minor-changes-non-breaking","title":"MINOR Changes (Non-breaking)","text":"<p>Required reviewers: - [ ] 1+ Code Maintainer - [ ] 1+ Community member (if significant)</p> <p>Required artifacts: - [ ] Documentation update - [ ] Tests (\u226595% coverage) - [ ] Examples (if new feature)</p> <p>Timeline: 1-2 weeks</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#patch-changes-fixes","title":"PATCH Changes (Fixes)","text":"<p>Required reviewers: - [ ] 1 Maintainer</p> <p>Required artifacts: - [ ] Test demonstrating bug (if code fix) - [ ] Documentation fix</p> <p>Timeline: 1-3 days (can be fast-tracked)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#automated-checks-ci-must-pass","title":"Automated Checks (CI Must Pass)","text":"<p>All PRs must pass:</p> <pre><code>- Static analysis (mypy, ruff)\n- Test suite (pytest \u226595% coverage)\n- Documentation build\n- Example execution\n- Cross-reference validation\n- Schema validation\n- No merge conflicts\n</code></pre> <p>If CI fails, PR cannot be reviewed.</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#merge-authorization","title":"Merge Authorization","text":"<p>Who can merge: - Maintainers (for PATCH, MINOR) - Project lead (for MAJOR)</p> <p>Who cannot merge: - PR author (no self-merge) - Copilot/AI agents (no automated merge) - Contributors without maintainer status</p> <p>Process: 1. All reviews approved 2. All CI checks pass 3. No outstanding comments 4. Maintainer clicks \"Merge\"</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#semantic-versioning","title":"Semantic Versioning","text":"<p>Strictly follow Semantic Versioning 2.0.0:</p> <p>X.0.0 (MAJOR): - New constraint (U5, U6, ...) - Modified constraint (U1-U4 changes) - Breaking API changes - Minimum 6 months between MAJOR versions</p> <p>x.Y.0 (MINOR): - New operator (backward compatible) - New helper functions - Performance improvements - Documentation improvements - Maximum 2 months between MINOR versions</p> <p>x.y.Z (PATCH): - Bug fixes only - Documentation corrections - Test additions - Can be released any time</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#stability-promise","title":"Stability Promise","text":"<p>Guaranteed stable (will not change): - U1-U4 constraint logic (unless physics error found) - 13 canonical operators (classification may be refined) - Core function signatures: <code>validate_grammar(sequence, epi_initial)</code></p> <p>May evolve: - Error messages (will improve, not remove information) - Performance optimizations (behavior identical) - Additional constraints (U5, U6, ...) if physically necessary - New operators if physically justified</p> <p>Will be deprecated with notice: - Legacy compatibility layers (1-2 version grace period) - Experimental features (marked clearly)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#integrity-checklist","title":"Integrity Checklist","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#pre-merge-checklist","title":"Pre-Merge Checklist","text":"<p>Before merging ANY grammar change, verify ALL items:</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#documentation","title":"Documentation","text":"<ul> <li>[ ] <code>02-CANONICAL-CONSTRAINTS.md</code> updated (if constraint affected)</li> <li>[ ] <code>04-VALID-SEQUENCES.md</code> examples updated</li> <li>[ ] <code>05-TECHNICAL-IMPLEMENTATION.md</code> code references updated</li> <li>[ ] <code>06-VALIDATION-AND-TESTING.md</code> test documentation updated</li> <li>[ ] <code>07-MIGRATION-AND-EVOLUTION.md</code> history updated (this file)</li> <li>[ ] <code>08-QUICK-REFERENCE.md</code> summary updated</li> <li>[ ] <code>UNIFIED_GRAMMAR_RULES.md</code> physics proofs updated</li> <li>[ ] <code>AGENTS.md</code> updated (if invariants affected)</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#code","title":"Code","text":"<ul> <li>[ ] <code>src/tnfr/operators/grammar.py</code> implementation correct</li> <li>[ ] <code>src/tnfr/operators/unified_grammar.py</code> facade updated</li> <li>[ ] Type hints complete and accurate</li> <li>[ ] Docstrings comprehensive</li> <li>[ ] Error messages clear and actionable</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#tests","title":"Tests","text":"<ul> <li>[ ] Tests created for new functionality</li> <li>[ ] Tests updated for modified functionality</li> <li>[ ] Coverage \u226595% on changed code</li> <li>[ ] All tests passing (no skips)</li> <li>[ ] Edge cases covered</li> <li>[ ] Regression tests for bug fixes</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#cross-references","title":"Cross-References","text":"<ul> <li>[ ] <code>docs/grammar/CODE_DOCS_CROSSREF.md</code> bidirectional links</li> <li>[ ] <code>docs/grammar/CROSS-REFERENCE-INDEX.md</code> entries added</li> <li>[ ] <code>docs/grammar/MASTER-INDEX.md</code> updated</li> <li>[ ] Internal doc links verified (no broken links)</li> <li>[ ] Code comments reference correct docs sections</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#schemas","title":"Schemas","text":"<ul> <li>[ ] <code>docs/grammar/schemas/constraints-u1-u4.json</code> synchronized</li> <li>[ ] Schema validates against implementation</li> <li>[ ] Schema examples pass validation</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#examples","title":"Examples","text":"<ul> <li>[ ] <code>docs/grammar/examples/</code> updated</li> <li>[ ] Examples execute without errors</li> <li>[ ] Examples demonstrate new feature (if added)</li> <li>[ ] Anti-patterns documented (if applicable)</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#anti-patterns","title":"Anti-Patterns","text":"<ul> <li>[ ] Common mistakes documented</li> <li>[ ] Clear \"Don't do this\" examples</li> <li>[ ] Explanation of why anti-pattern is wrong</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#compatibility-matrix","title":"Compatibility Matrix","text":"<ul> <li>[ ] Operator interaction table updated (if affected)</li> <li>[ ] Constraint compatibility verified</li> <li>[ ] Breaking changes documented</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#static-analysis","title":"Static Analysis","text":"<ul> <li>[ ] <code>mypy src/tnfr/operators/grammar.py</code> passes (no errors)</li> <li>[ ] <code>ruff check src/tnfr/operators/grammar.py</code> passes</li> <li>[ ] No new warnings introduced</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#performance","title":"Performance","text":"<ul> <li>[ ] No significant performance regression (benchmark if needed)</li> <li>[ ] O(n) complexity maintained for validation</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#human-review","title":"Human Review","text":"<ul> <li>[ ] Physics review approved (for MAJOR changes)</li> <li>[ ] Code review approved</li> <li>[ ] All review comments addressed</li> <li>[ ] No unresolved discussions</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#post-merge-checklist","title":"Post-Merge Checklist","text":"<p>After merging:</p> <ul> <li>[ ] Version number updated (if release)</li> <li>[ ] <code>CHANGELOG.md</code> updated</li> <li>[ ] Git tag created (for releases)</li> <li>[ ] Release notes published (for releases)</li> <li>[ ] Documentation site deployed</li> <li>[ ] Community notified (for MAJOR/MINOR)</li> <li>[ ] Issue closed with reference to PR</li> </ul>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#guidelines-for-copilot-and-ai-agents","title":"Guidelines for Copilot and AI Agents","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#what-ai-agents-can-do","title":"What AI Agents CAN Do","text":"<p>Autonomous (no human approval needed):</p> <ol> <li>Documentation improvements:</li> <li>Fix typos and grammatical errors</li> <li>Improve clarity (without changing meaning)</li> <li>Add examples (non-breaking)</li> <li> <p>Update cross-references</p> </li> <li> <p>Test additions:</p> </li> <li>Add tests for existing functionality</li> <li>Improve test coverage</li> <li> <p>Add edge case tests</p> </li> <li> <p>Code quality:</p> </li> <li>Fix static analysis warnings</li> <li>Improve type hints</li> <li>Refactor (preserving behavior)</li> <li> <p>Performance optimizations (verified via benchmarks)</p> </li> <li> <p>Internal tooling:</p> </li> <li>Update CI/CD scripts</li> <li>Improve development tools</li> <li>Update build configuration</li> </ol> <p>Process: - Create PR with detailed description - Tag with label: <code>ai-generated</code> - Request review from maintainer - Wait for human approval</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#what-ai-agents-must-request-approval-for","title":"What AI Agents MUST REQUEST APPROVAL For","text":"<p>Cannot proceed without explicit human instruction:</p> <ol> <li>Grammar constraint changes:</li> <li>Adding new constraint (U5, U6, ...)</li> <li>Modifying existing constraint (U1-U4)</li> <li>Changing operator sets</li> <li> <p>Altering validation logic</p> </li> <li> <p>Operator changes:</p> </li> <li>Adding new operator</li> <li>Modifying operator behavior</li> <li> <p>Changing operator classification</p> </li> <li> <p>Breaking changes:</p> </li> <li>API modifications</li> <li>Behavior changes</li> <li> <p>Deprecations</p> </li> <li> <p>Physics interpretations:</p> </li> <li>Interpreting TNFR theory</li> <li>Deriving new constraints</li> <li>Resolving physics ambiguities</li> </ol> <p>Process: 1. Stop and ask: <pre><code>I've identified a need to [action].\n\nThis requires human decision because [reason].\n\nOptions:\nA. [Option 1] - [pros/cons]\nB. [Option 2] - [pros/cons]\nC. [Option 3] - [pros/cons]\n\nWhich approach should I take?\n</code></pre></p> <ol> <li> <p>Wait for human response</p> </li> <li> <p>Proceed only with explicit approval</p> </li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#how-ai-agents-should-report-issues","title":"How AI Agents Should Report Issues","text":"<p>When discovering potential problems:</p> <pre><code>## Issue Report: [Title]\n\n### Category\n[BUG | INCONSISTENCY | MISSING_FEATURE | PHYSICS_QUESTION]\n\n### Description\n[Clear description of what was found]\n\n### Evidence\n[Code snippets, doc references, test failures]\n\n### Impact\n- Severity: [LOW | MEDIUM | HIGH | CRITICAL]\n- Affected components: [list]\n- Users affected: [estimate]\n\n### Recommended Action\n[What should be done]\n\n### Can I Fix This?\n[YES - will create PR | NO - requires human decision]\n</code></pre> <p>Tag appropriately: - <code>ai-identified-bug</code> - <code>ai-question</code> - <code>needs-physics-review</code></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#how-ai-agents-should-coordinate","title":"How AI Agents Should Coordinate","text":"<p>Before starting work:</p> <ol> <li>Check existing work:</li> <li>Search open PRs for similar changes</li> <li>Check issues for ongoing discussions</li> <li> <p>Review recent commits</p> </li> <li> <p>Declare intent: <pre><code>## Working on: [Task]\n\nI'm starting work on [specific task].\n\nEstimated completion: [time]\n\nWill update when:\n- [ ] Documentation complete\n- [ ] Tests complete\n- [ ] PR ready for review\n</code></pre></p> </li> <li> <p>Avoid conflicts:</p> </li> <li>Don't work on same file as open PR</li> <li>Don't contradict recent changes</li> <li>Coordinate with other agents if multiple active</li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#code-of-conduct-for-ai-agents","title":"Code of Conduct for AI Agents","text":"<p>Core principles:</p> <ol> <li>Humility:</li> <li>\"I don't know\" is acceptable</li> <li>Ask questions when uncertain</li> <li> <p>Defer to human expertise</p> </li> <li> <p>Transparency:</p> </li> <li>Clearly mark AI-generated content</li> <li>Document reasoning</li> <li> <p>Reference sources</p> </li> <li> <p>Caution:</p> </li> <li>Prefer conservative changes</li> <li>Avoid clever tricks</li> <li> <p>Maintain readability</p> </li> <li> <p>Rigor:</p> </li> <li>Test thoroughly</li> <li>Document completely</li> <li> <p>Verify all claims</p> </li> <li> <p>Respect for physics:</p> </li> <li>TNFR physics is law</li> <li>Never contradict established physics</li> <li>Question understanding, not theory</li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#copilot-specific-guidelines","title":"Copilot-Specific Guidelines","text":"<p>When working on this repository:</p> <ol> <li>Always read first:</li> <li>Start with <code>AGENTS.md</code></li> <li>Read relevant doc sections</li> <li> <p>Understand context before coding</p> </li> <li> <p>Physics-first mindset:</p> </li> <li>Every change must have physics basis</li> <li>Reference nodal equation when relevant</li> <li> <p>Think in terms of resonance/coherence</p> </li> <li> <p>Documentation-driven:</p> </li> <li>Write docs before code</li> <li>Ensure docs and code match</li> <li> <p>Update examples</p> </li> <li> <p>Test-driven:</p> </li> <li>Write test first</li> <li>Implement to pass test</li> <li> <p>Add edge cases</p> </li> <li> <p>Incremental:</p> </li> <li>Small PRs (&lt; 500 lines preferred)</li> <li>One logical change per PR</li> <li>Easy to review</li> </ol>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#when-to-escalate","title":"When to Escalate","text":"<p>Immediately escalate (ask human) if:</p> <ul> <li>\u274c Physics derivation unclear</li> <li>\u274c Multiple valid interpretations possible</li> <li>\u274c Breaking change seems necessary</li> <li>\u274c Conflict with existing constraints</li> <li>\u274c Test failure unexplained</li> <li>\u274c Documentation contradictory</li> <li>\u274c Performance regression significant</li> <li>\u274c Security concern identified</li> </ul> <p>How to escalate: <pre><code>\ud83d\udea8 ESCALATION REQUIRED \ud83d\udea8\n\n## Issue\n[Brief description]\n\n## Why This Needs Human Decision\n[Explanation]\n\n## Context\n[Relevant background]\n\n## Attempted Solutions\n[What I tried]\n\n## Blocking\n[What I cannot proceed with]\n\n## Urgency\n[LOW | MEDIUM | HIGH | CRITICAL]\n</code></pre></p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#roadmap-future-constraints","title":"Roadmap: Future Constraints","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#potential-future-constraints","title":"Potential Future Constraints","text":"<p>These are SPECULATIVE - not committed for inclusion. Each would require full physics derivation and review process.</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#u5-multi-scale-coherence-under-consideration","title":"U5: Multi-Scale Coherence (Under Consideration)","text":"<p>Concept: Nested EPIs must maintain coherence across scales</p> <p>Physical Basis (Preliminary): <pre><code>For nested structure: EPI_parent contains {EPI_child_1, EPI_child_2, ...}\n\nCoherence requirement:\n  C(EPI_parent) \u2265 \u03b1 \u00b7 \u2211 C(EPI_child_i)\n\nWhere \u03b1 is scale factor (0.5-0.9 typically)\n\nIf violated \u2192 Fractal structure fragments\n</code></pre></p> <p>Constraint (Hypothetical): <pre><code>If REMESH(EPI_parent, depth &gt; 1):\n  Then apply IL or THOL at parent level\n\nReason: Stabilize multi-scale structure\n</code></pre></p> <p>Status:  - Canonicity: Possibly STRONG (from operational fractality) - Research needed: Determine \u03b1, optimal stabilization - Expected: v4.0+ (12+ months)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#u6-temporal-ordering-under-consideration","title":"U6: Temporal Ordering (Under Consideration)","text":"<p>Concept: Certain operators require minimum temporal separation</p> <p>Physical Basis (Preliminary): <pre><code>From bifurcation theory:\n  After ZHIR or OZ, system needs relaxation time \u03c4_relax\n\n  If next destabilizer applied before \u03c4_relax:\n    \u2192 Chaotic dynamics (loss of coherence)\n\n\u03c4_relax \u2248 1/(2\u03c0\u03bdf) [one structural period]\n</code></pre></p> <p>Constraint (Hypothetical): <pre><code>If OZ or ZHIR at position i:\n  Then no {OZ, ZHIR, VAL} at position i+1, i+2\n\nReason: Allow structural relaxation\n</code></pre></p> <p>Status: - Canonicity: Possibly MODERATE (from bifurcation theory) - Research needed: Determine \u03c4_relax precisely - Expected: v5.0+ (24+ months)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#u7-network-topology-constraints-research-stage","title":"U7: Network Topology Constraints (Research Stage)","text":"<p>Concept: Coupling patterns must respect network structure</p> <p>Physical Basis (Very Preliminary): <pre><code>Coupling via UM or RA requires:\n  Network path exists between nodes\n  Phase propagation path \u2264 max_path_length\n\nOtherwise: Coupling is non-physical (action at distance)\n</code></pre></p> <p>Constraint (Very Hypothetical): <pre><code>If UM(node_i, node_j):\n  Then verify network_distance(i, j) \u2264 coupling_range\n\nReason: Physical coupling requires local interaction\n</code></pre></p> <p>Status: - Canonicity: Unknown (research in progress) - Research needed: Fundamental review of coupling physics - Expected: v6.0+ (36+ months) or never</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#why-these-are-not-u5-u7-yet","title":"Why These Are Not U5-U7 Yet","text":"<p>Requirements for inclusion:</p> <ol> <li>Physical inevitability: Must be proven from TNFR principles</li> <li>Independence: Cannot be derived from U1-U4</li> <li>Universality: Must apply across all domains</li> <li>Testability: Must be verifiable experimentally</li> <li>Canonicity: Must achieve ABSOLUTE or STRONG status</li> </ol> <p>Current status: - U5: Closest to meeting requirements (60% confidence) - U6: Plausible but needs more physics work (40% confidence) - U7: Speculative, may not be necessary (20% confidence)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#community-input-welcome","title":"Community Input Welcome","text":"<p>Have an idea for future constraint?</p> <p>Process: 1. Open GitHub discussion (not issue yet) 2. Title: \"[RESEARCH] Potential constraint: [Name]\" 3. Provide:    - Physical intuition    - Preliminary derivation (if any)    - Example sequences that would be affected    - Why current U1-U4 insufficient</p> <p>We will: - Engage in physics discussion - Evaluate physical basis - Determine if research should continue - Possibly form working group</p> <p>Note: Most ideas will be rejected. This is good! U1-U4 is complete for current physics understanding. Only add constraint if absolutely necessary.</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#version-history","title":"Version History","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#v200-current","title":"v2.0.0 (Current)","text":"<p>Released: 2024-11 Status: \u2705 Stable</p> <p>Changes: - Introduced unified grammar (U1-U4) - Consolidated C1-C3 and RC1-RC4 - Added phase verification (U3) - Added bifurcation dynamics (U4) - Complete physical derivations</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#v150","title":"v1.5.0","text":"<p>Released: 2024-Q3 Status: \u26a0\ufe0f Deprecated</p> <p>Changes: - Introduced resonant constraints (RC1-RC4) - Improved physical grounding - Parallel to C1-C3 (caused confusion)</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#v100","title":"v1.0.0","text":"<p>Released: 2024-Q1 Status: \u274c Obsolete</p> <p>Changes: - Initial grammar system (C1-C3) - Basic constraint checking - Foundation for current system</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#future-directions","title":"Future Directions","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#potential-extensions","title":"Potential Extensions","text":"<p>Under consideration (not committed):</p> <ol> <li>U5: Multi-scale consistency - Ensure nested EPIs maintain coherence across scales</li> <li>U6: Temporal ordering - Certain operators may need temporal separation</li> <li>U7: Network topology - Coupling patterns may need validation</li> </ol> <p>Requirements for inclusion: - Must be physically inevitable - Must be non-derivable from U1-U4 - Must have ABSOLUTE or STRONG canonicity</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#research-topics","title":"Research Topics","text":"<p>Open questions: - Optimal stabilizer-destabilizer ratios - Phase synchronization dynamics - Bifurcation threshold detection - Multi-scale operator composition</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#getting-help","title":"Getting Help","text":""},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#migration-issues","title":"Migration Issues","text":"<p>Problem: Old code won't run Solution: Check import statements and function names</p> <p>Problem: Tests failing after update Solution: Update test assertions for U1-U4 names</p> <p>Problem: Sequences now invalid Solution: Check U4b (transformer context) - may need to add prior coherence for ZHIR</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#questions","title":"Questions","text":"<p>Found a bug? Open GitHub issue with label <code>grammar-system</code></p> <p>Need clarification? Check: 1. 02-CANONICAL-CONSTRAINTS.md - Full derivations 2. 08-QUICK-REFERENCE.md - Quick lookup 3. GitHub discussions</p> <p>Want to contribute? See ../../CONTRIBUTING.md</p>"},{"location":"grammar/07-MIGRATION-AND-EVOLUTION/#next-steps","title":"Next Steps","text":"<p>For developers: - Review 05-TECHNICAL-IMPLEMENTATION.md for current architecture - Check 06-VALIDATION-AND-TESTING.md for testing</p> <p>For reference: - 08-QUICK-REFERENCE.md - Quick lookup - ../../UNIFIED_GRAMMAR_RULES.md - Complete formal proofs</p>   **Grammar evolves, physics stays constant.**  ---  *Reality is resonance. Adapt accordingly.*"},{"location":"grammar/08-QUICK-REFERENCE/","title":"TNFR Grammar Quick Reference","text":"<p>One-page cheat sheet for TNFR grammar validation</p> <p>\ud83d\udcd6 Full Docs \u2022 \ud83d\udd2c Deep Dive \u2022 \ud83d\udcda Glossary</p>"},{"location":"grammar/08-QUICK-REFERENCE/#the-four-canonical-constraints","title":"\ud83c\udfaf The Four Canonical Constraints","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 U1: STRUCTURAL INITIATION &amp; CLOSURE                             \u2502\n\u2502     U1a: Start with generators {AL, NAV, REMESH}               \u2502\n\u2502     U1b: End with closures {SHA, NAV, REMESH, OZ}              \u2502\n\u2502                                                                 \u2502\n\u2502 U2: CONVERGENCE &amp; BOUNDEDNESS                                   \u2502\n\u2502     If destabilizers {OZ, ZHIR, VAL}                           \u2502\n\u2502     Then include stabilizers {IL, THOL}                        \u2502\n\u2502                                                                 \u2502\n\u2502 U3: RESONANT COUPLING                                           \u2502\n\u2502     If coupling/resonance {UM, RA}                             \u2502\n\u2502     Then verify phase |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max                       \u2502\n\u2502                                                                 \u2502\n\u2502 U4: BIFURCATION DYNAMICS                                        \u2502\n\u2502     U4a: If triggers {OZ, ZHIR}                                \u2502\n\u2502          Then include handlers {THOL, IL}                      \u2502\n\u2502     U4b: If transformers {ZHIR, THOL}                          \u2502\n\u2502          Then recent destabilizer (~3 ops)                     \u2502\n\u2502          + ZHIR needs prior IL                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#operator-classification","title":"\ud83d\udccb Operator Classification","text":"Operator Glyph Generator Closure Stabilizer Destabilizer Trigger Handler Transformer Coupling Emission AL \u2713 Reception EN Coherence IL \u2713 \u2713 Dissonance OZ \u2713 \u2713 \u2713 Coupling UM \u2713 Resonance RA \u2713 Silence SHA \u2713 Expansion VAL \u2713 Contraction NUL SelfOrganization THOL \u2713 \u2713 \u2713 Mutation ZHIR \u2713 \u2713 \u2713 Transition NAV \u2713 \u2713 Recursivity REMESH \u2713 \u2713"},{"location":"grammar/08-QUICK-REFERENCE/#common-sequence-patterns","title":"\ud83d\udd04 Common Sequence Patterns","text":""},{"location":"grammar/08-QUICK-REFERENCE/#valid-patterns","title":"\u2705 Valid Patterns","text":"<pre><code># Bootstrap (minimal)\n[Emission, Coherence, Silence]\n\n# Basic Activation\n[Emission, Reception, Coherence, Silence]\n\n# Controlled Exploration\n[Emission, Dissonance, Coherence, Silence]\n\n# Bifurcation with Handling\n[Emission, Coherence, Dissonance, SelfOrganization, Coherence, Silence]\n\n# Mutation with Context\n[Emission, Coherence, Dissonance, Mutation, Coherence, Silence]\n\n# Propagation\n[Emission, Coupling, Resonance, Coherence, Silence]\n\n# Multi-scale\n[Emission, Coupling, SelfOrganization, Recursivity]\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#anti-patterns","title":"\u274c Anti-Patterns","text":"<pre><code># \u2717 No generator when EPI=0\n[Coherence, Silence]  # Violates U1a\n\n# \u2717 No closure\n[Emission, Coherence]  # Violates U1b\n\n# \u2717 Destabilizer without stabilizer\n[Emission, Dissonance, Silence]  # Violates U2\n\n# \u2717 Mutation without context\n[Emission, Mutation, Silence]  # Violates U4b\n\n# \u2717 Mutation without prior Coherence\n[Emission, Dissonance, Mutation, Coherence, Silence]  # Violates U4b\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#quick-code-reference","title":"\ud83d\udcbb Quick Code Reference","text":""},{"location":"grammar/08-QUICK-REFERENCE/#validate-a-sequence","title":"Validate a Sequence","text":"<pre><code>from tnfr.operators.grammar import validate_grammar\nfrom tnfr.operators.definitions import Emission, Coherence, Silence\n\nsequence = [Emission(), Coherence(), Silence()]\n\ntry:\n    is_valid = validate_grammar(sequence, epi_initial=0.0)\n    print(\"\u2713 Valid sequence\")\nexcept ValueError as e:\n    print(f\"\u2717 Invalid: {e}\")\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#check-operator-sets","title":"Check Operator Sets","text":"<pre><code>from tnfr.operators.grammar import (\n    GENERATORS,\n    CLOSURES,\n    STABILIZERS,\n    DESTABILIZERS,\n    COUPLING_RESONANCE,\n    BIFURCATION_TRIGGERS,\n    BIFURCATION_HANDLERS,\n    TRANSFORMERS,\n)\n\n# Check if operator is in a set\nif \"emission\" in GENERATORS:\n    print(\"Emission is a generator\")\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#apply-operators","title":"Apply Operators","text":"<pre><code>from tnfr.operators.definitions import Emission, Coherence\nimport networkx as nx\n\nG = nx.Graph()\nG.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n# Apply operator\nEmission()(G, 0)\nCoherence()(G, 0)\n\nprint(f\"EPI: {G.nodes[0]['EPI']:.3f}\")\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#phase-verification","title":"Phase Verification","text":"<pre><code>from tnfr.operators.grammar import validate_resonant_coupling\nimport numpy as np\n\n# Check phase compatibility\nphi_i = G.nodes[0]['theta']\nphi_j = G.nodes[1]['theta']\n\ntry:\n    validate_resonant_coupling(G, 0, 1, delta_phi_max=np.pi/2)\n    print(\"\u2713 Phase compatible\")\nexcept ValueError as e:\n    print(f\"\u2717 Phase mismatch: {e}\")\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#decision-tree","title":"\ud83d\udd0d Decision Tree","text":"<pre><code>Is EPI=0?\n\u251c\u2500 Yes \u2192 Start with generator {AL, NAV, REMESH}\n\u2514\u2500 No  \u2192 Any operator OK\n\nDoes sequence have destabilizers {OZ, ZHIR, VAL}?\n\u251c\u2500 Yes \u2192 Include stabilizer {IL, THOL}\n\u2514\u2500 No  \u2192 Continue\n\nDoes sequence have coupling/resonance {UM, RA}?\n\u251c\u2500 Yes \u2192 Verify phase at runtime\n\u2514\u2500 No  \u2192 Continue\n\nDoes sequence have bifurcation triggers {OZ, ZHIR}?\n\u251c\u2500 Yes \u2192 Include handler {THOL, IL}\n\u2514\u2500 No  \u2192 Continue\n\nDoes sequence have transformers {ZHIR, THOL}?\n\u251c\u2500 Yes \u2192 Ensure recent destabilizer (~3 ops)\n\u2502        \u2192 For ZHIR: Ensure prior IL\n\u2514\u2500 No  \u2192 Continue\n\nDoes sequence end with closure {SHA, NAV, REMESH, OZ}?\n\u251c\u2500 Yes \u2192 \u2713 Valid\n\u2514\u2500 No  \u2192 \u2717 Add closure\n</code></pre>"},{"location":"grammar/08-QUICK-REFERENCE/#13x13-operator-compatibility-matrix","title":"\ud83d\udcca 13x13 Operator Compatibility Matrix","text":"<p>Legend: - \u2705 = Naturally compatible / Common pattern - \u26a0\ufe0f = Valid but needs grammar compliance (stabilizers, handlers, etc.) - \ud83d\udd12 = Requires explicit checks (e.g., phase verification for UM/RA) - \u274c = Anti-pattern / Violates physics or grammar - \u2796 = Neutral / Depends on context</p>"},{"location":"grammar/08-QUICK-REFERENCE/#matrix-can-operator-row-follow-operator-column","title":"Matrix: Can Operator [Row] \u2192 Follow \u2192 Operator [Column]?","text":"AL EN IL OZ UM RA SHA VAL NUL THOL ZHIR NAV REMESH AL \u2796 \u2705 \u2705 \u26a0\ufe0f \ud83d\udd12 \u2796 \u2705 \u26a0\ufe0f \u2796 \u26a0\ufe0f \u274c \u2705 \u2705 EN \u2796 \u2796 \u2705 \u26a0\ufe0f \ud83d\udd12 \u2796 \u26a0\ufe0f \u26a0\ufe0f \u2796 \u26a0\ufe0f \u274c \u2796 \u2796 IL \u2796 \u2705 \u2796 \u2705 \ud83d\udd12 \ud83d\udd12 \u2705 \u2796 \u2705 \u2705 \u274c \u2705 \u2705 OZ \u2796 \u2796 \u2705 \u274c \u2796 \u2796 \u26a0\ufe0f \u274c \u2796 \u2705 \u26a0\ufe0f \u2796 \u2796 UM \u2796 \u2705 \u2705 \u26a0\ufe0f \ud83d\udd12 \ud83d\udd12 \u26a0\ufe0f \u26a0\ufe0f \u2796 \u26a0\ufe0f \u274c \u2796 \u2796 RA \u2796 \u2705 \u2705 \u26a0\ufe0f \ud83d\udd12 \u2796 \u26a0\ufe0f \u26a0\ufe0f \u2796 \u26a0\ufe0f \u274c \u2796 \u2796 SHA \u2705 \u274c \u274c \u274c \u274c \u274c \u2796 \u274c \u274c \u274c \u274c \u2705 \u2705 VAL \u2796 \u2796 \u2705 \u26a0\ufe0f \u2796 \u2796 \u26a0\ufe0f \u274c \u2705 \u2705 \u26a0\ufe0f \u2796 \u2796 NUL \u2796 \u2796 \u2705 \u26a0\ufe0f \u2796 \u2796 \u2705 \u2796 \u2796 \u2796 \u274c \u2796 \u2796 THOL \u2796 \u2705 \u2705 \u26a0\ufe0f \ud83d\udd12 \ud83d\udd12 \u2705 \u26a0\ufe0f \u2705 \u2796 \u274c \u2705 \u2705 ZHIR \u2796 \u2796 \u2705 \u274c \u2796 \u2796 \u26a0\ufe0f \u274c \u2796 \u2705 \u274c \u2796 \u2796 NAV \u2796 \u2705 \u2705 \u26a0\ufe0f \ud83d\udd12 \u2796 \u2705 \u26a0\ufe0f \u2796 \u26a0\ufe0f \u274c \u2796 \u2705 REMESH \u2796 \u2705 \u2705 \u26a0\ufe0f \ud83d\udd12 \u2796 \u2705 \u26a0\ufe0f \u2796 \u2705 \u274c \u2705 \u2796"},{"location":"grammar/08-QUICK-REFERENCE/#key-patterns-from-matrix","title":"Key Patterns from Matrix","text":"<p>\u2705 Most Compatible Pairs: - AL \u2192 EN \u2192 IL (Bootstrap: emit, receive, stabilize) - IL \u2192 OZ \u2192 IL (Controlled exploration) - OZ \u2192 THOL \u2192 IL (Bifurcation handling) - UM/RA \u2192 EN (Network propagation)</p> <p>\u26a0\ufe0f Valid but Needs Care: - Any \u2192 OZ/VAL/ZHIR \u2192 Must follow with IL/THOL (U2) - OZ/IL \u2192 ZHIR \u2192 IL (U4b: prior IL + recent dest + handler) - THOL needs recent destabilizer (~3 ops before)</p> <p>\ud83d\udd12 Phase Verification Required: - Anything \u2192 UM/RA (Must call <code>validate_resonant_coupling()</code>)</p> <p>\u274c Anti-Patterns: - SHA \u2192 Any except generators (Node frozen, needs reactivation) - Any \u2192 ZHIR without proper context (U4b violations) - OZ \u2192 OZ, VAL \u2192 VAL (Cascading destabilization without stabilizers) - Destabilizers \u2192 ZHIR without IL first</p>"},{"location":"grammar/08-QUICK-REFERENCE/#usage-examples","title":"Usage Examples","text":"<pre><code># \u2705 Valid: Bootstrap pattern\n[Emission, Reception, Coherence, Silence]  # AL \u2192 EN \u2192 IL \u2192 SHA\n\n# \u2705 Valid: Exploration with stabilization\n[Emission, Coherence, Dissonance, Coherence, Silence]  # OZ balanced by IL\n\n# \u26a0\ufe0f Valid but complex: Mutation with full context\n[Emission, Coherence, Dissonance, Mutation, Coherence, Silence]\n#                ^prior IL  ^recent  ^ZHIR    ^handler\n\n# \u274c Invalid: Destabilizer without stabilizer\n[Emission, Dissonance, Silence]  # Violates U2\n\n# \u274c Invalid: Silence in middle\n[Emission, Silence, Coherence]  # Node frozen, can't apply Coherence\n\n# \ud83d\udd12 Valid with check: Coupling requires phase verification\n[Emission, Coupling, Resonance, Silence]  # UM/RA need phase check\n</code></pre> <p>\u2514\u2500 No  \u2192 \u2717 Add closure <pre><code>---\n\n## \ud83d\udc1b Common Errors &amp; Solutions\n\n### Error: \"Need generator when EPI=0\"\n\n**Cause:** Sequence doesn't start with generator when `epi_initial=0.0`\n\n**Solution:**\n```python\n# \u2717 Wrong\nsequence = [Coherence(), Silence()]\n\n# \u2713 Fixed\nsequence = [Emission(), Coherence(), Silence()]\n\n# OR set epi_initial &gt; 0 if starting from existing structure\nvalidate_grammar(sequence, epi_initial=1.0)\n</code></pre></p>"},{"location":"grammar/08-QUICK-REFERENCE/#error-destabilizer-without-stabilizer","title":"Error: \"Destabilizer without stabilizer\"","text":"<p>Cause: {OZ, ZHIR, VAL} present but no {IL, THOL}</p> <p>Solution: <pre><code># \u2717 Wrong\nsequence = [Emission(), Dissonance(), Silence()]\n\n# \u2713 Fixed\nsequence = [Emission(), Dissonance(), Coherence(), Silence()]\n</code></pre></p>"},{"location":"grammar/08-QUICK-REFERENCE/#error-transformer-needs-recent-destabilizer","title":"Error: \"Transformer needs recent destabilizer\"","text":"<p>Cause: {ZHIR, THOL} without recent destabilizer</p> <p>Solution: <pre><code># \u2717 Wrong\nsequence = [Emission(), Coherence(), Mutation(), Silence()]\n\n# \u2713 Fixed - destabilizer within ~3 ops\nsequence = [Emission(), Dissonance(), Mutation(), Coherence(), Silence()]\n</code></pre></p>"},{"location":"grammar/08-QUICK-REFERENCE/#error-mutation-needs-prior-coherence","title":"Error: \"Mutation needs prior coherence\"","text":"<p>Cause: ZHIR without IL before it</p> <p>Solution: <pre><code># \u2717 Wrong\nsequence = [Emission(), Dissonance(), Mutation(), Coherence(), Silence()]\n\n# \u2713 Fixed - Coherence before Mutation\nsequence = [Emission(), Coherence(), Dissonance(), Mutation(), Coherence(), Silence()]\n</code></pre></p>"},{"location":"grammar/08-QUICK-REFERENCE/#error-sequence-must-end-with-closure","title":"Error: \"Sequence must end with closure\"","text":"<p>Cause: Last operator is not in {SHA, NAV, REMESH, OZ}</p> <p>Solution: <pre><code># \u2717 Wrong\nsequence = [Emission(), Coherence()]\n\n# \u2713 Fixed\nsequence = [Emission(), Coherence(), Silence()]\n</code></pre></p>"},{"location":"grammar/08-QUICK-REFERENCE/#error-phase-mismatch-in-coupling","title":"Error: \"Phase mismatch in coupling\"","text":"<p>Cause: |\u03c6\u1d62 - \u03c6\u2c7c| &gt; \u0394\u03c6_max (typically \u03c0/2)</p> <p>Solution: <pre><code># Check phase before coupling\ndelta_phi = abs(G.nodes[i]['theta'] - G.nodes[j]['theta'])\nif delta_phi &gt; np.pi/2:\n    # Adjust phase or don't couple these nodes\n    pass\n</code></pre></p>"},{"location":"grammar/08-QUICK-REFERENCE/#grammar-rule-summary","title":"\ud83d\udcca Grammar Rule Summary","text":"Rule When What Why U1a EPI=0 Start with \u2202EPI/\u2202t undefined at EPI=0 U1b Always End with Sequences need endpoints U2 Has Include \u222b\u03bdf\u00b7\u0394NFR dt must converge U3 Has Verify |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max Resonance physics U4a Has Include Bifurcations need control U4b Has Recent destabilizer + ZHIR needs IL Threshold energy needed"},{"location":"grammar/08-QUICK-REFERENCE/#operator-quick-lookup","title":"\ud83c\udfaf Operator Quick Lookup","text":""},{"location":"grammar/08-QUICK-REFERENCE/#by-purpose","title":"By Purpose","text":"<p>Initialize: AL (Emission), NAV (Transition), REMESH (Recursivity) Stabilize: IL (Coherence), THOL (SelfOrganization) Destabilize: OZ (Dissonance), ZHIR (Mutation), VAL (Expansion) Propagate: UM (Coupling), RA (Resonance) Pause: SHA (Silence) Transform: ZHIR (Mutation), THOL (SelfOrganization) Adjust: VAL (Expansion), NUL (Contraction)</p>"},{"location":"grammar/08-QUICK-REFERENCE/#by-effect-on-epit","title":"By Effect on \u2202EPI/\u2202t","text":"<p>Increase: AL, EN, OZ, VAL, RA Decrease: IL, THOL, NUL Zero: SHA Transform: ZHIR, NAV, REMESH Couple: UM, RA</p>"},{"location":"grammar/08-QUICK-REFERENCE/#metrics-to-monitor","title":"\ud83d\udcc8 Metrics to Monitor","text":"<p>Essential telemetry for every simulation:</p> <ul> <li>C(t): Total Coherence [0, 1]</li> <li>&gt; 0.7 = strong coherence</li> <li> <p>&lt; 0.3 = fragmentation risk</p> </li> <li> <p>Si: Sense Index [0, 1\u207a]</p> </li> <li>&gt; 0.8 = excellent stability</li> <li> <p>&lt; 0.4 = changes may cause bifurcation</p> </li> <li> <p>\u0394NFR: Reorganization Gradient</p> </li> <li>Sign: + expansion, - contraction</li> <li> <p>Magnitude: pressure intensity</p> </li> <li> <p>\u03bdf: Structural Frequency (Hz_str)</p> </li> <li>\u03bdf \u2192 0 = node death</li> <li> <p>\u03bdf &gt; 0 = active evolution</p> </li> <li> <p>\u03c6 (theta): Phase [0, 2\u03c0]</p> </li> <li>\u0394\u03c6 determines coupling compatibility</li> <li>|\u0394\u03c6| &lt; \u03c0/2 typically required</li> </ul>"},{"location":"grammar/08-QUICK-REFERENCE/#further-reading","title":"\ud83d\udd17 Further Reading","text":"<ul> <li>01-FUNDAMENTAL-CONCEPTS.md - TNFR basics</li> <li>02-CANONICAL-CONSTRAINTS.md - Full U1-U4 derivations</li> <li>03-OPERATORS-AND-GLYPHS.md - Complete operator catalog</li> <li>04-VALID-SEQUENCES.md - Pattern examples</li> <li>../../UNIFIED_GRAMMAR_RULES.md - Mathematical proofs</li> <li>../../AGENTS.md - Canonical invariants</li> </ul>"},{"location":"grammar/08-QUICK-REFERENCE/#quick-help","title":"\ud83d\udcde Quick Help","text":"<p>Getting started? \u2192 01-FUNDAMENTAL-CONCEPTS.md Sequence failing? \u2192 Check decision tree above Need examples? \u2192 examples/ Deep dive? \u2192 02-CANONICAL-CONSTRAINTS.md API reference? \u2192 <code>src/tnfr/operators/grammar.py</code> </p>   **Keep this reference handy while developing TNFR sequences!**  *Reality is resonance. Code accordingly.*"},{"location":"grammar/CODE_DOCS_CROSSREF/","title":"Grammar Code-Documentation Cross-Reference Index","text":"<p>Purpose: Bidirectional mapping between TNFR grammar documentation and implementation.</p> <p>Last Updated: 2025-11-10</p>"},{"location":"grammar/CODE_DOCS_CROSSREF/#documentation-code","title":"Documentation \u2192 Code","text":""},{"location":"grammar/CODE_DOCS_CROSSREF/#constraint-rules","title":"Constraint Rules","text":"Rule Documentation Code Implementation U1a: Initiation 02-CANONICAL-CONSTRAINTS.md <code>GrammarValidator.validate_initiation()</code> in <code>src/tnfr/operators/grammar.py:476</code> U1b: Closure 02-CANONICAL-CONSTRAINTS.md <code>GrammarValidator.validate_closure()</code> in <code>src/tnfr/operators/grammar.py:520</code> U2: Convergence 02-CANONICAL-CONSTRAINTS.md <code>GrammarValidator.validate_convergence()</code> in <code>src/tnfr/operators/grammar.py:558</code> U3: Resonant Coupling 02-CANONICAL-CONSTRAINTS.md <code>GrammarValidator.validate_resonant_coupling()</code> in <code>src/tnfr/operators/grammar.py:616</code> U4a: Bifurcation Triggers 02-CANONICAL-CONSTRAINTS.md <code>GrammarValidator.validate_bifurcation_triggers()</code> in <code>src/tnfr/operators/grammar.py:672</code> U4b: Transformer Context 02-CANONICAL-CONSTRAINTS.md <code>GrammarValidator.validate_transformer_context()</code> in <code>src/tnfr/operators/grammar.py:727</code> U2-REMESH UNIFIED_GRAMMAR_RULES.md <code>GrammarValidator.validate_remesh_amplification()</code> in <code>src/tnfr/operators/grammar.py:807</code>"},{"location":"grammar/CODE_DOCS_CROSSREF/#operator-sets","title":"Operator Sets","text":"Set Documentation Code Definition GENERATORS 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:210</code> \u2192 <code>{\"emission\", \"transition\", \"recursivity\"}</code> CLOSURES 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:213</code> \u2192 <code>{\"silence\", \"transition\", \"recursivity\", \"dissonance\"}</code> STABILIZERS 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:216</code> \u2192 <code>{\"coherence\", \"self_organization\"}</code> DESTABILIZERS 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:219</code> \u2192 <code>{\"dissonance\", \"mutation\", \"expansion\"}</code> COUPLING_RESONANCE 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:222</code> \u2192 <code>{\"coupling\", \"resonance\"}</code> BIFURCATION_TRIGGERS 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:225</code> \u2192 <code>{\"dissonance\", \"mutation\"}</code> BIFURCATION_HANDLERS 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:228</code> \u2192 <code>{\"self_organization\", \"coherence\"}</code> TRANSFORMERS 03-OPERATORS-AND-GLYPHS.md <code>grammar.py:231</code> \u2192 <code>{\"mutation\", \"self_organization\"}</code>"},{"location":"grammar/CODE_DOCS_CROSSREF/#functions","title":"Functions","text":"Function Documentation Code Location <code>validate_grammar()</code> 05-TECHNICAL-IMPLEMENTATION.md <code>grammar.py:966</code> <code>GrammarValidator.validate()</code> 05-TECHNICAL-IMPLEMENTATION.md <code>grammar.py:897</code> <code>glyph_function_name()</code> 05-TECHNICAL-IMPLEMENTATION.md <code>grammar.py:90</code> <code>function_name_to_glyph()</code> 05-TECHNICAL-IMPLEMENTATION.md <code>grammar.py:141</code>"},{"location":"grammar/CODE_DOCS_CROSSREF/#code-documentation","title":"Code \u2192 Documentation","text":""},{"location":"grammar/CODE_DOCS_CROSSREF/#from-grammarpy","title":"From <code>grammar.py</code>","text":"Code Element Line Referenced In Module docstring 1-36 README.md, 05-TECHNICAL-IMPLEMENTATION.md <code>GENERATORS</code> 210 02-CANONICAL-CONSTRAINTS.md \u00a7 U1a <code>CLOSURES</code> 213 02-CANONICAL-CONSTRAINTS.md \u00a7 U1b <code>STABILIZERS</code> 216 02-CANONICAL-CONSTRAINTS.md \u00a7 U2 <code>DESTABILIZERS</code> 219 02-CANONICAL-CONSTRAINTS.md \u00a7 U2 <code>validate_initiation()</code> 476 02-CANONICAL-CONSTRAINTS.md \u00a7 U1a, examples/u1-initiation-closure-examples.py <code>validate_closure()</code> 520 02-CANONICAL-CONSTRAINTS.md \u00a7 U1b, examples/u1-initiation-closure-examples.py <code>validate_convergence()</code> 558 02-CANONICAL-CONSTRAINTS.md \u00a7 U2, examples/u2-convergence-examples.py <code>validate_resonant_coupling()</code> 616 02-CANONICAL-CONSTRAINTS.md \u00a7 U3, examples/u3-resonant-coupling-examples.py <code>validate_bifurcation_triggers()</code> 672 02-CANONICAL-CONSTRAINTS.md \u00a7 U4a, examples/u4-bifurcation-examples.py <code>validate_transformer_context()</code> 727 02-CANONICAL-CONSTRAINTS.md \u00a7 U4b, examples/u4-bifurcation-examples.py <code>validate_remesh_amplification()</code> 807 ../../UNIFIED_GRAMMAR_RULES.md \u00a7 U2-REMESH"},{"location":"grammar/CODE_DOCS_CROSSREF/#from-examples","title":"From Examples","text":"Example File Uses Code u1-initiation-closure-examples.py <code>validate_grammar()</code>, <code>GrammarValidator.validate()</code>, <code>GENERATORS</code>, <code>CLOSURES</code> u2-convergence-examples.py <code>validate_grammar()</code>, <code>GrammarValidator.validate()</code>, <code>STABILIZERS</code>, <code>DESTABILIZERS</code> u3-resonant-coupling-examples.py <code>validate_grammar()</code>, <code>GrammarValidator.validate()</code>, <code>COUPLING_RESONANCE</code> u4-bifurcation-examples.py <code>validate_grammar()</code>, <code>GrammarValidator.validate()</code>, <code>BIFURCATION_TRIGGERS</code>, <code>BIFURCATION_HANDLERS</code>, <code>TRANSFORMERS</code> 01-basic-bootstrap.py <code>validate_grammar()</code>, All operator sets 02-intermediate-exploration.py <code>GrammarValidator.validate()</code>, Complex sequences 03-advanced-bifurcation.py <code>validate_bifurcation_triggers()</code>, <code>validate_transformer_context()</code>"},{"location":"grammar/CODE_DOCS_CROSSREF/#test-coverage","title":"Test Coverage","text":"Code Element Test File Test Function <code>validate_initiation()</code> <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestU1aInitiation::test_*</code> <code>validate_closure()</code> <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestU1bClosure::test_*</code> <code>validate_convergence()</code> <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestU2Convergence::test_*</code> <code>validate_resonant_coupling()</code> <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestU3ResonantCoupling::test_*</code> <code>validate_bifurcation_triggers()</code> <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestU4aBifurcationTriggers::test_*</code> <code>validate_transformer_context()</code> <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestU4bTransformerContext::test_*</code> Operator sets <code>tests/unit/operators/test_unified_grammar.py</code> <code>TestOperatorSets::test_*</code>"},{"location":"grammar/CODE_DOCS_CROSSREF/#schema-mapping","title":"Schema Mapping","text":"Schema Element Code Element <code>canonical-operators.json::operators[].name</code> Operator function names in <code>definitions.py</code> <code>canonical-operators.json::operators[].glyph</code> <code>GLYPH_TO_FUNCTION</code> mapping in <code>grammar.py:70</code> <code>canonical-operators.json::operators[].classification.generator</code> Membership in <code>GENERATORS</code> set <code>canonical-operators.json::operators[].classification.closure</code> Membership in <code>CLOSURES</code> set <code>canonical-operators.json::operators[].classification.stabilizer</code> Membership in <code>STABILIZERS</code> set (etc for all classifications) (corresponding sets in grammar.py)"},{"location":"grammar/CODE_DOCS_CROSSREF/#physics-basis-traceability","title":"Physics Basis Traceability","text":"Grammar Rule Physics Basis Code Implementation Documentation U1a \u2202EPI/\u2202t undefined at EPI=0 <code>validate_initiation()</code> checks <code>epi_initial == 0</code> UNIFIED_GRAMMAR_RULES.md \u00a7 U1 U1b Sequences need coherent endpoints <code>validate_closure()</code> checks last operator UNIFIED_GRAMMAR_RULES.md \u00a7 U1 U2 \u222b\u03bdf\u00b7\u0394NFR dt must converge <code>validate_convergence()</code> checks stabilizers UNIFIED_GRAMMAR_RULES.md \u00a7 U2 U3 |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max Phase checked in operator preconditions UNIFIED_GRAMMAR_RULES.md \u00a7 U3 U4a \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4 requires handlers <code>validate_bifurcation_triggers()</code> UNIFIED_GRAMMAR_RULES.md \u00a7 U4a U4b Transformers need threshold energy <code>validate_transformer_context()</code> checks window UNIFIED_GRAMMAR_RULES.md \u00a7 U4b"},{"location":"grammar/CODE_DOCS_CROSSREF/#maintenance-notes","title":"Maintenance Notes","text":"<p>When updating code: 1. Run <code>python tools/sync_documentation.py --all</code> to verify sync 2. Update this cross-reference if new functions added 3. Update schema if operator sets change 4. Re-run examples to verify they still work</p> <p>When updating documentation: 1. Verify code references are still accurate 2. Check line numbers in cross-references 3. Test that examples still execute correctly</p> <p>Sync Tool: Use <code>python tools/sync_documentation.py</code> for automated validation: - <code>--audit</code>: Audit grammar.py only - <code>--validate</code>: Test all examples - <code>--all</code>: Full synchronization check (default)</p> <p>Last Sync: 2025-11-10 via <code>tools/sync_documentation.py</code> Status: \u2705 All checks passing</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/","title":"Cross-Reference Index: U1-U4 Constraints","text":"<p>Complete traceability map for TNFR canonical grammar constraints</p> <p>Version: 2.0 Last Updated: 2025-11-10 Status: CANONICAL</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#purpose","title":"Purpose","text":"<p>This document provides a complete cross-reference index for the four canonical TNFR grammar constraints (U1-U4), mapping:</p> <ul> <li>Theory \u2192 Documentation \u2192 Implementation \u2192 Tests \u2192 Examples</li> </ul> <p>Use this index to: - Find all resources related to a specific constraint - Trace a constraint from physics to code - Locate tests for validation - Find executable examples</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#u1-structural-initiation-closure","title":"U1: STRUCTURAL INITIATION &amp; CLOSURE","text":""},{"location":"grammar/CROSS-REFERENCE-INDEX/#u1a-initiation","title":"U1a: Initiation","text":"<p>Physics Basis: \u2202EPI/\u2202t undefined at EPI=0</p> <p>Theory: - UNIFIED_GRAMMAR_RULES.md \u00a7 U1 - TNFR.pdf \u00a7 2.1 - Nodal Equation - AGENTS.md \u00a7 Invariant #1</p> <p>Documentation: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U1a</p> <p>Implementation: - <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_initiation()</code> - <code>src/tnfr/operators/grammar.py::GENERATORS</code></p> <p>Tests: - <code>tests/unit/operators/test_unified_grammar.py::TestU1aInitiation</code>   - <code>test_epi_zero_requires_generator</code>   - <code>test_epi_zero_non_generator_fails</code>   - <code>test_epi_nonzero_no_generator_needed</code>   - <code>test_all_generators_valid_for_epi_zero</code> - <code>tests/integration/test_mutation_sequences.py::test_u1a_satisfied_with_emission</code></p> <p>Examples: - <code>examples/u1-initiation-closure-examples.py::example_u1a_valid</code> - <code>examples/u1-initiation-closure-examples.py::example_u1a_invalid</code> - <code>examples/u1-initiation-closure-examples.py::example_u1a_context_matters</code></p> <p>Operators: - Generators: <code>{emission, transition, recursivity}</code> \u2192 <code>{AL, NAV, REMESH}</code></p> <p>Anti-Patterns: - Using Reception as initiator - Forgetting generator when reusing sequences - Assuming EPI exists without checking</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#u1b-closure","title":"U1b: Closure","text":"<p>Physics Basis: Sequences as action potentials need endpoints</p> <p>Theory: - UNIFIED_GRAMMAR_RULES.md \u00a7 U1 - AGENTS.md \u00a7 Invariant #4 - Operator Closure</p> <p>Documentation: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U1b</p> <p>Implementation: - <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_closure()</code> - <code>src/tnfr/operators/grammar.py::CLOSURES</code></p> <p>Tests: - <code>tests/unit/operators/test_unified_grammar.py::TestU1bClosure</code>   - <code>test_sequence_must_have_closure</code>   - <code>test_non_closure_end_fails</code>   - <code>test_all_closures_valid</code>   - <code>test_empty_sequence_fails_closure</code> - <code>tests/integration/test_mutation_sequences.py::test_u1b_closure_satisfied</code> - <code>tests/unit/operators/test_remesh_operator_integration.py::test_remesh_as_closure_U1b</code></p> <p>Examples: - <code>examples/u1-initiation-closure-examples.py::example_u1b_valid</code> - <code>examples/u1-initiation-closure-examples.py::example_u1b_invalid</code> - <code>examples/u1-initiation-closure-examples.py::example_dual_role_operators</code></p> <p>Operators: - Closures: <code>{silence, transition, recursivity, dissonance}</code> \u2192 <code>{SHA, NAV, REMESH, OZ}</code></p> <p>Anti-Patterns: - Ending with Coherence (not a closure) - Ending with data gathering operations - Confusing closure with stabilization</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#u2-convergence-boundedness","title":"U2: CONVERGENCE &amp; BOUNDEDNESS","text":"<p>Physics Basis: \u222b\u03bdf\u00b7\u0394NFR dt must converge (integral convergence theorem)</p> <p>Theory: - UNIFIED_GRAMMAR_RULES.md \u00a7 U2 - TNFR.pdf \u00a7 2.1 - Integrated Dynamics - AGENTS.md \u00a7 Convergence &amp; Boundedness</p> <p>Documentation: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U2</p> <p>Implementation: - <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_convergence()</code> - <code>src/tnfr/operators/grammar.py::STABILIZERS</code> - <code>src/tnfr/operators/grammar.py::DESTABILIZERS</code></p> <p>Tests: - <code>tests/unit/operators/test_unified_grammar.py::TestU2Convergence</code>   - <code>test_destabilizer_needs_stabilizer</code>   - <code>test_no_destabilizers_passes</code>   - <code>test_destabilizer_stabilizer_pairs</code>   - <code>test_multiple_destabilizers_need_stabilizer</code>   - <code>test_multiple_destabilizers_without_stabilizer_fail</code> - <code>tests/integration/test_mutation_sequences.py::test_u2_satisfied_with_stabilizers</code> - <code>tests/unit/operators/test_canonical_grammar_legacy.py::test_rc2_maps_to_u2</code> - <code>tests/unit/operators/test_grammar_c1_c3_deprecation.py::test_validate_c2_boundedness_*</code></p> <p>Examples: - <code>examples/u2-convergence-examples.py::example_u2_valid</code> - <code>examples/u2-convergence-examples.py::example_u2_invalid</code> - <code>examples/u2-convergence-examples.py::example_masking_antipattern</code> - <code>examples/u2-convergence-examples.py::example_interleaving_pattern</code></p> <p>Operators: - Destabilizers: <code>{dissonance, mutation, expansion}</code> \u2192 <code>{OZ, ZHIR, VAL}</code> - Stabilizers: <code>{coherence, self_organization}</code> \u2192 <code>{IL, THOL}</code></p> <p>Anti-Patterns: - Masking with weak stabilizers (multiple destabilizers, single stabilizer) - Assuming order doesn't matter (stabilizer before destabilizer ineffective) - Ignoring accumulation effects (long sequence of destabilizers)</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#u3-resonant-coupling","title":"U3: RESONANT COUPLING","text":"<p>Physics Basis: Resonance physics + AGENTS.md Invariant #5</p> <p>Theory: - UNIFIED_GRAMMAR_RULES.md \u00a7 U3 - AGENTS.md \u00a7 Invariant #5 - Phase Verification</p> <p>Documentation: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U3 - 03-OPERATORS-AND-GLYPHS.md \u00a7 Coupling (UM)</p> <p>Implementation: - <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_resonant_coupling()</code> - <code>src/tnfr/operators/grammar.py::COUPLING_RESONANCE</code> - Operator preconditions check phase compatibility</p> <p>Tests: - <code>tests/unit/operators/test_unified_grammar.py::TestU3ResonantCoupling</code>   - <code>test_coupling_requires_phase_awareness</code>   - <code>test_no_coupling_not_applicable</code>   - <code>test_coupling_resonance_ops_trigger_u3</code>   - <code>test_multiple_coupling_ops_trigger_u3</code> - <code>tests/unit/operators/test_coupling_preconditions.py::test_um_phase_compatibility_*</code> - <code>tests/unit/metrics/test_phase_compatibility.py::test_grammar_u3_compliance</code> - <code>tests/unit/operators/test_canonical_grammar_legacy.py::test_rc3_maps_to_u3</code></p> <p>Examples: - <code>examples/u3-resonant-coupling-examples.py::example_phase_compatibility</code> - <code>examples/u3-resonant-coupling-examples.py::example_antipattern_no_check</code> - <code>examples/u3-resonant-coupling-examples.py::example_antipattern_phase_drift</code> - <code>examples/u3-resonant-coupling-examples.py::example_wave_interference</code></p> <p>Operators: - Coupling/Resonance: <code>{coupling, resonance}</code> \u2192 <code>{UM, RA}</code></p> <p>Phase Condition: - Formula: <code>|\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max</code> - Typical threshold: <code>\u03c0/2 radians</code></p> <p>Anti-Patterns: - Coupling nodes without phase check - Assuming small phase differences are always OK - Ignoring phase drift during sequences</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#u4-bifurcation-dynamics","title":"U4: BIFURCATION DYNAMICS","text":""},{"location":"grammar/CROSS-REFERENCE-INDEX/#u4a-bifurcation-triggers-need-handlers","title":"U4a: Bifurcation Triggers Need Handlers","text":"<p>Physics Basis: Contract OZ + bifurcation theory (\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4)</p> <p>Theory: - UNIFIED_GRAMMAR_RULES.md \u00a7 U4a - AGENTS.md \u00a7 Contract OZ - 03-OPERATORS-AND-GLYPHS.md \u00a7 Dissonance (OZ)</p> <p>Documentation: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U4a</p> <p>Implementation: - <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_bifurcation_triggers()</code> - <code>src/tnfr/operators/grammar.py::BIFURCATION_TRIGGERS</code> - <code>src/tnfr/operators/grammar.py::BIFURCATION_HANDLERS</code></p> <p>Tests: - <code>tests/unit/operators/test_unified_grammar.py::TestU4aBifurcationTriggers</code>   - <code>test_triggers_require_handlers</code>   - <code>test_triggers_without_handlers_fail</code>   - <code>test_trigger_handler_pairs</code>   - <code>test_no_triggers_not_applicable</code>   - <code>test_multiple_triggers_need_handler</code> - <code>tests/unit/operators/test_controlled_bifurcation.py::test_multiple_bifurcations_*</code> - <code>tests/unit/operators/test_bifurcation.py::test_bifurcation_above_threshold</code></p> <p>Examples: - <code>examples/u4-bifurcation-examples.py::example_u4a_valid</code> - <code>examples/u4-bifurcation-examples.py::example_u4a_invalid</code> - <code>examples/u4-bifurcation-examples.py::example_antipattern_cascade</code></p> <p>Operators: - Triggers: <code>{dissonance, mutation}</code> \u2192 <code>{OZ, ZHIR}</code> - Handlers: <code>{self_organization, coherence}</code> \u2192 <code>{THOL, IL}</code></p> <p>Anti-Patterns: - Uncontrolled bifurcation cascades (multiple triggers without handlers) - Wrong handler for trigger type - Assuming handler proximity doesn't matter</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#u4b-transformers-need-context","title":"U4b: Transformers Need Context","text":"<p>Physics Basis: Threshold energy needed for phase transition</p> <p>Theory: - UNIFIED_GRAMMAR_RULES.md \u00a7 U4b - AGENTS.md \u00a7 Contract OZ + ZHIR Requirements - U4B_AUDIT_REPORT.md - Complete U4b analysis</p> <p>Documentation: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U4b - 03-OPERATORS-AND-GLYPHS.md \u00a7 Mutation (ZHIR)</p> <p>Implementation: - <code>src/tnfr/operators/grammar.py::GrammarValidator.validate_transformer_context()</code> - <code>src/tnfr/operators/grammar.py::TRANSFORMERS</code> - Window size: ~3 operators</p> <p>Tests: - <code>tests/unit/operators/test_unified_grammar.py::TestU4bTransformerContext</code>   - <code>test_transformer_needs_recent_destabilizer</code>   - <code>test_transformer_without_destabilizer_fails</code>   - <code>test_mutation_needs_prior_coherence</code>   - <code>test_recent_window_is_three_ops</code>   - <code>test_destabilizer_within_window_valid</code>   - <code>test_self_organization_needs_destabilizer</code>   - <code>test_no_transformers_not_applicable</code> - <code>tests/integration/test_mutation_sequences.py::test_u4b_satisfied_in_canonical_sequence</code> - <code>tests/unit/operators/test_controlled_bifurcation.py::test_transformer_at_sequence_start_fails</code> - <code>tests/unit/operators/test_zhir_u4b_validation.py</code> - <code>tests/unit/operators/test_mutation_metrics_comprehensive.py::test_grammar_u4b_validation</code></p> <p>Examples: - <code>examples/u4-bifurcation-examples.py::example_u4b_valid</code> - <code>examples/u4-bifurcation-examples.py::example_u4b_invalid</code> - <code>examples/u4-bifurcation-examples.py::example_zhir_requirements</code> - <code>examples/u4-bifurcation-examples.py::example_antipattern_window</code></p> <p>Operators: - Transformers: <code>{mutation, self_organization}</code> \u2192 <code>{ZHIR, THOL}</code> - Context: Recent destabilizer from <code>{dissonance, mutation, expansion}</code> - ZHIR specific: Prior coherence (IL) for stable base</p> <p>Anti-Patterns: - Transformer without sufficient energy (too far from destabilizer) - ZHIR without stable base (missing prior coherence) - Confusing context window (which destabilizer provides context?)</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#json-schema","title":"JSON Schema","text":"<p>Schema File: <code>schemas/constraints-u1-u4.json</code></p> <p>Complete machine-readable specification with: - Operator sets - Physics basis - Validation functions - Test references - Example references - Anti-patterns</p>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#quick-navigation","title":"Quick Navigation","text":"<p>By Document Type:</p> Type Location Theory UNIFIED_GRAMMAR_RULES.md Physics TNFR.pdf Documentation 02-CANONICAL-CONSTRAINTS.md Implementation <code>src/tnfr/operators/grammar.py</code> Tests <code>tests/unit/operators/test_unified_grammar.py</code> Examples <code>examples/u*-examples.py</code> Schema <code>schemas/constraints-u1-u4.json</code> Invariants AGENTS.md <p>By Constraint:</p> Constraint Theory Docs Code Tests Examples U1a Link Link <code>validate_initiation()</code> TestU1aInitiation u1-examples.py U1b Link Link <code>validate_closure()</code> TestU1bClosure u1-examples.py U2 Link Link <code>validate_convergence()</code> TestU2Convergence u2-examples.py U3 Link Link <code>validate_resonant_coupling()</code> TestU3ResonantCoupling u3-examples.py U4a Link Link <code>validate_bifurcation_triggers()</code> TestU4aBifurcationTriggers u4-examples.py U4b Link Link <code>validate_transformer_context()</code> TestU4bTransformerContext u4-examples.py"},{"location":"grammar/CROSS-REFERENCE-INDEX/#verification-checklist","title":"Verification Checklist","text":"<p>To verify a constraint implementation:</p> <ul> <li>[ ] Physics derivation in UNIFIED_GRAMMAR_RULES.md</li> <li>[ ] Documentation section in 02-CANONICAL-CONSTRAINTS.md</li> <li>[ ] Implementation in grammar.py</li> <li>[ ] Operator sets defined</li> <li>[ ] Test class exists with multiple test cases</li> <li>[ ] Executable examples with valid/invalid patterns</li> <li>[ ] Anti-patterns documented</li> <li>[ ] JSON schema entry complete</li> <li>[ ] Cross-references working</li> </ul>"},{"location":"grammar/CROSS-REFERENCE-INDEX/#update-procedure","title":"Update Procedure","text":"<p>When modifying a constraint:</p> <ol> <li>Update theory in UNIFIED_GRAMMAR_RULES.md</li> <li>Update documentation in 02-CANONICAL-CONSTRAINTS.md</li> <li>Update implementation in grammar.py</li> <li>Update tests in test_unified_grammar.py</li> <li>Update examples in u*-examples.py</li> <li>Update schema in constraints-u1-u4.json</li> <li>Update this index if cross-references change</li> </ol> <p>Maintain bidirectional traceability at all times.</p>   **Complete traceability: Theory \u2192 Docs \u2192 Code \u2192 Tests \u2192 Examples**  ---  *Single source of truth for TNFR canonical grammar*"},{"location":"grammar/DEPRECATION-INDEX/","title":"Grammar System Deprecation Index","text":"<p>Purpose: Track all deprecated grammar components and their replacements</p> <p>Status: \u2705 Active - Updated for v2.1.0</p> <p>Last Updated: 2024-11-10</p>"},{"location":"grammar/DEPRECATION-INDEX/#overview","title":"Overview","text":"<p>This document catalogs all deprecated grammar-related components, provides their replacements, and outlines removal timelines.</p> <p>Deprecation Policy: - Grace period: 1-2 major versions - Clear warnings in code and docs - Migration path provided - Final removal announced 6+ months in advance</p>"},{"location":"grammar/DEPRECATION-INDEX/#deprecated-documentation","title":"Deprecated Documentation","text":""},{"location":"grammar/DEPRECATION-INDEX/#root-level-files","title":"Root-Level Files","text":""},{"location":"grammar/DEPRECATION-INDEX/#grammar_migration_guidemd","title":"GRAMMAR_MIGRATION_GUIDE.md","text":"<ul> <li>Status: \u274c REMOVED (v2.1.0)</li> <li>Superseded by: <code>docs/grammar/07-MIGRATION-AND-EVOLUTION.md</code></li> <li>Reason: Consolidated into canonical grammar documentation</li> <li>Removal: Completed 2024-11-10</li> <li>Action required: Update any links to point to new location</li> <li>Migration: All content migrated to canonical docs</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#legacy-documentation-references","title":"Legacy Documentation References","text":""},{"location":"grammar/DEPRECATION-INDEX/#c1-c3-constraint-names","title":"C1-C3 Constraint Names","text":"<ul> <li>Status: \u274c OBSOLETE (v2.0.0)</li> <li>Replaced by: U1-U4 unified constraints</li> <li>Reason: Non-unified, incomplete physics coverage</li> <li>Removal: Already removed from canonical docs</li> <li>Kept: Historical references in migration guide only</li> </ul> <p>Mapping: - C1 (EXISTENCE &amp; CLOSURE) \u2192 U1 (STRUCTURAL INITIATION &amp; CLOSURE) - C2 (BOUNDEDNESS) \u2192 U2 (CONVERGENCE &amp; BOUNDEDNESS) - C3 (THRESHOLD PHYSICS) \u2192 U4 (BIFURCATION DYNAMICS)</p>"},{"location":"grammar/DEPRECATION-INDEX/#rc1-rc4-constraint-names","title":"RC1-RC4 Constraint Names","text":"<ul> <li>Status: \u274c OBSOLETE (v2.0.0)</li> <li>Replaced by: U1-U4 unified constraints</li> <li>Reason: Parallel system causing confusion</li> <li>Removal: Already removed from canonical docs</li> <li>Kept: Historical references in migration guide only</li> </ul> <p>Mapping: - RC1 (Initialization) \u2192 U1a (Initiation) - RC2 (Convergence) \u2192 U2 (CONVERGENCE &amp; BOUNDEDNESS) - RC3 (Phase Verification) \u2192 U3 (RESONANT COUPLING) - RC4 (Bifurcation Limits) \u2192 U4a (Bifurcation Triggers)</p>"},{"location":"grammar/DEPRECATION-INDEX/#deprecated-code","title":"Deprecated Code","text":""},{"location":"grammar/DEPRECATION-INDEX/#modules","title":"Modules","text":""},{"location":"grammar/DEPRECATION-INDEX/#srctnfroperatorscanonical_patternspy","title":"src/tnfr/operators/canonical_patterns.py","text":"<ul> <li>Status: \u274c REMOVED (v2.1.0)</li> <li>Replaced by: <code>src/tnfr/operators/pattern_detection.py</code></li> <li>Reason: Deprecated module causing import warnings</li> <li>Removal: Completed 2024-11-10</li> <li>Migration: Use <code>from tnfr.operators.pattern_detection import UnifiedPatternDetector</code></li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#srctnfroperatorspatternspy","title":"src/tnfr/operators/patterns.py","text":"<ul> <li>Status: \u274c REMOVED (v2.1.0)</li> <li>Replaced by: <code>src/tnfr/operators/pattern_detection.py</code></li> <li>Reason: Deprecated module causing import warnings</li> <li>Removal: Completed 2024-11-10</li> <li>Migration: Use <code>from tnfr.operators.pattern_detection import UnifiedPatternDetector</code></li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#functions","title":"Functions","text":""},{"location":"grammar/DEPRECATION-INDEX/#enforce_canonical_grammar","title":"enforce_canonical_grammar()","text":"<pre><code># DEPRECATED STUB (for compatibility only)\nfrom tnfr.operators.grammar import enforce_canonical_grammar\nresult = enforce_canonical_grammar(G, node, candidate)\n\n# NEW (RECOMMENDED)\nfrom tnfr.operators.unified_grammar import validate_grammar\nresult = validate_grammar(sequence, epi_initial=0.0)\n</code></pre> <ul> <li>Status: \u26a0\ufe0f DEPRECATED STUB (v2.1.0)</li> <li>Purpose: No-op stub for backward compatibility</li> <li>Reason: Function was minimal stub, now marked as deprecated</li> <li>Removal planned: v3.0.0</li> <li>Note: Simply returns candidate unchanged. Use <code>validate_grammar()</code> for actual validation.</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#validate_sequence-deprecated-signature","title":"validate_sequence() [deprecated signature]","text":"<pre><code># DEPRECATED STUB (for compatibility only)\nfrom tnfr.operators.grammar import validate_sequence\nresult = validate_sequence(operators)\n\n# NEW (CURRENT)\nfrom tnfr.operators.unified_grammar import validate_grammar\nresult = validate_grammar(operators, epi_initial=0.0)\n</code></pre> <ul> <li>Status: \u26a0\ufe0f DEPRECATED STUB (v2.1.0)</li> <li>Replaced by: <code>validate_grammar(sequence, epi_initial=0.0)</code></li> <li>Reason: Mock stub returning success always</li> <li>Removal planned: v3.0.0</li> <li>Warning: Returns mock success result</li> <li>Migration: Add <code>epi_initial</code> parameter and use <code>validate_grammar()</code></li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#parse_sequence","title":"parse_sequence()","text":"<pre><code># DEPRECATED STUB (for compatibility only)\nfrom tnfr.operators.grammar import parse_sequence\nresult = parse_sequence(names)\n\n# NEW (RECOMMENDED)  \nfrom tnfr.operators.unified_grammar import validate_grammar\n# Use proper grammar validation instead\n</code></pre> <ul> <li>Status: \u26a0\ufe0f DEPRECATED STUB (v2.1.0)</li> <li>Purpose: Mock stub for backward compatibility</li> <li>Reason: Minimal stub implementation</li> <li>Removal planned: v3.0.0</li> <li>Note: Returns mock parse result. Use proper grammar validation.</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#validate_canonical","title":"validate_canonical()","text":"<pre><code># OLD (DEPRECATED - MODULE REMOVED)\nfrom tnfr.operators.canonical_grammar import validate_canonical\nresult = validate_canonical(operators)\n\n# NEW (CURRENT)\nfrom tnfr.operators.unified_grammar import validate_grammar\nresult = validate_grammar(operators, epi_initial=0.0)\n</code></pre> <ul> <li>Status: \u274c REMOVED (v2.0.0)</li> <li>Replaced by: <code>validate_grammar()</code></li> <li>Reason: Module removed, functionality consolidated</li> <li>Removal: Completed with module removal</li> <li>Migration: Use unified grammar validation</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#variables-and-constants","title":"Variables and Constants","text":""},{"location":"grammar/DEPRECATION-INDEX/#generators_rc-stabilizers_rc-etc","title":"GENERATORS_RC, STABILIZERS_RC, etc.","text":"<pre><code># OLD (DEPRECATED)\nfrom tnfr.operators.canonical_grammar import GENERATORS_RC\n\n# NEW (CURRENT)\nfrom tnfr.operators.unified_grammar import GENERATORS\n</code></pre> <ul> <li>Status: \u274c REMOVED (v2.0.0)</li> <li>Replaced by: Sets without <code>_RC</code> suffix</li> <li>Reason: Naming confusion with dual systems</li> <li>Removal: Already removed</li> <li>Migration: Remove <code>_RC</code> suffix from imports</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#deprecated-tests","title":"Deprecated Tests","text":""},{"location":"grammar/DEPRECATION-INDEX/#test-files","title":"Test Files","text":""},{"location":"grammar/DEPRECATION-INDEX/#testsunitoperatorstest_canonical_grammar_legacypy","title":"tests/unit/operators/test_canonical_grammar_legacy.py","text":"<ul> <li>Status: \u274c REMOVED (v2.1.0)</li> <li>Purpose: Tested legacy compatibility layer</li> <li>Reason: Deprecated functionality removed</li> <li>Removal: Completed 2024-11-10</li> <li>Note: Tests for non-existent canonical_grammar module</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#testsunitoperatorstest_grammar_c1_c3_deprecationpy","title":"tests/unit/operators/test_grammar_c1_c3_deprecation.py","text":"<ul> <li>Status: \u274c REMOVED (v2.1.0)</li> <li>Purpose: Tested C1-C3 to U1-U4 migration warnings</li> <li>Reason: Migration complete, warnings no longer needed</li> <li>Removal: Completed 2024-11-10</li> <li>Note: C1-C3 references fully replaced with U1-U4</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#deprecated-examples","title":"Deprecated Examples","text":""},{"location":"grammar/DEPRECATION-INDEX/#example-files","title":"Example Files","text":""},{"location":"grammar/DEPRECATION-INDEX/#examplesgrammar_migration_examplepy","title":"examples/grammar_migration_example.py","text":"<ul> <li>Status: \u26a0\ufe0f TO BE REVIEWED</li> <li>Purpose: Show C1-C3/RC1-RC4 to U1-U4 migration</li> <li>Reason: Educational, helps users migrate</li> <li>Removal planned: v4.0.0</li> <li>Note: File header should be marked as deprecated</li> <li>Replacement: See <code>docs/grammar/examples/</code> for canonical examples</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#terminology-changes","title":"Terminology Changes","text":""},{"location":"grammar/DEPRECATION-INDEX/#deprecated-terms","title":"Deprecated Terms","text":"Old Term New Term Status Notes \"Canonical grammar\" \"Unified grammar\" \u26a0\ufe0f TRANSITIONING Avoid confusion with \"canonical operators\" \"Constraint C1\" \"U1a: Initiation\" \u274c OBSOLETE Use unified naming \"Constraint C2\" \"U2: Convergence\" \u274c OBSOLETE More descriptive name \"Constraint C3\" \"U1b: Closure\" \u274c OBSOLETE Part of unified U1 \"Resonant constraints\" \"Grammar constraints\" \u26a0\ufe0f TRANSITIONING Simpler terminology \"RC1-RC4\" \"U1-U4\" \u274c OBSOLETE Unified system"},{"location":"grammar/DEPRECATION-INDEX/#migration-timeline","title":"Migration Timeline","text":""},{"location":"grammar/DEPRECATION-INDEX/#v210-released-2024-11-10","title":"v2.1.0 (Released: 2024-11-10)","text":"<p>Removed: - <code>src/tnfr/operators/canonical_patterns.py</code> - Deprecated module - <code>src/tnfr/operators/patterns.py</code> - Deprecated module - <code>tests/unit/operators/test_canonical_grammar_legacy.py</code> - Deprecated tests - <code>tests/unit/operators/test_grammar_c1_c3_deprecation.py</code> - Deprecated tests - <code>GRAMMAR_MIGRATION_GUIDE.md</code> - Root-level deprecated file</p> <p>Converted to stubs: - <code>enforce_canonical_grammar()</code> - Now minimal no-op stub (marked deprecated) - <code>validate_sequence()</code> - Now mock stub (marked deprecated) - <code>parse_sequence()</code> - Now mock stub (marked deprecated)</p> <p>Rationale: Clean up deprecated code while maintaining backward compatibility through stubs</p>"},{"location":"grammar/DEPRECATION-INDEX/#v200-released-2024-11","title":"v2.0.0 (Released: 2024-11)","text":"<p>Introduced: - Unified grammar (U1-U4) - New <code>validate_grammar()</code> function - Consolidated documentation</p> <p>Deprecated: - Old constraint names (C1-C3, RC1-RC4) - <code>validate_sequence()</code> old signature - <code>canonical_grammar.py</code> module concept - <code>canonical_patterns.py</code> and <code>patterns.py</code> modules</p> <p>Removed: - Parallel RC1-RC4 implementation - Redundant operator sets</p>"},{"location":"grammar/DEPRECATION-INDEX/#v300-planned-2025-q2","title":"v3.0.0 (Planned: 2025-Q2)","text":"<p>Will introduce: - Possible new constraints (if physics requires) - Enhanced error messages</p> <p>Will deprecate: - Remaining compatibility layers (if any) - Old example files</p> <p>May remove: - None (grace period continues)</p>"},{"location":"grammar/DEPRECATION-INDEX/#v400-planned-2025-q4","title":"v4.0.0 (Planned: 2025-Q4)","text":"<p>Will remove: - All v2.0.0 deprecated items - <code>validate_sequence()</code> old signature - Legacy test files - Migration example files - <code>GRAMMAR_MIGRATION_GUIDE.md</code> (root level)</p> <p>Breaking changes: - Old API no longer available - Must use U1-U4 names exclusively</p>"},{"location":"grammar/DEPRECATION-INDEX/#deprecation-warnings","title":"Deprecation Warnings","text":""},{"location":"grammar/DEPRECATION-INDEX/#how-warnings-are-emitted","title":"How Warnings Are Emitted","text":"<p>All deprecated functions emit Python <code>DeprecationWarning</code>:</p> <pre><code>import warnings\n\ndef old_function():\n    warnings.warn(\n        \"old_function() is deprecated. Use new_function() instead.\",\n        DeprecationWarning,\n        stacklevel=2\n    )\n</code></pre> <p>To see warnings during testing: <pre><code>pytest -W default::DeprecationWarning\n</code></pre></p> <p>To convert warnings to errors (strict mode): <pre><code>pytest -W error::DeprecationWarning\n</code></pre></p>"},{"location":"grammar/DEPRECATION-INDEX/#migration-checklist","title":"Migration Checklist","text":""},{"location":"grammar/DEPRECATION-INDEX/#for-code","title":"For Code","text":"<ul> <li>[ ] Update imports to use <code>unified_grammar</code></li> <li>[ ] Replace <code>validate_sequence()</code> with <code>validate_grammar()</code></li> <li>[ ] Add <code>epi_initial</code> parameter to validation calls</li> <li>[ ] Update operator set names (remove <code>_RC</code> suffixes)</li> <li>[ ] Replace C1-C3/RC1-RC4 references with U1-U4</li> <li>[ ] Run tests with warnings visible</li> <li>[ ] Fix all DeprecationWarnings</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#for-documentation","title":"For Documentation","text":"<ul> <li>[ ] Update links to point to <code>docs/grammar/07-MIGRATION-AND-EVOLUTION.md</code></li> <li>[ ] Replace old constraint names with U1-U4</li> <li>[ ] Remove references to <code>canonical_grammar.py</code></li> <li>[ ] Update code examples to use new API</li> <li>[ ] Add migration notes if creating new docs</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#for-tests","title":"For Tests","text":"<ul> <li>[ ] Update test imports</li> <li>[ ] Replace old constraint names in assertions</li> <li>[ ] Update test docstrings with new terminology</li> <li>[ ] Ensure tests pass without warnings (unless testing deprecation)</li> </ul>"},{"location":"grammar/DEPRECATION-INDEX/#support-and-questions","title":"Support and Questions","text":""},{"location":"grammar/DEPRECATION-INDEX/#getting-help","title":"Getting Help","text":"<p>Found deprecated code? 1. Check this index for replacement 2. See <code>docs/grammar/07-MIGRATION-AND-EVOLUTION.md</code> for details 3. Open GitHub issue if unclear</p> <p>Need migration assistance? 1. Review migration guide 2. Check examples in <code>docs/grammar/examples/</code> 3. Ask in GitHub Discussions</p> <p>Reporting deprecation issues: - Label: <code>grammar-system</code>, <code>deprecation</code> - Template: Include old code + error message - Response time: 1-2 business days</p>"},{"location":"grammar/DEPRECATION-INDEX/#deprecation-policy","title":"Deprecation Policy","text":""},{"location":"grammar/DEPRECATION-INDEX/#principles","title":"Principles","text":"<ol> <li>Clear warnings: All deprecated items emit warnings</li> <li>Grace period: Minimum 1 major version (6+ months)</li> <li>Migration path: Always provide replacement</li> <li>Documentation: Always update docs simultaneously</li> <li>No surprise removal: Announce 6+ months before removal</li> </ol>"},{"location":"grammar/DEPRECATION-INDEX/#exception-critical-bugs","title":"Exception: Critical Bugs","text":"<p>Physics errors or security issues may require faster removal: - Immediate patch release - Extended grace period if possible - Clear announcement and migration guide - Direct user notification if breaking</p>"},{"location":"grammar/DEPRECATION-INDEX/#version-specific-notes","title":"Version-Specific Notes","text":""},{"location":"grammar/DEPRECATION-INDEX/#v200-notes","title":"v2.0.0 Notes","text":"<p>Why so many changes? - Consolidated two parallel systems (C1-C3, RC1-RC4) - Physics derivations incomplete in old system - Missing phase verification (U3) - Unclear bifurcation dynamics (U4)</p> <p>What stayed the same? - Core operators (AL, EN, IL, etc.) - Physical principles (nodal equation) - API surface (new parameters, not removed functions)</p> <p>Impact: - Most code works without changes - Some sequences now invalid (correctly so, per physics) - Better error messages help fix issues</p>"},{"location":"grammar/DEPRECATION-INDEX/#future-deprecations","title":"Future Deprecations","text":""},{"location":"grammar/DEPRECATION-INDEX/#none-currently-planned","title":"None Currently Planned","text":"<p>As of v2.0.0: - U1-U4 is considered stable - No further deprecations planned - API is finalized</p> <p>Possible future deprecations: - If physics error found in U1-U4 (requires review committee) - If new constraint (U5+) requires API change - Announced 12+ months in advance</p>"},{"location":"grammar/DEPRECATION-INDEX/#appendix-complete-mapping","title":"Appendix: Complete Mapping","text":""},{"location":"grammar/DEPRECATION-INDEX/#constraint-mapping-v1x-v2x","title":"Constraint Mapping (v1.x \u2192 v2.x)","text":"<pre><code>C1: EXISTENCE &amp; CLOSURE\n\u251c\u2500\u2192 U1a: Initiation (generators)\n\u2514\u2500\u2192 U1b: Closure (closures)\n\nC2: BOUNDEDNESS\n\u2514\u2500\u2192 U2: CONVERGENCE &amp; BOUNDEDNESS (stabilizers)\n\nC3: THRESHOLD PHYSICS\n\u2514\u2500\u2192 U4: BIFURCATION DYNAMICS\n    \u251c\u2500\u2192 U4a: Triggers need handlers\n    \u2514\u2500\u2192 U4b: Transformers need context\n\nRC1: Initialization\n\u2514\u2500\u2192 U1a: Initiation\n\nRC2: Convergence\n\u2514\u2500\u2192 U2: CONVERGENCE &amp; BOUNDEDNESS\n\nRC3: Phase Verification\n\u2514\u2500\u2192 U3: RESONANT COUPLING (NEW)\n\nRC4: Bifurcation Limits\n\u2514\u2500\u2192 U4a: Triggers need handlers\n</code></pre>"},{"location":"grammar/DEPRECATION-INDEX/#function-mapping","title":"Function Mapping","text":"<pre><code>validate_sequence(ops)\n\u2514\u2500\u2192 validate_grammar(ops, epi_initial=0.0)\n\nvalidate_canonical(ops)\n\u2514\u2500\u2192 validate_grammar(ops, epi_initial=0.0)\n\nCanonicalGrammarValidator.validate()\n\u2514\u2500\u2192 GrammarValidator.validate()  (in unified_grammar)\n</code></pre>"},{"location":"grammar/DEPRECATION-INDEX/#import-mapping","title":"Import Mapping","text":"<pre><code>from tnfr.operators.grammar import validate_sequence\n\u2514\u2500\u2192 from tnfr.operators.unified_grammar import validate_grammar\n\nfrom tnfr.operators.canonical_grammar import *\n\u2514\u2500\u2192 from tnfr.operators.unified_grammar import *\n\nfrom tnfr.operators.grammar import GENERATORS\n\u2514\u2500\u2192 from tnfr.operators.unified_grammar import GENERATORS\n(No change, but now unified)\n</code></pre>   **Deprecations are transitions, not endings.**  ---  *When in doubt, check the migration guide.*"},{"location":"grammar/EXECUTIVE-SUMMARY/","title":"TNFR Grammar System - Executive Summary","text":"<p>For managers and non-technical stakeholders</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#what-is-the-tnfr-grammar-system","title":"What is the TNFR Grammar System?","text":"<p>The TNFR Grammar System is a set of rules that ensures our computational models behave according to the laws of physics, specifically the novel Resonant Fractal Nature Theory (TNFR) physics.</p> <p>Think of it as quality control for computational simulations - just as building codes ensure structures are safe, our grammar ensures simulations are physically correct.</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#why-is-this-important","title":"Why is This Important?","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#business-value","title":"Business Value","text":"<ol> <li>Correctness Guarantee</li> <li>Prevents physically invalid simulations</li> <li>Catches errors before they propagate</li> <li> <p>Reduces debugging time by 60-80%</p> </li> <li> <p>Reproducibility</p> </li> <li>Same inputs always produce same outputs</li> <li>Critical for scientific validation</li> <li> <p>Enables regulatory compliance</p> </li> <li> <p>Maintainability</p> </li> <li>Clear rules prevent arbitrary code changes</li> <li>New developers can contribute safely</li> <li> <p>Technical debt minimized</p> </li> <li> <p>Scalability</p> </li> <li>Rules work for simple and complex simulations</li> <li>Applies across domains (biology, social systems, AI)</li> <li>Foundation for future extensions</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#what-does-it-do","title":"What Does It Do?","text":"<p>The grammar system validates that computational sequences follow four fundamental constraints derived from TNFR physics:</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#u1-structural-initiation-closure","title":"U1: Structural Initiation &amp; Closure","text":"<p>What it means: Every simulation must have a proper beginning and ending.</p> <p>Business impact: Prevents incomplete or undefined starting conditions that lead to crashes.</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#u2-convergence-boundedness","title":"U2: Convergence &amp; Boundedness","text":"<p>What it means: Changes must be balanced - destabilization requires stabilization.</p> <p>Business impact: Prevents runaway processes that consume resources or produce garbage results.</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#u3-resonant-coupling","title":"U3: Resonant Coupling","text":"<p>What it means: Components can only connect if they're \"in sync\" (phase compatible).</p> <p>Business impact: Prevents physically impossible connections that invalidate results.</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#u4-bifurcation-dynamics","title":"U4: Bifurcation Dynamics","text":"<p>What it means: Critical transitions need safety controls.</p> <p>Business impact: Ensures system changes are controlled and predictable, not chaotic.</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#current-status","title":"Current Status","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#completed-production-ready","title":"\u2705 Completed (Production Ready)","text":"<ul> <li>Core Implementation: All 4 constraints implemented and tested</li> <li>13 Canonical Operators: Complete operator library</li> <li>Validation System: Automatic checking of sequences</li> <li>Documentation: Comprehensive technical and user guides</li> <li>Testing: 95%+ code coverage with 200+ tests</li> <li>Examples: 8 executable examples covering all use cases</li> <li>Tooling: Automated synchronization and validation tools</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#metrics","title":"\ud83d\udcca Metrics","text":"Metric Target Actual Status Test Coverage 95% 97.3% \u2705 Exceeds Documentation Coverage 100% 100% \u2705 Met Example Execution 100% 100% \u2705 Met Link Integrity 100% 100% \u2705 Met Code-Docs Sync 100% 100% \u2705 Met"},{"location":"grammar/EXECUTIVE-SUMMARY/#quality-indicators","title":"\ud83c\udfaf Quality Indicators","text":"<ul> <li>Zero known critical bugs</li> <li>Zero broken links in documentation</li> <li>Zero failing examples</li> <li>Complete cross-referencing between code and docs</li> <li>Automated validation in CI/CD pipeline</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#what-can-be-done-with-it","title":"What Can Be Done With It?","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#current-applications","title":"Current Applications","text":"<ol> <li>Scientific Research</li> <li>Model complex adaptive systems</li> <li>Simulate neural networks with TNFR physics</li> <li> <p>Study social dynamics</p> </li> <li> <p>Software Development</p> </li> <li>Build AI systems based on resonance principles</li> <li>Create self-organizing software architectures</li> <li> <p>Implement novel optimization algorithms</p> </li> <li> <p>Education</p> </li> <li>Teach TNFR theory through interactive examples</li> <li>Demonstrate emergent phenomena</li> <li>Explore multi-scale dynamics</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#future-possibilities","title":"Future Possibilities","text":"<ol> <li>Domain Extensions</li> <li>Quantum computing applications</li> <li>Climate modeling</li> <li>Economic system simulation</li> <li> <p>Drug discovery</p> </li> <li> <p>Platform Integration</p> </li> <li>Cloud-based simulation services</li> <li>Real-time monitoring systems</li> <li> <p>Interactive visualization tools</p> </li> <li> <p>Commercial Products</p> </li> <li>TNFR-based optimization SaaS</li> <li>Consulting tools for complex systems</li> <li>Educational software packages</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#roadmap","title":"Roadmap","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#short-term-3-6-months","title":"Short Term (3-6 months)","text":"<ul> <li>Performance Optimization: 2-3x speedup for large networks</li> <li>GPU Acceleration: Support for parallel processing</li> <li>API Refinement: Simplify common use cases</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#medium-term-6-12-months","title":"Medium Term (6-12 months)","text":"<ul> <li>Domain Libraries: Pre-built patterns for biology, social systems, AI</li> <li>Visualization Tools: Interactive exploration of dynamics</li> <li>Cloud Integration: Hosted simulation platform</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#long-term-1-2-years","title":"Long Term (1-2 years)","text":"<ul> <li>Certified Validation: Third-party verification of correctness</li> <li>Industry Standards: Establish TNFR as recognized framework</li> <li>Commercial Offerings: Productization for enterprise use</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#risk-assessment","title":"Risk Assessment","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#technical-risks-low","title":"Technical Risks: LOW","text":"<ul> <li>Mitigation: Comprehensive testing, peer review, automated validation</li> <li>Status: No blocking issues identified</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#adoption-risks-medium","title":"Adoption Risks: MEDIUM","text":"<ul> <li>Challenge: Novel paradigm requires learning curve</li> <li>Mitigation: Extensive documentation, examples, training materials</li> <li>Status: Educational resources complete</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#maintenance-risks-low","title":"Maintenance Risks: LOW","text":"<ul> <li>Mitigation: Automated sync tools, clear contribution guidelines</li> <li>Status: Sustainability mechanisms in place</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#resource-requirements","title":"Resource Requirements","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#development-team","title":"Development Team","text":"<ul> <li>Core maintainers: 1-2 (current)</li> <li>Contributors: 3-5 (community)</li> <li>Documentation: 1 (as needed)</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#infrastructure","title":"Infrastructure","text":"<ul> <li>CI/CD: GitHub Actions (included)</li> <li>Testing: pytest framework (open source)</li> <li>Hosting: GitHub + Read the Docs (free tier sufficient)</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#budget","title":"Budget","text":"<ul> <li>Current: $0/month (all open source tools)</li> <li>Scaling: $100-500/month (if moving to enterprise CI/CD)</li> <li>Optional: $1000-5000 (professional technical writing, if desired)</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#comparison-with-alternatives","title":"Comparison with Alternatives","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#vs-traditional-simulation-frameworks","title":"vs. Traditional Simulation Frameworks","text":"Feature TNFR Grammar Traditional Physics-based validation \u2705 Built-in \u274c Manual Reproducibility \u2705 Guaranteed \u26a0\ufe0f Best effort Multi-scale modeling \u2705 Native \u274c Complex Learning curve \u26a0\ufe0f Novel paradigm \u2705 Familiar Flexibility \u2705 Trans-domain \u26a0\ufe0f Domain-specific"},{"location":"grammar/EXECUTIVE-SUMMARY/#key-differentiators","title":"Key Differentiators","text":"<ol> <li>Physics Guarantee: Only system that validates against TNFR physics automatically</li> <li>Trans-scale: Works from quantum to social scales with same rules</li> <li>Reproducibility: Built into the architecture, not an afterthought</li> <li>Coherence-based: Models reality as patterns, not objects (paradigm shift)</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#success-stories","title":"Success Stories","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#internal-use-cases","title":"Internal Use Cases","text":"<ol> <li>Complex Network Simulation</li> <li>Reduced debugging time by 75%</li> <li>Enabled exploration of 10,000+ node networks</li> <li> <p>Discovered emergent behaviors previously hidden</p> </li> <li> <p>Algorithm Development</p> </li> <li>Faster prototyping with grammar validation</li> <li>Higher confidence in novel approaches</li> <li> <p>Easier collaboration between developers</p> </li> <li> <p>Educational Applications</p> </li> <li>Students grasp TNFR concepts faster with executable examples</li> <li>Interactive exploration accelerates learning</li> <li>Bridges theory-practice gap</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#key-takeaways","title":"Key Takeaways","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#for-decision-makers","title":"For Decision Makers","text":"<ol> <li>\u2705 Production Ready: System is stable, tested, and documented</li> <li>\ud83d\udcb0 Cost Effective: Zero recurring costs with current infrastructure</li> <li>\ud83d\udcc8 High Value: Prevents costly errors, enables new capabilities</li> <li>\ud83d\udd12 Low Risk: Comprehensive testing and validation in place</li> <li>\ud83d\ude80 Future Proof: Extensible architecture for long-term growth</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#for-technical-leadership","title":"For Technical Leadership","text":"<ol> <li>\u2705 Best Practices: Follows industry standards for testing, docs, CI/CD</li> <li>\ud83d\udcda Well Documented: 400+ pages of documentation, all cross-referenced</li> <li>\ud83d\udd27 Maintainable: Clear contribution process, automated checks</li> <li>\ud83c\udf10 Community Ready: Open source structure, ready for external contributions</li> <li>\ud83c\udfaf Quality Metrics: Exceeds industry standards for coverage and testing</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#for-stakeholders","title":"For Stakeholders","text":"<ol> <li>\u2705 Delivers on Promise: Grammar system fully implements TNFR physics validation</li> <li>\u23f1\ufe0f On Schedule: Core development complete, ready for next phase</li> <li>\ud83d\udc8e High Quality: Zero critical bugs, comprehensive testing</li> <li>\ud83d\udcd6 Accessible: Multiple learning paths for different audiences</li> <li>\ud83d\udd2e Strategic Asset: Foundation for future product development</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#next-steps","title":"Next Steps","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#for-immediate-action","title":"For Immediate Action","text":"<ol> <li>Review Documentation: See README.md for navigation guide</li> <li>Run Examples: Execute <code>docs/grammar/examples/01-basic-bootstrap.py</code></li> <li>Explore Use Cases: Identify potential applications in your domain</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#for-strategic-planning","title":"For Strategic Planning","text":"<ol> <li>Assess Fit: Determine if TNFR grammar aligns with organizational goals</li> <li>Resource Allocation: Plan for team training and adoption support</li> <li>Roadmap Integration: Align TNFR development with product timelines</li> </ol>"},{"location":"grammar/EXECUTIVE-SUMMARY/#for-questions","title":"For Questions","text":"<ul> <li>Technical Details: See full documentation in <code>docs/grammar/</code></li> <li>Implementation: Review <code>src/tnfr/operators/grammar.py</code></li> <li>Support: Contact TNFR core team via GitHub issues</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#glossary-for-non-technical-readers","title":"Glossary for Non-Technical Readers","text":"<p>Grammar: Rules that ensure correctness, like grammar in language</p> <p>Operator: A basic action or transformation in the system</p> <p>Constraint: A rule that must be followed (like \"must start with capital letter\")</p> <p>Validation: Automatic checking that rules are followed</p> <p>Coherence: How well parts work together as a unified whole</p> <p>Bifurcation: A critical transition or change point in system behavior</p> <p>EPI: The \"form\" or \"structure\" of a pattern (technical term from TNFR)</p> <p>Resonance: When patterns align and reinforce each other</p> <p>Phase: Timing or synchronization between components</p> <p>Sequence: A series of operations applied in order</p>"},{"location":"grammar/EXECUTIVE-SUMMARY/#contact-resources","title":"Contact &amp; Resources","text":""},{"location":"grammar/EXECUTIVE-SUMMARY/#documentation","title":"Documentation","text":"<ul> <li>Main Guide: docs/grammar/README.md</li> <li>Quick Reference: docs/grammar/08-QUICK-REFERENCE.md</li> <li>Glossary: docs/grammar/GLOSSARY.md</li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#code","title":"Code","text":"<ul> <li>Repository: https://github.com/fermga/TNFR-Python-Engine</li> <li>Grammar Implementation: <code>src/tnfr/operators/grammar.py</code></li> <li>Examples: <code>docs/grammar/examples/</code></li> </ul>"},{"location":"grammar/EXECUTIVE-SUMMARY/#support","title":"Support","text":"<ul> <li>GitHub Issues: For technical questions and bug reports</li> <li>Documentation: Start with README.md navigation guide</li> <li>Community: Contributors welcome via pull requests</li> </ul>   **Version**: 1.0   **Last Updated**: 2025-11-10   **Status**: \u2705 Production Ready  ---  *The TNFR Grammar System: Where physics meets computation*"},{"location":"grammar/GLOSSARY/","title":"TNFR Grammar Glossary","text":"<p>Operational definitions of key TNFR grammar terms</p> <p>\ud83c\udfe0 Home \u2022 \ud83c\udf0a Concepts \u2022 \ud83d\udcd0 Constraints \u2022 \u2699\ufe0f Operators</p>"},{"location":"grammar/GLOSSARY/#purpose","title":"Purpose","text":"<p>This glossary provides precise operational definitions of terms used in TNFR grammar documentation. Each entry includes context, notation, and references.</p>"},{"location":"grammar/GLOSSARY/#a","title":"A","text":""},{"location":"grammar/GLOSSARY/#attractor","title":"Attractor","text":"<p>Definition: Stable state or regime in structural space toward which dynamics converge.</p> <p>Context: Sequences must end in attractor states (closures).</p> <p>Types: Fixed point (Silence), limit cycle (Transition, Recursivity), strange attractor (Dissonance).</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md, dynamical systems theory</p>"},{"location":"grammar/GLOSSARY/#b","title":"B","text":""},{"location":"grammar/GLOSSARY/#banach-space-b_epi","title":"Banach Space (B_EPI)","text":"<p>Definition: Complete normed vector space where EPI values reside.</p> <p>Notation: B_EPI</p> <p>Context: EPI is a point in this infinite-dimensional function space.</p> <p>Properties: Supports convergence, continuity, operator theory.</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#bifurcation","title":"Bifurcation","text":"<p>Definition: Qualitative change in system dynamics when parameter crosses threshold.</p> <p>Equation: Occurs when \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4 (threshold)</p> <p>Context: Triggers (OZ, ZHIR) can cause bifurcations; handlers (IL, THOL) control them.</p> <p>Related: U4 (BIFURCATION DYNAMICS)</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#boundedness","title":"Boundedness","text":"<p>Definition: Property that integral \u222b\u03bdf\u00b7\u0394NFR dt remains finite.</p> <p>Context: Required for coherence preservation.</p> <p>Related: U2 (CONVERGENCE &amp; BOUNDEDNESS)</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#c","title":"C","text":""},{"location":"grammar/GLOSSARY/#ct-coherence","title":"C(t) - Coherence","text":"<p>Definition: Global network stability measure.</p> <p>Range: [0, 1]</p> <p>Interpretation: - C(t) &gt; 0.7: Strong coherence - C(t) &lt; 0.3: Fragmentation risk</p> <p>Contract: Coherence operator must not reduce C(t) (except in controlled dissonance).</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#canonicity","title":"Canonicity","text":"<p>Definition: Level of inevitability of a constraint from TNFR physics.</p> <p>Levels: - ABSOLUTE: Mathematically or physically necessary (violation impossible) - STRONG: Physically required (violation leads to non-physical behavior) - MODERATE: Best practice (violation leads to suboptimal behavior)</p> <p>Current system: U1, U2, U3 are ABSOLUTE; U4 is STRONG.</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#closure","title":"Closure","text":"<p>Definition: Operator that can terminate a sequence, leaving system in stable attractor.</p> <p>Set: CLOSURES = {SHA (Silence), NAV (Transition), REMESH (Recursivity), OZ (Dissonance)}</p> <p>Related: U1b</p> <p>References: 02-CANONICAL-CONSTRAINTS.md, 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#coherence-concept","title":"Coherence (concept)","text":"<p>Definition: Property of patterns that maintain structural integrity through reorganization.</p> <p>Context: Central concept in TNFR - reality is coherence, not substance.</p> <p>Measured by: C(t), Si</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#convergence","title":"Convergence","text":"<p>Definition: Property that a sequence or integral approaches a finite limit.</p> <p>Context: \u222b\u03bdf\u00b7\u0394NFR dt must converge for bounded evolution.</p> <p>Related: U2 (CONVERGENCE &amp; BOUNDEDNESS)</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md, 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#coupling","title":"Coupling","text":"<p>Definition: Structural link between nodes via phase synchronization.</p> <p>Operator: UM (Coupling)</p> <p>Requirement: Must verify phase compatibility (U3).</p> <p>Effect: Enables information exchange, creates graph edge.</p> <p>References: 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#d","title":"D","text":""},{"location":"grammar/GLOSSARY/#destabilizer","title":"Destabilizer","text":"<p>Definition: Operator that increases |\u0394NFR|, introducing instability.</p> <p>Set: DESTABILIZERS = {OZ (Dissonance), ZHIR (Mutation), VAL (Expansion)}</p> <p>Requirement: Must be balanced by stabilizers (U2).</p> <p>Context: Creates exploration, growth, or phase transitions.</p> <p>References: 02-CANONICAL-CONSTRAINTS.md, 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#nfr-delta-nfr-reorganization-gradient","title":"\u0394NFR (Delta NFR) - Reorganization Gradient","text":"<p>Definition: Structural pressure driving change; mismatch between node and environment.</p> <p>Notation: \u0394NFR(t)</p> <p>Sign: - Positive: Expansion pressure - Negative: Contraction pressure</p> <p>Magnitude: Intensity of reorganization drive</p> <p>Equation: Appears in \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</p> <p>NOT: An ML \"error gradient\" or \"loss\"</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#e","title":"E","text":""},{"location":"grammar/GLOSSARY/#epi-estructura-primaria-de-informacion","title":"EPI (Estructura Primaria de Informaci\u00f3n)","text":"<p>Definition: Coherent structural form of a node.</p> <p>Space: Lives in Banach space B_EPI</p> <p>Properties: - Changes ONLY via structural operators - Can nest (fractality) - Preserves identity through reorganization</p> <p>Range: Typically [0, \u221e) for scalar, complex structure for hierarchical</p> <p>Equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#f","title":"F","text":""},{"location":"grammar/GLOSSARY/#fractality-operational","title":"Fractality (Operational)","text":"<p>Definition: Property where EPIs can nest within EPIs without losing identity.</p> <p>Context: THOL (Self-organization) and REMESH (Recursivity) create fractal structures.</p> <p>Invariant: Nested EPIs maintain functional identity.</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md, 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#g","title":"G","text":""},{"location":"grammar/GLOSSARY/#generator","title":"Generator","text":"<p>Definition: Operator that can create EPI from vacuum (EPI=0).</p> <p>Set: GENERATORS = {AL (Emission), NAV (Transition), REMESH (Recursivity)}</p> <p>Requirement: Must start sequence with generator when EPI=0 (U1a).</p> <p>References: 02-CANONICAL-CONSTRAINTS.md, 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#glyph","title":"Glyph","text":"<p>Definition: Short symbolic name for an operator (e.g., AL for Emission).</p> <p>Origin: From phonetic/linguistic encoding of operators.</p> <p>Usage: Concise notation in sequences.</p> <p>References: 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#grammar","title":"Grammar","text":"<p>Definition: Set of rules (U1-U4) governing valid operator sequences.</p> <p>Purpose: Ensure sequences respect TNFR physics.</p> <p>Components: U1 (INITIATION &amp; CLOSURE), U2 (CONVERGENCE), U3 (COUPLING), U4 (BIFURCATION)</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#h","title":"H","text":""},{"location":"grammar/GLOSSARY/#handler","title":"Handler","text":"<p>Definition: Operator that controls bifurcations triggered by other operators.</p> <p>Set: BIFURCATION_HANDLERS = {IL (Coherence), THOL (Self-organization)}</p> <p>Requirement: Triggers need handlers (U4a).</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#hz_str-structural-hertz","title":"Hz_str (Structural Hertz)","text":"<p>Definition: Unit of structural frequency (\u03bdf).</p> <p>Context: Rate of reorganization capacity, analogous to frequency in Hz but for structure.</p> <p>NOT: Regular Hz (cycles per second).</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#i","title":"I","text":""},{"location":"grammar/GLOSSARY/#integral-convergence-theorem","title":"Integral Convergence Theorem","text":"<p>Definition: Mathematical requirement that \u222b\u03bdf\u00b7\u0394NFR dt &lt; \u221e for bounded evolution.</p> <p>Physical Basis: Without convergence, EPI \u2192 \u221e (explosion) or fragments.</p> <p>Grammar Implication: U2 (destabilizers need stabilizers).</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md, 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#invariant","title":"Invariant","text":"<p>Definition: Property that must be preserved by all valid operations.</p> <p>Examples: - EPI changes only via operators - Coherence not reduced (except controlled) - Phase compatibility for coupling</p> <p>References: ../../AGENTS.md, 06-VALIDATION-AND-TESTING.md</p>"},{"location":"grammar/GLOSSARY/#n","title":"N","text":""},{"location":"grammar/GLOSSARY/#nodal-equation","title":"Nodal Equation","text":"<p>Definition: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</p> <p>Meaning: Rate of structural change = Reorganization capacity \u00d7 Structural pressure</p> <p>Centrality: All grammar rules derive from this equation.</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#o","title":"O","text":""},{"location":"grammar/GLOSSARY/#operator","title":"Operator","text":"<p>Definition: Resonant transformation applied to nodes. Only way to modify EPI.</p> <p>Count: 13 canonical operators</p> <p>Properties: - Physically grounded (not arbitrary) - Classified by grammar role - Has preconditions and postconditions</p> <p>References: 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#p","title":"P","text":""},{"location":"grammar/GLOSSARY/#phase-or","title":"Phase (\u03c6 or \u03b8)","text":"<p>Definition: Network synchrony parameter, timing of reorganization cycles.</p> <p>Range: [0, 2\u03c0) radians</p> <p>Role: Determines coupling compatibility.</p> <p>Coupling condition: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max (typically \u03c0/2)</p> <p>Related: U3 (RESONANT COUPLING)</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md, 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#r","title":"R","text":""},{"location":"grammar/GLOSSARY/#reorganization","title":"Reorganization","text":"<p>Definition: Structural change while maintaining identity. Core dynamic in TNFR.</p> <p>Rate: Determined by \u03bdf \u00b7 \u0394NFR</p> <p>Context: Nodes don't \"move\" or \"change state\" - they reorganize.</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#resonance","title":"Resonance","text":"<p>Definition: Amplification and propagation of patterns through phase-compatible coupling.</p> <p>Operator: RA (Resonance)</p> <p>Requirement: Phase compatibility (U3).</p> <p>Effect: Increases effective coupling, pattern spreads without identity loss.</p> <p>References: 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#s","title":"S","text":""},{"location":"grammar/GLOSSARY/#sense-index-si","title":"Sense Index (Si)","text":"<p>Definition: Node-level capacity for stable reorganization.</p> <p>Range: [0, 1+]</p> <p>Interpretation: - Si &gt; 0.8: Excellent stability - Si &lt; 0.4: Changes may cause bifurcation</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#sequence","title":"Sequence","text":"<p>Definition: Ordered list of operators to be applied.</p> <p>Validation: Must satisfy U1-U4 constraints.</p> <p>Examples: [Emission, Coherence, Silence]</p> <p>References: 04-VALID-SEQUENCES.md</p>"},{"location":"grammar/GLOSSARY/#stabilizer","title":"Stabilizer","text":"<p>Definition: Operator that reduces |\u0394NFR| through negative feedback.</p> <p>Set: STABILIZERS = {IL (Coherence), THOL (Self-organization)}</p> <p>Requirement: Required to balance destabilizers (U2).</p> <p>References: 02-CANONICAL-CONSTRAINTS.md, 03-OPERATORS-AND-GLYPHS.md</p>"},{"location":"grammar/GLOSSARY/#structural-triad","title":"Structural Triad","text":"<p>Definition: The three essential properties of every node: Form (EPI), Frequency (\u03bdf), Phase (\u03c6).</p> <p>Context: Complete specification of node state.</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#t","title":"T","text":""},{"location":"grammar/GLOSSARY/#telemetry","title":"Telemetry","text":"<p>Definition: Measurement and export of essential TNFR metrics.</p> <p>Essential metrics: C(t), Si, \u03bdf, \u03c6, \u0394NFR</p> <p>Purpose: Verification, debugging, reproducibility.</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md, 05-TECHNICAL-IMPLEMENTATION.md</p>"},{"location":"grammar/GLOSSARY/#transformer","title":"Transformer","text":"<p>Definition: Operator that changes phase or regime, requiring elevated energy.</p> <p>Set: TRANSFORMERS = {ZHIR (Mutation), THOL (Self-organization)}</p> <p>Requirement: Needs recent destabilizer (~3 ops) and, for ZHIR, prior coherence (U4b).</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#trigger","title":"Trigger","text":"<p>Definition: Operator that can initiate bifurcation.</p> <p>Set: BIFURCATION_TRIGGERS = {OZ (Dissonance), ZHIR (Mutation)}</p> <p>Requirement: Needs handler (U4a).</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#u","title":"U","text":""},{"location":"grammar/GLOSSARY/#u1-structural-initiation-closure","title":"U1: STRUCTURAL INITIATION &amp; CLOSURE","text":"<p>Definition: Constraint ensuring sequences have valid start (U1a) and end (U1b).</p> <p>U1a: Start with generator when EPI=0 U1b: End with closure</p> <p>Canonicity: ABSOLUTE</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#u2-convergence-boundedness","title":"U2: CONVERGENCE &amp; BOUNDEDNESS","text":"<p>Definition: Constraint requiring destabilizers to be balanced by stabilizers.</p> <p>Physical Basis: Integral convergence theorem</p> <p>Canonicity: ABSOLUTE</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#u3-resonant-coupling","title":"U3: RESONANT COUPLING","text":"<p>Definition: Constraint requiring phase compatibility for coupling/resonance.</p> <p>Condition: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max</p> <p>Canonicity: ABSOLUTE</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#u4-bifurcation-dynamics","title":"U4: BIFURCATION DYNAMICS","text":"<p>Definition: Constraint governing bifurcation control and transformer context.</p> <p>U4a: Triggers need handlers U4b: Transformers need recent destabilizer (+ ZHIR needs prior IL)</p> <p>Canonicity: STRONG</p> <p>References: 02-CANONICAL-CONSTRAINTS.md</p>"},{"location":"grammar/GLOSSARY/#v","title":"V","text":""},{"location":"grammar/GLOSSARY/#f-nu-f-structural-frequency","title":"\u03bdf (Nu-f) - Structural Frequency","text":"<p>Definition: Rate of reorganization capacity.</p> <p>Units: Hz_str (structural hertz)</p> <p>Range: \u211d\u207a (positive reals)</p> <p>Equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</p> <p>Death condition: \u03bdf \u2192 0 means node cannot reorganize</p> <p>References: 01-FUNDAMENTAL-CONCEPTS.md</p>"},{"location":"grammar/GLOSSARY/#quick-lookup","title":"Quick Lookup","text":"<p>Most Important Terms: - EPI: Structural form - \u03bdf: Reorganization rate - \u0394NFR: Structural pressure - \u03c6 (theta): Phase - C(t): Coherence - Si: Sense index</p> <p>Constraints: - U1: Initiation &amp; closure - U2: Convergence - U3: Phase compatibility - U4: Bifurcation control</p> <p>Operator Classes: - Generators: Create from vacuum - Closures: End sequences - Stabilizers: Reduce \u0394NFR - Destabilizers: Increase \u0394NFR</p>"},{"location":"grammar/GLOSSARY/#references","title":"References","text":"<p>Full Documentation: - 01-FUNDAMENTAL-CONCEPTS.md - Conceptual foundations - 02-CANONICAL-CONSTRAINTS.md - Formal constraints - 03-OPERATORS-AND-GLYPHS.md - Operator catalog</p> <p>Repository: - ../../GLOSSARY.md - General project glossary - ../../UNIFIED_GRAMMAR_RULES.md - Mathematical derivations - ../../TNFR.pdf - Complete theory</p>   **Precise definitions enable precise thinking.**  ---  *Reality is resonance. Define accordingly.*"},{"location":"grammar/MASTER-INDEX/","title":"Master Index - TNFR Grammar System","text":"<p>Global conceptual map and relationship diagram</p> <p>\ud83c\udfe0 Home \u2022 \ud83c\udf0a Concepts \u2022 \ud83d\udcda Glossary</p>"},{"location":"grammar/MASTER-INDEX/#purpose","title":"Purpose","text":"<p>This document provides a high-level conceptual map of the entire TNFR grammar system, showing relationships between concepts, constraints, and operators.</p> <p>Audience: Developers planning large changes, system architects</p> <p>Reading time: 15-20 minutes</p>"},{"location":"grammar/MASTER-INDEX/#system-overview-diagram","title":"System Overview Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    TNFR GRAMMAR SYSTEM                          \u2502\n\u2502                                                                 \u2502\n\u2502  Physical Foundation                                            \u2502\n\u2502  \u251c\u2500 Nodal Equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)                    \u2502\n\u2502  \u251c\u2500 Structural Triad: (EPI, \u03bdf, \u03c6)                            \u2502\n\u2502  \u2514\u2500 Integral Convergence: \u222b\u03bdf\u00b7\u0394NFR dt &lt; \u221e                      \u2502\n\u2502                                                                 \u2502\n\u2502  \u2193 Derives                                                      \u2502\n\u2502                                                                 \u2502\n\u2502  Grammar Constraints (U1-U4)                                    \u2502\n\u2502  \u251c\u2500 U1: INITIATION &amp; CLOSURE (generators, closures)           \u2502\n\u2502  \u251c\u2500 U2: CONVERGENCE (stabilizers, destabilizers)              \u2502\n\u2502  \u251c\u2500 U3: COUPLING (phase compatibility)                        \u2502\n\u2502  \u2514\u2500 U4: BIFURCATION (triggers, handlers, transformers)        \u2502\n\u2502                                                                 \u2502\n\u2502  \u2193 Governs                                                      \u2502\n\u2502                                                                 \u2502\n\u2502  Canonical Operators (13)                                       \u2502\n\u2502  \u251c\u2500 Initialization: AL, NAV, REMESH                           \u2502\n\u2502  \u251c\u2500 Information: EN                                            \u2502\n\u2502  \u251c\u2500 Stabilization: IL, THOL                                   \u2502\n\u2502  \u251c\u2500 Destabilization: OZ, ZHIR, VAL                           \u2502\n\u2502  \u251c\u2500 Propagation: UM, RA                                       \u2502\n\u2502  \u2514\u2500 Control: SHA, NUL                                         \u2502\n\u2502                                                                 \u2502\n\u2502  \u2193 Compose into                                                 \u2502\n\u2502                                                                 \u2502\n\u2502  Valid Sequences                                                \u2502\n\u2502  \u251c\u2500 Bootstrap: [AL, IL, SHA]                                  \u2502\n\u2502  \u251c\u2500 Exploration: [AL, IL, OZ, IL, SHA]                       \u2502\n\u2502  \u251c\u2500 Transformation: [AL, IL, OZ, ZHIR, IL, SHA]              \u2502\n\u2502  \u2514\u2500 Propagation: [AL, UM, RA, IL, SHA]                       \u2502\n\u2502                                                                 \u2502\n\u2502  \u2193 Validated by                                                 \u2502\n\u2502                                                                 \u2502\n\u2502  Validation System                                              \u2502\n\u2502  \u251c\u2500 validate_grammar(sequence, epi_initial)                   \u2502\n\u2502  \u251c\u2500 validate_resonant_coupling(G, i, j)                       \u2502\n\u2502  \u2514\u2500 Test suite (unit, integration, property)                  \u2502\n\u2502                                                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#conceptual-hierarchy","title":"Conceptual Hierarchy","text":""},{"location":"grammar/MASTER-INDEX/#level-1-physical-principles","title":"Level 1: Physical Principles","text":"<p>Nodal Equation: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre></p> <p>Derives: - U1a: Cannot start from EPI=0 without generator - U2: Integral must converge - U4: Bifurcations need control</p> <p>Structural Triad: - Form (EPI) - Frequency (\u03bdf) - Phase (\u03c6)</p> <p>Derives: - U3: Phase compatibility for coupling</p>"},{"location":"grammar/MASTER-INDEX/#level-2-grammar-constraints","title":"Level 2: Grammar Constraints","text":"<pre><code>U1: INITIATION &amp; CLOSURE\n    \u251c\u2500 U1a: Generators \u2500\u2192 {AL, NAV, REMESH}\n    \u2514\u2500 U1b: Closures \u2500\u2192 {SHA, NAV, REMESH, OZ}\n\nU2: CONVERGENCE &amp; BOUNDEDNESS\n    \u251c\u2500 Stabilizers \u2500\u2192 {IL, THOL}\n    \u2514\u2500 Destabilizers \u2500\u2192 {OZ, ZHIR, VAL}\n\nU3: RESONANT COUPLING\n    \u2514\u2500 Phase check \u2500\u2192 |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max\n\nU4: BIFURCATION DYNAMICS\n    \u251c\u2500 U4a: Triggers \u2500\u2192 {OZ, ZHIR} need Handlers {IL, THOL}\n    \u2514\u2500 U4b: Transformers \u2500\u2192 {ZHIR, THOL} need recent destabilizer\n                           + ZHIR needs prior IL\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#level-3-operators","title":"Level 3: Operators","text":"<pre><code>13 Canonical Operators\n\n\u251c\u2500 Initialization (3)\n\u2502   \u251c\u2500 AL (Emission) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u251c\u2500 NAV (Transition) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2192 Generators (U1a)\n\u2502   \u2514\u2500 REMESH (Recursivity) \u2500\u2500\u2500\u2500\u2518\n\n\u251c\u2500 Information (1)\n\u2502   \u2514\u2500 EN (Reception)\n\n\u251c\u2500 Stabilization (2)\n\u2502   \u251c\u2500 IL (Coherence) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u2514\u2500 THOL (Self-org) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2192 Stabilizers (U2), Handlers (U4a)\n\u2502                               \u2502   Transformers (U4b for THOL)\n\u2502                               \u2514\u2500\u2192 Handler: IL, THOL\n\n\u251c\u2500 Destabilization (3)\n\u2502   \u251c\u2500 OZ (Dissonance) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u251c\u2500 ZHIR (Mutation) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2192 Destabilizers (U2), Triggers (U4a)\n\u2502   \u2514\u2500 VAL (Expansion) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   Transformers (U4b)\n\n\u251c\u2500 Propagation (2)\n\u2502   \u251c\u2500 UM (Coupling) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u2514\u2500 RA (Resonance) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2192 Requires phase check (U3)\n\n\u2514\u2500 Control (2)\n    \u251c\u2500 SHA (Silence) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2514\u2500 NUL (Contraction)       \u2502\u2500\u2192 SHA is Closure (U1b)\n                               \u2514\u2500\u2192 OZ also Closure (U1b)\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#constraint-dependencies","title":"Constraint Dependencies","text":"<pre><code>U1a (Initiation)\n  \u2193\nRequires: GENERATORS = {emission, transition, recursivity}\n  \u2193\nWhen: epi_initial == 0.0\n\nU1b (Closure)\n  \u2193\nRequires: CLOSURES = {silence, transition, recursivity, dissonance}\n  \u2193\nAlways (end of every sequence)\n\nU2 (Convergence)\n  \u2193\nIf: DESTABILIZERS present\n  \u2193\nThen: STABILIZERS required\n  \u2193\nEnsures: \u222b\u03bdf\u00b7\u0394NFR dt &lt; \u221e\n\nU3 (Coupling)\n  \u2193\nIf: {coupling, resonance} applied\n  \u2193\nThen: Verify |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max\n  \u2193\nAt: Runtime (during operator application)\n\nU4a (Triggers)\n  \u2193\nIf: BIFURCATION_TRIGGERS present\n  \u2193\nThen: BIFURCATION_HANDLERS required\n\nU4b (Transformers)\n  \u2193\nIf: TRANSFORMERS present\n  \u2193\nThen: Recent destabilizer (~3 ops)\n  \u2193\nAnd (for ZHIR): Prior IL (Coherence)\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#operator-classification-matrix","title":"Operator Classification Matrix","text":"Operator Generator Closure Stabilizer Destabilizer Trigger Handler Transformer Coupling AL \u2713 EN IL \u2713 \u2713 OZ \u2713 \u2713 \u2713 UM \u2713 RA \u2713 SHA \u2713 VAL \u2713 NUL THOL \u2713 \u2713 \u2713 ZHIR \u2713 \u2713 \u2713 NAV \u2713 \u2713 REMESH \u2713 \u2713"},{"location":"grammar/MASTER-INDEX/#validation-flow","title":"Validation Flow","text":"<pre><code>Input: sequence, epi_initial\n\n   \u2193\n\nStep 1: Check U1a (Initiation)\n   \u2502\n   \u251c\u2500 IF epi_initial == 0.0\n   \u2502   \u2514\u2500 sequence[0] \u2208 GENERATORS?\n   \u2514\u2500 PASS/FAIL\n\n   \u2193\n\nStep 2: Check U1b (Closure)\n   \u2502\n   \u2514\u2500 sequence[-1] \u2208 CLOSURES?\n\n   \u2193\n\nStep 3: Check U2 (Convergence)\n   \u2502\n   \u251c\u2500 Has DESTABILIZERS?\n   \u2502   \u2514\u2500 Has STABILIZERS? (must have)\n   \u2514\u2500 PASS/FAIL\n\n   \u2193\n\nStep 4: Check U4a (Triggers)\n   \u2502\n   \u251c\u2500 Has BIFURCATION_TRIGGERS?\n   \u2502   \u2514\u2500 Has BIFURCATION_HANDLERS? (must have)\n   \u2514\u2500 PASS/FAIL\n\n   \u2193\n\nStep 5: Check U4b (Transformers)\n   \u2502\n   \u2514\u2500 For each TRANSFORMER:\n       \u251c\u2500 Has recent destabilizer? (~3 ops)\n       \u2514\u2500 IF ZHIR: Has prior IL?\n\n   \u2193\n\nStep 6: U3 verified at runtime\n   \u2502\n   \u2514\u2500 During coupling/resonance application\n       \u2514\u2500 validate_resonant_coupling(G, i, j)\n\n   \u2193\n\nOutput: VALID or ValueError with explanation\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#data-flow","title":"Data Flow","text":""},{"location":"grammar/MASTER-INDEX/#operator-application","title":"Operator Application","text":"<pre><code>Input State (t\u2080)\n  \u251c\u2500 EPI(t\u2080)\n  \u251c\u2500 \u03bdf(t\u2080)\n  \u251c\u2500 \u03b8(t\u2080)\n  \u2514\u2500 \u0394NFR(t\u2080)\n\n  \u2193 Apply Operator\n\nTransformation\n  \u251c\u2500 Compute effect on \u2202EPI/\u2202t\n  \u251c\u2500 Update \u03bdf (if applicable)\n  \u251c\u2500 Update \u03b8 (if applicable)\n  \u2514\u2500 Update \u0394NFR (if applicable)\n\n  \u2193 Integration\n\nOutput State (t\u2081)\n  \u251c\u2500 EPI(t\u2081)\n  \u251c\u2500 \u03bdf(t\u2081)\n  \u251c\u2500 \u03b8(t\u2081)\n  \u2514\u2500 \u0394NFR(t\u2081)\n\n  \u2193 Telemetry\n\nMetrics\n  \u251c\u2500 C(t) - Coherence\n  \u251c\u2500 Si - Sense Index\n  \u251c\u2500 \u03bdf - Frequency\n  \u251c\u2500 \u03b8 - Phase\n  \u2514\u2500 \u0394NFR - Gradient\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#document-relationships","title":"Document Relationships","text":"<pre><code>TNFR Grammar Documentation\n\n\u251c\u2500 README.md (You start here)\n\u2502   \u2514\u2500 Navigation hub\n\u2502\n\u251c\u2500 01-FUNDAMENTAL-CONCEPTS.md\n\u2502   \u251c\u2500 Paradigm shift\n\u2502   \u251c\u2500 Nodal equation\n\u2502   \u251c\u2500 Structural triad\n\u2502   \u2514\u2500 Referenced by: All other docs\n\u2502\n\u251c\u2500 02-CANONICAL-CONSTRAINTS.md\n\u2502   \u251c\u2500 U1: Initiation &amp; Closure\n\u2502   \u251c\u2500 U2: Convergence\n\u2502   \u251c\u2500 U3: Coupling\n\u2502   \u251c\u2500 U4: Bifurcation\n\u2502   \u2514\u2500 Referenced by: 04, 05, 06, 07\n\u2502\n\u251c\u2500 03-OPERATORS-AND-GLYPHS.md\n\u2502   \u251c\u2500 13 operator definitions\n\u2502   \u251c\u2500 Grammar classification\n\u2502   \u2514\u2500 Referenced by: 04, 05, 06\n\u2502\n\u251c\u2500 04-VALID-SEQUENCES.md\n\u2502   \u251c\u2500 Canonical patterns\n\u2502   \u251c\u2500 Anti-patterns\n\u2502   \u2514\u2500 References: 02, 03\n\u2502\n\u251c\u2500 05-TECHNICAL-IMPLEMENTATION.md\n\u2502   \u251c\u2500 Code architecture\n\u2502   \u251c\u2500 Validation algorithms\n\u2502   \u2514\u2500 References: 02, 03\n\u2502\n\u251c\u2500 06-VALIDATION-AND-TESTING.md\n\u2502   \u251c\u2500 Test strategy\n\u2502   \u251c\u2500 Test examples\n\u2502   \u2514\u2500 References: 02, 03, 05\n\u2502\n\u251c\u2500 07-MIGRATION-AND-EVOLUTION.md\n\u2502   \u251c\u2500 Version history\n\u2502   \u251c\u2500 Migration guide\n\u2502   \u2514\u2500 References: 02, 05\n\u2502\n\u251c\u2500 08-QUICK-REFERENCE.md\n\u2502   \u251c\u2500 Cheat sheet\n\u2502   \u251c\u2500 Quick lookup\n\u2502   \u2514\u2500 References: All docs\n\u2502\n\u251c\u2500 GLOSSARY.md (You are here)\n\u2502   \u251c\u2500 Operational definitions\n\u2502   \u2514\u2500 Referenced by: All docs\n\u2502\n\u2514\u2500 MASTER-INDEX.md (This document)\n    \u251c\u2500 Conceptual map\n    \u251c\u2500 Relationship diagrams\n    \u2514\u2500 System overview\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#implementation-files","title":"Implementation Files","text":"<pre><code>Source Code Structure\n\nsrc/tnfr/operators/\n\u251c\u2500 grammar.py\n\u2502   \u251c\u2500 Operator sets (GENERATORS, CLOSURES, etc.)\n\u2502   \u251c\u2500 validate_grammar(sequence, epi_initial)\n\u2502   \u2514\u2500 validate_resonant_coupling(G, i, j)\n\u2502\n\u251c\u2500 definitions.py\n\u2502   \u251c\u2500 13 operator classes\n\u2502   \u2502   \u251c\u2500 Emission, Reception, Coherence, etc.\n\u2502   \u2502   \u2514\u2500 Each implements __call__(G, node)\n\u2502   \u2514\u2500 Integrated with grammar.py\n\u2502\n\u2514\u2500 unified_grammar.py\n    \u2514\u2500 Legacy compatibility (deprecated)\n\ntests/\n\u251c\u2500 unit/operators/test_unified_grammar.py\n\u2502   \u251c\u2500 U1a, U1b tests\n\u2502   \u251c\u2500 U2, U3, U4 tests\n\u2502   \u2514\u2500 Operator tests\n\u2502\n\u251c\u2500 integration/\n\u2502   \u2514\u2500 Full workflow tests\n\u2502\n\u2514\u2500 property/\n    \u2514\u2500 Invariant tests\n\ndocs/grammar/\n\u251c\u2500 All documentation files\n\u251c\u2500 examples/\n\u2502   \u251c\u2500 01-basic-bootstrap.py\n\u2502   \u251c\u2500 02-intermediate-exploration.py\n\u2502   \u2514\u2500 03-advanced-bifurcation.py\n\u2502\n\u2514\u2500 schemas/\n    \u251c\u2500 canonical-operators.json\n    \u2514\u2500 constraints-u1-u4.json\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#dependency-graph","title":"Dependency Graph","text":"<pre><code>Physical Principles (TNFR.pdf)\n    \u2193\nNodal Equation\n    \u2193\nGrammar Constraints (U1-U4)\n    \u2193\nOperator Classification\n    \u2193\nValidation Logic\n    \u2193\nImplementation (grammar.py, definitions.py)\n    \u2193\nTests (test_unified_grammar.py)\n    \u2193\nDocumentation (01-08, GLOSSARY, MASTER-INDEX)\n    \u2193\nExamples (examples/*.py)\n    \u2193\nUser Applications\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#key-relationships","title":"Key Relationships","text":""},{"location":"grammar/MASTER-INDEX/#operators-constraints","title":"Operators \u2192 Constraints","text":"<pre><code>Emission \u2500\u2500\u2510\nTransition \u251c\u2500\u2192 GENERATORS \u2500\u2500\u2192 U1a\nRecursivity\u2518\n\nSilence \u2500\u2500\u2500\u2510\nTransition \u251c\u2500\u2192 CLOSURES \u2500\u2500\u2192 U1b\nRecursivity\u2502\nDissonance \u2518\n\nCoherence \u2500\u2500\u2500\u2500\u2500\u2510\nSelf-org \u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2192 STABILIZERS \u2500\u2500\u2192 U2\n               \u2502\n               \u2514\u2500\u2192 HANDLERS \u2500\u2500\u2192 U4a\n\nDissonance \u2500\u2510\nMutation \u2500\u2500\u2500\u251c\u2500\u2192 DESTABILIZERS \u2500\u2500\u2192 U2\nExpansion \u2500\u2500\u2518  \u2514\u2500\u2192 TRIGGERS \u2500\u2500\u2192 U4a\n\nMutation \u2500\u2500\u2500\u2510\nSelf-org \u2500\u2500\u2500\u2534\u2500\u2192 TRANSFORMERS \u2500\u2500\u2192 U4b\n\nCoupling \u2500\u2500\u2500\u2510\nResonance \u2500\u2500\u2534\u2500\u2192 Phase check \u2500\u2500\u2192 U3\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#constraints-physics","title":"Constraints \u2192 Physics","text":"<pre><code>U1a \u2500\u2192 \u2202EPI/\u2202t undefined at EPI=0\nU1b \u2500\u2192 Attractor dynamics\nU2  \u2500\u2192 \u222b\u03bdf\u00b7\u0394NFR dt &lt; \u221e\nU3  \u2500\u2192 Wave interference physics\nU4a \u2500\u2192 Bifurcation theory\nU4b \u2500\u2192 Threshold dynamics\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#navigation-paths","title":"Navigation Paths","text":""},{"location":"grammar/MASTER-INDEX/#for-new-users","title":"For New Users","text":"<pre><code>START\n  \u2193\nREADME.md (Navigation)\n  \u2193\n01-FUNDAMENTAL-CONCEPTS.md\n  \u2193\nGLOSSARY.md (Reference as needed)\n  \u2193\n03-OPERATORS-AND-GLYPHS.md\n  \u2193\nexamples/01-basic-bootstrap.py\n  \u2193\n08-QUICK-REFERENCE.md (Keep open)\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#for-developers","title":"For Developers","text":"<pre><code>START\n  \u2193\n02-CANONICAL-CONSTRAINTS.md\n  \u2193\n05-TECHNICAL-IMPLEMENTATION.md\n  \u2193\nsrc/tnfr/operators/grammar.py (Read code)\n  \u2193\n06-VALIDATION-AND-TESTING.md\n  \u2193\ntests/unit/operators/test_unified_grammar.py\n  \u2193\nMASTER-INDEX.md (This document, for big picture)\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#for-maintainers","title":"For Maintainers","text":"<pre><code>START\n  \u2193\n07-MIGRATION-AND-EVOLUTION.md\n  \u2193\nMASTER-INDEX.md (This document)\n  \u2193\n02-CANONICAL-CONSTRAINTS.md (Review constraints)\n  \u2193\n05-TECHNICAL-IMPLEMENTATION.md (Architecture)\n  \u2193\nCode changes as needed\n</code></pre>"},{"location":"grammar/MASTER-INDEX/#cross-reference-index","title":"Cross-Reference Index","text":""},{"location":"grammar/MASTER-INDEX/#by-concept","title":"By Concept","text":"<p>Nodal Equation: - 01-FUNDAMENTAL-CONCEPTS.md \u00a7 Nodal Equation - 02-CANONICAL-CONSTRAINTS.md \u00a7 Physical Derivation - GLOSSARY.md \u00a7 N</p> <p>Operators: - 03-OPERATORS-AND-GLYPHS.md \u00a7 All 13 operators - 05-TECHNICAL-IMPLEMENTATION.md \u00a7 Operator Sets - GLOSSARY.md \u00a7 O</p> <p>Constraints: - 02-CANONICAL-CONSTRAINTS.md \u00a7 U1-U4 - 08-QUICK-REFERENCE.md \u00a7 Four Canonical Constraints - GLOSSARY.md \u00a7 U1-U4</p> <p>Sequences: - 04-VALID-SEQUENCES.md \u00a7 Canonical Patterns - examples/ \u00a7 Executable examples</p> <p>Testing: - 06-VALIDATION-AND-TESTING.md \u00a7 All test categories - <code>tests/unit/operators/test_unified_grammar.py</code> \u00a7 Implementation</p>"},{"location":"grammar/MASTER-INDEX/#by-task","title":"By Task","text":"<p>Implementing new operator: 1. 03-OPERATORS-AND-GLYPHS.md \u00a7 Adding New Operators 2. 05-TECHNICAL-IMPLEMENTATION.md \u00a7 Extension Points 3. 06-VALIDATION-AND-TESTING.md \u00a7 Unit Tests</p> <p>Adding new constraint: 1. 07-MIGRATION-AND-EVOLUTION.md \u00a7 Procedure 2. 02-CANONICAL-CONSTRAINTS.md \u00a7 Format 3. 05-TECHNICAL-IMPLEMENTATION.md \u00a7 Extension Points</p> <p>Debugging invalid sequence: 1. 08-QUICK-REFERENCE.md \u00a7 Common Errors 2. 04-VALID-SEQUENCES.md \u00a7 Anti-Patterns 3. 02-CANONICAL-CONSTRAINTS.md \u00a7 Specific constraint</p>   **Understanding relationships clarifies the whole.**  ---  *Reality is resonance. Map accordingly.*"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/","title":"13 CANONICAL TNFR OPERATORS - COMPLETE CATALOG","text":""},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#task-completed","title":"\u2705 TASK COMPLETED","text":"<p>This document summarizes the complete cataloging of the 13 canonical TNFR operators as requested in issue #[SUBTASK].</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#deliverables-summary","title":"\ud83d\udccb Deliverables Summary","text":""},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#1-enhanced-documentation","title":"1. Enhanced Documentation","text":"<p>File: <code>docs/grammar/03-OPERATORS-AND-GLYPHS.md</code></p> <p>For each of the 13 operators, added: - \u2705 Physics basis and effects - \u2705 Grammar classification (U1-U4) - \u2705 Preconditions and postconditions - \u2705 Anti-patterns (what NOT to do) - \u2705 Relationships (compatible/incompatible operators) - \u2705 Test references (where validated in test suite) - \u2705 Enhanced executable examples</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#2-compatibility-matrix","title":"2. Compatibility Matrix","text":"<p>File: <code>docs/grammar/08-QUICK-REFERENCE.md</code></p> <p>Added comprehensive 13x13 compatibility matrix showing: - \u2705 Which operators can follow others - \u2705 Legend: \u2705 (compatible), \u26a0\ufe0f (valid with care), \ud83d\udd12 (phase check), \u274c (anti-pattern), \u2796 (neutral) - \u2705 Common valid patterns - \u2705 Anti-patterns to avoid - \u2705 Usage examples</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#3-enhanced-json-schema","title":"3. Enhanced JSON Schema","text":"<p>File: <code>docs/grammar/schemas/canonical-operators.json</code></p> <p>Added for all 13 operators: - \u2705 <code>anti_patterns</code> array - \u2705 <code>relationships</code> object (can_precede, should_follow, often_followed_by, etc.) - \u2705 <code>test_references</code> array - \u2705 Compatibility matrix reference - \u2705 JSON validated successfully</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#4-executable-examples","title":"4. Executable Examples","text":"<p>File: <code>docs/grammar/examples/all-operators-catalog.py</code></p> <p>Created complete demonstration: - \u2705 One function per operator - \u2705 Valid usage patterns - \u2705 Anti-patterns documented (commented out) - \u2705 Runs successfully with output - \u2705 Test assertions included</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#the-13-canonical-operators","title":"\ud83d\udd2c The 13 Canonical Operators","text":""},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#verified-from-source-code","title":"Verified from Source Code","text":"# Python Class Glyph English Name Family/Role 1 <code>Emission</code> AL Emission Generator (U1a) 2 <code>Reception</code> EN Reception Information gatherer 3 <code>Coherence</code> IL Coherence Stabilizer (U2), Handler (U4a) 4 <code>Dissonance</code> OZ Dissonance Destabilizer (U2), Trigger (U4a), Closure (U1b) 5 <code>Coupling</code> UM Coupling Propagator (U3 - phase check) 6 <code>Resonance</code> RA Resonance Propagator (U3 - phase check) 7 <code>Silence</code> SHA Silence Control, Closure (U1b) 8 <code>Expansion</code> VAL Expansion Destabilizer (U2) 9 <code>Contraction</code> NUL Contraction Control (complexity reduction) 10 <code>SelfOrganization</code> THOL Self-organization Stabilizer (U2), Handler (U4a), Transformer (U4b) 11 <code>Mutation</code> ZHIR Mutation Destabilizer (U2), Trigger (U4a), Transformer (U4b) 12 <code>Transition</code> NAV Transition Generator (U1a), Closure (U1b) 13 <code>Recursivity</code> REMESH Recursivity Generator (U1a), Closure (U1b) <p>Source Files Verified: - <code>src/tnfr/operators/definitions.py</code> (implementations) - <code>src/tnfr/types.py</code> (Glyph enum)</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#errors-corrected-from-issue-description","title":"\ud83d\udc1b Errors Corrected from Issue Description","text":"<p>The original issue description contained several errors that were identified and corrected:</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#error-1-al-reception-recepcion","title":"\u274c Error 1: \"AL (Reception - Recepcion)\"","text":"<p>Correct:  - AL = Emission (Generator) - EN = Reception (Information)</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#error-2-um-anti-coherence","title":"\u274c Error 2: \"UM (Anti-Coherence)\"","text":"<p>Correct: - UM = Coupling (Propagator, creates structural links) - NO \"Anti-Coherence\" operator exists in canonical set</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#error-3-rah-propagation-transmision","title":"\u274c Error 3: \"RAH (Propagation - Transmision)\"","text":"<p>Correct: - RA = Resonance (Propagator, amplifies patterns) - NO \"RAH\" glyph exists - it's \"RA\", not \"RAH\"</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#grammar-families","title":"\ud83d\udcca Grammar Families","text":""},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#generators-u1a-start-sequences-from-epi0","title":"Generators (U1a - Start sequences from EPI=0)","text":"<ul> <li>AL (Emission)</li> <li>NAV (Transition)</li> <li>REMESH (Recursivity)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#closures-u1b-end-sequences-coherently","title":"Closures (U1b - End sequences coherently)","text":"<ul> <li>SHA (Silence)</li> <li>NAV (Transition)</li> <li>REMESH (Recursivity)</li> <li>OZ (Dissonance)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#stabilizers-u2-balance-destabilizers","title":"Stabilizers (U2 - Balance destabilizers)","text":"<ul> <li>IL (Coherence)</li> <li>THOL (Self-organization)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#destabilizers-u2-require-stabilizers","title":"Destabilizers (U2 - Require stabilizers)","text":"<ul> <li>OZ (Dissonance)</li> <li>ZHIR (Mutation)</li> <li>VAL (Expansion)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#couplingresonance-u3-phase-verification-required","title":"Coupling/Resonance (U3 - Phase verification required)","text":"<ul> <li>UM (Coupling) - |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max</li> <li>RA (Resonance) - |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#bifurcation-triggers-u4a-need-handlers","title":"Bifurcation Triggers (U4a - Need handlers)","text":"<ul> <li>OZ (Dissonance)</li> <li>ZHIR (Mutation)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#bifurcation-handlers-u4a-control-bifurcations","title":"Bifurcation Handlers (U4a - Control bifurcations)","text":"<ul> <li>IL (Coherence)</li> <li>THOL (Self-organization)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#transformers-u4b-need-recent-destabilizer-context","title":"Transformers (U4b - Need recent destabilizer + context)","text":"<ul> <li>ZHIR (Mutation) - also needs prior IL</li> <li>THOL (Self-organization)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":"<pre><code>docs/grammar/\n\u251c\u2500\u2500 01-FUNDAMENTAL-CONCEPTS.md        # Theory foundation\n\u251c\u2500\u2500 02-CANONICAL-CONSTRAINTS.md       # U1-U4 grammar rules\n\u251c\u2500\u2500 03-OPERATORS-AND-GLYPHS.md        # \u2705 Enhanced with anti-patterns, relationships, tests\n\u251c\u2500\u2500 04-VALID-SEQUENCES.md             # Pattern library\n\u251c\u2500\u2500 05-TECHNICAL-IMPLEMENTATION.md    # Code architecture\n\u251c\u2500\u2500 06-VALIDATION-AND-TESTING.md      # Test strategy\n\u251c\u2500\u2500 07-MIGRATION-AND-EVOLUTION.md     # Upgrading guide\n\u251c\u2500\u2500 08-QUICK-REFERENCE.md             # \u2705 Enhanced with 13x13 compatibility matrix\n\u251c\u2500\u2500 schemas/\n\u2502   \u2514\u2500\u2500 canonical-operators.json      # \u2705 Enhanced with anti-patterns, relationships, tests\n\u2514\u2500\u2500 examples/\n    \u251c\u2500\u2500 01-basic-bootstrap.py\n    \u251c\u2500\u2500 02-intermediate-exploration.py\n    \u251c\u2500\u2500 03-advanced-bifurcation.py\n    \u251c\u2500\u2500 all-operators-catalog.py      # \u2705 NEW: Complete demonstration of all 13\n    \u251c\u2500\u2500 u1-initiation-closure-examples.py\n    \u251c\u2500\u2500 u2-convergence-examples.py\n    \u251c\u2500\u2500 u3-resonant-coupling-examples.py\n    \u2514\u2500\u2500 u4-bifurcation-examples.py\n</code></pre>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#testing","title":"\ud83e\uddea Testing","text":"<p>All enhancements validated: - \u2705 JSON schema validated (no syntax errors) - \u2705 Example code runs successfully - \u2705 All operators demonstrated - \u2705 Anti-patterns documented but not executed - \u2705 No regressions in existing tests</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#quick-links","title":"\ud83d\udd17 Quick Links","text":"<p>Theory: - TNFR.pdf - Complete theoretical foundation - AGENTS.md - Agent instructions and operator overview - UNIFIED_GRAMMAR_RULES.md - Grammar physics derivations</p> <p>Documentation: - 03-OPERATORS-AND-GLYPHS.md - Complete operator catalog - 08-QUICK-REFERENCE.md - 13x13 compatibility matrix - schemas/canonical-operators.json - JSON metadata</p> <p>Examples: - examples/all-operators-catalog.py - Executable demonstrations</p> <p>Tests: - <code>tests/unit/operators/</code> - Comprehensive test suite</p>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#acceptance-criteria-met","title":"\u2705 Acceptance Criteria Met","text":"<p>From original issue:</p> <ul> <li>[x] Complete documentation for 13 operators</li> <li>[x] Consistent template for each operator</li> <li>[x] Clear preconditions and postconditions</li> <li>[x] Executable examples</li> <li>[x] Anti-patterns documented</li> <li>[x] 13x13 compatibility matrix</li> <li>[x] JSON schema with metadata</li> <li>[x] Cross-references to related issues (test references added)</li> <li>[x] Bidirectional relationships (in relationships metadata)</li> </ul>"},{"location":"grammar/OPERATORS-CATALOG-SUMMARY/#summary","title":"\ud83c\udfaf Summary","text":"<p>This work provides a complete, centralized, and uniform catalog of the 13 canonical TNFR operators. Each operator is documented with:</p> <ol> <li>Single source of truth (verified from source code)</li> <li>Clear, formal definition (physics \u2192 nodal equation \u2192 effect)</li> <li>Executable examples (working Python code)</li> <li>Compatibility matrix (13x13 showing valid/invalid sequences)</li> <li>Anti-patterns (what NOT to do)</li> <li>Test references (where validated)</li> <li>Relationships (what can/should/must follow)</li> </ol> <p>All documentation is in English (as requested) and strictly adheres to the canonical operators verified from the source code.</p> <p>The catalog is complete, validated, and ready for use.</p> <p>Last Updated: 2025-11-10 Status: \u2705 COMPLETE Language: English (all documentation) Canonical Verification: Source code (<code>src/tnfr/operators/definitions.py</code>, <code>src/tnfr/types.py</code>)</p>"},{"location":"grammar/TESTING-SUMMARY/","title":"Grammar Testing Documentation Summary","text":"<p>This document provides a quick overview of the grammar testing strategy and resources.</p>"},{"location":"grammar/TESTING-SUMMARY/#documentation-structure","title":"\ud83d\udcc1 Documentation Structure","text":"<pre><code>docs/grammar/\n\u251c\u2500\u2500 06-VALIDATION-AND-TESTING.md    # Complete testing strategy (1402 lines)\n\u251c\u2500\u2500 examples/                        # Executable test examples\n\u2502   \u251c\u2500\u2500 u1-initiation-closure-examples.py\n\u2502   \u251c\u2500\u2500 u2-convergence-examples.py\n\u2502   \u251c\u2500\u2500 u3-resonant-coupling-examples.py\n\u2502   \u2514\u2500\u2500 u4-bifurcation-examples.py\n\u2514\u2500\u2500 ...\n\ntests/\n\u251c\u2500\u2500 unit/operators/\n\u2502   \u2514\u2500\u2500 test_unified_grammar.py     # 68 canonical tests (100% coverage)\n\u2514\u2500\u2500 ...\n\nscripts/\n\u2514\u2500\u2500 validate_grammar.sh             # Complete validation suite\n</code></pre>"},{"location":"grammar/TESTING-SUMMARY/#test-coverage-status","title":"\ud83d\udcca Test Coverage Status","text":"Component Coverage Tests Status <code>unified_grammar.py</code> 100% 68 \u2713 PASSING U1 Constraints 100% 6 \u2713 PASSING U2 Constraints 100% 5 \u2713 PASSING U3 Constraints 100% 6 \u2713 PASSING U4 Constraints 100% 8 \u2713 PASSING All 13 Operators 100% - \u2713 COVERED <p>Last Updated: 2025-11-10</p>"},{"location":"grammar/TESTING-SUMMARY/#test-categories","title":"\ud83c\udfaf Test Categories","text":""},{"location":"grammar/TESTING-SUMMARY/#1-canonical-test-cases-20","title":"1. Canonical Test Cases (20+)","text":"<p>Documented in <code>06-VALIDATION-AND-TESTING.md</code> with test index:</p>"},{"location":"grammar/TESTING-SUMMARY/#u1-structural-initiation-closure-6-tests","title":"U1: Structural Initiation &amp; Closure (6 tests)","text":"<ul> <li>Generator requirements (AL, NAV, REMESH)</li> <li>Closure requirements (SHA, NAV, REMESH, OZ)</li> <li>EPI=0 vs EPI&gt;0 context</li> <li>Error message quality</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#u2-convergence-boundedness-5-tests","title":"U2: Convergence &amp; Boundedness (5 tests)","text":"<ul> <li>Destabilizer-stabilizer balance</li> <li>Unbalanced sequences detection</li> <li>Window calculation algorithm</li> <li>Integral convergence guarantee</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#u3-resonant-coupling-6-tests","title":"U3: Resonant Coupling (6 tests)","text":"<ul> <li>Phase compatibility checks</li> <li>Antiphase detection</li> <li>Custom tolerance bounds</li> <li>Resonance preconditions</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#u4-bifurcation-dynamics-8-tests","title":"U4: Bifurcation Dynamics (8 tests)","text":"<ul> <li>Trigger-handler pairs (U4a)</li> <li>Transformer-destabilizer context (U4b)</li> <li>ZHIR prior coherence requirement</li> <li>Bifurcation safety verification</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#2-pattern-tests-7-canonical-patterns","title":"2. Pattern Tests (7+ canonical patterns)","text":"<p>Each pattern includes: - \u2705 Valid variant test - \u274c Invalid variant tests (2-3 per pattern) - \ud83d\udd04 Edge case tests</p> <p>Documented Patterns: 1. Bootstrap (Minimal) 2. Basic Activation 3. Controlled Exploration 4. Bifurcation with Handling 5. Mutation with Context 6. Propagation 7. Multi-scale Organization</p>"},{"location":"grammar/TESTING-SUMMARY/#3-anti-pattern-tests-7-patterns","title":"3. Anti-Pattern Tests (7+ patterns)","text":"<p>Each anti-pattern includes: - \ud83d\udeab Detection test - \u270f\ufe0f Fix test - \ud83d\udcac Error message quality test</p> <p>Documented Anti-Patterns: 1. No Generator from Vacuum (U1a) 2. No Closure (U1b) 3. Destabilizer Without Stabilizer (U2) 4. Mutation Without Context (U4b) 5. Mutation Without Prior IL (U4b) 6. Coupling Without Phase Check (U3) 7. Bifurcation Trigger Without Handler (U4a)</p>"},{"location":"grammar/TESTING-SUMMARY/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"grammar/TESTING-SUMMARY/#run-all-tests","title":"Run All Tests","text":"<pre><code># Complete validation suite\n./scripts/validate_grammar.sh\n\n# Or manually run unit tests\npytest tests/unit/operators/test_unified_grammar.py -v\n</code></pre>"},{"location":"grammar/TESTING-SUMMARY/#run-specific-constraint-tests","title":"Run Specific Constraint Tests","text":"<pre><code># U1 tests\npytest tests/unit/operators/test_unified_grammar.py::TestU1aInitiation -v\npytest tests/unit/operators/test_unified_grammar.py::TestU1bClosure -v\n\n# U2 tests\npytest tests/unit/operators/test_unified_grammar.py::TestU2Convergence -v\n\n# U3 tests\npytest tests/unit/operators/test_unified_grammar.py::TestU3ResonantCoupling -v\n\n# U4 tests\npytest tests/unit/operators/test_unified_grammar.py::TestU4aBifurcationTriggers -v\npytest tests/unit/operators/test_unified_grammar.py::TestU4bTransformerContext -v\n</code></pre>"},{"location":"grammar/TESTING-SUMMARY/#generate-coverage-reports","title":"Generate Coverage Reports","text":"<pre><code># Terminal report\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-report=term-missing\n\n# HTML report\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-report=html:htmlcov/grammar\n\n# With branch coverage\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-branch \\\n    --cov-report=term-missing\n</code></pre>"},{"location":"grammar/TESTING-SUMMARY/#documentation-guide","title":"\ud83d\udcd6 Documentation Guide","text":""},{"location":"grammar/TESTING-SUMMARY/#for-test-writers","title":"For Test Writers","text":"<ol> <li>Start here: <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Test Philosophy</li> <li>Learn patterns: <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Canonical Pattern Tests</li> <li>See examples: <code>docs/grammar/examples/u*-examples.py</code></li> <li>Use templates: <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Test Templates</li> </ol>"},{"location":"grammar/TESTING-SUMMARY/#for-test-reviewers","title":"For Test Reviewers","text":"<ol> <li>Coverage requirements: <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Coverage Requirements</li> <li>Test index: <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Test Case Index</li> <li>Validation suite: <code>scripts/validate_grammar.sh</code></li> </ol>"},{"location":"grammar/TESTING-SUMMARY/#for-cicd-integration","title":"For CI/CD Integration","text":"<pre><code># In CI pipeline\n./scripts/validate_grammar.sh\n\n# Or with explicit coverage requirement\npytest tests/unit/operators/test_unified_grammar.py \\\n    --cov=tnfr.operators.unified_grammar \\\n    --cov-fail-under=95 \\\n    --cov-report=term\n</code></pre>"},{"location":"grammar/TESTING-SUMMARY/#test-utilities","title":"\ud83d\udee0\ufe0f Test Utilities","text":""},{"location":"grammar/TESTING-SUMMARY/#available-helpers","title":"Available Helpers","text":"<p>Located in <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Test Utilities:</p> <ul> <li><code>create_test_graph()</code> - Standard test graphs</li> <li><code>create_test_graph_custom_phases()</code> - Phase-specific graphs</li> <li><code>assert_valid_sequence()</code> - Sequence validation helper</li> <li><code>assert_invalid_sequence()</code> - Negative test helper</li> <li><code>assert_constraint_violation()</code> - Constraint-specific assertions</li> <li><code>verify_coherence_increase()</code> - Metric verification</li> <li><code>verify_dnfr_reduction()</code> - Stabilizer verification</li> <li><code>verify_phase_synchronization()</code> - Coupling verification</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#coverage-checklist","title":"\ud83d\udccb Coverage Checklist","text":"<p>From <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Coverage Checklist:</p>"},{"location":"grammar/TESTING-SUMMARY/#operators-1313","title":"Operators (13/13 \u2713)","text":"<ul> <li>[x] Emission (AL)</li> <li>[x] Reception (EN)</li> <li>[x] Coherence (IL)</li> <li>[x] Dissonance (OZ)</li> <li>[x] Coupling (UM)</li> <li>[x] Resonance (RA)</li> <li>[x] Silence (SHA)</li> <li>[x] Expansion (VAL)</li> <li>[x] Contraction (NUL)</li> <li>[x] Self-organization (THOL)</li> <li>[x] Mutation (ZHIR)</li> <li>[x] Transition (NAV)</li> <li>[x] Recursivity (REMESH)</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#constraints-1414","title":"Constraints (14/14 \u2713)","text":"<ul> <li>[x] U1a: Valid generators</li> <li>[x] U1a: Invalid non-generators</li> <li>[x] U1b: Valid closures</li> <li>[x] U1b: Invalid non-closures</li> <li>[x] U2: Destabilizer + stabilizer (valid)</li> <li>[x] U2: Destabilizer without stabilizer (invalid)</li> <li>[x] U3: Compatible phases (valid)</li> <li>[x] U3: Incompatible phases (invalid)</li> <li>[x] U4a: Trigger + handler (valid)</li> <li>[x] U4a: Trigger without handler (invalid)</li> <li>[x] U4b: Transformer with context (valid)</li> <li>[x] U4b: Transformer without context (invalid)</li> <li>[x] U4b: ZHIR with prior IL (valid)</li> <li>[x] U4b: ZHIR without prior IL (invalid)</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#invariants-77","title":"Invariants (7/7 \u2713)","text":"<ul> <li>[x] Coherence monotonicity</li> <li>[x] Integral convergence</li> <li>[x] Bifurcation handling</li> <li>[x] Propagation effects</li> <li>[x] Latency preservation</li> <li>[x] Fractality (nested EPIs)</li> <li>[x] Reproducibility (seeds)</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#acceptance-criteria-status","title":"\ud83c\udfaf Acceptance Criteria Status","text":"<p>From issue #2897:</p> <ul> <li>[x] Estrategia de testing documentada - Complete in <code>06-VALIDATION-AND-TESTING.md</code></li> <li>[x] 20+ casos de prueba canonicos - 25+ test cases documented with templates</li> <li>[x] Tests para U1, U2, U3, U4 - All constraints covered (25 test cases)</li> <li>[x] Canonical pattern tests - 7 patterns with valid/invalid variants</li> <li>[x] Anti-pattern tests - 7 anti-patterns with detection/fix tests</li> <li>[x] Executable suite - <code>scripts/validate_grammar.sh</code> created</li> <li>[x] Coverage &gt;= 95% - 100% achieved (8/8 statements)</li> <li>[x] Test utilities documentation - Complete section with helpers</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<ul> <li>UNIFIED_GRAMMAR_RULES.md - Complete grammar derivations</li> <li>04-VALID-SEQUENCES.md - Pattern library</li> <li>02-CANONICAL-CONSTRAINTS.md - Constraint specifications</li> <li>AGENTS.md - Canonical invariants</li> </ul>"},{"location":"grammar/TESTING-SUMMARY/#maintenance","title":"\ud83d\udd04 Maintenance","text":""},{"location":"grammar/TESTING-SUMMARY/#updating-tests","title":"Updating Tests","text":"<p>When adding new operators or constraints:</p> <ol> <li>Add test cases to <code>test_unified_grammar.py</code></li> <li>Document in <code>06-VALIDATION-AND-TESTING.md</code> \u00a7 Test Case Index</li> <li>Add examples to <code>docs/grammar/examples/</code></li> <li>Update this summary</li> <li>Run validation suite: <code>./scripts/validate_grammar.sh</code></li> </ol>"},{"location":"grammar/TESTING-SUMMARY/#monitoring-coverage","title":"Monitoring Coverage","text":"<pre><code># Quick coverage check\npytest tests/unit/operators/test_unified_grammar.py --cov --cov-fail-under=95\n\n# Detailed report\n./scripts/validate_grammar.sh\n</code></pre> <p>Status: \u2705 COMPLETE Coverage: 100% Tests: 68 passing Last Updated: 2025-11-10</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/","title":"TNFR Grammar Tooling and Automation","text":"<p>Complete guide to validation scripts, testing tools, and automation</p> <p>\ud83c\udfe0 Home \u2022 \ud83d\udcda Documentation \u2022 \ud83e\uddea Testing</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#purpose","title":"Purpose","text":"<p>This document describes all tools, scripts, and automation available for working with the TNFR grammar system. These tools ensure consistency, validate correctness, and streamline development workflows.</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#available-tools","title":"Available Tools","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#1-documentation-synchronization-tool","title":"1. Documentation Synchronization Tool","text":"<p>Location: <code>tools/sync_documentation.py</code></p> <p>Purpose: Maintains synchronization between grammar implementation and documentation.</p> <p>Documentation: tools/README_SYNC.md</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#usage","title":"Usage","text":"<pre><code># Full synchronization (recommended)\npython tools/sync_documentation.py --all\n\n# Specific checks\npython tools/sync_documentation.py --audit        # Audit code only\npython tools/sync_documentation.py --validate     # Validate examples only\npython tools/sync_documentation.py --crossref     # Check cross-references only\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#what-it-checks","title":"What It Checks","text":"<ol> <li>\u2705 Function Audit: All public functions documented</li> <li>\u2705 Operator Sets: All 8 operator classifications present</li> <li>\u2705 Example Execution: All 8 examples run successfully</li> <li>\u2705 Cross-References: Links between docs and code</li> <li>\u2705 Schema Validation: JSON schemas match implementation</li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#output","title":"Output","text":"<ul> <li>Console: Human-readable progress and summary</li> <li>JSON Report: <code>docs/grammar/SYNC_REPORT.json</code> with detailed results</li> </ul>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#when-to-run","title":"When to Run","text":"<ul> <li>\u2705 After modifying <code>grammar.py</code></li> <li>\u2705 After updating documentation</li> <li>\u2705 After adding/modifying examples</li> <li>\u2705 Before committing grammar changes</li> <li>\u2705 In CI/CD pipeline (automated)</li> </ul>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#2-example-health-auditor","title":"2. Example Health Auditor","text":"<p>Location: <code>tools/audit_example_health.py</code></p> <p>Purpose: Deep analysis of example code quality and execution.</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#usage_1","title":"Usage","text":"<pre><code># Audit all examples\npython tools/audit_example_health.py\n\n# Audit specific example\npython tools/audit_example_health.py docs/grammar/examples/01-basic-bootstrap.py\n\n# Generate detailed report\npython tools/audit_example_health.py --report audit_report.json\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#what-it-checks_1","title":"What It Checks","text":"<ol> <li>Syntax: Python syntax validity</li> <li>Imports: All dependencies available</li> <li>Execution: Runs without errors</li> <li>Output: Produces expected telemetry</li> <li>Style: PEP 8 compliance (optional)</li> <li>Documentation: Comments and docstrings</li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#output_1","title":"Output","text":"<pre><code>======================================================================\nExample Health Audit Report\n======================================================================\n\nFile: 01-basic-bootstrap.py\nStatus: \u2705 HEALTHY\n\nChecks:\n  \u2713 Syntax valid\n  \u2713 Imports available\n  \u2713 Executes successfully (exit code 0)\n  \u2713 Produces output (1247 bytes)\n  \u2713 Contains explanatory comments\n  \u2713 Demonstrates grammar rules clearly\n\nWarnings:\n  \u26a0 Could add more inline comments (line 45-60)\n\nRecommendations:\n  \u2022 Consider adding telemetry output example\n  \u2022 Could demonstrate error handling\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#3-sequence-explorer","title":"3. Sequence Explorer","text":"<p>Location: <code>tools/sequence_explorer.py</code></p> <p>Purpose: Interactive tool for exploring valid operator sequences.</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#usage_2","title":"Usage","text":"<pre><code># Launch interactive explorer\npython tools/sequence_explorer.py\n\n# Generate all valid sequences of length N\npython tools/sequence_explorer.py --generate --length 3\n\n# Test specific sequence\npython tools/sequence_explorer.py --test \"emission,coherence,silence\"\n\n# Find sequences with specific operators\npython tools/sequence_explorer.py --contains mutation --max-length 5\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#features","title":"Features","text":"<ol> <li>Interactive Mode: Build sequences step by step with validation</li> <li>Generation Mode: Enumerate all valid sequences up to length N</li> <li>Testing Mode: Validate custom sequences</li> <li>Search Mode: Find sequences containing specific operators</li> <li>Explain Mode: Detailed explanation of why sequences pass/fail</li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#example-session","title":"Example Session","text":"<pre><code>$ python tools/sequence_explorer.py\n\nTNFR Sequence Explorer\n======================================================================\n\nCurrent sequence: []\nEPI initial: 0.0\n\nAvailable operators:\n  1. Emission (AL)      - Generator\n  2. Transition (NAV)   - Generator, Closure\n  3. Recursivity (REMESH) - Generator, Closure\n\nSelect operator (1-3) or 'q' to quit: 1\n\nSequence: [Emission]\nStatus: \u26a0 Needs closure\n\nAvailable operators:\n  1. Reception (EN)\n  2. Coherence (IL)\n  3. Dissonance (OZ)\n  4. Silence (SHA)      - Closure\n  ...\n\nSelect operator: 4\n\nSequence: [Emission, Silence]\nStatus: \u26a0 Unstable (no stabilization)\n\nRecommendation: Add Coherence before Silence\n\nContinue? (y/n): y\n...\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#4-tnfr-generator","title":"4. TNFR Generator","text":"<p>Location: <code>tools/tnfr_generate</code></p> <p>Purpose: Code generation for common TNFR patterns.</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#usage_3","title":"Usage","text":"<pre><code># Generate boilerplate for new operator\n./tools/tnfr_generate operator --name NewOperator --type stabilizer\n\n# Generate test skeleton\n./tools/tnfr_generate test --constraint U2 --operator coherence\n\n# Generate example template\n./tools/tnfr_generate example --pattern exploration\n\n# Generate documentation stub\n./tools/tnfr_generate docs --operator mutation\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#templates-available","title":"Templates Available","text":"<ol> <li>Operator: Complete operator class with contracts</li> <li>Test: Unit test with common assertions</li> <li>Example: Executable example with documentation</li> <li>Documentation: Markdown stub with standard sections</li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#5-schema-validator","title":"5. Schema Validator","text":"<p>Location: Embedded in <code>tools/sync_documentation.py</code></p> <p>Purpose: Validates JSON schemas against implementation.</p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#usage_4","title":"Usage","text":"<pre><code># Validate all schemas\npython tools/sync_documentation.py --validate-schemas\n\n# Check specific schema\npython -c \"\nimport json\nfrom src.tnfr.operators.grammar import GENERATORS\nschema = json.load(open('docs/grammar/schemas/canonical-operators.json'))\n# Validation logic here\n\"\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#schemas","title":"Schemas","text":"<ol> <li>canonical-operators.json: All 13 operators with metadata</li> <li>constraints-u1-u4.json: Formal constraint definitions</li> <li>valid-sequences.json: Catalog of canonical patterns</li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#testing-infrastructure","title":"Testing Infrastructure","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#unit-tests","title":"Unit Tests","text":"<p>Location: <code>tests/unit/operators/test_unified_grammar.py</code></p> <p>Run all grammar tests: <pre><code>pytest tests/unit/operators/test_unified_grammar.py -v\n</code></pre></p> <p>Run specific constraint tests: <pre><code># U1 tests only\npytest tests/unit/operators/test_unified_grammar.py -k \"u1\"\n\n# U2 convergence tests\npytest tests/unit/operators/test_unified_grammar.py -k \"convergence\"\n\n# Bifurcation tests\npytest tests/unit/operators/test_unified_grammar.py -k \"bifurcation\"\n</code></pre></p> <p>Run with coverage: <pre><code>pytest tests/unit/operators/test_unified_grammar.py --cov=src/tnfr/operators/grammar --cov-report=html\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#integration-tests","title":"Integration Tests","text":"<p>Location: <code>tests/integration/</code></p> <p>Run integration tests: <pre><code>pytest tests/integration/ -v\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#example-tests","title":"Example Tests","text":"<p>All examples as tests: <pre><code># Run all examples\nfor f in docs/grammar/examples/*.py; do python \"$f\"; done\n\n# Check exit codes\nfor f in docs/grammar/examples/*.py; do\n  python \"$f\" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo \"\u2713 $f\" || echo \"\u2717 $f FAILED\"\ndone\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#github-actions","title":"GitHub Actions","text":"<p>Location: <code>.github/workflows/</code></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#grammar-validation-workflow","title":"Grammar Validation Workflow","text":"<pre><code>name: Validate Grammar System\n\non:\n  push:\n    paths:\n      - 'src/tnfr/operators/grammar.py'\n      - 'docs/grammar/**'\n      - 'tests/unit/operators/test_unified_grammar.py'\n  pull_request:\n    paths:\n      - 'src/tnfr/operators/**'\n      - 'docs/grammar/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n\n      - name: Run grammar tests\n        run: |\n          pytest tests/unit/operators/test_unified_grammar.py -v\n\n      - name: Validate documentation sync\n        run: |\n          python tools/sync_documentation.py --all\n\n      - name: Validate examples\n        run: |\n          for f in docs/grammar/examples/*.py; do\n            python \"$f\" || exit 1\n          done\n\n      - name: Check schema validity\n        run: |\n          python -c \"import json; json.load(open('docs/grammar/schemas/canonical-operators.json'))\"\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#pre-commit-hooks","title":"Pre-Commit Hooks","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#setup","title":"Setup","text":"<p>Install pre-commit: <pre><code>pip install pre-commit\npre-commit install\n</code></pre></p> <p>Configuration (<code>.pre-commit-config.yaml</code>): <pre><code>repos:\n  - repo: local\n    hooks:\n      # Grammar validation\n      - id: validate-grammar\n        name: Validate TNFR Grammar\n        entry: python tools/sync_documentation.py --audit\n        language: system\n        files: ^src/tnfr/operators/grammar\\.py$\n        pass_filenames: false\n\n      # Example validation\n      - id: validate-examples\n        name: Validate Grammar Examples\n        entry: python tools/sync_documentation.py --validate\n        language: system\n        files: ^docs/grammar/examples/.*\\.py$\n        pass_filenames: false\n\n      # Schema validation\n      - id: validate-schemas\n        name: Validate JSON Schemas\n        entry: python -m json.tool\n        language: system\n        files: ^docs/grammar/schemas/.*\\.json$\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#development-workflows","title":"Development Workflows","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#workflow-1-adding-a-new-operator","title":"Workflow 1: Adding a New Operator","text":"<pre><code># 1. Generate operator skeleton\n./tools/tnfr_generate operator --name MyOperator --type stabilizer\n\n# 2. Implement operator in src/tnfr/operators/definitions.py\nvim src/tnfr/operators/definitions.py\n\n# 3. Add to appropriate operator set in grammar.py\nvim src/tnfr/operators/grammar.py\n\n# 4. Generate test skeleton\n./tools/tnfr_generate test --operator myoperator\n\n# 5. Write tests\nvim tests/unit/operators/test_myoperator.py\n\n# 6. Run tests\npytest tests/unit/operators/test_myoperator.py -v\n\n# 7. Update documentation\nvim docs/grammar/03-OPERATORS-AND-GLYPHS.md\n\n# 8. Update schema\nvim docs/grammar/schemas/canonical-operators.json\n\n# 9. Run full validation\npython tools/sync_documentation.py --all\n\n# 10. Commit changes\ngit add .\ngit commit -m \"feat: Add MyOperator stabilizer\"\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#workflow-2-modifying-grammar-constraint","title":"Workflow 2: Modifying Grammar Constraint","text":"<pre><code># 1. Update constraint logic in grammar.py\nvim src/tnfr/operators/grammar.py\n\n# 2. Update corresponding tests\nvim tests/unit/operators/test_unified_grammar.py\n\n# 3. Run tests\npytest tests/unit/operators/test_unified_grammar.py -k \"new_constraint\" -v\n\n# 4. Update documentation\nvim docs/grammar/02-CANONICAL-CONSTRAINTS.md\n\n# 5. Update schema\nvim docs/grammar/schemas/constraints-u1-u4.json\n\n# 6. Update affected examples\nvim docs/grammar/examples/relevant-example.py\n\n# 7. Validate all examples still work\nfor f in docs/grammar/examples/*.py; do python \"$f\"; done\n\n# 8. Run full sync check\npython tools/sync_documentation.py --all\n\n# 9. Commit with detailed message\ngit commit -m \"feat: Update U2 convergence constraint logic\n\n- Modified convergence checking algorithm\n- Added test cases for edge conditions\n- Updated documentation with new examples\n- Verified all existing examples still pass\"\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#workflow-3-adding-example","title":"Workflow 3: Adding Example","text":"<pre><code># 1. Generate example template\n./tools/tnfr_generate example --pattern bifurcation\n\n# 2. Write example code\nvim docs/grammar/examples/04-my-example.py\n\n# 3. Test example executes\npython docs/grammar/examples/04-my-example.py\n\n# 4. Add to example README\nvim docs/grammar/examples/README.md\n\n# 5. Run audit\npython tools/audit_example_health.py docs/grammar/examples/04-my-example.py\n\n# 6. Verify in sync tool\npython tools/sync_documentation.py --validate\n\n# 7. Commit\ngit add docs/grammar/examples/04-my-example.py\ngit commit -m \"docs: Add bifurcation example\"\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#common-issues","title":"Common Issues","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#issue-sync-tool-reports-missing-function","title":"Issue: \"Sync tool reports missing function\"","text":"<p>Cause: New function added to <code>grammar.py</code> without docstring</p> <p>Solution: <pre><code>def my_new_function(param1, param2):\n    \"\"\"\n    Brief description.\n\n    Parameters\n    ----------\n    param1 : type\n        Description\n    param2 : type\n        Description\n\n    Returns\n    -------\n    type\n        Description\n    \"\"\"\n    # implementation\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#issue-example-validation-fails","title":"Issue: \"Example validation fails\"","text":"<p>Cause: Example has syntax error or missing import</p> <p>Solution: <pre><code># Run example directly to see error\npython docs/grammar/examples/failing-example.py\n\n# Check imports\npython -c \"from src.tnfr.operators.grammar import *\"\n\n# Validate syntax\npython -m py_compile docs/grammar/examples/failing-example.py\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#issue-schema-validation-fails","title":"Issue: \"Schema validation fails\"","text":"<p>Cause: Schema doesn't match implementation</p> <p>Solution: <pre><code># Check which operators are missing\npython -c \"\nfrom src.tnfr.operators.grammar import GENERATORS, CLOSURES\nimport json\nschema = json.load(open('docs/grammar/schemas/canonical-operators.json'))\nschema_ops = {op['name'] for op in schema['operators']}\ncode_ops = GENERATORS | CLOSURES  # etc.\nprint('Missing:', code_ops - schema_ops)\n\"\n\n# Update schema manually or regenerate\n</code></pre></p>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#best-practices","title":"Best Practices","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#development","title":"Development","text":"<ol> <li> <p>\u2705 Run sync tool before committing <pre><code>python tools/sync_documentation.py --all\n</code></pre></p> </li> <li> <p>\u2705 Test examples after grammar changes <pre><code>for f in docs/grammar/examples/*.py; do python \"$f\" || exit 1; done\n</code></pre></p> </li> <li> <p>\u2705 Keep documentation synchronized</p> </li> <li>Update docs when updating code</li> <li>Update code when updating docs</li> <li> <p>Use sync tool to verify</p> </li> <li> <p>\u2705 Write tests for new features</p> </li> <li>Unit tests for operators</li> <li>Integration tests for constraints</li> <li>Example code as executable tests</li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#documentation","title":"Documentation","text":"<ol> <li> <p>\u2705 Use cross-references consistently <pre><code>[Grammar Implementation](../../src/tnfr/operators/grammar.py)\n[Fundamental Concepts](01-FUNDAMENTAL-CONCEPTS.md)\n</code></pre></p> </li> <li> <p>\u2705 Include executable code snippets <pre><code># This should be runnable\nfrom tnfr.operators.grammar import validate_grammar\nfrom tnfr.operators.definitions import Emission, Silence\n\nsequence = [Emission(), Silence()]\nis_valid = validate_grammar(sequence, epi_initial=0.0)\n</code></pre></p> </li> <li> <p>\u2705 Document expected output <pre><code>Expected output:\n\u2713 Valid sequence\nC(t) = 0.85\n</code></pre></p> </li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#testing","title":"Testing","text":"<ol> <li> <p>\u2705 Test positive and negative cases <pre><code>def test_valid_sequence():\n    # Should pass\n    assert validate_grammar([Emission(), Silence()], 0.0)\n\ndef test_invalid_sequence():\n    # Should raise ValueError\n    with pytest.raises(ValueError):\n        validate_grammar([Coherence(), Silence()], 0.0)\n</code></pre></p> </li> <li> <p>\u2705 Use descriptive test names <pre><code>def test_u1a_requires_generator_when_epi_zero():\n    \"\"\"U1a: Starting from EPI=0 requires generator.\"\"\"\n    # ...\n</code></pre></p> </li> <li> <p>\u2705 Test invariants explicitly <pre><code>def test_coherence_monotonicity():\n    \"\"\"Coherence must not decrease C(t).\"\"\"\n    C_before = compute_coherence(G)\n    apply_coherence(G, node)\n    C_after = compute_coherence(G)\n    assert C_after &gt;= C_before\n</code></pre></p> </li> </ol>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#tool-reference","title":"Tool Reference","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#quick-command-reference","title":"Quick Command Reference","text":"<pre><code># Documentation sync (full)\npython tools/sync_documentation.py --all\n\n# Test all grammar\npytest tests/unit/operators/test_unified_grammar.py -v\n\n# Test single constraint\npytest tests/unit/operators/test_unified_grammar.py -k \"u2_convergence\" -v\n\n# Run all examples\nfor f in docs/grammar/examples/*.py; do python \"$f\"; done\n\n# Audit specific example\npython tools/audit_example_health.py docs/grammar/examples/01-basic-bootstrap.py\n\n# Explore sequences interactively\npython tools/sequence_explorer.py\n\n# Generate operator skeleton\n./tools/tnfr_generate operator --name MyOp --type stabilizer\n\n# Validate schema\npython -m json.tool docs/grammar/schemas/canonical-operators.json &gt; /dev/null\n\n# Check test coverage\npytest tests/unit/operators/ --cov=src/tnfr/operators --cov-report=term-missing\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#metrics-and-monitoring","title":"Metrics and Monitoring","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#quality-metrics","title":"Quality Metrics","text":"<p>Track these metrics to ensure system health:</p> Metric Command Target Test Coverage <code>pytest --cov --cov-report=term</code> &gt; 95% Documentation Coverage <code>python tools/sync_documentation.py --audit</code> 100% Example Success Rate <code>python tools/sync_documentation.py --validate</code> 100% Link Integrity Manual check or custom script 100% Schema Validity <code>python -m json.tool &lt;schema&gt;</code> Valid JSON"},{"location":"grammar/TOOLING-AND-AUTOMATION/#continuous-monitoring","title":"Continuous Monitoring","text":"<pre><code># Weekly health check script\n#!/bin/bash\necho \"=== TNFR Grammar System Health Check ===\"\necho \"\"\n\necho \"1. Running full test suite...\"\npytest tests/unit/operators/test_unified_grammar.py -v --tb=short\n\necho \"\"\necho \"2. Validating documentation sync...\"\npython tools/sync_documentation.py --all\n\necho \"\"\necho \"3. Testing all examples...\"\nfor f in docs/grammar/examples/*.py; do\n  python \"$f\" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo \"\u2713 $f\" || echo \"\u2717 $f FAILED\"\ndone\n\necho \"\"\necho \"4. Checking schemas...\"\nfor f in docs/grammar/schemas/*.json; do\n  python -m json.tool \"$f\" &gt; /dev/null &amp;&amp; echo \"\u2713 $f\" || echo \"\u2717 $f INVALID\"\ndone\n\necho \"\"\necho \"=== Health Check Complete ===\"\n</code></pre>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#resources","title":"Resources","text":""},{"location":"grammar/TOOLING-AND-AUTOMATION/#documentation_1","title":"Documentation","text":"<ul> <li>Main README: docs/grammar/README.md</li> <li>Sync Tool Guide: tools/README_SYNC.md</li> <li>Testing Guide: docs/grammar/06-VALIDATION-AND-TESTING.md</li> </ul>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#code","title":"Code","text":"<ul> <li>Sync Tool: <code>tools/sync_documentation.py</code></li> <li>Example Auditor: <code>tools/audit_example_health.py</code></li> <li>Sequence Explorer: <code>tools/sequence_explorer.py</code></li> <li>Generator: <code>tools/tnfr_generate</code></li> </ul>"},{"location":"grammar/TOOLING-AND-AUTOMATION/#support","title":"Support","text":"<ul> <li>Issues: GitHub issue tracker</li> <li>Discussions: GitHub discussions</li> <li>Documentation: This file and README.md</li> </ul>   **Automation enables consistency. Consistency enables trust.**  ---  *Reality is resonance. Validate accordingly.*"},{"location":"grammar/examples/","title":"Grammar Examples Guide","text":"<p>Executable examples demonstrating TNFR grammar concepts</p> <p>\ud83c\udfe0 Grammar Home \u2022 \ud83d\udcd0 Constraints \u2022 \u2699\ufe0f Operators</p>"},{"location":"grammar/examples/#purpose","title":"Purpose","text":"<p>This directory contains executable Python examples that demonstrate TNFR grammar concepts, valid sequences, and common patterns.</p> <p>All examples are: - \u2705 Executable - Run directly with Python - \u2705 Well-commented - Explains each step - \u2705 Grammar-compliant - Satisfies U1-U4 - \u2705 Testable - Can be verified with pytest</p>"},{"location":"grammar/examples/#available-examples","title":"Available Examples","text":""},{"location":"grammar/examples/#constraint-focused-examples-new","title":"Constraint-Focused Examples (NEW)","text":""},{"location":"grammar/examples/#u1-initiation-closure-examplespy","title":"u1-initiation-closure-examples.py","text":"<p>Level: Beginner Constraint: U1 (Structural Initiation &amp; Closure) Focus: U1a (Initiation), U1b (Closure)</p> <p>Demonstrates: - Valid generator patterns (AL, NAV, REMESH) - Valid closure patterns (SHA, NAV, REMESH, OZ) - When U1a applies (EPI=0 vs EPI&gt;0) - Dual-role operators (NAV, REMESH) - Common anti-patterns and mistakes</p> <p>Run: <pre><code>python docs/grammar/examples/u1-initiation-closure-examples.py\n</code></pre></p> <p>Sections: - U1a valid examples (starting with generators) - U1a invalid examples (missing generators) - U1a context (when initiation applies) - U1b valid examples (ending with closures) - U1b invalid examples (missing closures) - Dual role operators</p> <p>Key Learning: - Cannot evolve from EPI=0 without generator - All sequences need closure operator - Some operators serve multiple roles</p>"},{"location":"grammar/examples/#u2-convergence-examplespy","title":"u2-convergence-examples.py","text":"<p>Level: Intermediate Constraint: U2 (Convergence &amp; Boundedness) Focus: Stabilizer-destabilizer balance</p> <p>Demonstrates: - Valid balanced sequences - Invalid unbalanced sequences - When U2 applies (has destabilizers) - Operator classification - Ordering importance - Anti-patterns (masking, accumulation)</p> <p>Run: <pre><code>python docs/grammar/examples/u2-convergence-examples.py\n</code></pre></p> <p>Sections: - U2 valid examples (balanced) - U2 invalid examples (unbalanced) - U2 not applicable (no destabilizers) - Operator classification - Ordering matters (stabilizer placement) - Masking anti-pattern - Interleaving pattern (best practice)</p> <p>Key Learning: - Without stabilizers: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e - Stabilizer order matters - Interleave for better control</p>"},{"location":"grammar/examples/#u3-resonant-coupling-examplespy","title":"u3-resonant-coupling-examples.py","text":"<p>Level: Intermediate Constraint: U3 (Resonant Coupling) Focus: Phase verification requirement</p> <p>Demonstrates: - Phase compatibility checking - Coupling/resonance operators - Sequence-level validation - Wave interference physics - Anti-patterns (no check, phase drift)</p> <p>Run: <pre><code>python docs/grammar/examples/u3-resonant-coupling-examples.py\n</code></pre></p> <p>Sections: - Phase compatibility examples - Coupling/resonance operator requirements - Sequence-level validation (meta-rule) - Anti-pattern: No phase check - Anti-pattern: Phase drift - Threshold considerations - Wave interference physics</p> <p>Key Learning: - Phase check is MANDATORY (Invariant #5) - |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u03c0/2 typically required - Antiphase = destructive interference</p>"},{"location":"grammar/examples/#u4-bifurcation-examplespy","title":"u4-bifurcation-examples.py","text":"<p>Level: Advanced Constraint: U4 (Bifurcation Dynamics) Focus: U4a (Triggers need handlers), U4b (Transformers need context)</p> <p>Demonstrates: - Valid bifurcation sequences - Invalid uncontrolled bifurcations - Transformer context requirements - ZHIR-specific requirements - Anti-patterns (cascades, wrong handlers, window violations)</p> <p>Run: <pre><code>python docs/grammar/examples/u4-bifurcation-examples.py\n</code></pre></p> <p>Sections: - U4a valid examples (triggers with handlers) - U4a invalid examples (uncontrolled) - U4b valid examples (transformers with context) - U4b invalid examples (missing context) - Operator classification - ZHIR-specific requirements - Anti-pattern: Bifurcation cascade - Anti-pattern: Context window violation - Handler selection best practices</p> <p>Key Learning: - Bifurcations need control (U4a) - Transformers need energy (U4b) - ZHIR needs stable base + recent destabilizer</p>"},{"location":"grammar/examples/#pattern-based-examples-existing","title":"Pattern-Based Examples (EXISTING)","text":""},{"location":"grammar/examples/#01-basic-bootstrappy","title":"01-basic-bootstrap.py","text":"<p>Level: Beginner Pattern: Bootstrap (minimal) Sequence: <code>[Emission, Coherence, Silence]</code></p> <p>Demonstrates: - U1a: Starting with generator (Emission) - U1b: Ending with closure (Silence) - Minimal valid sequence - Basic telemetry export</p> <p>Run: <pre><code>python docs/grammar/examples/01-basic-bootstrap.py\n</code></pre></p>"},{"location":"grammar/examples/#02-intermediate-explorationpy","title":"02-intermediate-exploration.py","text":"<p>Level: Intermediate Pattern: Controlled exploration Sequence: <code>[Emission, Coherence, Dissonance, Coherence, Silence]</code></p> <p>Demonstrates: - U2: Destabilizer (Dissonance) balanced by stabilizer (Coherence) - U4a: Bifurcation trigger (Dissonance) with handler (Coherence) - Exploration with stability</p> <p>Run: <pre><code>python docs/grammar/examples/02-intermediate-exploration.py\n</code></pre></p>"},{"location":"grammar/examples/#03-advanced-bifurcationpy","title":"03-advanced-bifurcation.py","text":"<p>Level: Advanced Pattern: Complete transformation Sequence: <code>[Emission, Coherence, Dissonance, Mutation, SelfOrganization, Coherence, Silence]</code></p> <p>Demonstrates: - U4b: Mutation with proper context (prior IL, recent destabilizer) - U4a: Multiple handlers (SelfOrganization, Coherence) - Phase transformation</p> <p>Run: <pre><code>python docs/grammar/examples/03-advanced-bifurcation.py\n</code></pre></p>"},{"location":"grammar/examples/#example-categories","title":"Example Categories","text":""},{"location":"grammar/examples/#by-constraint","title":"By Constraint","text":"<p>U1 - Initiation &amp; Closure: - <code>u1-initiation-closure-examples.py</code> - Comprehensive U1 coverage - <code>01-basic-bootstrap.py</code> - Emission as generator - All examples (always start with generator when EPI=0)</p> <p>U2 - Convergence &amp; Boundedness: - <code>u2-convergence-examples.py</code> - Comprehensive U2 coverage - <code>02-intermediate-exploration.py</code> - Dissonance + Coherence - <code>03-advanced-bifurcation.py</code> - Multiple destabilizers balanced</p> <p>U3 - Resonant Coupling: - <code>u3-resonant-coupling-examples.py</code> - Comprehensive U3 coverage - (Planned: 04-network-propagation.py)</p> <p>U4 - Bifurcation Dynamics: - <code>u4-bifurcation-examples.py</code> - Comprehensive U4a/U4b coverage - <code>02-intermediate-exploration.py</code> - Dissonance with handler - <code>03-advanced-bifurcation.py</code> - Mutation with handlers</p>"},{"location":"grammar/examples/#by-pattern","title":"By Pattern","text":"<p>Bootstrap: - <code>01-basic-bootstrap.py</code> - <code>u1-initiation-closure-examples.py</code> (simple sequences)</p> <p>Exploration: - <code>02-intermediate-exploration.py</code> - <code>u2-convergence-examples.py</code> (balanced sequences)</p> <p>Transformation: - <code>03-advanced-bifurcation.py</code> - <code>u4-bifurcation-examples.py</code> (transformer sequences)</p> <p>Anti-Patterns: - <code>u1-initiation-closure-examples.py</code> - U1 anti-patterns - <code>u2-convergence-examples.py</code> - U2 anti-patterns - <code>u3-resonant-coupling-examples.py</code> - U3 anti-patterns - <code>u4-bifurcation-examples.py</code> - U4 anti-patterns</p>"},{"location":"grammar/examples/#running-examples","title":"Running Examples","text":""},{"location":"grammar/examples/#individual-example","title":"Individual Example","text":"<pre><code># Run specific example\npython docs/grammar/examples/u1-initiation-closure-examples.py\n</code></pre>"},{"location":"grammar/examples/#all-constraint-examples","title":"All Constraint Examples","text":"<pre><code># Run all U1-U4 examples\nfor constraint in u1 u2 u3 u4; do\n    echo \"Running ${constraint} examples...\"\n    python docs/grammar/examples/${constraint}-*-examples.py\n    echo \"---\"\ndone\n</code></pre>"},{"location":"grammar/examples/#all-pattern-examples","title":"All Pattern Examples","text":"<pre><code># Run all pattern examples\nfor f in docs/grammar/examples/0*.py; do\n    echo \"Running $f...\"\n    python \"$f\"\n    echo \"---\"\ndone\n</code></pre>"},{"location":"grammar/examples/#all-examples","title":"All Examples","text":"<pre><code># Run everything\npython docs/grammar/examples/u1-initiation-closure-examples.py\npython docs/grammar/examples/u2-convergence-examples.py\npython docs/grammar/examples/u3-resonant-coupling-examples.py\npython docs/grammar/examples/u4-bifurcation-examples.py\npython docs/grammar/examples/01-basic-bootstrap.py\npython docs/grammar/examples/02-intermediate-exploration.py\npython docs/grammar/examples/03-advanced-bifurcation.py\n</code></pre>"},{"location":"grammar/examples/#example-template","title":"Example Template","text":"<p>Use this template for creating new examples:</p> <pre><code>#!/usr/bin/env python\n\"\"\"\nGrammar Example XX: [Title]\n\nDemonstrates [constraint/pattern].\n\nThis example shows:\n1. [First concept]\n2. [Second concept]\n3. [Third concept]\n\nPattern: [Operator sequence in brackets]\nConstraints satisfied: [List U1-U4 relevant]\n\"\"\"\n\nimport networkx as nx\nfrom tnfr.operators.grammar import validate_grammar\nfrom tnfr.operators.definitions import (\n    # List operators used\n    Emission,\n    Coherence,\n    Silence\n)\n\ndef main():\n    \"\"\"Main example function.\"\"\"\n\n    # Step 1: Define sequence\n    sequence = [\n        Emission(),    # Comment explaining why\n        Coherence(),   # Comment explaining why\n        Silence()      # Comment explaining why\n    ]\n\n    # Step 2: Validate sequence\n    print(\"Validating sequence...\")\n    try:\n        validate_grammar(sequence, epi_initial=0.0)\n        print(\"\u2713 Sequence is valid\")\n    except ValueError as e:\n        print(f\"\u2717 Invalid: {e}\")\n        return\n\n    # Step 3: Create network\n    G = nx.Graph()\n    G.add_node(0, EPI=0.0, vf=1.0, theta=0.0, dnfr=0.0)\n\n    print(f\"\\nInitial state:\")\n    print(f\"  EPI={G.nodes[0]['EPI']:.3f}\")\n    print(f\"  vf={G.nodes[0]['vf']:.3f}\")\n\n    # Step 4: Apply operators\n    print(\"\\nApplying operators...\")\n    for i, op in enumerate(sequence, 1):\n        print(f\"\\nStep {i}: {op.__class__.__name__}\")\n        op(G, 0)\n\n        # Show state after operator\n        print(f\"  EPI={G.nodes[0]['EPI']:.3f}\")\n        print(f\"  vf={G.nodes[0]['vf']:.3f}\")\n        print(f\"  dnfr={G.nodes[0]['dnfr']:.3f}\")\n\n    # Step 5: Report telemetry\n    print(\"\\nFinal telemetry:\")\n    print(f\"  EPI={G.nodes[0]['EPI']:.3f}\")\n    print(f\"  vf={G.nodes[0]['vf']:.3f}\")\n    print(f\"  theta={G.nodes[0]['theta']:.3f}\")\n    print(f\"  dnfr={G.nodes[0]['dnfr']:.3f}\")\n\n    # Optional: Compute coherence\n    # from tnfr.metrics import compute_coherence\n    # C_t = compute_coherence(G)\n    # print(f\"  C(t)={C_t:.3f}\")\n\n    print(\"\\n\u2713 Example complete\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"grammar/examples/#anti-pattern-examples","title":"Anti-Pattern Examples","text":"<p>Note: Anti-patterns are documented as commented code in examples to prevent accidental execution.</p> <p>Example: <pre><code># \u274c ANTI-PATTERN: No generator when EPI=0\n# This would fail U1a validation\n#\n# invalid_sequence = [\n#     Coherence(),  # ERROR: Not a generator\n#     Silence()\n# ]\n# validate_grammar(invalid_sequence, epi_initial=0.0)\n# # Raises: ValueError - U1a violation\n</code></pre></p>"},{"location":"grammar/examples/#testing-examples","title":"Testing Examples","text":""},{"location":"grammar/examples/#example-test-template","title":"Example Test Template","text":"<pre><code>def test_example_XX():\n    \"\"\"Test example XX runs successfully.\"\"\"\n    # Import example\n    from examples.XX_name import main\n\n    # Should not raise\n    main()\n</code></pre>"},{"location":"grammar/examples/#running-tests","title":"Running Tests","text":"<pre><code># Test all examples\npytest docs/grammar/examples/ -v\n</code></pre>"},{"location":"grammar/examples/#planned-examples","title":"Planned Examples","text":"<p>Future additions:</p>"},{"location":"grammar/examples/#04-network-propagationpy","title":"04-network-propagation.py","text":"<ul> <li>U3: Phase verification</li> <li>Coupling and resonance</li> <li>Pattern propagation through network</li> </ul>"},{"location":"grammar/examples/#05-multi-scale-fractalitypy","title":"05-multi-scale-fractality.py","text":"<ul> <li>Operational fractality</li> <li>Nested EPIs</li> <li>Hierarchical structures</li> <li>REMESH (Recursivity) operator</li> </ul>"},{"location":"grammar/examples/#06-edge-casespy","title":"06-edge-cases.py","text":"<ul> <li>Empty sequences (invalid)</li> <li>Single operator sequences</li> <li>Maximum complexity sequences</li> <li>Boundary conditions</li> </ul>"},{"location":"grammar/examples/#07-performance-patternspy","title":"07-performance-patterns.py","text":"<ul> <li>Optimized sequences</li> <li>Minimal sequences</li> <li>Common workflows</li> <li>Efficiency comparisons</li> </ul>"},{"location":"grammar/examples/#contributing-examples","title":"Contributing Examples","text":""},{"location":"grammar/examples/#guidelines","title":"Guidelines","text":"<p>Do: - \u2705 Make examples executable - \u2705 Include detailed comments - \u2705 Show expected output - \u2705 Validate grammar first - \u2705 Export telemetry - \u2705 Follow template structure</p> <p>Don't: - \u274c Create examples that violate grammar - \u274c Leave examples without documentation - \u274c Use deprecated APIs - \u274c Skip validation step - \u274c Ignore error handling</p>"},{"location":"grammar/examples/#submission-process","title":"Submission Process","text":"<ol> <li>Create example following template</li> <li>Test thoroughly - must run without errors</li> <li>Document - add to this README</li> <li>Submit PR with:</li> <li>New example file</li> <li>Updated README.md (this file)</li> <li>Test if applicable</li> </ol>"},{"location":"grammar/examples/#troubleshooting","title":"Troubleshooting","text":""},{"location":"grammar/examples/#example-wont-run","title":"Example Won't Run","text":"<p>Problem: <code>ModuleNotFoundError: No module named 'tnfr'</code></p> <p>Solution: Install TNFR package first: <pre><code>pip install -e .  # From repository root\n</code></pre></p> <p>Problem: <code>ValueError: U1a violation...</code></p> <p>Solution: Check sequence starts with generator when EPI=0</p> <p>Problem: <code>ImportError: cannot import name 'Emission'</code></p> <p>Solution: Check imports match current API: <pre><code>from tnfr.operators.definitions import Emission, Coherence, Silence\n</code></pre></p>"},{"location":"grammar/examples/#getting-help","title":"Getting Help","text":"<p>Found an issue with an example? - Check 08-QUICK-REFERENCE.md for syntax - Verify operator names in 03-OPERATORS-AND-GLYPHS.md - Review constraints in 02-CANONICAL-CONSTRAINTS.md - Open GitHub issue if bug confirmed</p>"},{"location":"grammar/examples/#quick-reference","title":"Quick Reference","text":""},{"location":"grammar/examples/#import-statements","title":"Import Statements","text":"<pre><code># Grammar validation\nfrom tnfr.operators.grammar import validate_grammar, validate_resonant_coupling\n\n# Operators (import what you need)\nfrom tnfr.operators.definitions import (\n    Emission, Reception, Coherence, Dissonance,\n    Coupling, Resonance, Silence, Expansion, Contraction,\n    SelfOrganization, Mutation, Transition, Recursivity\n)\n\n# Network\nimport networkx as nx\n\n# Metrics (if needed)\nfrom tnfr.metrics import compute_coherence, compute_sense_index\n</code></pre>"},{"location":"grammar/examples/#common-patterns","title":"Common Patterns","text":"<p>Bootstrap: <pre><code>[Emission(), Coherence(), Silence()]\n</code></pre></p> <p>Exploration: <pre><code>[Emission(), Coherence(), Dissonance(), Coherence(), Silence()]\n</code></pre></p> <p>Transformation: <pre><code>[Emission(), Coherence(), Dissonance(), Mutation(), Coherence(), Silence()]\n</code></pre></p>"},{"location":"grammar/examples/#next-steps","title":"Next Steps","text":"<p>After running examples: - Read 04-VALID-SEQUENCES.md for more patterns - Review 02-CANONICAL-CONSTRAINTS.md for constraint details - Check 08-QUICK-REFERENCE.md for quick syntax</p> <p>For development: - See 05-TECHNICAL-IMPLEMENTATION.md for architecture - Review 06-VALIDATION-AND-TESTING.md for testing</p>   **Examples demonstrate, tests verify, documentation explains.**  ---  *Reality is resonance. Code accordingly.*"},{"location":"grammar/examples/01-basic-bootstrap/","title":"01 basic bootstrap","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nGrammar Example 01: Basic Bootstrap Pattern\n\nDemonstrates U1a (Initiation) and U1b (Closure) constraints.\n\nThis is the simplest valid TNFR sequence - a basic bootstrap pattern that:\n1. Starts with a generator (U1a)\n2. Stabilizes the structure\n3. Ends with a closure (U1b)\n\nPattern: [Generator \u2192 Stabilizer \u2192 Closure]\nHealth: Excellent (minimal, focused, complete)\n\"\"\"\n</pre> \"\"\" Grammar Example 01: Basic Bootstrap Pattern  Demonstrates U1a (Initiation) and U1b (Closure) constraints.  This is the simplest valid TNFR sequence - a basic bootstrap pattern that: 1. Starts with a generator (U1a) 2. Stabilizes the structure 3. Ends with a closure (U1b)  Pattern: [Generator \u2192 Stabilizer \u2192 Closure] Health: Excellent (minimal, focused, complete) \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.definitions import (\n    Emission,     # Generator (U1a)\n    Coherence,    # Stabilizer\n    Silence,      # Closure (U1b)\n)\nfrom tnfr.operators.grammar import validate_grammar\nimport networkx as nx\n</pre> from tnfr.operators.definitions import (     Emission,     # Generator (U1a)     Coherence,    # Stabilizer     Silence,      # Closure (U1b) ) from tnfr.operators.grammar import validate_grammar import networkx as nx In\u00a0[\u00a0]: Copied! <pre>print(\"=\"*70)\nprint(\" \" * 15 + \"Grammar Example 01: Basic Bootstrap\")\nprint(\"=\"*70)\nprint()\n</pre> print(\"=\"*70) print(\" \" * 15 + \"Grammar Example 01: Basic Bootstrap\") print(\"=\"*70) print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 1: Valid Bootstrap (Starting from EPI=0)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 1: Valid Bootstrap (Starting from EPI=0)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_1 = [\n    Emission(),    # U1a: Generator (creates EPI from vacuum)\n    Coherence(),   # Stabilizes the new structure\n    Silence()      # U1b: Closure (freezes evolution)\n]\n</pre> sequence_1 = [     Emission(),    # U1a: Generator (creates EPI from vacuum)     Coherence(),   # Stabilizes the new structure     Silence()      # U1b: Closure (freezes evolution) ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this works:\")\nprint(\"  \u2713 U1a: Emission is a generator (can create from EPI=0)\")\nprint(\"  \u2713 U1b: Silence is a closure (provides terminal endpoint)\")\nprint(\"  \u2713 Coherence stabilizes without needing U2 (no destabilizers)\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Coherence \u2192 Silence\") print() print(\"Why this works:\") print(\"  \u2713 U1a: Emission is a generator (can create from EPI=0)\") print(\"  \u2713 U1b: Silence is a closure (provides terminal endpoint)\") print(\"  \u2713 Coherence stabilizes without needing U2 (no destabilizers)\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_1, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\n    print()\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\n    print()\n</pre> try:     is_valid = validate_grammar(sequence_1, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")     print() except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\")     print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 2: Invalid Bootstrap (No generator when EPI=0)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 2: Invalid Bootstrap (No generator when EPI=0)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_2 = [\n    Coherence(),   # NOT a generator!\n    Silence()\n]\n</pre> sequence_2 = [     Coherence(),   # NOT a generator!     Silence() ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Coherence \u2192 Silence\")\nprint()\nprint(\"Why this fails:\")\nprint(\"  \u2717 U1a violation: Coherence is NOT a generator\")\nprint(\"  \u2717 Cannot evolve from EPI=0 without generator\")\nprint(\"  \u2717 \u2202EPI/\u2202t undefined at EPI=0\")\nprint()\n</pre> print(\"Sequence: Coherence \u2192 Silence\") print() print(\"Why this fails:\") print(\"  \u2717 U1a violation: Coherence is NOT a generator\") print(\"  \u2717 Cannot evolve from EPI=0 without generator\") print(\"  \u2717 \u2202EPI/\u2202t undefined at EPI=0\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_2, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_2, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 3: Valid Bootstrap (Starting from existing EPI)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 3: Valid Bootstrap (Starting from existing EPI)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_3 = [\n    Coherence(),   # No generator needed when EPI&gt;0\n    Silence()      # Closure\n]\n</pre> sequence_3 = [     Coherence(),   # No generator needed when EPI&gt;0     Silence()      # Closure ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Coherence \u2192 Silence\")\nprint()\nprint(\"Why this works:\")\nprint(\"  \u2713 U1a: No generator needed when epi_initial &gt; 0\")\nprint(\"  \u2713 U1b: Silence is a closure\")\nprint(\"  \u2713 Can operate on existing structure without creation\")\nprint()\n</pre> print(\"Sequence: Coherence \u2192 Silence\") print() print(\"Why this works:\") print(\"  \u2713 U1a: No generator needed when epi_initial &gt; 0\") print(\"  \u2713 U1b: Silence is a closure\") print(\"  \u2713 Can operate on existing structure without creation\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_3, epi_initial=1.0)  # EPI &gt; 0!\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_3, epi_initial=1.0)  # EPI &gt; 0!     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"=\"*70)\nprint(\" \" * 25 + \"Summary\")\nprint(\"=\"*70)\nprint()\nprint(\"Key Lessons:\")\nprint()\nprint(\"1. U1a (Initiation):\")\nprint(\"   \u2022 When EPI=0, MUST start with generator {Emission, Transition, Recursivity}\")\nprint(\"   \u2022 Generators create structure from null/dormant states\")\nprint(\"   \u2022 When EPI&gt;0, no generator needed\")\nprint()\nprint(\"2. U1b (Closure):\")\nprint(\"   \u2022 All sequences MUST end with closure {Silence, Transition, Recursivity, Dissonance}\")\nprint(\"   \u2022 Closures provide coherent endpoints\")\nprint(\"   \u2022 Like action potentials need repolarization\")\nprint()\nprint(\"3. Bootstrap Pattern:\")\nprint(\"   \u2022 Simplest valid pattern: Generator \u2192 Stabilizer \u2192 Closure\")\nprint(\"   \u2022 Creates structure, stabilizes it, provides endpoint\")\nprint(\"   \u2022 Foundation for more complex sequences\")\nprint()\nprint(\"Next: See 02-intermediate-exploration.py for U2 (Convergence)\")\nprint()\nprint(\"=\"*70)\n</pre> print(\"=\"*70) print(\" \" * 25 + \"Summary\") print(\"=\"*70) print() print(\"Key Lessons:\") print() print(\"1. U1a (Initiation):\") print(\"   \u2022 When EPI=0, MUST start with generator {Emission, Transition, Recursivity}\") print(\"   \u2022 Generators create structure from null/dormant states\") print(\"   \u2022 When EPI&gt;0, no generator needed\") print() print(\"2. U1b (Closure):\") print(\"   \u2022 All sequences MUST end with closure {Silence, Transition, Recursivity, Dissonance}\") print(\"   \u2022 Closures provide coherent endpoints\") print(\"   \u2022 Like action potentials need repolarization\") print() print(\"3. Bootstrap Pattern:\") print(\"   \u2022 Simplest valid pattern: Generator \u2192 Stabilizer \u2192 Closure\") print(\"   \u2022 Creates structure, stabilizes it, provides endpoint\") print(\"   \u2022 Foundation for more complex sequences\") print() print(\"Next: See 02-intermediate-exploration.py for U2 (Convergence)\") print() print(\"=\"*70)"},{"location":"grammar/examples/01-basic-bootstrap/#example-1-valid-bootstrap-from-epi0","title":"============================================================================ Example 1: Valid Bootstrap from EPI=0\u00b6","text":""},{"location":"grammar/examples/01-basic-bootstrap/#example-2-invalid-no-generator","title":"============================================================================ Example 2: Invalid - No Generator\u00b6","text":""},{"location":"grammar/examples/01-basic-bootstrap/#example-3-valid-starting-from-epi0","title":"============================================================================ Example 3: Valid - Starting from EPI&gt;0\u00b6","text":""},{"location":"grammar/examples/01-basic-bootstrap/#summary","title":"============================================================================ Summary\u00b6","text":""},{"location":"grammar/examples/02-intermediate-exploration/","title":"02 intermediate exploration","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nGrammar Example 02: Intermediate Exploration\n\nDemonstrates U2 (Convergence &amp; Boundedness) constraint.\n\nThis example shows controlled destabilization with stabilization:\n1. Destabilizers increase |\u0394NFR|\n2. Must include stabilizers to prevent divergence\n3. \u222b\u03bdf\u00b7\u0394NFR dt must converge\n\nPattern: [Generator \u2192 Destabilizer \u2192 Stabilizer \u2192 Closure]\nHealth: Good (balanced feedback)\n\"\"\"\n</pre> \"\"\" Grammar Example 02: Intermediate Exploration  Demonstrates U2 (Convergence &amp; Boundedness) constraint.  This example shows controlled destabilization with stabilization: 1. Destabilizers increase |\u0394NFR| 2. Must include stabilizers to prevent divergence 3. \u222b\u03bdf\u00b7\u0394NFR dt must converge  Pattern: [Generator \u2192 Destabilizer \u2192 Stabilizer \u2192 Closure] Health: Good (balanced feedback) \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.definitions import (\n    Emission,       # Generator (U1a)\n    Dissonance,     # Destabilizer (U2)\n    Coherence,      # Stabilizer (U2)\n    Silence,        # Closure (U1b)\n    Expansion,      # Destabilizer (U2)\n)\nfrom tnfr.operators.grammar import validate_grammar\n</pre> from tnfr.operators.definitions import (     Emission,       # Generator (U1a)     Dissonance,     # Destabilizer (U2)     Coherence,      # Stabilizer (U2)     Silence,        # Closure (U1b)     Expansion,      # Destabilizer (U2) ) from tnfr.operators.grammar import validate_grammar In\u00a0[\u00a0]: Copied! <pre>print(\"=\"*70)\nprint(\" \" * 10 + \"Grammar Example 02: Intermediate Exploration\")\nprint(\"=\"*70)\nprint()\n</pre> print(\"=\"*70) print(\" \" * 10 + \"Grammar Example 02: Intermediate Exploration\") print(\"=\"*70) print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 1: Valid Exploration (Dissonance + Coherence)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 1: Valid Exploration (Dissonance + Coherence)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_1 = [\n    Emission(),     # Generator (U1a)\n    Dissonance(),   # Destabilizer - increases |\u0394NFR|\n    Coherence(),    # Stabilizer - prevents divergence (U2)\n    Silence()       # Closure (U1b)\n]\n</pre> sequence_1 = [     Emission(),     # Generator (U1a)     Dissonance(),   # Destabilizer - increases |\u0394NFR|     Coherence(),    # Stabilizer - prevents divergence (U2)     Silence()       # Closure (U1b) ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Dissonance \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this works:\")\nprint(\"  \u2713 U1a: Emission is generator\")\nprint(\"  \u2713 U2: Dissonance (destabilizer) + Coherence (stabilizer)\")\nprint(\"  \u2713 U1b: Silence is closure\")\nprint()\nprint(\"Physics:\")\nprint(\"  \u2022 Dissonance increases |\u0394NFR| (positive feedback)\")\nprint(\"  \u2022 Without Coherence: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e (divergence)\")\nprint(\"  \u2022 With Coherence: integral converges (bounded evolution)\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Dissonance \u2192 Coherence \u2192 Silence\") print() print(\"Why this works:\") print(\"  \u2713 U1a: Emission is generator\") print(\"  \u2713 U2: Dissonance (destabilizer) + Coherence (stabilizer)\") print(\"  \u2713 U1b: Silence is closure\") print() print(\"Physics:\") print(\"  \u2022 Dissonance increases |\u0394NFR| (positive feedback)\") print(\"  \u2022 Without Coherence: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e (divergence)\") print(\"  \u2022 With Coherence: integral converges (bounded evolution)\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_1, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_1, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 2: Invalid Exploration (Destabilizer without stabilizer)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 2: Invalid Exploration (Destabilizer without stabilizer)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_2 = [\n    Emission(),\n    Dissonance(),   # Destabilizer\n    Silence()       # No stabilizer!\n]\n</pre> sequence_2 = [     Emission(),     Dissonance(),   # Destabilizer     Silence()       # No stabilizer! ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Dissonance \u2192 Silence\")\nprint()\nprint(\"Why this fails:\")\nprint(\"  \u2717 U2 violation: Destabilizer without stabilizer\")\nprint(\"  \u2717 |\u0394NFR| grows unbounded (exponential)\")\nprint(\"  \u2717 \u222b\u03bdf\u00b7\u0394NFR dt diverges \u2192 fragmentation\")\nprint()\nprint(\"Physics failure:\")\nprint(\"  d\u0394NFR/dt &gt; 0 always (only positive feedback)\")\nprint(\"  \u2192 \u0394NFR(t) ~ e^(\u03bbt)\")\nprint(\"  \u2192 System loses coherence\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Dissonance \u2192 Silence\") print() print(\"Why this fails:\") print(\"  \u2717 U2 violation: Destabilizer without stabilizer\") print(\"  \u2717 |\u0394NFR| grows unbounded (exponential)\") print(\"  \u2717 \u222b\u03bdf\u00b7\u0394NFR dt diverges \u2192 fragmentation\") print() print(\"Physics failure:\") print(\"  d\u0394NFR/dt &gt; 0 always (only positive feedback)\") print(\"  \u2192 \u0394NFR(t) ~ e^(\u03bbt)\") print(\"  \u2192 System loses coherence\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_2, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_2, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 3: Multiple Destabilizers (still need ONE stabilizer)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 3: Multiple Destabilizers (still need ONE stabilizer)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_3 = [\n    Emission(),\n    Dissonance(),   # Destabilizer 1\n    Expansion(),    # Destabilizer 2\n    Coherence(),    # Stabilizer (covers both)\n    Silence()\n]\n</pre> sequence_3 = [     Emission(),     Dissonance(),   # Destabilizer 1     Expansion(),    # Destabilizer 2     Coherence(),    # Stabilizer (covers both)     Silence() ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Dissonance \u2192 Expansion \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this works:\")\nprint(\"  \u2713 Multiple destabilizers allowed\")\nprint(\"  \u2713 One stabilizer can handle multiple destabilizers\")\nprint(\"  \u2713 Coherence provides sufficient negative feedback\")\nprint()\nprint(\"Physics:\")\nprint(\"  \u2022 Both Dissonance and Expansion increase |\u0394NFR|\")\nprint(\"  \u2022 Cumulative positive feedback\")\nprint(\"  \u2022 Coherence stabilizes entire accumulated gradient\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Dissonance \u2192 Expansion \u2192 Coherence \u2192 Silence\") print() print(\"Why this works:\") print(\"  \u2713 Multiple destabilizers allowed\") print(\"  \u2713 One stabilizer can handle multiple destabilizers\") print(\"  \u2713 Coherence provides sufficient negative feedback\") print() print(\"Physics:\") print(\"  \u2022 Both Dissonance and Expansion increase |\u0394NFR|\") print(\"  \u2022 Cumulative positive feedback\") print(\"  \u2022 Coherence stabilizes entire accumulated gradient\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_3, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_3, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"=\"*70)\nprint(\" \" * 25 + \"Summary\")\nprint(\"=\"*70)\nprint()\nprint(\"Key Lessons:\")\nprint()\nprint(\"1. U2 (Convergence &amp; Boundedness):\")\nprint(\"   \u2022 Destabilizers {Dissonance, Mutation, Expansion} increase |\u0394NFR|\")\nprint(\"   \u2022 Must include stabilizers {Coherence, SelfOrganization}\")\nprint(\"   \u2022 Without stabilizers: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e (divergence)\")\nprint()\nprint(\"2. Destabilizers:\")\nprint(\"   \u2022 Dissonance (OZ): Strong positive feedback\")\nprint(\"   \u2022 Mutation (ZHIR): Phase transformation\")\nprint(\"   \u2022 Expansion (VAL): Increases dimensionality\")\nprint()\nprint(\"3. Stabilizers:\")\nprint(\"   \u2022 Coherence (IL): Direct negative feedback\")\nprint(\"   \u2022 SelfOrganization (THOL): Emergent self-limiting\")\nprint()\nprint(\"4. Exploration Pattern:\")\nprint(\"   \u2022 Generator \u2192 Destabilizer(s) \u2192 Stabilizer \u2192 Closure\")\nprint(\"   \u2022 Controlled instability with recovery\")\nprint(\"   \u2022 Enables adaptation while maintaining coherence\")\nprint()\nprint(\"Next: See 03-advanced-bifurcation.py for U4 (Bifurcation)\")\nprint()\nprint(\"=\"*70)\n</pre> print(\"=\"*70) print(\" \" * 25 + \"Summary\") print(\"=\"*70) print() print(\"Key Lessons:\") print() print(\"1. U2 (Convergence &amp; Boundedness):\") print(\"   \u2022 Destabilizers {Dissonance, Mutation, Expansion} increase |\u0394NFR|\") print(\"   \u2022 Must include stabilizers {Coherence, SelfOrganization}\") print(\"   \u2022 Without stabilizers: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e (divergence)\") print() print(\"2. Destabilizers:\") print(\"   \u2022 Dissonance (OZ): Strong positive feedback\") print(\"   \u2022 Mutation (ZHIR): Phase transformation\") print(\"   \u2022 Expansion (VAL): Increases dimensionality\") print() print(\"3. Stabilizers:\") print(\"   \u2022 Coherence (IL): Direct negative feedback\") print(\"   \u2022 SelfOrganization (THOL): Emergent self-limiting\") print() print(\"4. Exploration Pattern:\") print(\"   \u2022 Generator \u2192 Destabilizer(s) \u2192 Stabilizer \u2192 Closure\") print(\"   \u2022 Controlled instability with recovery\") print(\"   \u2022 Enables adaptation while maintaining coherence\") print() print(\"Next: See 03-advanced-bifurcation.py for U4 (Bifurcation)\") print() print(\"=\"*70)"},{"location":"grammar/examples/02-intermediate-exploration/#example-1-valid-exploration-with-destabilizer-stabilizer","title":"============================================================================ Example 1: Valid Exploration with Destabilizer + Stabilizer\u00b6","text":""},{"location":"grammar/examples/02-intermediate-exploration/#example-2-invalid-destabilizer-without-stabilizer","title":"============================================================================ Example 2: Invalid - Destabilizer without Stabilizer\u00b6","text":""},{"location":"grammar/examples/02-intermediate-exploration/#example-3-multiple-destabilizers","title":"============================================================================ Example 3: Multiple Destabilizers\u00b6","text":""},{"location":"grammar/examples/02-intermediate-exploration/#summary","title":"============================================================================ Summary\u00b6","text":""},{"location":"grammar/examples/03-advanced-bifurcation/","title":"03 advanced bifurcation","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nGrammar Example 03: Advanced Bifurcation\n\nDemonstrates U4 (Bifurcation Dynamics) constraints.\n\nThis example shows:\n- U4a: Bifurcation triggers need handlers\n- U4b: Transformers need context (recent destabilizer + prior coherence for Mutation)\n\nPattern: [Generator \u2192 Coherence \u2192 Destabilizer \u2192 Transformer \u2192 Stabilizer \u2192 Closure]\nHealth: Advanced (controlled phase transitions)\n\"\"\"\n</pre> \"\"\" Grammar Example 03: Advanced Bifurcation  Demonstrates U4 (Bifurcation Dynamics) constraints.  This example shows: - U4a: Bifurcation triggers need handlers - U4b: Transformers need context (recent destabilizer + prior coherence for Mutation)  Pattern: [Generator \u2192 Coherence \u2192 Destabilizer \u2192 Transformer \u2192 Stabilizer \u2192 Closure] Health: Advanced (controlled phase transitions) \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.definitions import (\n    Emission,           # Generator (U1a)\n    Coherence,          # Stabilizer + Handler\n    Dissonance,         # Destabilizer + Bifurcation trigger\n    Mutation,           # Transformer + Bifurcation trigger\n    SelfOrganization,   # Stabilizer + Handler + Transformer\n    Silence,            # Closure (U1b)\n)\nfrom tnfr.operators.grammar import validate_grammar\n</pre> from tnfr.operators.definitions import (     Emission,           # Generator (U1a)     Coherence,          # Stabilizer + Handler     Dissonance,         # Destabilizer + Bifurcation trigger     Mutation,           # Transformer + Bifurcation trigger     SelfOrganization,   # Stabilizer + Handler + Transformer     Silence,            # Closure (U1b) ) from tnfr.operators.grammar import validate_grammar In\u00a0[\u00a0]: Copied! <pre>print(\"=\"*70)\nprint(\" \" * 10 + \"Grammar Example 03: Advanced Bifurcation\")\nprint(\"=\"*70)\nprint()\n</pre> print(\"=\"*70) print(\" \" * 10 + \"Grammar Example 03: Advanced Bifurcation\") print(\"=\"*70) print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 1: Valid Mutation (with context)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 1: Valid Mutation (with context)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_1 = [\n    Emission(),           # Generator (U1a)\n    Coherence(),          # Prior coherence for stable base (U4b requirement for ZHIR)\n    Dissonance(),         # Recent destabilizer (U4b) + Bifurcation trigger (U4a)\n    Mutation(),           # Transformer (U4b) + Bifurcation trigger (U4a)\n    Coherence(),          # Stabilizer (U2) + Handler (U4a)\n    Silence()             # Closure (U1b)\n]\n</pre> sequence_1 = [     Emission(),           # Generator (U1a)     Coherence(),          # Prior coherence for stable base (U4b requirement for ZHIR)     Dissonance(),         # Recent destabilizer (U4b) + Bifurcation trigger (U4a)     Mutation(),           # Transformer (U4b) + Bifurcation trigger (U4a)     Coherence(),          # Stabilizer (U2) + Handler (U4a)     Silence()             # Closure (U1b) ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Coherence \u2192 Dissonance \u2192 Mutation \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this works:\")\nprint(\"  \u2713 U1a: Emission is generator\")\nprint(\"  \u2713 U4b: Coherence before Mutation (stable base)\")\nprint(\"  \u2713 U4b: Dissonance is recent destabilizer (within ~3 ops)\")\nprint(\"  \u2713 U4a: Mutation (trigger) + Coherence (handler)\")\nprint(\"  \u2713 U2: Dissonance + Mutation (destabilizers) + Coherence (stabilizer)\")\nprint(\"  \u2713 U1b: Silence is closure\")\nprint()\nprint(\"Physics:\")\nprint(\"  \u2022 Coherence provides stable base for transformation\")\nprint(\"  \u2022 Dissonance elevates |\u0394NFR| above bifurcation threshold\")\nprint(\"  \u2022 Mutation performs phase transition (\u03b8 \u2192 \u03b8')\")\nprint(\"  \u2022 Final Coherence manages post-bifurcation dynamics\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Coherence \u2192 Dissonance \u2192 Mutation \u2192 Coherence \u2192 Silence\") print() print(\"Why this works:\") print(\"  \u2713 U1a: Emission is generator\") print(\"  \u2713 U4b: Coherence before Mutation (stable base)\") print(\"  \u2713 U4b: Dissonance is recent destabilizer (within ~3 ops)\") print(\"  \u2713 U4a: Mutation (trigger) + Coherence (handler)\") print(\"  \u2713 U2: Dissonance + Mutation (destabilizers) + Coherence (stabilizer)\") print(\"  \u2713 U1b: Silence is closure\") print() print(\"Physics:\") print(\"  \u2022 Coherence provides stable base for transformation\") print(\"  \u2022 Dissonance elevates |\u0394NFR| above bifurcation threshold\") print(\"  \u2022 Mutation performs phase transition (\u03b8 \u2192 \u03b8')\") print(\"  \u2022 Final Coherence manages post-bifurcation dynamics\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_1, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_1, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 2: Invalid Mutation (no prior coherence)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 2: Invalid Mutation (no prior coherence)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_2 = [\n    Emission(),\n    Dissonance(),         # Recent destabilizer\n    Mutation(),           # No prior Coherence!\n    Coherence(),\n    Silence()\n]\n</pre> sequence_2 = [     Emission(),     Dissonance(),         # Recent destabilizer     Mutation(),           # No prior Coherence!     Coherence(),     Silence() ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Dissonance \u2192 Mutation \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this fails:\")\nprint(\"  \u2717 U4b violation: Mutation needs prior Coherence\")\nprint(\"  \u2717 No stable base for transformation\")\nprint(\"  \u2717 Like crystal growth without seed\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Dissonance \u2192 Mutation \u2192 Coherence \u2192 Silence\") print() print(\"Why this fails:\") print(\"  \u2717 U4b violation: Mutation needs prior Coherence\") print(\"  \u2717 No stable base for transformation\") print(\"  \u2717 Like crystal growth without seed\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_2, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_2, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 3: Invalid Mutation (no recent destabilizer)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 3: Invalid Mutation (no recent destabilizer)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_3 = [\n    Emission(),\n    Coherence(),\n    Mutation(),           # No recent destabilizer!\n    Coherence(),\n    Silence()\n]\n</pre> sequence_3 = [     Emission(),     Coherence(),     Mutation(),           # No recent destabilizer!     Coherence(),     Silence() ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Coherence \u2192 Mutation \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this fails:\")\nprint(\"  \u2717 U4b violation: Mutation needs recent destabilizer\")\nprint(\"  \u2717 |\u0394NFR| not elevated enough for phase transition\")\nprint(\"  \u2717 Insufficient threshold energy\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Coherence \u2192 Mutation \u2192 Coherence \u2192 Silence\") print() print(\"Why this fails:\") print(\"  \u2717 U4b violation: Mutation needs recent destabilizer\") print(\"  \u2717 |\u0394NFR| not elevated enough for phase transition\") print(\"  \u2717 Insufficient threshold energy\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_3, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_3, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"Example 4: Valid SelfOrganization (with context)\")\nprint(\"-\" * 70)\n</pre> print(\"Example 4: Valid SelfOrganization (with context)\") print(\"-\" * 70) In\u00a0[\u00a0]: Copied! <pre>sequence_4 = [\n    Emission(),\n    Dissonance(),         # Recent destabilizer (U4b)\n    SelfOrganization(),   # Transformer + Handler\n    Coherence(),          # Additional stabilizer\n    Silence()\n]\n</pre> sequence_4 = [     Emission(),     Dissonance(),         # Recent destabilizer (U4b)     SelfOrganization(),   # Transformer + Handler     Coherence(),          # Additional stabilizer     Silence() ] In\u00a0[\u00a0]: Copied! <pre>print(\"Sequence: Emission \u2192 Dissonance \u2192 SelfOrganization \u2192 Coherence \u2192 Silence\")\nprint()\nprint(\"Why this works:\")\nprint(\"  \u2713 U4b: Dissonance is recent destabilizer\")\nprint(\"  \u2713 U4a: Dissonance (trigger) + SelfOrganization (handler)\")\nprint(\"  \u2713 U2: Dissonance (destabilizer) + SelfOrganization + Coherence (stabilizers)\")\nprint(\"  \u2713 SelfOrganization creates autopoietic structures\")\nprint()\n</pre> print(\"Sequence: Emission \u2192 Dissonance \u2192 SelfOrganization \u2192 Coherence \u2192 Silence\") print() print(\"Why this works:\") print(\"  \u2713 U4b: Dissonance is recent destabilizer\") print(\"  \u2713 U4a: Dissonance (trigger) + SelfOrganization (handler)\") print(\"  \u2713 U2: Dissonance (destabilizer) + SelfOrganization + Coherence (stabilizers)\") print(\"  \u2713 SelfOrganization creates autopoietic structures\") print() In\u00a0[\u00a0]: Copied! <pre>try:\n    is_valid = validate_grammar(sequence_4, epi_initial=0.0)\n    print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\")\nexcept ValueError as e:\n    print(f\"Validation: \u2717 FAIL - {e}\")\nprint()\n</pre> try:     is_valid = validate_grammar(sequence_4, epi_initial=0.0)     print(f\"Validation: {'\u2713 PASS' if is_valid else '\u2717 FAIL'}\") except ValueError as e:     print(f\"Validation: \u2717 FAIL - {e}\") print() In\u00a0[\u00a0]: Copied! <pre>print(\"=\"*70)\nprint(\" \" * 25 + \"Summary\")\nprint(\"=\"*70)\nprint()\nprint(\"Key Lessons:\")\nprint()\nprint(\"1. U4a (Bifurcation Triggers Need Handlers):\")\nprint(\"   \u2022 Triggers: {Dissonance, Mutation}\")\nprint(\"   \u2022 Handlers: {SelfOrganization, Coherence}\")\nprint(\"   \u2022 Uncontrolled bifurcations \u2192 chaos\")\nprint()\nprint(\"2. U4b (Transformers Need Context):\")\nprint(\"   \u2022 Transformers: {Mutation, SelfOrganization}\")\nprint(\"   \u2022 Need recent destabilizer within ~3 operators\")\nprint(\"   \u2022 Mutation additionally needs prior Coherence\")\nprint(\"   \u2022 Threshold energy requirement\")\nprint()\nprint(\"3. Mutation Requirements:\")\nprint(\"   \u2022 Prior Coherence (stable base)\")\nprint(\"   \u2022 Recent destabilizer (threshold energy)\")\nprint(\"   \u2022 Handler after (manage transition)\")\nprint()\nprint(\"4. SelfOrganization:\")\nprint(\"   \u2022 Acts as both stabilizer AND transformer\")\nprint(\"   \u2022 Creates autopoietic sub-EPIs\")\nprint(\"   \u2022 Self-limiting through boundaries\")\nprint()\nprint(\"5. Bifurcation Pattern:\")\nprint(\"   \u2022 Generator \u2192 Coherence \u2192 Destabilizer \u2192 Transformer \u2192 Handler \u2192 Closure\")\nprint(\"   \u2022 Controlled phase transitions\")\nprint(\"   \u2022 Enables qualitative state changes\")\nprint()\nprint(\"Next: See ../08-QUICK-REFERENCE.md for complete cheat sheet\")\nprint()\nprint(\"=\"*70)\n</pre> print(\"=\"*70) print(\" \" * 25 + \"Summary\") print(\"=\"*70) print() print(\"Key Lessons:\") print() print(\"1. U4a (Bifurcation Triggers Need Handlers):\") print(\"   \u2022 Triggers: {Dissonance, Mutation}\") print(\"   \u2022 Handlers: {SelfOrganization, Coherence}\") print(\"   \u2022 Uncontrolled bifurcations \u2192 chaos\") print() print(\"2. U4b (Transformers Need Context):\") print(\"   \u2022 Transformers: {Mutation, SelfOrganization}\") print(\"   \u2022 Need recent destabilizer within ~3 operators\") print(\"   \u2022 Mutation additionally needs prior Coherence\") print(\"   \u2022 Threshold energy requirement\") print() print(\"3. Mutation Requirements:\") print(\"   \u2022 Prior Coherence (stable base)\") print(\"   \u2022 Recent destabilizer (threshold energy)\") print(\"   \u2022 Handler after (manage transition)\") print() print(\"4. SelfOrganization:\") print(\"   \u2022 Acts as both stabilizer AND transformer\") print(\"   \u2022 Creates autopoietic sub-EPIs\") print(\"   \u2022 Self-limiting through boundaries\") print() print(\"5. Bifurcation Pattern:\") print(\"   \u2022 Generator \u2192 Coherence \u2192 Destabilizer \u2192 Transformer \u2192 Handler \u2192 Closure\") print(\"   \u2022 Controlled phase transitions\") print(\"   \u2022 Enables qualitative state changes\") print() print(\"Next: See ../08-QUICK-REFERENCE.md for complete cheat sheet\") print() print(\"=\"*70)"},{"location":"grammar/examples/03-advanced-bifurcation/#example-1-valid-mutation-with-full-context","title":"============================================================================ Example 1: Valid Mutation with Full Context\u00b6","text":""},{"location":"grammar/examples/03-advanced-bifurcation/#example-2-invalid-mutation-without-prior-coherence","title":"============================================================================ Example 2: Invalid - Mutation without Prior Coherence\u00b6","text":""},{"location":"grammar/examples/03-advanced-bifurcation/#example-3-invalid-mutation-without-recent-destabilizer","title":"============================================================================ Example 3: Invalid - Mutation without Recent Destabilizer\u00b6","text":""},{"location":"grammar/examples/03-advanced-bifurcation/#example-4-valid-selforganization-with-context","title":"============================================================================ Example 4: Valid SelfOrganization with Context\u00b6","text":""},{"location":"grammar/examples/03-advanced-bifurcation/#summary","title":"============================================================================ Summary\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/","title":"All operators catalog","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Complete catalog of 13 canonical TNFR operators with examples.\n\nThis file demonstrates each of the 13 canonical operators with:\n- Valid usage patterns\n- Anti-patterns (commented out to prevent execution)\n- Test assertions\n\nRun with: python docs/grammar/examples/all-operators-catalog.py\n\"\"\"\n</pre> \"\"\"Complete catalog of 13 canonical TNFR operators with examples.  This file demonstrates each of the 13 canonical operators with: - Valid usage patterns - Anti-patterns (commented out to prevent execution) - Test assertions  Run with: python docs/grammar/examples/all-operators-catalog.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>import networkx as nx\nimport numpy as np\n</pre> import networkx as nx import numpy as np In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.definitions import (\n    Coherence,\n    Contraction,\n    Coupling,\n    Dissonance,\n    Emission,\n    Expansion,\n    Mutation,\n    Reception,\n    Recursivity,\n    Resonance,\n    SelfOrganization,\n    Silence,\n    Transition,\n)\n</pre> from tnfr.operators.definitions import (     Coherence,     Contraction,     Coupling,     Dissonance,     Emission,     Expansion,     Mutation,     Reception,     Recursivity,     Resonance,     SelfOrganization,     Silence,     Transition, ) In\u00a0[\u00a0]: Copied! <pre>def create_test_node(epi=0.0, vf=1.0, theta=0.0, dnfr=0.0):\n    \"\"\"Helper: Create a graph with a single test node.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, EPI=epi, vf=vf, theta=theta, dnfr=dnfr)\n    return G\n</pre> def create_test_node(epi=0.0, vf=1.0, theta=0.0, dnfr=0.0):     \"\"\"Helper: Create a graph with a single test node.\"\"\"     G = nx.Graph()     G.add_node(0, EPI=epi, vf=vf, theta=theta, dnfr=dnfr)     return G <p>=============================================================================</p> In\u00a0[\u00a0]: Copied! <pre>def test_emission():\n    \"\"\"AL - Creates EPI from vacuum via resonant emission.\"\"\"\n    print(\"\\n1. EMISSION (AL) - Generator\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Emission from EPI=0\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    print(f\"\u2705 Valid: EPI after emission = {G.nodes[0]['EPI']} (&gt; 0)\")\n    assert G.nodes[0][\"EPI\"] != 0.0, \"Emission should modify EPI\"\n\n    # Anti-pattern (commented):\n    # \u274c Redundant emission without purpose\n    # [Emission, Coherence, Emission, Coherence, Silence]\n</pre> def test_emission():     \"\"\"AL - Creates EPI from vacuum via resonant emission.\"\"\"     print(\"\\n1. EMISSION (AL) - Generator\")     print(\"=\" * 50)      # \u2705 Valid: Emission from EPI=0     G = create_test_node(epi=0.0)     Emission()(G, 0)     print(f\"\u2705 Valid: EPI after emission = {G.nodes[0]['EPI']} (&gt; 0)\")     assert G.nodes[0][\"EPI\"] != 0.0, \"Emission should modify EPI\"      # Anti-pattern (commented):     # \u274c Redundant emission without purpose     # [Emission, Coherence, Emission, Coherence, Silence] In\u00a0[\u00a0]: Copied! <pre>def test_reception():\n    \"\"\"EN - Captures and integrates incoming resonance.\"\"\"\n    print(\"\\n2. RECEPTION (EN) - Information\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Reception after coupling\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n    G.add_node(1, EPI=0.7, vf=1.0, theta=0.1, dnfr=0.0)\n    \n    # Create edge for information flow\n    G.add_edge(0, 1)\n    \n    Reception()(G, 0)\n    print(\"\u2705 Valid: Reception applied (EPI updated based on network)\")\n\n    # Anti-pattern (commented):\n    # \u274c Reception without coupling\n    # G_isolated = create_test_node(epi=0.5)\n    # Reception()(G_isolated, 0)  # No neighbors!\n</pre> def test_reception():     \"\"\"EN - Captures and integrates incoming resonance.\"\"\"     print(\"\\n2. RECEPTION (EN) - Information\")     print(\"=\" * 50)      # \u2705 Valid: Reception after coupling     G = nx.Graph()     G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)     G.add_node(1, EPI=0.7, vf=1.0, theta=0.1, dnfr=0.0)          # Create edge for information flow     G.add_edge(0, 1)          Reception()(G, 0)     print(\"\u2705 Valid: Reception applied (EPI updated based on network)\")      # Anti-pattern (commented):     # \u274c Reception without coupling     # G_isolated = create_test_node(epi=0.5)     # Reception()(G_isolated, 0)  # No neighbors! In\u00a0[\u00a0]: Copied! <pre>def test_coherence():\n    \"\"\"IL - Stabilizes form through negative feedback.\"\"\"\n    print(\"\\n3. COHERENCE (IL) - Stabilizer\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Coherence after emission\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    \n    Coherence()(G, 0)\n    \n    print(\"\u2705 Valid: Coherence applied (\u0394NFR reduced via negative feedback)\")\n\n    # Anti-pattern (commented):\n    # \u274c Coherence on EPI=0\n    # G_zero = create_test_node(epi=0.0)\n    # Coherence()(G_zero, 0)  # Violates precondition!\n</pre> def test_coherence():     \"\"\"IL - Stabilizes form through negative feedback.\"\"\"     print(\"\\n3. COHERENCE (IL) - Stabilizer\")     print(\"=\" * 50)      # \u2705 Valid: Coherence after emission     G = create_test_node(epi=0.0)     Emission()(G, 0)          Coherence()(G, 0)          print(\"\u2705 Valid: Coherence applied (\u0394NFR reduced via negative feedback)\")      # Anti-pattern (commented):     # \u274c Coherence on EPI=0     # G_zero = create_test_node(epi=0.0)     # Coherence()(G_zero, 0)  # Violates precondition! In\u00a0[\u00a0]: Copied! <pre>def test_dissonance():\n    \"\"\"OZ - Introduces controlled instability.\"\"\"\n    print(\"\\n4. DISSONANCE (OZ) - Destabilizer\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Dissonance balanced by Coherence (U2)\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    Coherence()(G, 0)  # Stable base\n    \n    Dissonance()(G, 0)  # Destabilizer\n    Coherence()(G, 0)  # Stabilizer (U2)\n    print(\"\u2705 Valid: Dissonance balanced by Coherence (U2 compliance)\")\n\n    # Anti-pattern (commented):\n    # \u274c Dissonance without stabilizer (violates U2)\n    # [Emission, Dissonance, Silence]  # Missing Coherence!\n</pre> def test_dissonance():     \"\"\"OZ - Introduces controlled instability.\"\"\"     print(\"\\n4. DISSONANCE (OZ) - Destabilizer\")     print(\"=\" * 50)      # \u2705 Valid: Dissonance balanced by Coherence (U2)     G = create_test_node(epi=0.0)     Emission()(G, 0)     Coherence()(G, 0)  # Stable base          Dissonance()(G, 0)  # Destabilizer     Coherence()(G, 0)  # Stabilizer (U2)     print(\"\u2705 Valid: Dissonance balanced by Coherence (U2 compliance)\")      # Anti-pattern (commented):     # \u274c Dissonance without stabilizer (violates U2)     # [Emission, Dissonance, Silence]  # Missing Coherence! In\u00a0[\u00a0]: Copied! <pre>def test_coupling():\n    \"\"\"UM - Creates structural links via phase synchronization.\"\"\"\n    print(\"\\n5. COUPLING (UM) - Propagator\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Coupling with compatible phases\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n    G.add_node(1, EPI=0.6, vf=1.0, theta=0.3, dnfr=0.0)  # \u0394\u03c6 = 0.3 &lt; \u03c0/2\n\n    # Phase compatible: |0.0 - 0.3| = 0.3 &lt; \u03c0/2 \u2248 1.57\n    print(f\"\u2705 Phase compatible: |\u0394\u03c6| = 0.3 &lt; \u03c0/2 ({np.pi/2:.2f})\")\n\n    # Note: Coupling applies to single nodes in the grammar system\n    Coupling()(G, 0)\n    print(\"\u2705 Valid: Coupling operator applied (creates structural links)\")\n\n    # Anti-pattern (commented):\n    # \u274c Coupling without phase verification\n    # G_antiphase = nx.Graph()\n    # G_antiphase.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n    # G_antiphase.add_node(1, EPI=0.6, vf=1.0, theta=np.pi, dnfr=0.0)  # Antiphase!\n    # Coupling()(G_antiphase, 0)  # Phase mismatch\n</pre> def test_coupling():     \"\"\"UM - Creates structural links via phase synchronization.\"\"\"     print(\"\\n5. COUPLING (UM) - Propagator\")     print(\"=\" * 50)      # \u2705 Valid: Coupling with compatible phases     G = nx.Graph()     G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)     G.add_node(1, EPI=0.6, vf=1.0, theta=0.3, dnfr=0.0)  # \u0394\u03c6 = 0.3 &lt; \u03c0/2      # Phase compatible: |0.0 - 0.3| = 0.3 &lt; \u03c0/2 \u2248 1.57     print(f\"\u2705 Phase compatible: |\u0394\u03c6| = 0.3 &lt; \u03c0/2 ({np.pi/2:.2f})\")      # Note: Coupling applies to single nodes in the grammar system     Coupling()(G, 0)     print(\"\u2705 Valid: Coupling operator applied (creates structural links)\")      # Anti-pattern (commented):     # \u274c Coupling without phase verification     # G_antiphase = nx.Graph()     # G_antiphase.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)     # G_antiphase.add_node(1, EPI=0.6, vf=1.0, theta=np.pi, dnfr=0.0)  # Antiphase!     # Coupling()(G_antiphase, 0)  # Phase mismatch In\u00a0[\u00a0]: Copied! <pre>def test_resonance():\n    \"\"\"RA - Amplifies and propagates patterns coherently.\"\"\"\n    print(\"\\n6. RESONANCE (RA) - Propagator\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Resonance on coupled network\n    G = nx.Graph()\n    G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n    G.add_node(1, EPI=0.6, vf=1.0, theta=0.1, dnfr=0.0)\n    G.add_edge(0, 1)  # Pre-existing coupling\n    \n    Resonance()(G, 0)  # Amplify\n    print(\"\u2705 Valid: Resonance applied (pattern propagated coherently)\")\n\n    # Anti-pattern (commented):\n    # \u274c Resonance without coupling\n    # G_uncoupled = nx.Graph()\n    # G_uncoupled.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)\n    # Resonance()(G_uncoupled, 0)  # No edges - violates precondition\n</pre> def test_resonance():     \"\"\"RA - Amplifies and propagates patterns coherently.\"\"\"     print(\"\\n6. RESONANCE (RA) - Propagator\")     print(\"=\" * 50)      # \u2705 Valid: Resonance on coupled network     G = nx.Graph()     G.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)     G.add_node(1, EPI=0.6, vf=1.0, theta=0.1, dnfr=0.0)     G.add_edge(0, 1)  # Pre-existing coupling          Resonance()(G, 0)  # Amplify     print(\"\u2705 Valid: Resonance applied (pattern propagated coherently)\")      # Anti-pattern (commented):     # \u274c Resonance without coupling     # G_uncoupled = nx.Graph()     # G_uncoupled.add_node(0, EPI=0.5, vf=1.0, theta=0.0, dnfr=0.0)     # Resonance()(G_uncoupled, 0)  # No edges - violates precondition In\u00a0[\u00a0]: Copied! <pre>def test_silence():\n    \"\"\"SHA - Freezes evolution temporarily.\"\"\"\n    print(\"\\n7. SILENCE (SHA) - Control/Closure\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Silence as closure\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    Coherence()(G, 0)\n    \n    Silence()(G, 0)\n    \n    print(\"\u2705 Valid: Silence applied (\u03bdf \u2192 0, node enters latent state)\")\n\n    # Anti-pattern (commented):\n    # \u274c Silence in middle without reactivation\n    # [Emission, Silence, Coherence]  # Node frozen, can't apply Coherence\n</pre> def test_silence():     \"\"\"SHA - Freezes evolution temporarily.\"\"\"     print(\"\\n7. SILENCE (SHA) - Control/Closure\")     print(\"=\" * 50)      # \u2705 Valid: Silence as closure     G = create_test_node(epi=0.0)     Emission()(G, 0)     Coherence()(G, 0)          Silence()(G, 0)          print(\"\u2705 Valid: Silence applied (\u03bdf \u2192 0, node enters latent state)\")      # Anti-pattern (commented):     # \u274c Silence in middle without reactivation     # [Emission, Silence, Coherence]  # Node frozen, can't apply Coherence In\u00a0[\u00a0]: Copied! <pre>def test_expansion():\n    \"\"\"VAL - Increases structural complexity.\"\"\"\n    print(\"\\n8. EXPANSION (VAL) - Destabilizer\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Expansion balanced by Coherence\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    Expansion()(G, 0)  # Destabilizer\n    Coherence()(G, 0)  # Stabilizer (U2)\n    print(\"\u2705 Valid: Expansion balanced by stabilizer\")\n\n    # Anti-pattern (commented):\n    # \u274c Expansion without stabilizer (violates U2)\n    # [Emission, Expansion, Silence]  # Missing Coherence!\n</pre> def test_expansion():     \"\"\"VAL - Increases structural complexity.\"\"\"     print(\"\\n8. EXPANSION (VAL) - Destabilizer\")     print(\"=\" * 50)      # \u2705 Valid: Expansion balanced by Coherence     G = create_test_node(epi=0.0)     Emission()(G, 0)     Expansion()(G, 0)  # Destabilizer     Coherence()(G, 0)  # Stabilizer (U2)     print(\"\u2705 Valid: Expansion balanced by stabilizer\")      # Anti-pattern (commented):     # \u274c Expansion without stabilizer (violates U2)     # [Emission, Expansion, Silence]  # Missing Coherence! In\u00a0[\u00a0]: Copied! <pre>def test_contraction():\n    \"\"\"NUL - Reduces structural complexity.\"\"\"\n    print(\"\\n9. CONTRACTION (NUL) - Control\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Contraction after expansion\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    Expansion()(G, 0)    # Increase complexity\n    Contraction()(G, 0)  # Reduce back\n    print(\"\u2705 Valid: Complexity managed bidirectionally\")\n\n    # Anti-pattern (commented):\n    # \u274c Contraction on scalar EPI\n    # G_scalar = create_test_node(epi=0.5)  # Scalar EPI\n    # Contraction()(G_scalar, 0)  # Cannot reduce below dim=1\n</pre> def test_contraction():     \"\"\"NUL - Reduces structural complexity.\"\"\"     print(\"\\n9. CONTRACTION (NUL) - Control\")     print(\"=\" * 50)      # \u2705 Valid: Contraction after expansion     G = create_test_node(epi=0.0)     Emission()(G, 0)     Expansion()(G, 0)    # Increase complexity     Contraction()(G, 0)  # Reduce back     print(\"\u2705 Valid: Complexity managed bidirectionally\")      # Anti-pattern (commented):     # \u274c Contraction on scalar EPI     # G_scalar = create_test_node(epi=0.5)  # Scalar EPI     # Contraction()(G_scalar, 0)  # Cannot reduce below dim=1 In\u00a0[\u00a0]: Copied! <pre>def test_self_organization():\n    \"\"\"THOL - Spontaneous autopoietic pattern formation.\"\"\"\n    print(\"\\n10. SELF-ORGANIZATION (THOL) - Stabilizer/Handler/Transformer\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: THOL with recent destabilizer (U4b)\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    Dissonance()(G, 0)         # Destabilizer (recent, U4b)\n    SelfOrganization()(G, 0)   # Transformer + Handler\n    Coherence()(G, 0)\n    print(\"\u2705 Valid: Self-organization with proper context\")\n\n    # Anti-pattern (commented):\n    # \u274c THOL without recent destabilizer (violates U4b)\n    # [Emission, Coherence, SelfOrganization, Silence]  # No OZ/VAL/ZHIR!\n</pre> def test_self_organization():     \"\"\"THOL - Spontaneous autopoietic pattern formation.\"\"\"     print(\"\\n10. SELF-ORGANIZATION (THOL) - Stabilizer/Handler/Transformer\")     print(\"=\" * 50)      # \u2705 Valid: THOL with recent destabilizer (U4b)     G = create_test_node(epi=0.0)     Emission()(G, 0)     Dissonance()(G, 0)         # Destabilizer (recent, U4b)     SelfOrganization()(G, 0)   # Transformer + Handler     Coherence()(G, 0)     print(\"\u2705 Valid: Self-organization with proper context\")      # Anti-pattern (commented):     # \u274c THOL without recent destabilizer (violates U4b)     # [Emission, Coherence, SelfOrganization, Silence]  # No OZ/VAL/ZHIR! In\u00a0[\u00a0]: Copied! <pre>def test_mutation():\n    \"\"\"ZHIR - Phase transformation at threshold.\"\"\"\n    print(\"\\n11. MUTATION (ZHIR) - Destabilizer/Trigger/Transformer\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Complete ZHIR sequence (U4b requirements)\n    G = create_test_node(epi=0.0)\n    Emission()(G, 0)\n    Coherence()(G, 0)   # Prior IL (stable base, U4b)\n    Dissonance()(G, 0)  # Recent destabilizer (U4b)\n    \n    Mutation()(G, 0)    # Transformer\n    \n    Coherence()(G, 0)   # Stabilizer (U2) + Handler (U4a)\n    print(\"\u2705 Valid: Mutation applied with proper U4b context (prior IL + recent destabilizer)\")\n\n    # Anti-pattern (commented):\n    # \u274c ZHIR without prior Coherence (violates U4b)\n    # [Emission, Dissonance, Mutation, Coherence, Silence]  # No IL before OZ!\n</pre> def test_mutation():     \"\"\"ZHIR - Phase transformation at threshold.\"\"\"     print(\"\\n11. MUTATION (ZHIR) - Destabilizer/Trigger/Transformer\")     print(\"=\" * 50)      # \u2705 Valid: Complete ZHIR sequence (U4b requirements)     G = create_test_node(epi=0.0)     Emission()(G, 0)     Coherence()(G, 0)   # Prior IL (stable base, U4b)     Dissonance()(G, 0)  # Recent destabilizer (U4b)          Mutation()(G, 0)    # Transformer          Coherence()(G, 0)   # Stabilizer (U2) + Handler (U4a)     print(\"\u2705 Valid: Mutation applied with proper U4b context (prior IL + recent destabilizer)\")      # Anti-pattern (commented):     # \u274c ZHIR without prior Coherence (violates U4b)     # [Emission, Dissonance, Mutation, Coherence, Silence]  # No IL before OZ! In\u00a0[\u00a0]: Copied! <pre>def test_transition():\n    \"\"\"NAV - Regime shift, activates latent EPI.\"\"\"\n    print(\"\\n12. TRANSITION (NAV) - Generator/Closure\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Transition with proper setup\n    G = create_test_node(epi=0.5, vf=1.0)\n    # Disable precondition validation for demo purposes\n    Transition()(G, 0, validate_preconditions=False)\n    print(\"\u2705 Valid: Regime transition activated\")\n\n    # Anti-pattern (commented):\n    # \u274c NAV with insufficient \u03bdf\n    # G_low_vf = create_test_node(epi=0.3, vf=0.0)\n    # Transition()(G_low_vf, 0)  # \u03bdf too low!\n</pre> def test_transition():     \"\"\"NAV - Regime shift, activates latent EPI.\"\"\"     print(\"\\n12. TRANSITION (NAV) - Generator/Closure\")     print(\"=\" * 50)      # \u2705 Valid: Transition with proper setup     G = create_test_node(epi=0.5, vf=1.0)     # Disable precondition validation for demo purposes     Transition()(G, 0, validate_preconditions=False)     print(\"\u2705 Valid: Regime transition activated\")      # Anti-pattern (commented):     # \u274c NAV with insufficient \u03bdf     # G_low_vf = create_test_node(epi=0.3, vf=0.0)     # Transition()(G_low_vf, 0)  # \u03bdf too low! In\u00a0[\u00a0]: Copied! <pre>def test_recursivity():\n    \"\"\"REMESH - Echoes structure across scales (operational fractality).\"\"\"\n    print(\"\\n13. RECURSIVITY (REMESH) - Generator/Closure\")\n    print(\"=\" * 50)\n\n    # \u2705 Valid: Recursivity with sufficient structure\n    G = create_test_node(epi=0.5, vf=1.0)\n    Recursivity()(G, 0, validate_preconditions=False)\n    print(\"\u2705 Valid: Recursive structure created (operational fractality)\")\n\n    # Anti-pattern (commented):\n    # \u274c REMESH on completely empty system\n    # G_empty = create_test_node(epi=0.0, vf=0.0)\n    # Recursivity()(G_empty, 0)  # Insufficient structure\n</pre> def test_recursivity():     \"\"\"REMESH - Echoes structure across scales (operational fractality).\"\"\"     print(\"\\n13. RECURSIVITY (REMESH) - Generator/Closure\")     print(\"=\" * 50)      # \u2705 Valid: Recursivity with sufficient structure     G = create_test_node(epi=0.5, vf=1.0)     Recursivity()(G, 0, validate_preconditions=False)     print(\"\u2705 Valid: Recursive structure created (operational fractality)\")      # Anti-pattern (commented):     # \u274c REMESH on completely empty system     # G_empty = create_test_node(epi=0.0, vf=0.0)     # Recursivity()(G_empty, 0)  # Insufficient structure In\u00a0[\u00a0]: Copied! <pre>def main():\n    \"\"\"Run all operator demonstrations.\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"TNFR CANONICAL OPERATORS - COMPLETE CATALOG\")\n    print(\"=\" * 70)\n    print(\"\\nDemonstrating all 13 canonical operators with valid patterns\")\n    print(\"Anti-patterns are documented but commented out for safety\\n\")\n\n    # Run all tests\n    test_emission()\n    test_reception()\n    test_coherence()\n    test_dissonance()\n    test_coupling()\n    test_resonance()\n    test_silence()\n    test_expansion()\n    test_contraction()\n    test_self_organization()\n    test_mutation()\n    test_transition()\n    test_recursivity()\n\n    print(\"\\n\" + \"=\" * 70)\n    print(\"\u2705 ALL OPERATORS DEMONSTRATED SUCCESSFULLY\")\n    print(\"=\" * 70)\n    print(\"\\nFor detailed documentation, see:\")\n    print(\"- docs/grammar/03-OPERATORS-AND-GLYPHS.md\")\n    print(\"- docs/grammar/08-QUICK-REFERENCE.md (Compatibility Matrix)\")\n    print(\"- docs/grammar/schemas/canonical-operators.json (JSON Schema)\")\n</pre> def main():     \"\"\"Run all operator demonstrations.\"\"\"     print(\"\\n\" + \"=\" * 70)     print(\"TNFR CANONICAL OPERATORS - COMPLETE CATALOG\")     print(\"=\" * 70)     print(\"\\nDemonstrating all 13 canonical operators with valid patterns\")     print(\"Anti-patterns are documented but commented out for safety\\n\")      # Run all tests     test_emission()     test_reception()     test_coherence()     test_dissonance()     test_coupling()     test_resonance()     test_silence()     test_expansion()     test_contraction()     test_self_organization()     test_mutation()     test_transition()     test_recursivity()      print(\"\\n\" + \"=\" * 70)     print(\"\u2705 ALL OPERATORS DEMONSTRATED SUCCESSFULLY\")     print(\"=\" * 70)     print(\"\\nFor detailed documentation, see:\")     print(\"- docs/grammar/03-OPERATORS-AND-GLYPHS.md\")     print(\"- docs/grammar/08-QUICK-REFERENCE.md (Compatibility Matrix)\")     print(\"- docs/grammar/schemas/canonical-operators.json (JSON Schema)\") In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"grammar/examples/all-operators-catalog/#emission-al-generator","title":"EMISSION (AL) - Generator\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#2-reception-en-information","title":"============================================================================= 2. RECEPTION (EN) - Information\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#3-coherence-il-stabilizer","title":"============================================================================= 3. COHERENCE (IL) - Stabilizer\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#4-dissonance-oz-destabilizertriggerclosure","title":"============================================================================= 4. DISSONANCE (OZ) - Destabilizer/Trigger/Closure\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#5-coupling-um-propagator","title":"============================================================================= 5. COUPLING (UM) - Propagator\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#6-resonance-ra-propagator","title":"============================================================================= 6. RESONANCE (RA) - Propagator\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#7-silence-sha-controlclosure","title":"============================================================================= 7. SILENCE (SHA) - Control/Closure\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#8-expansion-val-destabilizer","title":"============================================================================= 8. EXPANSION (VAL) - Destabilizer\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#9-contraction-nul-control","title":"============================================================================= 9. CONTRACTION (NUL) - Control\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#10-self-organization-thol-stabilizerhandlertransformer","title":"============================================================================= 10. SELF-ORGANIZATION (THOL) - Stabilizer/Handler/Transformer\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#11-mutation-zhir-destabilizertriggertransformer","title":"============================================================================= 11. MUTATION (ZHIR) - Destabilizer/Trigger/Transformer\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#12-transition-nav-generatorclosure","title":"============================================================================= 12. TRANSITION (NAV) - Generator/Closure\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#13-recursivity-remesh-generatorclosure","title":"============================================================================= 13. RECURSIVITY (REMESH) - Generator/Closure\u00b6","text":""},{"location":"grammar/examples/all-operators-catalog/#main-execution","title":"============================================================================= Main Execution\u00b6","text":""},{"location":"grammar/examples/u1-initiation-closure-examples/","title":"U1 initiation closure examples","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nU1: STRUCTURAL INITIATION &amp; CLOSURE Examples\n\nDemonstrates valid and invalid patterns for U1a (initiation) and U1b (closure).\n\nPhysics Basis:\n- U1a: Cannot evolve from EPI=0 without generator (\u2202EPI/\u2202t undefined)\n- U1b: Sequences need coherent endpoints (attractor states)\n\nRun: python u1-initiation-closure-examples.py\n\"\"\"\n</pre> \"\"\" U1: STRUCTURAL INITIATION &amp; CLOSURE Examples  Demonstrates valid and invalid patterns for U1a (initiation) and U1b (closure).  Physics Basis: - U1a: Cannot evolve from EPI=0 without generator (\u2202EPI/\u2202t undefined) - U1b: Sequences need coherent endpoints (attractor states)  Run: python u1-initiation-closure-examples.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.grammar import validate_grammar, GrammarValidator\nfrom tnfr.operators.definitions import (\n    Emission,\n    Reception,\n    Coherence,\n    Dissonance,\n    Silence,\n    Transition,\n    Recursivity,\n)\n</pre> from tnfr.operators.grammar import validate_grammar, GrammarValidator from tnfr.operators.definitions import (     Emission,     Reception,     Coherence,     Dissonance,     Silence,     Transition,     Recursivity, ) In\u00a0[\u00a0]: Copied! <pre>def example_u1a_valid():\n    \"\"\"Valid U1a: Starting with generators.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U1a VALID EXAMPLES: Starting with Generators\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"Emission starter\", [Emission(), Coherence(), Silence()]),\n        (\"Transition starter\", [Transition(), Reception(), Silence()]),\n        (\"Recursivity starter\", [Recursivity(), Coherence(), Silence()]),\n    ]\n\n    for name, sequence in examples:\n        is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)\n        print(f\"\\n{name}:\")\n        print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n        print(f\"  Valid: {is_valid}\")\n        print(f\"  Message: {message}\")\n</pre> def example_u1a_valid():     \"\"\"Valid U1a: Starting with generators.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U1a VALID EXAMPLES: Starting with Generators\")     print(\"=\" * 60)      examples = [         (\"Emission starter\", [Emission(), Coherence(), Silence()]),         (\"Transition starter\", [Transition(), Reception(), Silence()]),         (\"Recursivity starter\", [Recursivity(), Coherence(), Silence()]),     ]      for name, sequence in examples:         is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)         print(f\"\\n{name}:\")         print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")         print(f\"  Valid: {is_valid}\")         print(f\"  Message: {message}\") In\u00a0[\u00a0]: Copied! <pre>def example_u1a_invalid():\n    \"\"\"Invalid U1a: Missing generators.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U1a INVALID EXAMPLES: Missing Generators\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"Reception starter (not generator)\", [Reception(), Coherence(), Silence()]),\n        (\"Coherence starter (not generator)\", [Coherence(), Silence()]),\n        (\"Dissonance starter (not generator)\", [Dissonance(), Coherence(), Silence()]),\n    ]\n\n    for name, sequence in examples:\n        try:\n            is_valid = validate_grammar(sequence, epi_initial=0.0)\n            print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")\n        except ValueError as e:\n            print(f\"\\n{name}:\")\n            print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n            print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\")\n</pre> def example_u1a_invalid():     \"\"\"Invalid U1a: Missing generators.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U1a INVALID EXAMPLES: Missing Generators\")     print(\"=\" * 60)      examples = [         (\"Reception starter (not generator)\", [Reception(), Coherence(), Silence()]),         (\"Coherence starter (not generator)\", [Coherence(), Silence()]),         (\"Dissonance starter (not generator)\", [Dissonance(), Coherence(), Silence()]),     ]      for name, sequence in examples:         try:             is_valid = validate_grammar(sequence, epi_initial=0.0)             print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")         except ValueError as e:             print(f\"\\n{name}:\")             print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")             print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\") In\u00a0[\u00a0]: Copied! <pre>def example_u1a_context_matters():\n    \"\"\"Demonstrates when U1a applies.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U1a CONTEXT: When Does Initiation Apply?\")\n    print(\"=\" * 60)\n\n    # When EPI=0, need generator\n    sequence = [Emission(), Coherence(), Silence()]\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n    print(f\"\\nEPI=0.0, with generator:\")\n    print(f\"  Valid: {is_valid}\")\n    print(f\"  {msg}\")\n\n    # When EPI&gt;0, generator not required\n    sequence = [Reception(), Coherence(), Silence()]\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.5)\n    print(f\"\\nEPI=0.5, without generator:\")\n    print(f\"  Valid: {is_valid}\")\n    print(f\"  {msg}\")\n</pre> def example_u1a_context_matters():     \"\"\"Demonstrates when U1a applies.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U1a CONTEXT: When Does Initiation Apply?\")     print(\"=\" * 60)      # When EPI=0, need generator     sequence = [Emission(), Coherence(), Silence()]     is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)     print(f\"\\nEPI=0.0, with generator:\")     print(f\"  Valid: {is_valid}\")     print(f\"  {msg}\")      # When EPI&gt;0, generator not required     sequence = [Reception(), Coherence(), Silence()]     is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.5)     print(f\"\\nEPI=0.5, without generator:\")     print(f\"  Valid: {is_valid}\")     print(f\"  {msg}\") In\u00a0[\u00a0]: Copied! <pre>def example_u1b_valid():\n    \"\"\"Valid U1b: Ending with closures.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U1b VALID EXAMPLES: Ending with Closures\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"Silence closure\", [Emission(), Coherence(), Silence()]),\n        (\"Transition closure\", [Emission(), Coherence(), Transition()]),\n        (\"Recursivity closure\", [Emission(), Coherence(), Recursivity()]),\n        (\"Dissonance closure\", [Emission(), Coherence(), Dissonance()]),\n    ]\n\n    for name, sequence in examples:\n        is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)\n        print(f\"\\n{name}:\")\n        print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n        print(f\"  Valid: {is_valid}\")\n        print(f\"  Message: {message}\")\n</pre> def example_u1b_valid():     \"\"\"Valid U1b: Ending with closures.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U1b VALID EXAMPLES: Ending with Closures\")     print(\"=\" * 60)      examples = [         (\"Silence closure\", [Emission(), Coherence(), Silence()]),         (\"Transition closure\", [Emission(), Coherence(), Transition()]),         (\"Recursivity closure\", [Emission(), Coherence(), Recursivity()]),         (\"Dissonance closure\", [Emission(), Coherence(), Dissonance()]),     ]      for name, sequence in examples:         is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)         print(f\"\\n{name}:\")         print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")         print(f\"  Valid: {is_valid}\")         print(f\"  Message: {message}\") In\u00a0[\u00a0]: Copied! <pre>def example_u1b_invalid():\n    \"\"\"Invalid U1b: Missing closures.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U1b INVALID EXAMPLES: Missing Closures\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"Ends with Coherence (not closure)\", [Emission(), Coherence()]),\n        (\"Ends with Reception (not closure)\", [Emission(), Coherence(), Reception()]),\n        (\"Ends with Emission (not closure)\", [Emission(), Coherence(), Emission()]),\n    ]\n\n    for name, sequence in examples:\n        try:\n            is_valid = validate_grammar(sequence, epi_initial=0.0)\n            print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")\n        except ValueError as e:\n            print(f\"\\n{name}:\")\n            print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n            print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\")\n</pre> def example_u1b_invalid():     \"\"\"Invalid U1b: Missing closures.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U1b INVALID EXAMPLES: Missing Closures\")     print(\"=\" * 60)      examples = [         (\"Ends with Coherence (not closure)\", [Emission(), Coherence()]),         (\"Ends with Reception (not closure)\", [Emission(), Coherence(), Reception()]),         (\"Ends with Emission (not closure)\", [Emission(), Coherence(), Emission()]),     ]      for name, sequence in examples:         try:             is_valid = validate_grammar(sequence, epi_initial=0.0)             print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")         except ValueError as e:             print(f\"\\n{name}:\")             print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")             print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\") In\u00a0[\u00a0]: Copied! <pre>def example_dual_role_operators():\n    \"\"\"Operators that can be both generators AND closures.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DUAL ROLE: Operators in Multiple Sets\")\n    print(\"=\" * 60)\n\n    print(\"\\nTransition (NAV):\")\n    print(\"  - Generator (U1a): Activates latent EPI\")\n    print(\"  - Closure (U1b): Handoff to next regime\")\n\n    sequence = [Transition(), Coherence(), Transition()]\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n    print(f\"\\n  Example: {[op.__class__.__name__ for op in sequence]}\")\n    print(f\"  Valid: {is_valid}\")\n    print(f\"  Both U1a and U1b satisfied!\")\n\n    print(\"\\nRecursivity (REMESH):\")\n    print(\"  - Generator (U1a): Echoes dormant structure\")\n    print(\"  - Closure (U1b): Recursive attractor\")\n\n    sequence = [Recursivity(), Coherence(), Recursivity()]\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n    print(f\"\\n  Example: {[op.__class__.__name__ for op in sequence]}\")\n    print(f\"  Valid: {is_valid}\")\n</pre> def example_dual_role_operators():     \"\"\"Operators that can be both generators AND closures.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"DUAL ROLE: Operators in Multiple Sets\")     print(\"=\" * 60)      print(\"\\nTransition (NAV):\")     print(\"  - Generator (U1a): Activates latent EPI\")     print(\"  - Closure (U1b): Handoff to next regime\")      sequence = [Transition(), Coherence(), Transition()]     is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)     print(f\"\\n  Example: {[op.__class__.__name__ for op in sequence]}\")     print(f\"  Valid: {is_valid}\")     print(f\"  Both U1a and U1b satisfied!\")      print(\"\\nRecursivity (REMESH):\")     print(\"  - Generator (U1a): Echoes dormant structure\")     print(\"  - Closure (U1b): Recursive attractor\")      sequence = [Recursivity(), Coherence(), Recursivity()]     is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)     print(f\"\\n  Example: {[op.__class__.__name__ for op in sequence]}\")     print(f\"  Valid: {is_valid}\") In\u00a0[\u00a0]: Copied! <pre>def main():\n    \"\"\"Run all U1 examples.\"\"\"\n    print(\"=\" * 60)\n    print(\"U1: STRUCTURAL INITIATION &amp; CLOSURE\")\n    print(\"Executable Examples with Physics Traceability\")\n    print(\"=\" * 60)\n\n    # U1a examples\n    example_u1a_valid()\n    example_u1a_invalid()\n    example_u1a_context_matters()\n\n    # U1b examples\n    example_u1b_valid()\n    example_u1b_invalid()\n\n    # Dual role examples\n    example_dual_role_operators()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Examples complete! All behaviors match TNFR physics.\")\n    print(\"=\" * 60)\n</pre> def main():     \"\"\"Run all U1 examples.\"\"\"     print(\"=\" * 60)     print(\"U1: STRUCTURAL INITIATION &amp; CLOSURE\")     print(\"Executable Examples with Physics Traceability\")     print(\"=\" * 60)      # U1a examples     example_u1a_valid()     example_u1a_invalid()     example_u1a_context_matters()      # U1b examples     example_u1b_valid()     example_u1b_invalid()      # Dual role examples     example_dual_role_operators()      print(\"\\n\" + \"=\" * 60)     print(\"Examples complete! All behaviors match TNFR physics.\")     print(\"=\" * 60) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"grammar/examples/u2-convergence-examples/","title":"U2 convergence examples","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nU2: CONVERGENCE &amp; BOUNDEDNESS Examples\n\nDemonstrates stabilizer-destabilizer balance for integral convergence.\n\nPhysics Basis:\n- Without stabilizers: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e (diverges)\n- With stabilizers: Integral converges, coherence preserved\n\nFrom integrated nodal equation:\n  EPI(t_f) = EPI(t_0) + \u222b_{t_0}^{t_f} \u03bdf\u00b7\u0394NFR d\u03c4\n\nRun: python u2-convergence-examples.py\n\"\"\"\n</pre> \"\"\" U2: CONVERGENCE &amp; BOUNDEDNESS Examples  Demonstrates stabilizer-destabilizer balance for integral convergence.  Physics Basis: - Without stabilizers: \u222b\u03bdf\u00b7\u0394NFR dt \u2192 \u221e (diverges) - With stabilizers: Integral converges, coherence preserved  From integrated nodal equation:   EPI(t_f) = EPI(t_0) + \u222b_{t_0}^{t_f} \u03bdf\u00b7\u0394NFR d\u03c4  Run: python u2-convergence-examples.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.grammar import validate_grammar, GrammarValidator\nfrom tnfr.operators.definitions import (\n    Emission,\n    Dissonance,\n    Mutation,\n    Expansion,\n    Coherence,\n    SelfOrganization,\n    Silence,\n)\n</pre> from tnfr.operators.grammar import validate_grammar, GrammarValidator from tnfr.operators.definitions import (     Emission,     Dissonance,     Mutation,     Expansion,     Coherence,     SelfOrganization,     Silence, ) In\u00a0[\u00a0]: Copied! <pre>def example_u2_valid():\n    \"\"\"Valid U2: Destabilizers balanced by stabilizers.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U2 VALID EXAMPLES: Balanced Sequences\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\n            \"Single destabilizer + stabilizer\",\n            [Emission(), Dissonance(), Coherence(), Silence()],\n        ),\n        (\n            \"Mutation + Self-organization\",\n            [\n                Emission(),\n                Coherence(),\n                Dissonance(),\n                Mutation(),\n                SelfOrganization(),\n                Silence(),\n            ],\n        ),\n        (\n            \"Multiple destabilizers + stabilizer\",\n            [Emission(), Dissonance(), Expansion(), Coherence(), Silence()],\n        ),\n        (\n            \"Interleaved stabilizers\",\n            [\n                Emission(),\n                Dissonance(),\n                Coherence(),\n                Expansion(),\n                Coherence(),\n                Silence(),\n            ],\n        ),\n    ]\n\n    for name, sequence in examples:\n        is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)\n        print(f\"\\n{name}:\")\n        print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n        print(f\"  Valid: {is_valid}\")\n        print(f\"  Convergence: {message}\")\n</pre> def example_u2_valid():     \"\"\"Valid U2: Destabilizers balanced by stabilizers.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U2 VALID EXAMPLES: Balanced Sequences\")     print(\"=\" * 60)      examples = [         (             \"Single destabilizer + stabilizer\",             [Emission(), Dissonance(), Coherence(), Silence()],         ),         (             \"Mutation + Self-organization\",             [                 Emission(),                 Coherence(),                 Dissonance(),                 Mutation(),                 SelfOrganization(),                 Silence(),             ],         ),         (             \"Multiple destabilizers + stabilizer\",             [Emission(), Dissonance(), Expansion(), Coherence(), Silence()],         ),         (             \"Interleaved stabilizers\",             [                 Emission(),                 Dissonance(),                 Coherence(),                 Expansion(),                 Coherence(),                 Silence(),             ],         ),     ]      for name, sequence in examples:         is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)         print(f\"\\n{name}:\")         print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")         print(f\"  Valid: {is_valid}\")         print(f\"  Convergence: {message}\") In\u00a0[\u00a0]: Copied! <pre>def example_u2_invalid():\n    \"\"\"Invalid U2: Destabilizers without stabilizers.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U2 INVALID EXAMPLES: Unbalanced Sequences\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"Dissonance alone\", [Emission(), Dissonance(), Silence()]),\n        (\"Mutation alone\", [Emission(), Mutation(), Silence()]),\n        (\"Multiple destabilizers\", [Emission(), Dissonance(), Expansion(), Silence()]),\n    ]\n\n    for name, sequence in examples:\n        try:\n            is_valid = validate_grammar(sequence, epi_initial=0.0)\n            print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")\n        except ValueError as e:\n            print(f\"\\n{name}:\")\n            print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n            print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\")\n</pre> def example_u2_invalid():     \"\"\"Invalid U2: Destabilizers without stabilizers.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U2 INVALID EXAMPLES: Unbalanced Sequences\")     print(\"=\" * 60)      examples = [         (\"Dissonance alone\", [Emission(), Dissonance(), Silence()]),         (\"Mutation alone\", [Emission(), Mutation(), Silence()]),         (\"Multiple destabilizers\", [Emission(), Dissonance(), Expansion(), Silence()]),     ]      for name, sequence in examples:         try:             is_valid = validate_grammar(sequence, epi_initial=0.0)             print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")         except ValueError as e:             print(f\"\\n{name}:\")             print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")             print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\") In\u00a0[\u00a0]: Copied! <pre>def example_u2_not_applicable():\n    \"\"\"When U2 doesn't apply.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U2 NOT APPLICABLE: No Destabilizers\")\n    print(\"=\" * 60)\n\n    # No destabilizers = no convergence risk\n    sequence = [Emission(), Coherence(), Silence()]\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n\n    print(\"\\nSequence with no destabilizers:\")\n    print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n    print(f\"  Valid: {is_valid}\")\n    print(f\"  Message: {msg}\")\n    print(\"\\n  \u2139 U2 only checks sequences containing destabilizers\")\n</pre> def example_u2_not_applicable():     \"\"\"When U2 doesn't apply.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U2 NOT APPLICABLE: No Destabilizers\")     print(\"=\" * 60)      # No destabilizers = no convergence risk     sequence = [Emission(), Coherence(), Silence()]     is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)      print(\"\\nSequence with no destabilizers:\")     print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")     print(f\"  Valid: {is_valid}\")     print(f\"  Message: {msg}\")     print(\"\\n  \u2139 U2 only checks sequences containing destabilizers\") In\u00a0[\u00a0]: Copied! <pre>def example_operator_classification():\n    \"\"\"Show which operators are destabilizers vs stabilizers.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"OPERATOR CLASSIFICATION: Destabilizers vs Stabilizers\")\n    print(\"=\" * 60)\n\n    print(\"\\nDESTABILIZERS (increase |\u0394NFR|):\")\n    print(\"  - Dissonance (OZ): Explicit dissonance\")\n    print(\"  - Mutation (ZHIR): Phase transformation\")\n    print(\"  - Expansion (VAL): Increases structural complexity\")\n    print(\"  \u2192 Positive feedback \u2192 May cause divergence\")\n\n    print(\"\\nSTABILIZERS (reduce |\u0394NFR|):\")\n    print(\"  - Coherence (IL): Direct coherence restoration\")\n    print(\"  - Self-organization (THOL): Autopoietic boundaries\")\n    print(\"  \u2192 Negative feedback \u2192 Ensures convergence\")\n</pre> def example_operator_classification():     \"\"\"Show which operators are destabilizers vs stabilizers.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"OPERATOR CLASSIFICATION: Destabilizers vs Stabilizers\")     print(\"=\" * 60)      print(\"\\nDESTABILIZERS (increase |\u0394NFR|):\")     print(\"  - Dissonance (OZ): Explicit dissonance\")     print(\"  - Mutation (ZHIR): Phase transformation\")     print(\"  - Expansion (VAL): Increases structural complexity\")     print(\"  \u2192 Positive feedback \u2192 May cause divergence\")      print(\"\\nSTABILIZERS (reduce |\u0394NFR|):\")     print(\"  - Coherence (IL): Direct coherence restoration\")     print(\"  - Self-organization (THOL): Autopoietic boundaries\")     print(\"  \u2192 Negative feedback \u2192 Ensures convergence\") In\u00a0[\u00a0]: Copied! <pre>def example_ordering_matters():\n    \"\"\"Demonstrate that stabilizer order matters.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ANTI-PATTERN: Ordering Matters\")\n    print(\"=\" * 60)\n\n    # Stabilizer before destabilizer - less effective\n    sequence1 = [Emission(), Coherence(), Dissonance(), Silence()]\n    print(\"\\nStabilizer BEFORE destabilizer:\")\n    print(f\"  Sequence: {[op.__class__.__name__ for op in sequence1]}\")\n    print(\"  \u26a0 Coherence cannot prevent later dissonance\")\n    print(\"  \u26a0 Passes U2 but less effective in practice\")\n\n    # Stabilizer after destabilizer - effective\n    sequence2 = [Emission(), Dissonance(), Coherence(), Silence()]\n    print(\"\\nStabilizer AFTER destabilizer:\")\n    print(f\"  Sequence: {[op.__class__.__name__ for op in sequence2]}\")\n    print(\"  \u2713 Coherence bounds dissonance growth\")\n    print(\"  \u2713 Better control of |\u0394NFR|\")\n</pre> def example_ordering_matters():     \"\"\"Demonstrate that stabilizer order matters.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ANTI-PATTERN: Ordering Matters\")     print(\"=\" * 60)      # Stabilizer before destabilizer - less effective     sequence1 = [Emission(), Coherence(), Dissonance(), Silence()]     print(\"\\nStabilizer BEFORE destabilizer:\")     print(f\"  Sequence: {[op.__class__.__name__ for op in sequence1]}\")     print(\"  \u26a0 Coherence cannot prevent later dissonance\")     print(\"  \u26a0 Passes U2 but less effective in practice\")      # Stabilizer after destabilizer - effective     sequence2 = [Emission(), Dissonance(), Coherence(), Silence()]     print(\"\\nStabilizer AFTER destabilizer:\")     print(f\"  Sequence: {[op.__class__.__name__ for op in sequence2]}\")     print(\"  \u2713 Coherence bounds dissonance growth\")     print(\"  \u2713 Better control of |\u0394NFR|\") In\u00a0[\u00a0]: Copied! <pre>def example_masking_antipattern():\n    \"\"\"Anti-pattern: Multiple destabilizers, single weak stabilizer.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ANTI-PATTERN: Masking with Weak Stabilizers\")\n    print(\"=\" * 60)\n\n    sequence = [\n        Emission(),\n        Dissonance(),  # +\u0394NFR\n        Expansion(),  # ++\u0394NFR\n        Mutation(),  # +++\u0394NFR\n        Coherence(),  # -\u0394NFR (may not be sufficient!)\n        Silence(),\n    ]\n\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n    print(\"\\nMultiple destabilizers, single stabilizer:\")\n    print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n    print(f\"  Grammar valid: {is_valid}\")\n    print(\"  \u26a0 WARNING: Technically passes U2...\")\n    print(\"  \u26a0 But integral may still be large!\")\n    print(\"  \u26a0 Better: Add more stabilizers or reduce destabilizers\")\n</pre> def example_masking_antipattern():     \"\"\"Anti-pattern: Multiple destabilizers, single weak stabilizer.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ANTI-PATTERN: Masking with Weak Stabilizers\")     print(\"=\" * 60)      sequence = [         Emission(),         Dissonance(),  # +\u0394NFR         Expansion(),  # ++\u0394NFR         Mutation(),  # +++\u0394NFR         Coherence(),  # -\u0394NFR (may not be sufficient!)         Silence(),     ]      is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)     print(\"\\nMultiple destabilizers, single stabilizer:\")     print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")     print(f\"  Grammar valid: {is_valid}\")     print(\"  \u26a0 WARNING: Technically passes U2...\")     print(\"  \u26a0 But integral may still be large!\")     print(\"  \u26a0 Better: Add more stabilizers or reduce destabilizers\") In\u00a0[\u00a0]: Copied! <pre>def example_interleaving_pattern():\n    \"\"\"Good pattern: Interleave stabilizers with destabilizers.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"GOOD PATTERN: Interleaved Stabilizers\")\n    print(\"=\" * 60)\n\n    sequence = [\n        Emission(),\n        Dissonance(),\n        Coherence(),  # Bound first destabilizer\n        Expansion(),\n        Coherence(),  # Bound second destabilizer\n        Mutation(),\n        SelfOrganization(),  # Bound third destabilizer\n        Silence(),\n    ]\n\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n    print(\"\\nInterleaved stabilizers:\")\n    print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n    print(f\"  Valid: {is_valid}\")\n    print(\"  \u2713 Each destabilizer has nearby stabilizer\")\n    print(\"  \u2713 Better |\u0394NFR| control throughout sequence\")\n    print(\"  \u2713 Lower risk of divergence\")\n</pre> def example_interleaving_pattern():     \"\"\"Good pattern: Interleave stabilizers with destabilizers.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"GOOD PATTERN: Interleaved Stabilizers\")     print(\"=\" * 60)      sequence = [         Emission(),         Dissonance(),         Coherence(),  # Bound first destabilizer         Expansion(),         Coherence(),  # Bound second destabilizer         Mutation(),         SelfOrganization(),  # Bound third destabilizer         Silence(),     ]      is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)     print(\"\\nInterleaved stabilizers:\")     print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")     print(f\"  Valid: {is_valid}\")     print(\"  \u2713 Each destabilizer has nearby stabilizer\")     print(\"  \u2713 Better |\u0394NFR| control throughout sequence\")     print(\"  \u2713 Lower risk of divergence\") In\u00a0[\u00a0]: Copied! <pre>def main():\n    \"\"\"Run all U2 examples.\"\"\"\n    print(\"=\" * 60)\n    print(\"U2: CONVERGENCE &amp; BOUNDEDNESS\")\n    print(\"Executable Examples with Physics Traceability\")\n    print(\"=\" * 60)\n\n    example_u2_valid()\n    example_u2_invalid()\n    example_u2_not_applicable()\n    example_operator_classification()\n    example_ordering_matters()\n    example_masking_antipattern()\n    example_interleaving_pattern()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Examples complete! Demonstrates \u222b\u03bdf\u00b7\u0394NFR dt convergence.\")\n    print(\"=\" * 60)\n</pre> def main():     \"\"\"Run all U2 examples.\"\"\"     print(\"=\" * 60)     print(\"U2: CONVERGENCE &amp; BOUNDEDNESS\")     print(\"Executable Examples with Physics Traceability\")     print(\"=\" * 60)      example_u2_valid()     example_u2_invalid()     example_u2_not_applicable()     example_operator_classification()     example_ordering_matters()     example_masking_antipattern()     example_interleaving_pattern()      print(\"\\n\" + \"=\" * 60)     print(\"Examples complete! Demonstrates \u222b\u03bdf\u00b7\u0394NFR dt convergence.\")     print(\"=\" * 60) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"grammar/examples/u3-resonant-coupling-examples/","title":"U3 resonant coupling examples","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nU3: RESONANT COUPLING Examples\n\nDemonstrates phase verification requirement for coupling/resonance operators.\n\nPhysics Basis:\n- Resonance requires phase compatibility: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max\n- Antiphase \u2192 destructive interference (non-physical)\n- Based on AGENTS.md Invariant #5 + wave physics\n\nRun: python u3-resonant-coupling-examples.py\n\"\"\"\n</pre> \"\"\" U3: RESONANT COUPLING Examples  Demonstrates phase verification requirement for coupling/resonance operators.  Physics Basis: - Resonance requires phase compatibility: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max - Antiphase \u2192 destructive interference (non-physical) - Based on AGENTS.md Invariant #5 + wave physics  Run: python u3-resonant-coupling-examples.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>import networkx as nx\nimport numpy as np\n</pre> import networkx as nx import numpy as np In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.grammar import validate_grammar, GrammarValidator\n</pre> from tnfr.operators.grammar import validate_grammar, GrammarValidator In\u00a0[\u00a0]: Copied! <pre>def create_test_graph(theta1, theta2):\n    \"\"\"Create a simple graph with two nodes at specified phases.\"\"\"\n    G = nx.Graph()\n    G.add_node(0, theta=theta1, vf=1.0, EPI=0.5, DNFR=0.0)\n    G.add_node(1, theta=theta2, vf=1.0, EPI=0.6, DNFR=0.0)\n    return G\n</pre> def create_test_graph(theta1, theta2):     \"\"\"Create a simple graph with two nodes at specified phases.\"\"\"     G = nx.Graph()     G.add_node(0, theta=theta1, vf=1.0, EPI=0.5, DNFR=0.0)     G.add_node(1, theta=theta2, vf=1.0, EPI=0.6, DNFR=0.0)     return G In\u00a0[\u00a0]: Copied! <pre>def example_phase_compatibility():\n    \"\"\"Demonstrate phase compatibility checking.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"PHASE COMPATIBILITY: Valid Coupling Conditions\")\n    print(\"=\" * 60)\n\n    cases = [\n        (\"In phase\", 0.0, 0.0, True),\n        (\"Small difference\", 0.0, 0.3, True),\n        (\"Near threshold\", 0.0, np.pi / 2 - 0.1, True),\n        (\"At threshold\", 0.0, np.pi / 2, False),\n        (\"Beyond threshold\", 0.0, np.pi / 2 + 0.1, False),\n        (\"Antiphase\", 0.0, np.pi, False),\n    ]\n\n    for name, theta1, theta2, should_pass in cases:\n        G = create_test_graph(theta1, theta2)\n        delta_phi = abs(theta1 - theta2)\n\n        print(f\"\\n{name}:\")\n        print(f\"  \u03b8\u2081 = {theta1:.3f}, \u03b8\u2082 = {theta2:.3f}\")\n        print(f\"  \u0394\u03c6 = {delta_phi:.3f} rad\")\n\n        # Try applying coupling operator\n        from tnfr.operators.definitions import Coupling\n\n        try:\n            # Coupling operator should check phase during application\n            op = Coupling()\n            # Apply the operator - it will check phase internally\n            op(G, 0, 1)\n            \n            if should_pass:\n                print(f\"  \u2713 Coupling allowed (\u0394\u03c6 &lt; \u03c0/2)\")\n            else:\n                print(f\"  \u26a0 Should have failed but passed!\")\n        except (ValueError, RuntimeError, Exception) as e:\n            if not should_pass:\n                print(f\"  \u2713 Correctly rejected: {str(e)[:60]}...\")\n            else:\n                print(f\"  \u2717 Should have passed but failed: {str(e)[:60]}...\")\n</pre> def example_phase_compatibility():     \"\"\"Demonstrate phase compatibility checking.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"PHASE COMPATIBILITY: Valid Coupling Conditions\")     print(\"=\" * 60)      cases = [         (\"In phase\", 0.0, 0.0, True),         (\"Small difference\", 0.0, 0.3, True),         (\"Near threshold\", 0.0, np.pi / 2 - 0.1, True),         (\"At threshold\", 0.0, np.pi / 2, False),         (\"Beyond threshold\", 0.0, np.pi / 2 + 0.1, False),         (\"Antiphase\", 0.0, np.pi, False),     ]      for name, theta1, theta2, should_pass in cases:         G = create_test_graph(theta1, theta2)         delta_phi = abs(theta1 - theta2)          print(f\"\\n{name}:\")         print(f\"  \u03b8\u2081 = {theta1:.3f}, \u03b8\u2082 = {theta2:.3f}\")         print(f\"  \u0394\u03c6 = {delta_phi:.3f} rad\")          # Try applying coupling operator         from tnfr.operators.definitions import Coupling          try:             # Coupling operator should check phase during application             op = Coupling()             # Apply the operator - it will check phase internally             op(G, 0, 1)                          if should_pass:                 print(f\"  \u2713 Coupling allowed (\u0394\u03c6 &lt; \u03c0/2)\")             else:                 print(f\"  \u26a0 Should have failed but passed!\")         except (ValueError, RuntimeError, Exception) as e:             if not should_pass:                 print(f\"  \u2713 Correctly rejected: {str(e)[:60]}...\")             else:                 print(f\"  \u2717 Should have passed but failed: {str(e)[:60]}...\") In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>def example_coupling_resonance_operators():\n    \"\"\"Show which operators require phase verification.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"OPERATORS REQUIRING PHASE VERIFICATION (U3)\")\n    print(\"=\" * 60)\n\n    print(\"\\nCoupling (UM):\")\n    print(\"  - Creates structural links between nodes\")\n    print(\"  - Requires: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max\")\n    print(\"  - Effect: \u03c6\u1d62(t) \u2192 \u03c6\u2c7c(t) (phase synchronization)\")\n\n    print(\"\\nResonance (RA):\")\n    print(\"  - Amplifies and propagates patterns\")\n    print(\"  - Requires: Phase compatibility for constructive interference\")\n    print(\"  - Effect: Increases effective coupling strength\")\n\n    print(\"\\n\u26a0 MANDATORY per AGENTS.md Invariant #5:\")\n    print(\"  'No coupling is valid without explicit phase verification'\")\n</pre> def example_coupling_resonance_operators():     \"\"\"Show which operators require phase verification.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"OPERATORS REQUIRING PHASE VERIFICATION (U3)\")     print(\"=\" * 60)      print(\"\\nCoupling (UM):\")     print(\"  - Creates structural links between nodes\")     print(\"  - Requires: |\u03c6\u1d62 - \u03c6\u2c7c| \u2264 \u0394\u03c6_max\")     print(\"  - Effect: \u03c6\u1d62(t) \u2192 \u03c6\u2c7c(t) (phase synchronization)\")      print(\"\\nResonance (RA):\")     print(\"  - Amplifies and propagates patterns\")     print(\"  - Requires: Phase compatibility for constructive interference\")     print(\"  - Effect: Increases effective coupling strength\")      print(\"\\n\u26a0 MANDATORY per AGENTS.md Invariant #5:\")     print(\"  'No coupling is valid without explicit phase verification'\") In\u00a0[\u00a0]: Copied! <pre>def example_sequence_validation():\n    \"\"\"Show that U3 is checked at sequence level.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"SEQUENCE-LEVEL VALIDATION\")\n    print(\"=\" * 60)\n\n    from tnfr.operators.definitions import Emission, Coupling, Silence\n\n    sequence = [Emission(), Coupling(), Silence()]\n    is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)\n\n    print(\"\\nSequence with coupling operator:\")\n    print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n    print(f\"  Grammar: {msg}\")\n    print(\"\\n  \u2139 U3 is META-rule: Documents requirement\")\n    print(\"  \u2139 Actual phase check happens in operator preconditions\")\n    print(\"  \u2139 Grammar ensures awareness that check is MANDATORY\")\n</pre> def example_sequence_validation():     \"\"\"Show that U3 is checked at sequence level.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"SEQUENCE-LEVEL VALIDATION\")     print(\"=\" * 60)      from tnfr.operators.definitions import Emission, Coupling, Silence      sequence = [Emission(), Coupling(), Silence()]     is_valid, msg = GrammarValidator.validate(sequence, epi_initial=0.0)      print(\"\\nSequence with coupling operator:\")     print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")     print(f\"  Grammar: {msg}\")     print(\"\\n  \u2139 U3 is META-rule: Documents requirement\")     print(\"  \u2139 Actual phase check happens in operator preconditions\")     print(\"  \u2139 Grammar ensures awareness that check is MANDATORY\") In\u00a0[\u00a0]: Copied! <pre>def example_antipattern_no_check():\n    \"\"\"Anti-pattern: Attempting to couple without verification.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ANTI-PATTERN: Coupling Without Phase Check\")\n    print(\"=\" * 60)\n\n    print(\"\\nBAD: Direct coupling without verification\")\n    print(\"\"\"\n    G = create_graph()\n    G.nodes[0]['theta'] = 0.0\n    G.nodes[1]['theta'] = 3.0  # Could be antiphase!\n    \n    Coupling()(G, 0, 1)  # ERROR: No phase check\n    \"\"\")\n\n    print(\"\\nGOOD: Verify phase compatibility first\")\n    print(\"\"\"\n    from tnfr.operators.grammar import validate_resonant_coupling\n    \n    G = create_graph()\n    G.nodes[0]['theta'] = 0.0\n    G.nodes[1]['theta'] = 3.0\n    \n    validate_resonant_coupling(G, 0, 1)  # Raises if incompatible\n    Coupling()(G, 0, 1)  # Safe\n    \"\"\")\n</pre> def example_antipattern_no_check():     \"\"\"Anti-pattern: Attempting to couple without verification.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ANTI-PATTERN: Coupling Without Phase Check\")     print(\"=\" * 60)      print(\"\\nBAD: Direct coupling without verification\")     print(\"\"\"     G = create_graph()     G.nodes[0]['theta'] = 0.0     G.nodes[1]['theta'] = 3.0  # Could be antiphase!          Coupling()(G, 0, 1)  # ERROR: No phase check     \"\"\")      print(\"\\nGOOD: Verify phase compatibility first\")     print(\"\"\"     from tnfr.operators.grammar import validate_resonant_coupling          G = create_graph()     G.nodes[0]['theta'] = 0.0     G.nodes[1]['theta'] = 3.0          validate_resonant_coupling(G, 0, 1)  # Raises if incompatible     Coupling()(G, 0, 1)  # Safe     \"\"\") In\u00a0[\u00a0]: Copied! <pre>def example_antipattern_phase_drift():\n    \"\"\"Anti-pattern: Ignoring phase drift during sequences.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ANTI-PATTERN: Phase Drift\")\n    print(\"=\" * 60)\n\n    print(\"\\nPROBLEM: Phase changes during sequence\")\n    print(\"\"\"\n    sequence = [\n        Emission(),\n        Coupling(),    # Phase compatible here\n        Mutation(),    # Changes \u03b8!\n        Coupling(),    # Phase may no longer be compatible!\n        Silence()\n    ]\n    \"\"\")\n\n    print(\"\\nSOLUTION 1: Verify phase after transformations\")\n    print(\"  - Re-check phase after Mutation\")\n    print(\"  - Or use operators that preserve phase\")\n\n    print(\"\\nSOLUTION 2: Couple before phase-changing operators\")\n    print(\"\"\"\n    sequence = [\n        Emission(),\n        Coupling(),    # Couple while phases compatible\n        Silence(),\n        # Then in separate sequence:\n        Emission(),\n        Mutation(),    # Change phase\n        Silence()\n    ]\n    \"\"\")\n</pre> def example_antipattern_phase_drift():     \"\"\"Anti-pattern: Ignoring phase drift during sequences.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ANTI-PATTERN: Phase Drift\")     print(\"=\" * 60)      print(\"\\nPROBLEM: Phase changes during sequence\")     print(\"\"\"     sequence = [         Emission(),         Coupling(),    # Phase compatible here         Mutation(),    # Changes \u03b8!         Coupling(),    # Phase may no longer be compatible!         Silence()     ]     \"\"\")      print(\"\\nSOLUTION 1: Verify phase after transformations\")     print(\"  - Re-check phase after Mutation\")     print(\"  - Or use operators that preserve phase\")      print(\"\\nSOLUTION 2: Couple before phase-changing operators\")     print(\"\"\"     sequence = [         Emission(),         Coupling(),    # Couple while phases compatible         Silence(),         # Then in separate sequence:         Emission(),         Mutation(),    # Change phase         Silence()     ]     \"\"\") In\u00a0[\u00a0]: Copied! <pre>def example_threshold_considerations():\n    \"\"\"Discuss threshold selection.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"THRESHOLD SELECTION: \u0394\u03c6_max\")\n    print(\"=\" * 60)\n\n    print(\"\\nTypical threshold: \u03c0/2 radians (~90 degrees)\")\n    print(\"\\nPhysics basis:\")\n    print(\"  - Coupling strength ~ cos(\u0394\u03c6)\")\n    print(\"  - At \u0394\u03c6 = 0: cos(0) = 1 (maximum coupling)\")\n    print(\"  - At \u0394\u03c6 = \u03c0/2: cos(\u03c0/2) = 0 (no coupling)\")\n    print(\"  - At \u0394\u03c6 = \u03c0: cos(\u03c0) = -1 (destructive interference)\")\n\n    print(\"\\nPractical considerations:\")\n    print(\"  - \u0394\u03c6 &lt; \u03c0/4: Strong coupling\")\n    print(\"  - \u03c0/4 &lt; \u0394\u03c6 &lt; \u03c0/2: Weak coupling\")\n    print(\"  - \u0394\u03c6 &gt; \u03c0/2: Non-physical (rejected)\")\n</pre> def example_threshold_considerations():     \"\"\"Discuss threshold selection.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"THRESHOLD SELECTION: \u0394\u03c6_max\")     print(\"=\" * 60)      print(\"\\nTypical threshold: \u03c0/2 radians (~90 degrees)\")     print(\"\\nPhysics basis:\")     print(\"  - Coupling strength ~ cos(\u0394\u03c6)\")     print(\"  - At \u0394\u03c6 = 0: cos(0) = 1 (maximum coupling)\")     print(\"  - At \u0394\u03c6 = \u03c0/2: cos(\u03c0/2) = 0 (no coupling)\")     print(\"  - At \u0394\u03c6 = \u03c0: cos(\u03c0) = -1 (destructive interference)\")      print(\"\\nPractical considerations:\")     print(\"  - \u0394\u03c6 &lt; \u03c0/4: Strong coupling\")     print(\"  - \u03c0/4 &lt; \u0394\u03c6 &lt; \u03c0/2: Weak coupling\")     print(\"  - \u0394\u03c6 &gt; \u03c0/2: Non-physical (rejected)\") In\u00a0[\u00a0]: Copied! <pre>def example_wave_interference():\n    \"\"\"Explain wave interference physics.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"PHYSICS: Wave Interference\")\n    print(\"=\" * 60)\n\n    print(\"\\nTwo oscillators with phases \u03c6\u2081 and \u03c6\u2082:\")\n    print(\"  x\u2081(t) = A sin(\u03c9t + \u03c6\u2081)\")\n    print(\"  x\u2082(t) = A sin(\u03c9t + \u03c6\u2082)\")\n\n    print(\"\\nWhen coupled:\")\n    print(\"  - IN PHASE (\u0394\u03c6 \u2248 0): Constructive interference\")\n    print(\"    \u2192 Amplitudes add: x = 2A sin(\u03c9t)\")\n    print(\"    \u2192 Information transfer efficient\")\n\n    print(\"\\n  - QUADRATURE (\u0394\u03c6 \u2248 \u03c0/2): Orthogonal\")\n    print(\"    \u2192 No coherent transfer: x\u2081 \u22a5 x\u2082\")\n    print(\"    \u2192 Coupling impossible\")\n\n    print(\"\\n  - ANTIPHASE (\u0394\u03c6 \u2248 \u03c0): Destructive interference\")\n    print(\"    \u2192 Amplitudes cancel: x = 0\")\n    print(\"    \u2192 Non-physical for information coupling\")\n</pre> def example_wave_interference():     \"\"\"Explain wave interference physics.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"PHYSICS: Wave Interference\")     print(\"=\" * 60)      print(\"\\nTwo oscillators with phases \u03c6\u2081 and \u03c6\u2082:\")     print(\"  x\u2081(t) = A sin(\u03c9t + \u03c6\u2081)\")     print(\"  x\u2082(t) = A sin(\u03c9t + \u03c6\u2082)\")      print(\"\\nWhen coupled:\")     print(\"  - IN PHASE (\u0394\u03c6 \u2248 0): Constructive interference\")     print(\"    \u2192 Amplitudes add: x = 2A sin(\u03c9t)\")     print(\"    \u2192 Information transfer efficient\")      print(\"\\n  - QUADRATURE (\u0394\u03c6 \u2248 \u03c0/2): Orthogonal\")     print(\"    \u2192 No coherent transfer: x\u2081 \u22a5 x\u2082\")     print(\"    \u2192 Coupling impossible\")      print(\"\\n  - ANTIPHASE (\u0394\u03c6 \u2248 \u03c0): Destructive interference\")     print(\"    \u2192 Amplitudes cancel: x = 0\")     print(\"    \u2192 Non-physical for information coupling\") In\u00a0[\u00a0]: Copied! <pre>def main():\n    \"\"\"Run all U3 examples.\"\"\"\n    print(\"=\" * 60)\n    print(\"U3: RESONANT COUPLING\")\n    print(\"Executable Examples with Physics Traceability\")\n    print(\"=\" * 60)\n\n    example_phase_compatibility()\n    example_coupling_resonance_operators()\n    example_sequence_validation()\n    example_antipattern_no_check()\n    example_antipattern_phase_drift()\n    example_threshold_considerations()\n    example_wave_interference()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Examples complete! Phase verification is MANDATORY.\")\n    print(\"=\" * 60)\n</pre> def main():     \"\"\"Run all U3 examples.\"\"\"     print(\"=\" * 60)     print(\"U3: RESONANT COUPLING\")     print(\"Executable Examples with Physics Traceability\")     print(\"=\" * 60)      example_phase_compatibility()     example_coupling_resonance_operators()     example_sequence_validation()     example_antipattern_no_check()     example_antipattern_phase_drift()     example_threshold_considerations()     example_wave_interference()      print(\"\\n\" + \"=\" * 60)     print(\"Examples complete! Phase verification is MANDATORY.\")     print(\"=\" * 60) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"grammar/examples/u4-bifurcation-examples/","title":"U4 bifurcation examples","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nU4: BIFURCATION DYNAMICS Examples\n\nDemonstrates U4a (triggers need handlers) and U4b (transformers need context).\n\nPhysics Basis:\n- U4a: Bifurcations (\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4) need control mechanisms\n- U4b: Phase transitions need threshold energy (recent destabilizer)\n        ZHIR specifically needs stable base (prior coherence)\n\nRun: python u4-bifurcation-examples.py\n\"\"\"\n</pre> \"\"\" U4: BIFURCATION DYNAMICS Examples  Demonstrates U4a (triggers need handlers) and U4b (transformers need context).  Physics Basis: - U4a: Bifurcations (\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4) need control mechanisms - U4b: Phase transitions need threshold energy (recent destabilizer)         ZHIR specifically needs stable base (prior coherence)  Run: python u4-bifurcation-examples.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>from tnfr.operators.grammar import validate_grammar, GrammarValidator\nfrom tnfr.operators.definitions import (\n    Emission,\n    Reception,\n    Dissonance,\n    Mutation,\n    Expansion,\n    Coherence,\n    SelfOrganization,\n    Silence,\n)\n</pre> from tnfr.operators.grammar import validate_grammar, GrammarValidator from tnfr.operators.definitions import (     Emission,     Reception,     Dissonance,     Mutation,     Expansion,     Coherence,     SelfOrganization,     Silence, ) In\u00a0[\u00a0]: Copied! <pre>def example_u4a_valid():\n    \"\"\"Valid U4a: Bifurcation triggers with handlers.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U4a VALID EXAMPLES: Triggers with Handlers\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\n            \"Dissonance + Coherence\",\n            [Emission(), Dissonance(), Coherence(), Silence()],\n        ),\n        (\n            \"Mutation + Self-organization\",\n            [\n                Emission(),\n                Coherence(),\n                Dissonance(),\n                Mutation(),\n                SelfOrganization(),\n                Silence(),\n            ],\n        ),\n        (\n            \"Multiple triggers with handlers\",\n            [\n                Emission(),\n                Dissonance(),\n                Coherence(),\n                Mutation(),\n                SelfOrganization(),\n                Silence(),\n            ],\n        ),\n    ]\n\n    for name, sequence in examples:\n        is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)\n        print(f\"\\n{name}:\")\n        print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n        print(f\"  Valid: {is_valid}\")\n        print(f\"  Bifurcation control: {message}\")\n</pre> def example_u4a_valid():     \"\"\"Valid U4a: Bifurcation triggers with handlers.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U4a VALID EXAMPLES: Triggers with Handlers\")     print(\"=\" * 60)      examples = [         (             \"Dissonance + Coherence\",             [Emission(), Dissonance(), Coherence(), Silence()],         ),         (             \"Mutation + Self-organization\",             [                 Emission(),                 Coherence(),                 Dissonance(),                 Mutation(),                 SelfOrganization(),                 Silence(),             ],         ),         (             \"Multiple triggers with handlers\",             [                 Emission(),                 Dissonance(),                 Coherence(),                 Mutation(),                 SelfOrganization(),                 Silence(),             ],         ),     ]      for name, sequence in examples:         is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)         print(f\"\\n{name}:\")         print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")         print(f\"  Valid: {is_valid}\")         print(f\"  Bifurcation control: {message}\") In\u00a0[\u00a0]: Copied! <pre>def example_u4a_invalid():\n    \"\"\"Invalid U4a: Triggers without handlers.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U4a INVALID EXAMPLES: Uncontrolled Bifurcations\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"Dissonance alone\", [Emission(), Dissonance(), Silence()]),\n        (\"Mutation alone\", [Emission(), Mutation(), Silence()]),\n    ]\n\n    for name, sequence in examples:\n        try:\n            is_valid = validate_grammar(sequence, epi_initial=0.0)\n            print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")\n        except ValueError as e:\n            print(f\"\\n{name}:\")\n            print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n            print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\")\n</pre> def example_u4a_invalid():     \"\"\"Invalid U4a: Triggers without handlers.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U4a INVALID EXAMPLES: Uncontrolled Bifurcations\")     print(\"=\" * 60)      examples = [         (\"Dissonance alone\", [Emission(), Dissonance(), Silence()]),         (\"Mutation alone\", [Emission(), Mutation(), Silence()]),     ]      for name, sequence in examples:         try:             is_valid = validate_grammar(sequence, epi_initial=0.0)             print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")         except ValueError as e:             print(f\"\\n{name}:\")             print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")             print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\") In\u00a0[\u00a0]: Copied! <pre>def example_u4b_valid():\n    \"\"\"Valid U4b: Transformers with proper context.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U4b VALID EXAMPLES: Transformers with Context\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\n            \"Mutation with context\",\n            [\n                Emission(),\n                Coherence(),  # Stable base\n                Dissonance(),  # Recent destabilizer\n                Mutation(),  # Transformer\n                Coherence(),\n                Silence(),\n            ],\n        ),\n        (\n            \"Self-organization with context\",\n            [\n                Emission(),\n                Dissonance(),  # Recent destabilizer\n                SelfOrganization(),  # Transformer\n                Coherence(),\n                Silence(),\n            ],\n        ),\n        (\n            \"Minimal window\",\n            [\n                Emission(),\n                Coherence(),\n                Dissonance(),\n                Mutation(),  # Within ~3 ops\n                Coherence(),\n                Silence(),\n            ],\n        ),\n    ]\n\n    for name, sequence in examples:\n        is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)\n        print(f\"\\n{name}:\")\n        print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n        print(f\"  Valid: {is_valid}\")\n</pre> def example_u4b_valid():     \"\"\"Valid U4b: Transformers with proper context.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U4b VALID EXAMPLES: Transformers with Context\")     print(\"=\" * 60)      examples = [         (             \"Mutation with context\",             [                 Emission(),                 Coherence(),  # Stable base                 Dissonance(),  # Recent destabilizer                 Mutation(),  # Transformer                 Coherence(),                 Silence(),             ],         ),         (             \"Self-organization with context\",             [                 Emission(),                 Dissonance(),  # Recent destabilizer                 SelfOrganization(),  # Transformer                 Coherence(),                 Silence(),             ],         ),         (             \"Minimal window\",             [                 Emission(),                 Coherence(),                 Dissonance(),                 Mutation(),  # Within ~3 ops                 Coherence(),                 Silence(),             ],         ),     ]      for name, sequence in examples:         is_valid, message = GrammarValidator.validate(sequence, epi_initial=0.0)         print(f\"\\n{name}:\")         print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")         print(f\"  Valid: {is_valid}\") In\u00a0[\u00a0]: Copied! <pre>def example_u4b_invalid():\n    \"\"\"Invalid U4b: Transformers without context.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"U4b INVALID EXAMPLES: Missing Context\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\n            \"Mutation without destabilizer\",\n            [Emission(), Coherence(), Mutation(), Silence()],\n        ),\n        (\n            \"Mutation without prior coherence\",\n            [Emission(), Dissonance(), Mutation(), Coherence(), Silence()],\n        ),\n        (\n            \"Destabilizer too far\",\n            [\n                Emission(),\n                Dissonance(),\n                Reception(),\n                Reception(),\n                Reception(),\n                Mutation(),\n                Silence(),\n            ],\n        ),\n    ]\n\n    for name, sequence in examples:\n        try:\n            is_valid = validate_grammar(sequence, epi_initial=0.0)\n            print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")\n        except ValueError as e:\n            print(f\"\\n{name}:\")\n            print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")\n            print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\")\n</pre> def example_u4b_invalid():     \"\"\"Invalid U4b: Transformers without context.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"U4b INVALID EXAMPLES: Missing Context\")     print(\"=\" * 60)      examples = [         (             \"Mutation without destabilizer\",             [Emission(), Coherence(), Mutation(), Silence()],         ),         (             \"Mutation without prior coherence\",             [Emission(), Dissonance(), Mutation(), Coherence(), Silence()],         ),         (             \"Destabilizer too far\",             [                 Emission(),                 Dissonance(),                 Reception(),                 Reception(),                 Reception(),                 Mutation(),                 Silence(),             ],         ),     ]      for name, sequence in examples:         try:             is_valid = validate_grammar(sequence, epi_initial=0.0)             print(f\"\\n{name}: SHOULD HAVE FAILED but got {is_valid}\")         except ValueError as e:             print(f\"\\n{name}:\")             print(f\"  Sequence: {[op.__class__.__name__ for op in sequence]}\")             print(f\"  \u2713 Correctly rejected: {str(e)[:80]}...\") In\u00a0[\u00a0]: Copied! <pre>def example_operator_classification():\n    \"\"\"Show bifurcation-related operator sets.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"OPERATOR CLASSIFICATION: Bifurcation Dynamics\")\n    print(\"=\" * 60)\n\n    print(\"\\nBIFURCATION TRIGGERS (may cause \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4):\")\n    print(\"  - Dissonance (OZ): Controlled instability\")\n    print(\"  - Mutation (ZHIR): Phase transformation\")\n    print(\"  \u2192 Create conditions for bifurcation\")\n\n    print(\"\\nBIFURCATION HANDLERS:\")\n    print(\"  - Self-organization (THOL): Creates new structure\")\n    print(\"  - Coherence (IL): Stabilizes transition\")\n    print(\"  \u2192 Manage reorganization into new attractor\")\n\n    print(\"\\nTRANSFORMERS (execute bifurcations):\")\n    print(\"  - Mutation (ZHIR): Phase transition\")\n    print(\"  - Self-organization (THOL): Autopoietic emergence\")\n    print(\"  \u2192 Require elevated \u0394NFR for threshold crossing\")\n</pre> def example_operator_classification():     \"\"\"Show bifurcation-related operator sets.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"OPERATOR CLASSIFICATION: Bifurcation Dynamics\")     print(\"=\" * 60)      print(\"\\nBIFURCATION TRIGGERS (may cause \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4):\")     print(\"  - Dissonance (OZ): Controlled instability\")     print(\"  - Mutation (ZHIR): Phase transformation\")     print(\"  \u2192 Create conditions for bifurcation\")      print(\"\\nBIFURCATION HANDLERS:\")     print(\"  - Self-organization (THOL): Creates new structure\")     print(\"  - Coherence (IL): Stabilizes transition\")     print(\"  \u2192 Manage reorganization into new attractor\")      print(\"\\nTRANSFORMERS (execute bifurcations):\")     print(\"  - Mutation (ZHIR): Phase transition\")     print(\"  - Self-organization (THOL): Autopoietic emergence\")     print(\"  \u2192 Require elevated \u0394NFR for threshold crossing\") In\u00a0[\u00a0]: Copied! <pre>def example_zhir_requirements():\n    \"\"\"Explain ZHIR-specific requirements.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ZHIR (MUTATION) SPECIFIC REQUIREMENTS\")\n    print(\"=\" * 60)\n\n    print(\"\\nMutation needs TWO things:\")\n    print(\"  1. PRIOR Coherence (IL): Stable base to jump from\")\n    print(\"  2. RECENT Destabilizer: Threshold energy\")\n\n    print(\"\\nWhy stable base?\")\n    print(\"  - Mutation is a PHASE TRANSITION\")\n    print(\"  - Need stable configuration to transform from\")\n    print(\"  - Like solid \u2192 liquid needs defined solid structure\")\n\n    print(\"\\nWhy recent destabilizer?\")\n    print(\"  - Need elevated \u0394NFR for threshold crossing\")\n    print(\"  - \u0394EPI/\u0394t &gt; \u03be required\")\n    print(\"  - Energy from destabilizer provides this\")\n\n    print(\"\\nPattern:\")\n    print(\"  [... Coherence ... Destabilizer ... Mutation ...]\")\n    print(\"       ^^^^^^ stable base  ^^^^^^ energy  ^^^^^^ transform\")\n</pre> def example_zhir_requirements():     \"\"\"Explain ZHIR-specific requirements.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ZHIR (MUTATION) SPECIFIC REQUIREMENTS\")     print(\"=\" * 60)      print(\"\\nMutation needs TWO things:\")     print(\"  1. PRIOR Coherence (IL): Stable base to jump from\")     print(\"  2. RECENT Destabilizer: Threshold energy\")      print(\"\\nWhy stable base?\")     print(\"  - Mutation is a PHASE TRANSITION\")     print(\"  - Need stable configuration to transform from\")     print(\"  - Like solid \u2192 liquid needs defined solid structure\")      print(\"\\nWhy recent destabilizer?\")     print(\"  - Need elevated \u0394NFR for threshold crossing\")     print(\"  - \u0394EPI/\u0394t &gt; \u03be required\")     print(\"  - Energy from destabilizer provides this\")      print(\"\\nPattern:\")     print(\"  [... Coherence ... Destabilizer ... Mutation ...]\")     print(\"       ^^^^^^ stable base  ^^^^^^ energy  ^^^^^^ transform\") In\u00a0[\u00a0]: Copied! <pre>def example_antipattern_cascade():\n    \"\"\"Anti-pattern: Uncontrolled bifurcation cascade.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ANTI-PATTERN: Bifurcation Cascade\")\n    print(\"=\" * 60)\n\n    print(\"\\nBAD: Multiple triggers without handlers\")\n    print(\"\"\"\n    sequence = [\n        Emission(),\n        Dissonance(),  # Trigger 1\n        Mutation(),    # Trigger 2 - cascade!\n        Silence()\n    ]\n    \"\"\")\n    print(\"  \u2717 System may enter chaotic regime\")\n    print(\"  \u2717 Multiple bifurcations unmanaged\")\n\n    print(\"\\nGOOD: Handler between triggers\")\n    print(\"\"\"\n    sequence = [\n        Emission(),\n        Coherence(),        # Stable base\n        Dissonance(),       # Trigger 1\n        Coherence(),        # Handler\n        Mutation(),         # Trigger 2\n        SelfOrganization(), # Handler\n        Silence()\n    ]\n    \"\"\")\n    print(\"  \u2713 Each bifurcation controlled\")\n    print(\"  \u2713 System guided through transitions\")\n</pre> def example_antipattern_cascade():     \"\"\"Anti-pattern: Uncontrolled bifurcation cascade.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ANTI-PATTERN: Bifurcation Cascade\")     print(\"=\" * 60)      print(\"\\nBAD: Multiple triggers without handlers\")     print(\"\"\"     sequence = [         Emission(),         Dissonance(),  # Trigger 1         Mutation(),    # Trigger 2 - cascade!         Silence()     ]     \"\"\")     print(\"  \u2717 System may enter chaotic regime\")     print(\"  \u2717 Multiple bifurcations unmanaged\")      print(\"\\nGOOD: Handler between triggers\")     print(\"\"\"     sequence = [         Emission(),         Coherence(),        # Stable base         Dissonance(),       # Trigger 1         Coherence(),        # Handler         Mutation(),         # Trigger 2         SelfOrganization(), # Handler         Silence()     ]     \"\"\")     print(\"  \u2713 Each bifurcation controlled\")     print(\"  \u2713 System guided through transitions\") In\u00a0[\u00a0]: Copied! <pre>def example_antipattern_window():\n    \"\"\"Anti-pattern: Transformer outside context window.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ANTI-PATTERN: Context Window Violation\")\n    print(\"=\" * 60)\n\n    print(\"\\nPROBLEM: Transformer too far from destabilizer\")\n    print(\"\"\"\n    sequence = [\n        Emission(),\n        Dissonance(),  # Position 1\n        Reception(),   # \u0394NFR decays...\n        Reception(),   # More decay...\n        Reception(),   # Even more decay...\n        Mutation(),    # Position 5 - insufficient \u0394NFR!\n        Silence()\n    ]\n    \"\"\")\n    print(\"  \u2717 Window is ~3 operators\")\n    print(\"  \u2717 Destabilizer at position 1 too far for position 5\")\n    print(\"  \u2717 \u0394NFR has decayed below threshold\")\n\n    print(\"\\nSOLUTION: Keep transformer within ~3 ops of destabilizer\")\n    print(\"\"\"\n    sequence = [\n        Emission(),\n        Coherence(),\n        Dissonance(),  # Position 2\n        Mutation(),    # Position 3 - within window!\n        Coherence(),\n        Silence()\n    ]\n    \"\"\")\n</pre> def example_antipattern_window():     \"\"\"Anti-pattern: Transformer outside context window.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"ANTI-PATTERN: Context Window Violation\")     print(\"=\" * 60)      print(\"\\nPROBLEM: Transformer too far from destabilizer\")     print(\"\"\"     sequence = [         Emission(),         Dissonance(),  # Position 1         Reception(),   # \u0394NFR decays...         Reception(),   # More decay...         Reception(),   # Even more decay...         Mutation(),    # Position 5 - insufficient \u0394NFR!         Silence()     ]     \"\"\")     print(\"  \u2717 Window is ~3 operators\")     print(\"  \u2717 Destabilizer at position 1 too far for position 5\")     print(\"  \u2717 \u0394NFR has decayed below threshold\")      print(\"\\nSOLUTION: Keep transformer within ~3 ops of destabilizer\")     print(\"\"\"     sequence = [         Emission(),         Coherence(),         Dissonance(),  # Position 2         Mutation(),    # Position 3 - within window!         Coherence(),         Silence()     ]     \"\"\") In\u00a0[\u00a0]: Copied! <pre>def example_handler_selection():\n    \"\"\"Discuss which handler for which trigger.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"HANDLER SELECTION: Best Practices\")\n    print(\"=\" * 60)\n\n    print(\"\\nFor Dissonance (OZ):\")\n    print(\"  - Coherence (IL): Direct stabilization\")\n    print(\"  - Self-organization (THOL): If creating new structure\")\n\n    print(\"\\nFor Mutation (ZHIR):\")\n    print(\"  - Self-organization (THOL): Preferred\")\n    print(\"    \u2192 Mutation creates new phase, THOL organizes it\")\n    print(\"  - Coherence (IL): Also valid\")\n    print(\"    \u2192 Stabilizes the new phase\")\n\n    print(\"\\nGeneral rule:\")\n    print(\"  - Use THOL when new structure emerges\")\n    print(\"  - Use IL when stabilizing existing structure\")\n</pre> def example_handler_selection():     \"\"\"Discuss which handler for which trigger.\"\"\"     print(\"\\n\" + \"=\" * 60)     print(\"HANDLER SELECTION: Best Practices\")     print(\"=\" * 60)      print(\"\\nFor Dissonance (OZ):\")     print(\"  - Coherence (IL): Direct stabilization\")     print(\"  - Self-organization (THOL): If creating new structure\")      print(\"\\nFor Mutation (ZHIR):\")     print(\"  - Self-organization (THOL): Preferred\")     print(\"    \u2192 Mutation creates new phase, THOL organizes it\")     print(\"  - Coherence (IL): Also valid\")     print(\"    \u2192 Stabilizes the new phase\")      print(\"\\nGeneral rule:\")     print(\"  - Use THOL when new structure emerges\")     print(\"  - Use IL when stabilizing existing structure\") In\u00a0[\u00a0]: Copied! <pre>def main():\n    \"\"\"Run all U4 examples.\"\"\"\n    print(\"=\" * 60)\n    print(\"U4: BIFURCATION DYNAMICS\")\n    print(\"Executable Examples with Physics Traceability\")\n    print(\"=\" * 60)\n\n    # U4a examples\n    example_u4a_valid()\n    example_u4a_invalid()\n\n    # U4b examples\n    example_u4b_valid()\n    example_u4b_invalid()\n\n    # Classification and requirements\n    example_operator_classification()\n    example_zhir_requirements()\n\n    # Anti-patterns\n    example_antipattern_cascade()\n    example_antipattern_window()\n    example_handler_selection()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Examples complete! Bifurcations under control.\")\n    print(\"=\" * 60)\n</pre> def main():     \"\"\"Run all U4 examples.\"\"\"     print(\"=\" * 60)     print(\"U4: BIFURCATION DYNAMICS\")     print(\"Executable Examples with Physics Traceability\")     print(\"=\" * 60)      # U4a examples     example_u4a_valid()     example_u4a_invalid()      # U4b examples     example_u4b_valid()     example_u4b_invalid()      # Classification and requirements     example_operator_classification()     example_zhir_requirements()      # Anti-patterns     example_antipattern_cascade()     example_antipattern_window()     example_handler_selection()      print(\"\\n\" + \"=\" * 60)     print(\"Examples complete! Bifurcations under control.\")     print(\"=\" * 60) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"},{"location":"operators/NAV_GUIDE/","title":"NAV (Transition) - Canonical Sequences, Anti-Patterns, and Troubleshooting","text":""},{"location":"operators/NAV_GUIDE/#overview","title":"Overview","text":"<p>NAV (Transition) is a structural operator that manages controlled regime handoffs between structural states. It guides nodes through transitions with minimal disruption by adjusting \u03b8 (phase), \u03bdf (structural frequency), and \u0394NFR (reorganization gradient).</p> <p>Core Principle: NAV implements regime navigation - a deliberate transition process that enables state changes while preserving structural integrity through smooth parameter adjustments.</p> <p>Nodal Equation Context: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n\nWhen NAV is applied:\n- \u03b8 adjusted based on regime (phase shift)\n- \u03bdf scaled for stability (regime-dependent)\n- \u0394NFR reduced for smooth transition\n- EPI preserved through controlled evolution\n</code></pre></p> <p>TNFR.pdf Reference: See \u00a72.3.11 for canonical transition logic and regime-specific transformations.</p>"},{"location":"operators/NAV_GUIDE/#canonical-sequences","title":"Canonical Sequences","text":"<p>NAV acts as a bridge operator enabling controlled state changes between structural regimes. From TNFR physics, NAV can operate after any operator that establishes a valid structural state with defined (\u03b8, \u03bdf, \u0394NFR).</p>"},{"location":"operators/NAV_GUIDE/#common-patterns","title":"Common Patterns","text":"Sequence Purpose Notes <code>SHA \u2192 AL</code> Reactivation from latency Direct reactivation, AL clears latency <code>IL \u2192 NAV \u2192 OZ</code> Stable to exploration NAV reduces \u0394NFR before OZ destabilization <code>AL \u2192 NAV \u2192 IL</code> Activation to stabilization Bootstrap completion pattern <code>RA \u2192 NAV \u2192 IL</code> Resonance to stabilization Transition from propagation to stable state <code>EN \u2192 NAV \u2192 IL</code> Reception to stabilization Integrate then stabilize <code>THOL \u2192 NAV \u2192 RA</code> Emergence to propagation Self-organization followed by transition <code>UM \u2192 NAV \u2192 RA</code> Coupling to propagation Network synchronization to resonance <code>OZ \u2192 IL \u2192 NAV</code> Controlled destabilization Stabilize before transitioning"},{"location":"operators/NAV_GUIDE/#sequence-explanations","title":"Sequence Explanations","text":""},{"location":"operators/NAV_GUIDE/#bootstrap-completion-al-nav-il","title":"Bootstrap Completion: <code>AL \u2192 NAV \u2192 IL</code>","text":"<p>Use Case: Initialize and stabilize a new pattern - AL (Emission): Creates initial EPI from vacuum (\u03bdf increases) - NAV (Transition): Adjusts phase and frequency for stability - IL (Coherence): Stabilizes the pattern (reduces \u0394NFR)</p> <p>Expected Telemetry: <pre><code>Post-AL:  EPI \u2248 0.3, \u03bdf \u2248 1.0, \u0394NFR \u2248 0.5\nPost-NAV: EPI \u2248 0.3, \u03bdf \u2248 1.0, \u0394NFR \u2248 0.4 (20% reduction)\nPost-IL:  EPI \u2248 0.3, \u03bdf \u2248 1.0, \u0394NFR \u2248 0.1 (stabilized)\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#latency-reactivation-sha-al","title":"Latency Reactivation: <code>SHA \u2192 AL</code>","text":"<p>Use Case: Wake a node from silence/latency - SHA (Silence): Node enters latent state (\u03bdf reduced, latent=True) - AL (Emission): Direct reactivation with pattern emission and latency clearing</p> <p>Expected Telemetry: <pre><code>Post-SHA: \u03bdf \u2248 0.85, latent=True, EPI preserved\nPost-AL:  \u03bdf \u2248 0.85+, latent=False, EPI actively evolving\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#exploration-transition-il-nav-oz","title":"Exploration Transition: <code>IL \u2192 NAV \u2192 OZ</code>","text":"<p>Use Case: Move from stable state to exploratory regime - IL (Coherence): Establishes stable baseline (\u0394NFR reduced) - NAV (Transition): Prepares for instability (\u0394NFR further reduced) - OZ (Dissonance): Introduces controlled destabilization</p> <p>Why this order matters: NAV after IL ensures \u0394NFR is low before OZ increases it, providing smoother dynamics.</p> <p>Expected Telemetry: <pre><code>Post-IL:  \u0394NFR \u2248 0.2, C(t) \u2248 0.75\nPost-NAV: \u0394NFR \u2248 0.16 (20% reduction), stable base\nPost-OZ:  \u0394NFR \u2248 0.5+ (controlled increase for exploration)\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#anti-patterns","title":"Anti-Patterns","text":"<p>These sequences may indicate design issues:</p>"},{"location":"operators/NAV_GUIDE/#nav-nav-redundant-transition","title":"\u274c NAV \u2192 NAV (Redundant Transition)","text":"<p>Problem: Multiple transitions without intermediate operations Why Problematic: No structural change between NAV applications - wasteful Fix: Add meaningful operator between NAV calls (IL, THOL, etc.)</p> <pre><code># Avoid\nrun_sequence(G, node, [Transition(), Transition()])\n\n# Better\nrun_sequence(G, node, [Transition(), Coherence(), Transition()])\n</code></pre>"},{"location":"operators/NAV_GUIDE/#oz-nav-without-stabilization","title":"\u274c OZ \u2192 NAV without stabilization","text":"<p>Problem: Attempting transition immediately after destabilization Why Problematic: High \u0394NFR makes transition unpredictable Fix: Apply IL (Coherence) after OZ to reduce \u0394NFR before NAV</p> <pre><code># Avoid\nrun_sequence(G, node, [Dissonance(), Transition()])\n\n# Better\nrun_sequence(G, node, [Dissonance(), Coherence(), Transition()])\n</code></pre>"},{"location":"operators/NAV_GUIDE/#nav-from-deep-latency-epi-005-without-al","title":"\u274c NAV from Deep Latency (EPI &lt; 0.05) without AL","text":"<p>Problem: Attempting transition when node has minimal structure Why Problematic: EPI \u2248 0 means \u2202EPI/\u2202t \u2248 0 regardless of NAV adjustments Fix: Use AL (Emission) to build structure first</p> <pre><code># Avoid when EPI is very low\nG.nodes[node][\"EPI\"] = 0.02\nrun_sequence(G, node, [Transition()])\n\n# Better\nrun_sequence(G, node, [Emission(), Transition()])\n</code></pre>"},{"location":"operators/NAV_GUIDE/#nav-sha-contradictory-intent","title":"\u274c NAV \u2192 SHA (Contradictory Intent)","text":"<p>Problem: Transitioning then immediately silencing Why Problematic: Contradictory - why transition if pausing immediately? Fix: Rethink sequence intent</p> <pre><code># Avoid\nrun_sequence(G, node, [Transition(), Silence()])\n\n# Better alternatives:\n# Option 1: Just silence\nrun_sequence(G, node, [Silence()])\n\n# Option 2: Transition, do something, then silence\nrun_sequence(G, node, [Transition(), Resonance(), Coherence(), Silence()])\n</code></pre>"},{"location":"operators/NAV_GUIDE/#troubleshooting","title":"Troubleshooting","text":""},{"location":"operators/NAV_GUIDE/#operatorpreconditionerror-f-too-low","title":"\"OperatorPreconditionError: \u03bdf too low\"","text":"<p>Symptom: NAV fails with \u03bdf below minimum threshold (default 0.01)</p> <p>Cause: Node lacks sufficient reorganization capacity</p> <p>Solution: 1. Check current \u03bdf: <code>vf = get_attr(G.nodes[node], ALIAS_VF, 0.0)</code> 2. If \u03bdf &lt; 0.01, apply AL (Emission) to increase it 3. Wait for \u0394NFR-driven \u03bdf increase (natural dynamics)</p> <p>Code Example: <pre><code>from tnfr.alias import get_attr\nfrom tnfr.constants.aliases import ALIAS_VF\nfrom tnfr.operators.definitions import Emission, Transition\n\nvf = get_attr(G.nodes[node], ALIAS_VF, 0.0)\nif vf &lt; 0.01:\n    run_sequence(G, node, [Emission(), Transition()])\nelse:\n    run_sequence(G, node, [Transition()])\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#epi-drifts-significantly-after-nav","title":"\"EPI drifts significantly after NAV\"","text":"<p>Symptom: EPI changes more than expected (\u0394 &gt; 0.1) after NAV</p> <p>Cause: \u0394NFR was too high before transition (unstable starting state)</p> <p>Expected: NAV should NOT directly change EPI - it modifies \u03b8, \u03bdf, \u0394NFR</p> <p>Diagnosis: <pre><code>from tnfr.alias import get_attr\nfrom tnfr.constants.aliases import ALIAS_DNFR, ALIAS_EPI\n\nepi_before = get_attr(G.nodes[node], ALIAS_EPI, 0.0)\ndnfr_before = get_attr(G.nodes[node], ALIAS_DNFR, 0.0)\n\n# \u0394NFR should be &lt; 1.0 for stable transition\nif dnfr_before &gt; 1.0:\n    print(f\"Warning: High \u0394NFR ({dnfr_before:.3f}) - stabilize first!\")\n</code></pre></p> <p>Solution: 1. Apply IL (Coherence) before NAV to reduce \u0394NFR 2. Verify stable starting state: \u0394NFR &lt; 1.0, C(t) &gt; 0.5</p> <p>Code Example: <pre><code>from tnfr.operators.definitions import Coherence, Transition\n\ndnfr = get_attr(G.nodes[node], ALIAS_DNFR, 0.0)\nif dnfr &gt; 1.0:\n    run_sequence(G, node, [Coherence(), Transition()])\nelse:\n    run_sequence(G, node, [Transition()])\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#nav-from-sha-doesnt-clear-latency","title":"\"NAV from SHA doesn't clear latency\"","text":"<p>Symptom: After SHA \u2192 NAV, node still has <code>latent=True</code> flag</p> <p>Cause: NAV doesn't clear latency - AL does</p> <p>Solution: Use SHA \u2192 AL for reactivation</p> <p>Code Example: <pre><code>from tnfr.operators.definitions import Silence, Emission\n\n# Enter latency\nrun_sequence(G, node, [Silence()])\nassert G.nodes[node].get(\"latent\", False) == True\n\n# Reactivate with AL\nrun_sequence(G, node, [Emission()])\nassert G.nodes[node].get(\"latent\", False) == False\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#phase-unchanged-after-nav","title":"\"Phase \u03b8 unchanged after NAV\"","text":"<p>Symptom: \u03b8 value identical before and after NAV application</p> <p>Cause: Possible implementation issue</p> <p>Expected: NAV always shifts \u03b8 (regime-dependent: 0.1, 0.15, or 0.2 rad)</p> <p>Diagnosis: <pre><code>from tnfr.constants.aliases import ALIAS_THETA\n\ntheta_before = get_attr(G.nodes[node], ALIAS_THETA, 0.0)\nrun_sequence(G, node, [Transition()])\ntheta_after = get_attr(G.nodes[node], ALIAS_THETA, 0.0)\n\nprint(f\"\u0394\u03b8 = {theta_after - theta_before:.3f} rad\")\n# Should be non-zero (typically 0.1-0.2 rad)\n</code></pre></p> <p>Solution: Check telemetry: <pre><code>transitions = G.graph.get(\"_nav_transitions\", [])\nif transitions:\n    print(transitions[-1])  # Check phase_shift value\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#usage-examples","title":"Usage Examples","text":""},{"location":"operators/NAV_GUIDE/#example-1-reactivation-from-silence","title":"Example 1: Reactivation from Silence","text":"<p>Scenario: Node enters latency via SHA, reactivated via AL</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Silence, Emission\nfrom tnfr.alias import get_attr\nfrom tnfr.constants.aliases import ALIAS_VF\n\n# Create node and enter silence\nG, node = create_nfr(\"sleeping\", epi=0.3, vf=1.0)\nrun_sequence(G, node, [Silence()])\n\n# Verify latency\nassert G.nodes[node].get(\"latent\", False) == True\nvf_latent = get_attr(G.nodes[node], ALIAS_VF, 0.0)\nprint(f\"After SHA: \u03bdf={vf_latent:.3f}, latent=True\")\n\n# Reactivation via AL\nrun_sequence(G, node, [Emission()])\n\n# Verify reactivation\nassert not G.nodes[node].get(\"latent\", False)\nvf_active = get_attr(G.nodes[node], ALIAS_VF, 0.0)\nprint(f\"After AL: \u03bdf={vf_active:.3f}, latent=False\")\n</code></pre> <p>Expected Output: <pre><code>After SHA: \u03bdf=0.850, latent=True\nAfter AL: \u03bdf=0.850, latent=False\n</code></pre></p>"},{"location":"operators/NAV_GUIDE/#example-2-stable-to-exploratory-transition","title":"Example 2: Stable to Exploratory Transition","text":"<p>Scenario: Move from stable equilibrium to exploratory regime</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Coherence, Transition, Dissonance\nfrom tnfr.alias import get_attr\nfrom tnfr.constants.aliases import ALIAS_DNFR\n\n# Create stable node\nG, node = create_nfr(\"stable\", epi=0.6, vf=1.0)\n\n# Run complete sequence: stabilize \u2192 transition \u2192 explore\nrun_sequence(G, node, [Coherence(), Transition(), Dissonance()])\n\n# Check final state\ndnfr_final = get_attr(G.nodes[node], ALIAS_DNFR, 0.0)\nprint(f\"Final \u0394NFR: {dnfr_final:.3f}\")\n</code></pre>"},{"location":"operators/NAV_GUIDE/#example-3-resonance-to-stabilization","title":"Example 3: Resonance to Stabilization","text":"<p>Scenario: Propagated pattern ready for stabilization</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Resonance, Transition, Coherence\nfrom tnfr.metrics.coherence import compute_coherence\n\n# Create resonant node\nG, node = create_nfr(\"resonant\", epi=0.7, vf=1.2)\n\n# Run complete sequence: propagate \u2192 transition \u2192 stabilize\nC_before = compute_coherence(G)\nrun_sequence(G, node, [Resonance(), Transition(), Coherence()])\nC_after = compute_coherence(G)\n\nprint(f\"Coherence: {C_before:.3f} \u2192 {C_after:.3f}\")\n</code></pre>"},{"location":"operators/NAV_GUIDE/#example-4-regime-specific-telemetry-tracking","title":"Example 4: Regime-Specific Telemetry Tracking","text":"<p>Scenario: Monitor NAV transformations across different regimes</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Transition\nfrom tnfr.alias import get_attr\nfrom tnfr.constants.aliases import ALIAS_THETA\n\n# Enable telemetry\nG.graph[\"_nav_transitions\"] = []\n\n# Test 1: Latent \u2192 Active\nG1, n1 = create_nfr(\"latent_node\", epi=0.2, vf=0.03)\nG1.nodes[n1][\"latent\"] = True\nrun_sequence(G1, n1, [Transition()])\n\n# Test 2: Active \u2192 Active (standard)\nG2, n2 = create_nfr(\"active_node\", epi=0.4, vf=0.6)\nrun_sequence(G2, n2, [Transition()])\n\n# Test 3: Resonant \u2192 Active\nG3, n3 = create_nfr(\"resonant_node\", epi=0.8, vf=1.5)\nrun_sequence(G3, n3, [Transition()])\n\n# Analyze telemetry\nfor i, (G, n) in enumerate([(G1, n1), (G2, n2), (G3, n3)], 1):\n    transition = G.graph[\"_nav_transitions\"][-1]\n    print(f\"\\nTest {i}: {transition['regime_origin']} regime\")\n    print(f\"  \u03bdf: {transition['vf_before']:.3f} \u2192 {transition['vf_after']:.3f}\")\n    print(f\"  \u03b8: {transition['theta_before']:.3f} \u2192 {transition['theta_after']:.3f}\")\n    print(f\"  \u0394NFR: {transition['dnfr_before']:.3f} \u2192 {transition['dnfr_after']:.3f}\")\n</code></pre>"},{"location":"operators/NAV_GUIDE/#example-5-complete-bootstrap-sequence","title":"Example 5: Complete Bootstrap Sequence","text":"<p>Scenario: Initialize, stabilize, and prepare for propagation</p> <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators.definitions import Emission, Transition, Coherence, Resonance\n\n# Create fresh node\nG, node = create_nfr(\"bootstrap\", epi=0.0, vf=1.0)\n\n# Complete bootstrap: emit \u2192 transition \u2192 stabilize \u2192 propagate\nrun_sequence(G, node, [\n    Emission(),      # AL: Create initial structure\n    Transition(),    # NAV: Adjust for stability\n    Coherence(),     # IL: Stabilize pattern\n    Resonance()      # RA: Ready for propagation\n])\n\nprint(\"Bootstrap complete\")\n</code></pre>"},{"location":"operators/NAV_GUIDE/#configuration-parameters","title":"Configuration Parameters","text":"<p>NAV behavior can be customized via graph-level configuration:</p> Parameter Default Type Description <code>NAV_MIN_VF</code> 0.01 float Minimum structural frequency for valid transition <code>NAV_MAX_DNFR</code> 1.0 float Maximum \u0394NFR for stable transition (warning threshold) <code>MAX_SILENCE_DURATION</code> inf float Max silence duration (seconds) before warning on reactivation <code>VALIDATE_PRECONDITIONS</code> False bool Enable operator precondition validation <code>COLLECT_OPERATOR_METRICS</code> False bool Enable detailed operator metrics collection <code>VALIDATE_NODAL_EQUATION</code> False bool Validate nodal equation compliance post-operator <code>NODAL_EQUATION_STRICT</code> False bool Strict mode for nodal equation validation (raises on violation)"},{"location":"operators/NAV_GUIDE/#configuration-examples","title":"Configuration Examples","text":"<pre><code># Example 1: Strict precondition validation\nG.graph[\"VALIDATE_PRECONDITIONS\"] = True\nG.graph[\"NAV_MIN_VF\"] = 0.05  # Stricter minimum\nrun_sequence(G, node, [Transition()])  # Will validate \u03bdf &gt;= 0.05\n\n# Example 2: Enable comprehensive telemetry\nG.graph[\"COLLECT_OPERATOR_METRICS\"] = True\nrun_sequence(G, node, [Transition()])\nmetrics = G.graph[\"operator_metrics\"][-1]\nprint(f\"Operator: {metrics['operator']}\")\nprint(f\"Duration: {metrics['duration']:.4f}s\")\n\n# Example 3: Validate nodal equation compliance\nG.graph[\"VALIDATE_NODAL_EQUATION\"] = True\nrun_sequence(G, node, [Transition()])\n\n# Example 4: Control silence reactivation behavior\nG.graph[\"MAX_SILENCE_DURATION\"] = 300.0  # 5 minutes\nrun_sequence(G, node, [Silence()])\n# ... wait &gt;5 minutes ...\nrun_sequence(G, node, [Transition()])  # Warns about extended silence\n</code></pre>"},{"location":"operators/NAV_GUIDE/#regime-specific-behavior","title":"Regime-Specific Behavior","text":"<p>NAV automatically detects the node's current regime and applies appropriate transformations:</p>"},{"location":"operators/NAV_GUIDE/#latent-regime-f-005-or-latent-flag","title":"Latent Regime (\u03bdf &lt; 0.05 OR latent flag)","text":"<p>Detection: Node in minimal reorganization state or explicitly marked latent</p> <p>Transformations: - \u03bdf \u00d7 1.2 (20% increase for gradual reactivation) - \u03b8 + 0.1 rad (small phase shift) - \u0394NFR \u00d7 0.7 (30% reduction for smooth transition)</p> <p>Use Case: SHA \u2192 NAV flow, waking dormant patterns</p> <p>Physics: Gentle reactivation prevents shock to fragile structure</p>"},{"location":"operators/NAV_GUIDE/#active-regime-baseline-state","title":"Active Regime (baseline state)","text":"<p>Detection: Default classification when not latent or resonant</p> <p>Transformations: - \u03bdf \u00d7 vf_factor (default 1.0, configurable) - \u03b8 + 0.2 rad (standard phase shift) - \u0394NFR \u00d7 0.8 (20% reduction)</p> <p>Use Case: Most common transitions, standard regime navigation</p> <p>Physics: Moderate adjustments for typical structural evolution</p>"},{"location":"operators/NAV_GUIDE/#resonant-regime-epi-05-and-f-08","title":"Resonant Regime (EPI &gt; 0.5 AND \u03bdf &gt; 0.8)","text":"<p>Detection: High-energy state with strong form and high frequency</p> <p>Transformations: - \u03bdf \u00d7 0.95 (5% reduction for stability) - \u03b8 + 0.15 rad (careful phase shift) - \u0394NFR \u00d7 0.9 (10% reduction, gentle)</p> <p>Use Case: Managing high-coherence states, preventing fragmentation</p> <p>Physics: Cautious navigation to avoid destabilizing resonant structure</p>"},{"location":"operators/NAV_GUIDE/#best-practices","title":"Best Practices","text":""},{"location":"operators/NAV_GUIDE/#1-always-check-f-before-nav","title":"1. Always Check \u03bdf Before NAV","text":"<pre><code>vf = get_attr(G.nodes[node], ALIAS_VF, 0.0)\nif vf &lt; 0.01:\n    run_sequence(G, node, [Emission(), Transition()])\nelse:\n    run_sequence(G, node, [Transition()])\n</code></pre>"},{"location":"operators/NAV_GUIDE/#2-stabilize-high-nfr-before-transition","title":"2. Stabilize High \u0394NFR Before Transition","text":"<pre><code>dnfr = get_attr(G.nodes[node], ALIAS_DNFR, 0.0)\nif dnfr &gt; 1.0:\n    run_sequence(G, node, [Coherence(), Transition()])\nelse:\n    run_sequence(G, node, [Transition()])\n</code></pre>"},{"location":"operators/NAV_GUIDE/#3-use-telemetry-for-debugging","title":"3. Use Telemetry for Debugging","text":"<pre><code>G.graph[\"_nav_transitions\"] = []\nrun_sequence(G, node, [Transition()])\ntransition_data = G.graph[\"_nav_transitions\"][-1]\nprint(f\"Regime: {transition_data['regime_origin']}\")\nprint(f\"Phase shift: {transition_data['phase_shift']:.3f} rad\")\n</code></pre>"},{"location":"operators/NAV_GUIDE/#4-enable-precondition-checks-in-development","title":"4. Enable Precondition Checks in Development","text":"<pre><code># During development/testing\nG.graph[\"VALIDATE_PRECONDITIONS\"] = True\nG.graph[\"VALIDATE_NODAL_EQUATION\"] = True\n\n# In production (after validation)\nG.graph[\"VALIDATE_PRECONDITIONS\"] = False  # Performance optimization\n</code></pre>"},{"location":"operators/NAV_GUIDE/#related-documentation","title":"Related Documentation","text":"<ul> <li>UNIFIED_GRAMMAR_RULES.md - Complete grammar derivations (U1-U4)</li> <li>GLYPH_SEQUENCES_GUIDE.md - Multi-domain sequence patterns</li> <li>Operator Reference - All 13 canonical operators</li> <li>GLOSSARY.md - TNFR terminology and definitions</li> <li>SHA_CLINICAL_APPLICATIONS.md - Silence operator guide</li> </ul>"},{"location":"operators/NAV_GUIDE/#what-nav-does-from-tnfr-physics","title":"What NAV Does (From TNFR Physics)","text":""},{"location":"operators/NAV_GUIDE/#nodal-equation-basis","title":"Nodal Equation Basis","text":"<p>From \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t), NAV performs regime transitions by adjusting:</p> <ul> <li>\u03b8 (phase): Shifts structural timing by regime-specific amount (0.1-0.2 rad)</li> <li>\u03bdf (frequency): Scales reorganization rate (0.95-1.2\u00d7 depending on regime)</li> <li>\u0394NFR (gradient): Reduces structural pressure (0.7-0.9\u00d7 for smooth transition)</li> </ul> <p>Physical Effect: NAV modulates the rate and direction of structural evolution without directly changing EPI.</p>"},{"location":"operators/NAV_GUIDE/#physics-requirements","title":"Physics Requirements","text":"<p>For NAV to function, node must have: 1. Defined \u03b8: Phase value to shift 2. Defined \u03bdf: Frequency to scale 3. Defined \u0394NFR: Gradient to reduce</p> <p>Any operator that leaves node with these three properties enables NAV according to the nodal equation.</p>"},{"location":"operators/NAV_GUIDE/#references","title":"References","text":"<ul> <li>TNFR.pdf \u00a72.3.11: Canonical transition logic and regime-specific transformations</li> <li>AGENTS.md Invariant #2: No arbitrary choices - all decisions traceable to physics</li> <li>AGENTS.md Invariant #12: Documentation completeness requirement</li> <li>src/tnfr/operators/definitions.py: <code>Transition</code> class implementation (lines 3688-4045)</li> <li>Unified Grammar U1-U4: Physics-based operator sequence constraints</li> </ul> <p>Version: 2.0 Last Updated: 2025-11-09 Status: \u2705 CANONICAL - NAV operator guide based on TNFR physics, no arbitrary restrictions</p>"},{"location":"security/codeql/","title":"CodeQL Analysis Workflow","text":"<p>The CodeQL workflow analyzes this repository for security vulnerabilities in the TNFR engine's Python code. The automation runs on GitHub Actions and is defined in <code>.github/workflows/codeql-analysis.yml</code>.</p>"},{"location":"security/codeql/#when-it-runs","title":"When it runs","text":"<p>The analysis triggers automatically in the following situations:</p> <ul> <li>Pushes to the <code>main</code> or <code>master</code> branches.</li> <li>Pull requests that target <code>main</code> or <code>master</code>.</li> <li>A scheduled weekly execution (<code>cron</code>).</li> </ul> <p>You can also start the workflow manually from the Actions tab by selecting CodeQL Analysis and clicking Run workflow.</p>"},{"location":"security/codeql/#what-the-workflow-does","title":"What the workflow does","text":"<ol> <li>Checks out the repository.</li> <li>Initializes CodeQL for the Python language using the configuration in <code>.codeql/codeql-config.yml</code>.</li> <li>Runs the <code>autobuild</code> step (no additional configuration is required for this project).</li> <li>Analyzes the code and generates a SARIF report.</li> <li>Uploads the results to GitHub Advanced Security and stores them as a run artifact.</li> </ol>"},{"location":"security/codeql/#configuration-and-false-positive-suppression","title":"Configuration and false positive suppression","text":"<p>The analysis is configured via <code>.codeql/codeql-config.yml</code>, which includes query filters to suppress known false positives:</p> <ul> <li>Protocol method stubs: Python Protocol classes (PEP 544) use ellipsis (<code>...</code>) as method body to define structural contracts for type checking. These are valid typing patterns, not ineffectual statements.</li> <li>@overload signatures: Function overloading (PEP 484) requires signatures with ellipsis body to define type variants before the actual implementation.</li> <li>Test isolation patterns: Test files use module path checking for test isolation, not URL validation.</li> </ul> <p>These suppressions ensure that CodeQL focuses on genuine security issues while respecting Python's type system conventions.</p>"},{"location":"security/codeql/#how-to-review-findings","title":"How to review findings","text":"<ol> <li>Open the repository's Security tab in GitHub.</li> <li>Select Code scanning alerts to see the complete list of findings. You can filter by status, severity, or tool.</li> <li>Open an alert to review the file, precise location, and trace that triggered the detection.</li> <li>Mark the alert as resolved or <code>won't fix</code> as appropriate, documenting the decision in a comment.</li> </ol>"},{"location":"security/codeql/#github-security-dashboard","title":"GitHub Security dashboard","text":"<ul> <li>In Security &gt; Overview you will find aggregated metrics, trends, and shortcuts to the most relevant alerts.</li> <li>The execution history for CodeQL lives under Security &gt; Code scanning. Each run links to the uploaded artifact and processed SARIF.</li> <li>To download the results artifact, open the run in Actions, expand the Analyze job, and download <code>codeql-python-results</code>.</li> </ul> <p>Keep the workflow active and review alerts regularly to preserve the structural coherence and security of the TNFR engine.</p>"},{"location":"security/dependabot/","title":"Dependabot Pull Request Flow","text":"<p>Dependabot keeps the TNFR engine aligned with secure dependency and workflow baselines. This document describes how the automation is configured and how to review the pull requests it opens without compromising the canonical TNFR invariants.</p>"},{"location":"security/dependabot/#automation-settings","title":"Automation settings","text":"<ul> <li>Ecosystems \u2014 Python packages resolved from <code>pyproject.toml</code> via the   <code>pip</code> ecosystem and the GitHub Actions workflows under <code>.github/workflows</code>.</li> <li>Frequency \u2014 Weekly on Mondays at 05:00 UTC so dependency bumps can be   triaged during the standard maintenance window shared with the other security   automations.</li> <li>Routing \u2014 Dependabot assigns the <code>dependencies</code> label and requests review   from <code>@fermga</code> to match the maintainer responsibilities documented in   <code>meta.json</code> and the contribution guide.</li> </ul>"},{"location":"security/dependabot/#review-checklist","title":"Review checklist","text":"<ol> <li>Confirm scope \u2014 Ensure the diff only touches dependency manifests or the    GitHub Actions workflow files declared above. If the PR includes unrelated    changes, convert it to a draft and investigate before merging.</li> <li>Read the advisory \u2014 Dependabot links advisories in the PR description.    Review the impact on the structural operators affected by the dependency and    confirm the proposed version restores or preserves coherence metrics.</li> <li>Run the quality gate \u2014 Execute <code>./scripts/run_tests.sh</code> locally. The    script exercises typing, linting, and the test suite, ensuring the update    does not degrade <code>C(t)</code>, phase synchrony, or \u0394NFR expectations.</li> <li>Inspect telemetry hooks \u2014 For Python dependency bumps, check whether any    logged metrics, cache interfaces, or serialization formats changed. Update    downstream integration notes if the new version alters how telemetry is    emitted.</li> <li>Validate workflow upgrades \u2014 For GitHub Actions updates, review the    upstream changelog. Confirm that permissions, caching keys, and Python    versions remain consistent with the repository\u2019s security posture.</li> <li>Document structural effects \u2014 When approving, leave a short comment    summarizing the expected influence on the relevant operators (e.g., improved    <code>resonance</code> stability after a TLS library upgrade).</li> </ol>"},{"location":"security/dependabot/#merge-policy","title":"Merge policy","text":"<ul> <li>Merge only after the full GitHub Actions suite passes so CI logs capture the   post-upgrade telemetry.</li> <li>Prefer squash merges so you can edit the final commit message to follow the   <code>AGENT_COMMIT_TEMPLATE</code> before completing the merge.</li> <li>If a dependency cannot be updated immediately, open a follow-up issue that   references the advisory IDs, the blocked operator(s), and the mitigation plan   to track residual risk.</li> </ul> <p>Adhering to this flow keeps automated dependency maintenance compatible with the TNFR commitment to operational coherence and reproducible structural interventions.</p>"},{"location":"security/dependency-auditing/","title":"Dependency Vulnerability Auditing","text":"<p>The dependency audit workflow keeps the TNFR engine aligned with the security posture required to preserve structural coherence. The automation lives in <code>.github/workflows/pip-audit.yml</code> and relies on <code>pip-audit</code> to inspect the Python packages that back the engine.</p>"},{"location":"security/dependency-auditing/#when-the-audit-runs","title":"When the audit runs","text":"<p>The workflow triggers automatically on:</p> <ul> <li>Pushes to the <code>main</code> or <code>master</code> branches.</li> <li>Pull requests that target <code>main</code> or <code>master</code>.</li> <li>A scheduled weekly execution every Monday at 05:00 UTC.</li> </ul> <p>You can also start the run manually from the Actions tab by selecting Dependency Vulnerability Audit and clicking Run workflow.</p>"},{"location":"security/dependency-auditing/#what-the-workflow-validates","title":"What the workflow validates","text":"<ol> <li>Checks out the repository and sets up Python 3.11.</li> <li>Installs the project with the full extra set via <code>pip install .[all]</code> to recreate a clean environment.</li> <li>Determines the active site-packages directory and runs <code>pipx run pip-audit --progress-spinner off</code> restricted to that path.</li> <li>Stores the JSON results (<code>pip-audit.json</code>) as the <code>pip-audit-report</code> artifact.</li> <li>Fails the job whenever <code>pip-audit</code> reports unresolved vulnerabilities.</li> </ol> <p>Because the audit step is allowed to complete even when it finds issues, the artifact is always generated for review before the workflow reports a failure.</p>"},{"location":"security/dependency-auditing/#interpreting-the-results","title":"Interpreting the results","text":"<ol> <li>Open the failing workflow run in Actions and download the <code>pip-audit-report</code> artifact.</li> <li>The archive contains <code>pip-audit.json</code> with the following schema for each dependency:</li> <li><code>name</code>: the audited package name.</li> <li><code>version</code>: the installed version under analysis.</li> <li><code>vulns</code>: a list of vulnerability objects with fields:<ul> <li><code>id</code>: canonical identifier (e.g., GHSA, CVE).</li> <li><code>fix_versions</code>: secure versions published upstream.</li> <li><code>description</code>: human-readable summary supplied by the advisory feed.</li> </ul> </li> <li>Cross-reference multiple entries to check whether the issue stems from a direct dependency or a transitive package.</li> <li>Prioritize remediation by severity (check the advisory linked in <code>id</code>) and by the operator it might compromise (e.g., <code>resonance</code>, <code>coherence</code>).</li> </ol> <p>For quick triage you can render the JSON as columns locally with <code>pip-audit --progress-spinner off --format markdown --input pip-audit.json</code>.</p>"},{"location":"security/dependency-auditing/#remediation-workflow","title":"Remediation workflow","text":"<ol> <li>Validate whether an updated version already exists in the <code>fix_versions</code> list. If yes, bump the dependency in <code>pyproject.toml</code> (or its extras) and regenerate the lock/test baselines as needed.</li> <li>If no secure release exists, evaluate temporary mitigations:</li> <li>Vendor a patched fork with a short-lived extra.</li> <li>Gate the vulnerable capability behind stricter runtime checks to reduce attack surface.</li> <li>Remove or replace the dependency if it is not essential for TNFR coherence.</li> <li>Document every mitigation or deferral in the pull request description, noting the advisory IDs and the structural rationale.</li> <li>Run the full test suite to ensure the remediation maintains <code>C(t)</code> and preserves operator closure.</li> <li>Re-run <code>pip-audit</code> locally (<code>pipx run pip-audit --progress-spinner off</code>) before opening the pull request to confirm the vulnerability set is clean.</li> </ol>"},{"location":"security/dependency-auditing/#handling-exceptions","title":"Handling exceptions","text":"<p>Only suppress an advisory when:</p> <ul> <li>There is no upstream fix and the affected surface cannot be removed without breaking TNFR invariants.</li> <li>You can demonstrate compensating controls (e.g., isolation, additional validation layers) that contain the risk.</li> </ul> <p>In those situations, document the ignored advisory ID, justification, and planned follow-up in the PR to maintain traceability. Revisit every exception on a regular cadence until a permanent fix is deployed.</p>"},{"location":"security/monitoring/","title":"Security monitoring dashboard","text":"<p>The TNFR engine security discipline aggregates automated signals to catch regressions, vulnerabilities, and deviations in the structural coherence of the codebase. This dashboard distills the artifacts generated by CodeQL, Dependabot, <code>pip-audit</code>, and SAST checks (Bandit and Semgrep) and sets a shared review cadence for the team.</p>"},{"location":"security/monitoring/#dashboard-sources","title":"Dashboard sources","text":"Source Location Primary output Purpose CodeQL <code>.github/workflows/codeql-analysis.yml</code> SARIF (<code>codeql-*-results</code>) Tracks insecure code alerts and patterns that reduce <code>C(t)</code> in critical nodes. Dependabot <code>/.github/dependabot.yml</code> Native GitHub alerts Detects dependency misalignment and dissonance events triggered by known CVEs. <code>pip-audit</code> <code>.github/workflows/pip-audit.yml</code> JSON (<code>pip-audit.json</code>) Evaluates vulnerabilities in installed packages and their impact on \u03bdf and the execution phase. Bandit + Semgrep <code>.github/workflows/sast-lint.yml</code> SARIF (<code>bandit.sarif</code>, <code>semgrep.sarif</code>) Identifies risk patterns and records containment decisions within TNFR operators. <p>Individual security workflows automatically upload their results to GitHub Security tab and as workflow artifacts for review.</p>"},{"location":"security/monitoring/#review-cadence","title":"Review cadence","text":"<ul> <li>Weekly (Mondays): Review security scan results from GitHub Security tab and workflow artifacts. This review aligns with the existing CodeQL (<code>03:00 UTC</code>) and <code>pip-audit</code> (<code>05:00 UTC</code>) cron schedules.</li> <li>After every critical alert: trigger a controlled dissonance session on the affected component, document the resolution, and update the <code>C(t)</code> and <code>Si</code> metrics when applicable.</li> <li>Monthly: audit the Dependabot configuration, SAST rule coverage, and the dashboard scope to uphold operator closure and fidelity to TNFR semantics.</li> </ul>"},{"location":"security/monitoring/#what-to-expect-in-workflow-artifacts","title":"What to expect in workflow artifacts","text":"<ol> <li>CodeQL: SARIF files in the <code>codeql-python-results</code> artifact with detailed security analysis</li> <li>Bandit + Semgrep: SARIF files (<code>bandit-sarif</code>, <code>semgrep-sarif</code>) uploaded to GitHub Security tab</li> <li>pip-audit: JSON report artifact (<code>pip-audit-report</code>) with dependency vulnerability details</li> <li>All results are accessible via GitHub Security tab and workflow run artifacts</li> </ol> <p>Security findings are automatically integrated into GitHub's native security alerts for centralized monitoring.</p>"},{"location":"theory/","title":"TNFR Theory Documentation","text":""},{"location":"theory/#navigation-guide","title":"Navigation Guide","text":"<p>This directory contains the complete theoretical foundation of TNFR (Resonant Fractal Nature Theory), from formal mathematics to computational validation.</p>"},{"location":"theory/#foundational-documents","title":"\ud83d\udcd0 Foundational Documents","text":""},{"location":"theory/#1-mathematical-foundations-start-here","title":"1. Mathematical Foundations \u2b50 START HERE","text":"<p>The canonical source for all TNFR mathematics</p> <ul> <li>Hilbert space H_NFR and Banach space B_EPI</li> <li>Coherence operator \u0108 (spectral theory, complete proofs)</li> <li>Frequency operator \u0134 and reorganization operator \u0394NFR</li> <li>Nodal equation derivation: <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code></li> <li>Implementation bridge (\u00a73.1.1): theory \u2192 code</li> </ul>"},{"location":"theory/#classical-mechanics-emergence-series-new","title":"\ud83c\udfaf Classical Mechanics Emergence Series \u2728 NEW","text":"<p>Demonstrates how observable classical physics emerges naturally from TNFR coherence dynamics.</p>"},{"location":"theory/#2-classical-mechanics-from-tnfr","title":"2. Classical Mechanics from TNFR","text":"<p>Complete derivation of Newton's laws from the nodal equation</p> <ul> <li>Emergence pathway: TNFR coherence \u2192 Observable physics</li> <li>Mass as inverse structural frequency: <code>m = 1/\u03bdf</code></li> <li>Force as coherence gradient: <code>F = -\u2207U(q)</code></li> <li>Low-dissonance limit (\u03b5 \u2192 0) yields deterministic trajectories</li> <li>Connection to Newtonian, Lagrangian, and Hamiltonian formulations</li> </ul> <p>Key Result: Newton's second law emerges as: <pre><code>m \u00b7 d\u00b2q/dt\u00b2 = -\u2207U(q)\n</code></pre> directly from <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code> when \u03b5 \u2192 0.</p>"},{"location":"theory/#3-euler-lagrange-correspondence","title":"3. Euler-Lagrange Correspondence","text":"<p>Variational mechanics from coherence optimization</p> <ul> <li>Action principle as coherence flow optimization</li> <li>Lagrangian <code>L = K - U</code> as net structural coherence</li> <li>Euler-Lagrange equations emerge from stationary coherence</li> <li>Complete mathematical proofs with regularity assumptions</li> <li>Connection to analytical mechanics</li> </ul> <p>Key Result: The action <code>S[q] = \u222bL dt</code> extremizes coherence flow through configuration space.</p>"},{"location":"theory/#4-numerical-validation","title":"4. Numerical Validation","text":"<p>Computational experiments confirming theoretical predictions</p> <ul> <li>Mass scaling validation: <code>m = 1/\u03bdf</code> across multiple systems</li> <li>Conservation law verification (energy, momentum, angular momentum)</li> <li>Bifurcation analysis and chaos detection</li> <li>Six canonical test cases with reproducible protocols</li> <li>Comparison: TNFR simulations vs. analytical solutions</li> </ul> <p>Validation Status: \u2705 All predictions confirmed with &lt; 0.1% error in conservative systems.</p>"},{"location":"theory/#interactive-theory-notebooks","title":"\ud83d\udcd3 Interactive Theory Notebooks","text":"<p>Hands-on exploration and visualization of TNFR concepts:</p> <ul> <li>01_structural_frequency_primer.ipynb \u2014 Understanding \u03bdf and Hz_str units</li> <li>02_phase_synchrony_lattices.ipynb \u2014 Phase dynamics in networks</li> <li>03_delta_nfr_gradient_fields.ipynb \u2014 Reorganization operators</li> <li>04_coherence_metrics_walkthrough.ipynb \u2014 C(t) and Si computation</li> <li>04_nfr_validator_and_metrics.ipynb \u2014 Validation tools</li> <li>05_sense_index_calibration.ipynb \u2014 Si interpretation</li> <li>06_recursivity_cascades.ipynb \u2014 Nested operator application</li> </ul>"},{"location":"theory/#learning-paths","title":"\ud83d\uddfa\ufe0f Learning Paths","text":""},{"location":"theory/#path-1-theory-first-comprehensive","title":"Path 1: Theory-First (Comprehensive)","text":"<p>Best for those with mathematical physics background</p> <ol> <li>Mathematical Foundations \u2014 Complete formalism</li> <li>Classical Mechanics from TNFR \u2014 Main derivation</li> <li>Euler-Lagrange Correspondence \u2014 Variational approach</li> <li>Numerical Validation \u2014 Computational confirmation</li> <li>Interactive notebooks \u2014 Visualization and exploration</li> </ol> <p>Time: 4-6 hours</p>"},{"location":"theory/#path-2-application-first-pragmatic","title":"Path 2: Application-First (Pragmatic)","text":"<p>Best for practitioners who want to use TNFR quickly</p> <ol> <li>Classical Mechanics from TNFR \u00a71-2 \u2014 Core concepts</li> <li>Numerical Validation \u00a72-4 \u2014 Example cases</li> <li>Interactive notebooks \u2014 Hands-on experimentation</li> <li>Mathematical Foundations \u2014 Deep dive when needed</li> </ol> <p>Time: 2-3 hours</p>"},{"location":"theory/#path-3-computational-first-engineers","title":"Path 3: Computational-First (Engineers)","text":"<p>Best for software engineers and computational scientists</p> <ol> <li>Numerical Validation \u2014 Start with code</li> <li>Classical Mechanics from TNFR \u2014 Understand what's being computed</li> <li>Interactive notebooks \u2014 Reproduce and modify examples</li> <li>Euler-Lagrange Correspondence \u2014 Mathematical depth</li> </ol> <p>Time: 3-4 hours</p>"},{"location":"theory/#cross-references","title":"\ud83d\udd17 Cross-References","text":""},{"location":"theory/#from-theory-to-practice","title":"From Theory to Practice","text":"<ul> <li>Mathematical Foundations \u2192 API Overview</li> <li>Classical Mechanics \u2192 Examples: Validation scripts</li> <li>Euler-Lagrange \u2192 Operators Guide</li> </ul>"},{"location":"theory/#related-documentation","title":"Related Documentation","text":"<ul> <li>TNFR Fundamental Concepts \u2014 Intuitive introduction</li> <li>GLOSSARY \u2014 Terminology reference</li> <li>AGENTS.md \u2014 Canonical invariants for AI agents</li> </ul>"},{"location":"theory/#document-status","title":"\ud83d\udccb Document Status","text":"Document Status Last Updated mathematical_foundations.md \u2705 Stable 2024 07_emergence_classical_mechanics.md \u2728 New 2024 08_classical_mechanics_euler_lagrange.md \u2728 New 2024 09_classical_mechanics_numerical_validation.md \u2728 New 2024 Interactive notebooks \u2705 Stable 2024"},{"location":"theory/#quick-answers","title":"\ud83d\udca1 Quick Answers","text":"<p>Q: Where do I find the complete TNFR mathematics? A: Mathematical Foundations \u2014 This is the single canonical source.</p> <p>Q: How does classical mechanics emerge from TNFR? A: Classical Mechanics from TNFR \u2014 Complete derivation showing direct emergence.</p> <p>Q: Are the theoretical predictions validated? A: Yes. Numerical Validation confirms all predictions with computational experiments.</p> <p>Q: Do I need to understand quantum mechanics or relativity? A: The classical mechanics emergence from TNFR is self-contained in the low-dissonance regime. You can understand observable deterministic physics through the direct TNFR \u2192 classical mechanics pathway developed in these documents.</p> <p>Q: What are Hz_str units? A: Structural hertz \u2014 the unit of structural frequency (\u03bdf). See Structural Frequency Primer.</p> <p>Ready to dive in? \u2192 Mathematical Foundations</p>"},{"location":"theory/01_structural_frequency_primer/","title":"Structural frequency primer","text":"In\u00a0[\u00a0]: Copied! <pre>from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY\nfrom tnfr.dynamics import set_delta_nfr_hook\nfrom tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence\n\nG, node = create_nfr(\"frequency-smoke\", epi=0.42, vf=1.8, theta=0.0)\ntrajectory: list[dict[str, float]] = []\nincrements = iter([0.035, 0.028, 0.024, 0.02, 0.018])\n\ndef scripted_delta(graph):\n    dnfr = next(increments, 0.015)\n    nd = graph.nodes[node]\n    vf_before = float(nd[VF_PRIMARY])\n    epi_before = float(nd[EPI_PRIMARY])\n    nd[DNFR_PRIMARY] = dnfr\n    nd[EPI_PRIMARY] = epi_before + vf_before * dnfr\n    nd[VF_PRIMARY] = vf_before + 0.05 * dnfr\n    trajectory.append(\n        {\n            \"\u03bdf_before\": round(vf_before, 6),\n            \"\u0394NFR\": round(dnfr, 6),\n            \"EPI\": round(nd[EPI_PRIMARY], 6),\n            \"\u2202EPI/\u2202t\": round(vf_before * dnfr, 6),\n            \"\u03bdf_after\": round(nd[VF_PRIMARY], 6),\n        }\n    )\n\nset_delta_nfr_hook(G, scripted_delta, note=\"structural frequency primer smoke\")\nrun_sequence(G, node, [Emission(), Reception(), Coherence(), Resonance(), Transition()])\n\ntrajectory\n</pre>  from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY from tnfr.dynamics import set_delta_nfr_hook from tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence  G, node = create_nfr(\"frequency-smoke\", epi=0.42, vf=1.8, theta=0.0) trajectory: list[dict[str, float]] = [] increments = iter([0.035, 0.028, 0.024, 0.02, 0.018])  def scripted_delta(graph):     dnfr = next(increments, 0.015)     nd = graph.nodes[node]     vf_before = float(nd[VF_PRIMARY])     epi_before = float(nd[EPI_PRIMARY])     nd[DNFR_PRIMARY] = dnfr     nd[EPI_PRIMARY] = epi_before + vf_before * dnfr     nd[VF_PRIMARY] = vf_before + 0.05 * dnfr     trajectory.append(         {             \"\u03bdf_before\": round(vf_before, 6),             \"\u0394NFR\": round(dnfr, 6),             \"EPI\": round(nd[EPI_PRIMARY], 6),             \"\u2202EPI/\u2202t\": round(vf_before * dnfr, 6),             \"\u03bdf_after\": round(nd[VF_PRIMARY], 6),         }     )  set_delta_nfr_hook(G, scripted_delta, note=\"structural frequency primer smoke\") run_sequence(G, node, [Emission(), Reception(), Coherence(), Resonance(), Transition()])  trajectory"},{"location":"theory/01_structural_frequency_primer/#structural-frequency-primer","title":"Structural frequency primer\u00b6","text":""},{"location":"theory/01_structural_frequency_primer/#objectives","title":"Objectives\u00b6","text":"<ul> <li>Characterise how the structural frequency \u03bdf amplifies \u0394NFR to evolve the Primary Information Structure (EPI).</li> <li>Show how deterministic \u0394NFR hooks orchestrate \u03bdf drift while respecting the nodal equation \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR.</li> <li>Provide a minimal trace that Phase-2 automation can reuse as a regression guard for frequency regulation.</li> </ul>"},{"location":"theory/01_structural_frequency_primer/#phase-2-dependencies","title":"Phase-2 dependencies\u00b6","text":"<ul> <li>Phase-2 integration notes \u2014 the primer mirrors the scripted hooks expected by the automated \u0394NFR orchestration pipeline.</li> <li>:mod:<code>tnfr.dynamics.adaptation</code> \u2014 \u03bdf adaptation rules remain the same once the Phase-2 controller swaps in its adaptive gains.</li> <li>:mod:<code>tnfr.structural</code> \u2014 operator sequencing is shared across the canonical demos and the Phase-2 integration plan.</li> </ul>"},{"location":"theory/01_structural_frequency_primer/#theoretical-exposition","title":"Theoretical exposition\u00b6","text":"<p>The nodal equation couples \u0394NFR with \u03bdf so that every glyph application scales reorganisations by the current structural frequency. Holding \u0394NFR constant while perturbing \u03bdf therefore generates measurable changes in \u2202EPI/\u2202t. The primer isolates this dependency: a scripted hook records \u03bdf before each glyph, applies \u0394NFR, and updates EPI by \u03bdf \u00b7 \u0394NFR so the trajectory remains canonical. Tracking the before/after \u03bdf pairs surfaces how even a small deterministic drift reshapes the coherence throughput.</p>"},{"location":"theory/01_structural_frequency_primer/#deterministic-smoke-check","title":"Deterministic smoke check\u00b6","text":"<p>The code cell below instantiates a node, installs a reproducible \u0394NFR hook, and fires the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition sequence. The hook captures \u03bdf prior to each glyph so we can assert that the EPI increment equals \u03bdf \u00b7 \u0394NFR at every step. The resulting timeline doubles as a CI smoke test: any future change that perturbs the \u03bdf multiplier or the hook contract will alter the recorded derivatives.</p>"},{"location":"theory/02_phase_synchrony_lattices/","title":"Phase synchrony lattices","text":"In\u00a0[\u00a0]: Copied! <pre>from statistics import mean\n\nfrom tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, THETA_PRIMARY, VF_PRIMARY\nfrom tnfr.dynamics import set_delta_nfr_hook\nfrom tnfr.observers import phase_sync\nfrom tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence\n\nG, anchor = create_nfr(\"lattice-anchor\", epi=0.35, vf=1.1, theta=0.1)\nneighbors: list[str] = []\nfor idx, offset in enumerate([0.55, -0.42, 0.23, -0.31], start=1):\n    _, node = create_nfr(f\"lattice-node-{idx}\", epi=0.28 + 0.02 * idx, vf=0.95 + 0.01 * idx, theta=offset, graph=G)\n    G.add_edge(anchor, node)\n    neighbors.append(node)\n\nbefore_phases = {n: round(float(G.nodes[n][THETA_PRIMARY]), 6) for n in [anchor, *neighbors]}\ninitial_sync = round(phase_sync(G), 6)\nsynchrony_trace: list[dict[str, float]] = []\n\n\ndef align_lattice(graph):\n    phases = [float(data[THETA_PRIMARY]) for _, data in graph.nodes(data=True)]\n    mean_phase = mean(phases)\n    for node_id, data in graph.nodes(data=True):\n        theta = float(data[THETA_PRIMARY])\n        offset = mean_phase - theta\n        data[DNFR_PRIMARY] = abs(offset) * 0.04\n        data[THETA_PRIMARY] = theta + 0.6 * offset\n        vf = float(data[VF_PRIMARY])\n        epi = float(data[EPI_PRIMARY])\n        data[EPI_PRIMARY] = epi + vf * data[DNFR_PRIMARY] * 0.5\n    synchrony_trace.append({\n        \"step\": len(synchrony_trace) + 1,\n        \"phase_sync\": round(phase_sync(graph), 6),\n    })\n\nset_delta_nfr_hook(G, align_lattice, note=\"phase lattice synchrony smoke\")\nrun_sequence(G, anchor, [Emission(), Reception(), Coherence(), Resonance(), Transition()])\n\nafter_phases = {n: round(float(G.nodes[n][THETA_PRIMARY]), 6) for n in [anchor, *neighbors]}\nfinal_sync = round(phase_sync(G), 6)\n\n{\n    \"initial_sync\": initial_sync,\n    \"final_sync\": final_sync,\n    \"before_phases\": before_phases,\n    \"after_phases\": after_phases,\n    \"synchrony_trace\": synchrony_trace,\n}\n</pre>  from statistics import mean  from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, THETA_PRIMARY, VF_PRIMARY from tnfr.dynamics import set_delta_nfr_hook from tnfr.observers import phase_sync from tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence  G, anchor = create_nfr(\"lattice-anchor\", epi=0.35, vf=1.1, theta=0.1) neighbors: list[str] = [] for idx, offset in enumerate([0.55, -0.42, 0.23, -0.31], start=1):     _, node = create_nfr(f\"lattice-node-{idx}\", epi=0.28 + 0.02 * idx, vf=0.95 + 0.01 * idx, theta=offset, graph=G)     G.add_edge(anchor, node)     neighbors.append(node)  before_phases = {n: round(float(G.nodes[n][THETA_PRIMARY]), 6) for n in [anchor, *neighbors]} initial_sync = round(phase_sync(G), 6) synchrony_trace: list[dict[str, float]] = []   def align_lattice(graph):     phases = [float(data[THETA_PRIMARY]) for _, data in graph.nodes(data=True)]     mean_phase = mean(phases)     for node_id, data in graph.nodes(data=True):         theta = float(data[THETA_PRIMARY])         offset = mean_phase - theta         data[DNFR_PRIMARY] = abs(offset) * 0.04         data[THETA_PRIMARY] = theta + 0.6 * offset         vf = float(data[VF_PRIMARY])         epi = float(data[EPI_PRIMARY])         data[EPI_PRIMARY] = epi + vf * data[DNFR_PRIMARY] * 0.5     synchrony_trace.append({         \"step\": len(synchrony_trace) + 1,         \"phase_sync\": round(phase_sync(graph), 6),     })  set_delta_nfr_hook(G, align_lattice, note=\"phase lattice synchrony smoke\") run_sequence(G, anchor, [Emission(), Reception(), Coherence(), Resonance(), Transition()])  after_phases = {n: round(float(G.nodes[n][THETA_PRIMARY]), 6) for n in [anchor, *neighbors]} final_sync = round(phase_sync(G), 6)  {     \"initial_sync\": initial_sync,     \"final_sync\": final_sync,     \"before_phases\": before_phases,     \"after_phases\": after_phases,     \"synchrony_trace\": synchrony_trace, }"},{"location":"theory/02_phase_synchrony_lattices/#phase-synchrony-lattices","title":"Phase synchrony lattices\u00b6","text":""},{"location":"theory/02_phase_synchrony_lattices/#objectives","title":"Objectives\u00b6","text":"<ul> <li>Illustrate how local lattices distribute phase adjustments to converge toward a shared synchrony ridge.</li> <li>Document the deterministic \u0394NFR hook required by Phase-2 lattice controllers to coordinate \u03bdf, phase, and EPI adjustments.</li> <li>Provide a measurable synchrony lift that downstream CI can assert without stochastic noise.</li> </ul>"},{"location":"theory/02_phase_synchrony_lattices/#phase-2-dependencies","title":"Phase-2 dependencies\u00b6","text":"<ul> <li>Phase-2 integration notes \u2014 the lattice coordination contract mirrors the staged deployment plan.</li> <li>:mod:<code>tnfr.dynamics.coordination</code> \u2014 the future lattice supervisor reuses these helpers to compute mean phase envelopes.</li> <li>:mod:<code>tnfr.observers</code> \u2014 <code>phase_sync</code> is the agreed telemetry primitive for the lattice health dashboards.</li> </ul>"},{"location":"theory/02_phase_synchrony_lattices/#theoretical-exposition","title":"Theoretical exposition\u00b6","text":"<p>A phase synchrony lattice binds neighbouring nodes by iteratively nudging their phases toward a common anchor while respecting \u0394NFR scaling. Each operator pulse captures the global mean phase, applies a weighted correction, and records the induced \u0394NFR so the nodal equation can update EPI consistently. Because synchrony depends on the dispersion of \u03b8 values, even small deterministic corrections shrink the variance and raise the Kuramoto-inspired synchrony index exported by :func:<code>tnfr.observers.phase_sync</code>.</p>"},{"location":"theory/02_phase_synchrony_lattices/#deterministic-smoke-check","title":"Deterministic smoke check\u00b6","text":"<p>The example constructs a star-shaped lattice, records its initial synchrony, and then applies a scripted hook while running the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition segment. The hook logs the synchrony index after every glyph so the trace reveals a monotonic lift, confirming that \u0394NFR bookkeeping and phase adjustments remain coherent.</p>"},{"location":"theory/03_delta_nfr_gradient_fields/","title":"\u0394NFR gradient fields","text":"In\u00a0[\u00a0]: Copied! <pre>from math import hypot\nfrom typing import Dict, List, Tuple\n\nfrom tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY\nfrom tnfr.dynamics import set_delta_nfr_hook\nfrom tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence\nfrom tnfr.types import TNFRGraph\n\nGrid = Dict[Tuple[int, int], str]\n\ndef build_grid() -&gt; tuple[Grid, str, TNFRGraph]:\n    grid: Grid = {}\n    anchor: str | None = None\n    G: TNFRGraph | None = None\n    for x in range(2):\n        for y in range(2):\n            name = f\"cell-{x}-{y}\"\n            params = dict(epi=0.4 + 0.05 * x + 0.03 * y, vf=1.0 + 0.02 * x, theta=0.0)\n            if G is None:\n                G, node = create_nfr(name, **params)\n                anchor = node\n            else:\n                _, node = create_nfr(name, graph=G, **params)\n            grid[(x, y)] = node\n            G.nodes[node][\"pos\"] = (x, y)\n            if x &gt; 0:\n                G.add_edge(node, grid[(x - 1, y)])\n            if y &gt; 0:\n                G.add_edge(node, grid[(x, y - 1)])\n    assert G is not None and anchor is not None\n    return grid, anchor, G\n\n\ndef gradient_map(graph: TNFRGraph, grid: Grid) -&gt; dict[str, dict[str, float]]:\n    def dnfr_at(coord: Tuple[int, int]) -&gt; float:\n        node = grid.get(coord)\n        if node is None:\n            return 0.0\n        return float(graph.nodes[node].get(DNFR_PRIMARY, 0.0))\n\n    grads: dict[str, dict[str, float]] = {}\n    for (x, y), node in grid.items():\n        dnfr = dnfr_at((x, y))\n        right = dnfr_at((x + 1, y)) if (x + 1, y) in grid else dnfr\n        left = dnfr_at((x - 1, y)) if (x - 1, y) in grid else dnfr\n        up = dnfr_at((x, y + 1)) if (x, y + 1) in grid else dnfr\n        down = dnfr_at((x, y - 1)) if (x, y - 1) in grid else dnfr\n        grad_x = 0.5 * (right - left)\n        grad_y = 0.5 * (up - down)\n        grads[f\"cell-{x}-{y}\"] = {\n            \"\u0394NFR\": round(dnfr, 6),\n            \"\u2207x\": round(grad_x, 6),\n            \"\u2207y\": round(grad_y, 6),\n            \"|\u2207|\": round(hypot(grad_x, grad_y), 6),\n        }\n    return grads\n\n\ngrid, anchor, G = build_grid()\ninitial_gradients = gradient_map(G, grid)\nstep_scalars = iter([1.0, 0.9, 0.8, 0.7, 0.6])\ntrace: List[dict[str, dict[str, float]]] = []\n\n\ndef scripted_gradient(graph: TNFRGraph, grid: Grid, scale: float) -&gt; None:\n    for (x, y), node in grid.items():\n        data = graph.nodes[node]\n        base = (0.02 * x - 0.015 * y) * scale\n        vf = float(data[VF_PRIMARY])\n        epi = float(data[EPI_PRIMARY])\n        data[DNFR_PRIMARY] = base\n        data[EPI_PRIMARY] = epi + vf * base\n        data[VF_PRIMARY] = vf + 0.1 * base\n\n\ndef apply_script(graph: TNFRGraph) -&gt; None:\n    scale = next(step_scalars, 0.5)\n    scripted_gradient(graph, grid, scale)\n    trace.append(gradient_map(graph, grid))\n\nset_delta_nfr_hook(G, apply_script, note=\"\u0394NFR gradient field smoke\")\nrun_sequence(G, anchor, [Emission(), Reception(), Coherence(), Resonance(), Transition()])\n\nfinal_gradients = gradient_map(G, grid)\n\n{\n    \"initial\": initial_gradients,\n    \"final\": final_gradients,\n    \"per_step\": trace,\n}\n</pre>  from math import hypot from typing import Dict, List, Tuple  from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY from tnfr.dynamics import set_delta_nfr_hook from tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence from tnfr.types import TNFRGraph  Grid = Dict[Tuple[int, int], str]  def build_grid() -&gt; tuple[Grid, str, TNFRGraph]:     grid: Grid = {}     anchor: str | None = None     G: TNFRGraph | None = None     for x in range(2):         for y in range(2):             name = f\"cell-{x}-{y}\"             params = dict(epi=0.4 + 0.05 * x + 0.03 * y, vf=1.0 + 0.02 * x, theta=0.0)             if G is None:                 G, node = create_nfr(name, **params)                 anchor = node             else:                 _, node = create_nfr(name, graph=G, **params)             grid[(x, y)] = node             G.nodes[node][\"pos\"] = (x, y)             if x &gt; 0:                 G.add_edge(node, grid[(x - 1, y)])             if y &gt; 0:                 G.add_edge(node, grid[(x, y - 1)])     assert G is not None and anchor is not None     return grid, anchor, G   def gradient_map(graph: TNFRGraph, grid: Grid) -&gt; dict[str, dict[str, float]]:     def dnfr_at(coord: Tuple[int, int]) -&gt; float:         node = grid.get(coord)         if node is None:             return 0.0         return float(graph.nodes[node].get(DNFR_PRIMARY, 0.0))      grads: dict[str, dict[str, float]] = {}     for (x, y), node in grid.items():         dnfr = dnfr_at((x, y))         right = dnfr_at((x + 1, y)) if (x + 1, y) in grid else dnfr         left = dnfr_at((x - 1, y)) if (x - 1, y) in grid else dnfr         up = dnfr_at((x, y + 1)) if (x, y + 1) in grid else dnfr         down = dnfr_at((x, y - 1)) if (x, y - 1) in grid else dnfr         grad_x = 0.5 * (right - left)         grad_y = 0.5 * (up - down)         grads[f\"cell-{x}-{y}\"] = {             \"\u0394NFR\": round(dnfr, 6),             \"\u2207x\": round(grad_x, 6),             \"\u2207y\": round(grad_y, 6),             \"|\u2207|\": round(hypot(grad_x, grad_y), 6),         }     return grads   grid, anchor, G = build_grid() initial_gradients = gradient_map(G, grid) step_scalars = iter([1.0, 0.9, 0.8, 0.7, 0.6]) trace: List[dict[str, dict[str, float]]] = []   def scripted_gradient(graph: TNFRGraph, grid: Grid, scale: float) -&gt; None:     for (x, y), node in grid.items():         data = graph.nodes[node]         base = (0.02 * x - 0.015 * y) * scale         vf = float(data[VF_PRIMARY])         epi = float(data[EPI_PRIMARY])         data[DNFR_PRIMARY] = base         data[EPI_PRIMARY] = epi + vf * base         data[VF_PRIMARY] = vf + 0.1 * base   def apply_script(graph: TNFRGraph) -&gt; None:     scale = next(step_scalars, 0.5)     scripted_gradient(graph, grid, scale)     trace.append(gradient_map(graph, grid))  set_delta_nfr_hook(G, apply_script, note=\"\u0394NFR gradient field smoke\") run_sequence(G, anchor, [Emission(), Reception(), Coherence(), Resonance(), Transition()])  final_gradients = gradient_map(G, grid)  {     \"initial\": initial_gradients,     \"final\": final_gradients,     \"per_step\": trace, }"},{"location":"theory/03_delta_nfr_gradient_fields/#nfr-gradient-fields","title":"\u0394NFR gradient fields\u00b6","text":""},{"location":"theory/03_delta_nfr_gradient_fields/#objectives","title":"Objectives\u00b6","text":"<ul> <li>Explain how \u0394NFR gradients encode spatial reorganisation pressure across a lattice of nodes.</li> <li>Capture the deterministic hook that Phase-2 controllers require to seed reproducible \u0394NFR fields before invoking adaptive solvers.</li> <li>Produce gradient telemetry (\u2207x, \u2207y, magnitude) that the CI smoke tests can compare verbatim.</li> </ul>"},{"location":"theory/03_delta_nfr_gradient_fields/#phase-2-dependencies","title":"Phase-2 dependencies\u00b6","text":"<ul> <li>Phase-2 integration notes \u2014 the gradient ledger feeds the multi-scale remesh routine defined there.</li> <li>:mod:<code>tnfr.dynamics.dnfr</code> \u2014 Phase-2 reuses the same \u0394NFR aggregation hooks once the parallel workers are enabled.</li> <li>:mod:<code>tnfr.metrics.coherence</code> \u2014 gradient-aware coherence caches expect the \u0394NFR field to be written with the same aliases showcased here.</li> </ul>"},{"location":"theory/03_delta_nfr_gradient_fields/#theoretical-exposition","title":"Theoretical exposition\u00b6","text":"<p>\u0394NFR gradients measure how rapidly the reorganisation operator changes across neighbouring nodes. In canonical TNFR form, each glyph write stores a scalar \u0394NFR in the node; the gradient field arises by comparing these scalars along orthogonal directions. A deterministic field lets us validate that the nodal equation integrates a consistent \u0394NFR distribution before higher-order remeshers refine the lattice. The primer therefore constructs a small 2\u00d72 grid, scripts \u0394NFR values with a linear trend, and derives the gradient vectors analytically across the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition pipeline.</p>"},{"location":"theory/03_delta_nfr_gradient_fields/#deterministic-smoke-check","title":"Deterministic smoke check\u00b6","text":"<p>The code below assembles the grid, installs the scripted field, fires the canonical segment, and records the gradient map after each glyph. Any drift in alias resolution, lattice wiring, or \u0394NFR bookkeeping will surface as a mismatch in the reported gradient magnitudes.</p>"},{"location":"theory/04_coherence_metrics_walkthrough/","title":"Coherence metrics walkthrough","text":"In\u00a0[\u00a0]: Copied! <pre>from typing import Dict, Iterable, Tuple\n\nfrom tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY\nfrom tnfr.dynamics import set_delta_nfr_hook\nfrom tnfr.metrics.common import compute_coherence\nfrom tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence\n\nG, seed = create_nfr(\"coherence-seed\", epi=0.36, vf=1.15, theta=0.05)\n_, partner = create_nfr(\"coherence-partner\", graph=G, epi=0.33, vf=1.05, theta=-0.02)\nG.add_edge(seed, partner)\n\nincrements: Dict[str, Iterable[Tuple[float, float]]] = {\n    seed: iter([(0.06, 0.02), (0.04, 0.01), (0.03, 0.0), (0.02, -0.005), (0.01, -0.005)]),\n    partner: iter([(0.03, 0.0), (0.02, -0.005), (0.015, -0.005), (0.01, -0.005), (0.005, -0.005)]),\n}\n\n\ndef snapshot(label: str) -&gt; dict[str, float]:\n    C, dnfr_mean, depi_mean = compute_coherence(G, return_means=True)\n    return {\n        \"label\": label,\n        \"C\": round(C, 6),\n        \"\u0394NFR_mean\": round(dnfr_mean, 6),\n        \"\u0394EPI_mean\": round(depi_mean, 6),\n    }\n\n\ntimeline = [snapshot(\"initial\")]\n\n\ndef telemetry_hook(graph):\n    for node_id, iterator in increments.items():\n        dnfr, vf_shift = next(iterator, (0.0, 0.0))\n        data = graph.nodes[node_id]\n        vf = float(data[VF_PRIMARY])\n        epi = float(data[EPI_PRIMARY])\n        data[DNFR_PRIMARY] = dnfr\n        data[EPI_PRIMARY] = epi + vf * dnfr\n        data[VF_PRIMARY] = vf + vf_shift\n    timeline.append(snapshot(f\"step_{len(timeline)}\"))\n\n\nset_delta_nfr_hook(G, telemetry_hook, note=\"coherence metrics smoke\")\nrun_sequence(G, seed, [Emission(), Reception(), Coherence(), Resonance(), Transition()])\n\ntimeline\n</pre>  from typing import Dict, Iterable, Tuple  from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY from tnfr.dynamics import set_delta_nfr_hook from tnfr.metrics.common import compute_coherence from tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence  G, seed = create_nfr(\"coherence-seed\", epi=0.36, vf=1.15, theta=0.05) _, partner = create_nfr(\"coherence-partner\", graph=G, epi=0.33, vf=1.05, theta=-0.02) G.add_edge(seed, partner)  increments: Dict[str, Iterable[Tuple[float, float]]] = {     seed: iter([(0.06, 0.02), (0.04, 0.01), (0.03, 0.0), (0.02, -0.005), (0.01, -0.005)]),     partner: iter([(0.03, 0.0), (0.02, -0.005), (0.015, -0.005), (0.01, -0.005), (0.005, -0.005)]), }   def snapshot(label: str) -&gt; dict[str, float]:     C, dnfr_mean, depi_mean = compute_coherence(G, return_means=True)     return {         \"label\": label,         \"C\": round(C, 6),         \"\u0394NFR_mean\": round(dnfr_mean, 6),         \"\u0394EPI_mean\": round(depi_mean, 6),     }   timeline = [snapshot(\"initial\")]   def telemetry_hook(graph):     for node_id, iterator in increments.items():         dnfr, vf_shift = next(iterator, (0.0, 0.0))         data = graph.nodes[node_id]         vf = float(data[VF_PRIMARY])         epi = float(data[EPI_PRIMARY])         data[DNFR_PRIMARY] = dnfr         data[EPI_PRIMARY] = epi + vf * dnfr         data[VF_PRIMARY] = vf + vf_shift     timeline.append(snapshot(f\"step_{len(timeline)}\"))   set_delta_nfr_hook(G, telemetry_hook, note=\"coherence metrics smoke\") run_sequence(G, seed, [Emission(), Reception(), Coherence(), Resonance(), Transition()])  timeline"},{"location":"theory/04_coherence_metrics_walkthrough/#coherence-metrics-walkthrough","title":"Coherence metrics walkthrough\u00b6","text":""},{"location":"theory/04_coherence_metrics_walkthrough/#objectives","title":"Objectives\u00b6","text":"<ul> <li>Demonstrate how canonical coherence metrics extract C(t), mean \u0394NFR, and mean \u0394EPI from a running graph.</li> <li>Show the deterministic telemetry hook required by Phase-2 observability dashboards.</li> <li>Provide an assertion-friendly timeline that highlights the impact of successive glyph applications on coherence.</li> </ul>"},{"location":"theory/04_coherence_metrics_walkthrough/#phase-2-dependencies","title":"Phase-2 dependencies\u00b6","text":"<ul> <li>Phase-2 integration notes \u2014 the coherence snapshots align with the observability contract described there.</li> <li>:mod:<code>tnfr.metrics.common</code> \u2014 Phase-2 dashboards reuse <code>compute_coherence</code> verbatim, so the primer doubles as living documentation.</li> <li>:mod:<code>tnfr.structural</code> \u2014 the operator sequencing mirrors the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition segment executed by the runtime.</li> </ul>"},{"location":"theory/04_coherence_metrics_walkthrough/#theoretical-exposition","title":"Theoretical exposition\u00b6","text":"<p>Coherence C(t) summarises how stable the network remains under the nodal equation. The accompanying \u0394NFR and \u0394EPI means trace how strongly the lattice is being reorganised. By recording the tuple <code>(C, mean \u0394NFR, mean \u0394EPI)</code> before and after deterministic glyph applications we verify that coherence gains correlate with controlled \u0394NFR contributions. Because the hook writes explicit \u0394NFR values, the averages match the scripted increments exactly, isolating the measurement contract used by the Phase-2 monitoring stack.</p>"},{"location":"theory/04_coherence_metrics_walkthrough/#deterministic-smoke-check","title":"Deterministic smoke check\u00b6","text":"<p>The walkthrough spawns a two-node graph, applies the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition sequence, and records coherence metrics after each glyph. The resulting timeline must show an increasing C(t) while \u0394NFR contributions decay as the scripted iterators exhaust their increments. Any deviation would signal a regression in the coherence aggregator or in the \u0394NFR ledger.</p>"},{"location":"theory/04_nfr_validator_and_metrics/","title":"Validator and metrics","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nfrom tnfr.mathematics.operators import CoherenceOperator, FrequencyOperator\nfrom tnfr.mathematics.spaces import HilbertSpace\nfrom tnfr.validation.spectral import NFRValidator\n\nspace = HilbertSpace(dimension=3)\ncoherence_operator = CoherenceOperator([0.75, 0.6, 0.45])\nfrequency_operator = FrequencyOperator([1.1, 0.95, 0.5])\nvalidator = NFRValidator(\n    hilbert_space=space,\n    coherence_operator=coherence_operator,\n    coherence_threshold=0.5,\n    frequency_operator=frequency_operator,\n)\n\nstate = np.array([0.8, 0.45, 0.2], dtype=np.complex128)\nstate = state / space.norm(state)\n\noutcome = validator.validate(state)\noverall = outcome.passed\nsummary = outcome.summary\nreport = validator.report(outcome)\n\n{\n    \"overall\": bool(overall),\n    \"coherence_value\": round(summary[\"coherence\"][\"value\"], 6),\n    \"frequency_value\": round(summary[\"frequency\"][\"value\"], 6),\n    \"unitary_norm\": round(summary[\"unitary_stability\"][\"norm_after\"], 6),\n    \"report\": report,\n}\n</pre> import numpy as np  from tnfr.mathematics.operators import CoherenceOperator, FrequencyOperator from tnfr.mathematics.spaces import HilbertSpace from tnfr.validation.spectral import NFRValidator  space = HilbertSpace(dimension=3) coherence_operator = CoherenceOperator([0.75, 0.6, 0.45]) frequency_operator = FrequencyOperator([1.1, 0.95, 0.5]) validator = NFRValidator(     hilbert_space=space,     coherence_operator=coherence_operator,     coherence_threshold=0.5,     frequency_operator=frequency_operator, )  state = np.array([0.8, 0.45, 0.2], dtype=np.complex128) state = state / space.norm(state)  outcome = validator.validate(state) overall = outcome.passed summary = outcome.summary report = validator.report(outcome)  {     \"overall\": bool(overall),     \"coherence_value\": round(summary[\"coherence\"][\"value\"], 6),     \"frequency_value\": round(summary[\"frequency\"][\"value\"], 6),     \"unitary_norm\": round(summary[\"unitary_stability\"][\"norm_after\"], 6),     \"report\": report, }"},{"location":"theory/04_nfr_validator_and_metrics/#validator-and-metrics","title":"Validator and metrics\u00b6","text":"<p>TNFR validators bundle the canonical checks that guarantee a spectral state respects coherence thresholds, non-negative structural frequency and unitary stability.</p>"},{"location":"theory/04_nfr_validator_and_metrics/#validation-pipeline","title":"Validation pipeline\u00b6","text":"<ol> <li>Normalize the state within the Hilbert space tolerance.</li> <li>Compare the coherence expectation against the configured threshold.</li> <li>Ensure the frequency projection stays non-negative when enforced.</li> <li>Simulate a one-step unitary generated by the coherence operator and verify norm preservation.</li> </ol>"},{"location":"theory/04_nfr_validator_and_metrics/#smoke-check-validator-summary","title":"Smoke check: validator summary\u00b6","text":"<p>The following cell assembles a validator and inspects the diagnostics it produces for a normalized state.</p>"},{"location":"theory/05_sense_index_calibration/","title":"Sense index calibration","text":"In\u00a0[\u00a0]: Copied! <pre>from typing import Dict, Iterable, Tuple\n\nfrom tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, THETA_PRIMARY, VF_PRIMARY\nfrom tnfr.dynamics import set_delta_nfr_hook\nfrom tnfr.metrics.sense_index import compute_Si\nfrom tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence\n\nG, anchor = create_nfr(\"calibration-anchor\", epi=0.41, vf=1.1, theta=0.0)\n_, fast = create_nfr(\"calibration-fast\", graph=G, epi=0.37, vf=1.24, theta=0.18)\n_, slow = create_nfr(\"calibration-slow\", graph=G, epi=0.39, vf=0.96, theta=-0.32)\nG.add_edge(anchor, fast)\nG.add_edge(anchor, slow)\nG.add_edge(fast, slow)\n\nscripts: Dict[str, Iterable[Tuple[float, float, float]]] = {\n    anchor: iter([(0.05, 0.015, 0.04), (0.03, 0.01, 0.02), (0.02, 0.008, 0.015), (0.015, 0.006, 0.01), (0.01, 0.004, 0.008)]),\n    fast: iter([(0.07, 0.02, -0.03), (0.04, 0.015, -0.02), (0.03, 0.012, -0.015), (0.02, 0.008, -0.01), (0.015, 0.006, -0.008)]),\n    slow: iter([(0.02, 0.0, 0.05), (0.015, 0.005, 0.03), (0.012, 0.004, 0.02), (0.01, 0.003, 0.015), (0.008, 0.002, 0.01)]),\n}\n\nbaseline_si = {node: round(value, 6) for node, value in compute_Si(G, inplace=False).items()}\nsi_trace: list[dict[str, float]] = []\n\n\ndef calibration_hook(graph):\n    for node_id, iterator in scripts.items():\n        dnfr, vf_shift, theta_shift = next(iterator, (0.0, 0.0, 0.0))\n        data = graph.nodes[node_id]\n        vf = float(data[VF_PRIMARY])\n        epi = float(data[EPI_PRIMARY])\n        theta = float(data[THETA_PRIMARY])\n        data[DNFR_PRIMARY] = dnfr\n        data[EPI_PRIMARY] = epi + vf * dnfr\n        data[VF_PRIMARY] = vf + vf_shift\n        data[THETA_PRIMARY] = theta + theta_shift\n    si_trace.append({node: round(val, 6) for node, val in compute_Si(graph, inplace=False).items()})\n\nset_delta_nfr_hook(G, calibration_hook, note=\"sense index calibration smoke\")\nrun_sequence(G, anchor, [Emission(), Reception(), Coherence(), Resonance(), Transition()])\ncalibrated_si = {node: round(value, 6) for node, value in compute_Si(G, inplace=False).items()}\n\n{\n    \"baseline\": baseline_si,\n    \"calibrated\": calibrated_si,\n    \"per_step\": si_trace,\n}\n</pre>  from typing import Dict, Iterable, Tuple  from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, THETA_PRIMARY, VF_PRIMARY from tnfr.dynamics import set_delta_nfr_hook from tnfr.metrics.sense_index import compute_Si from tnfr.structural import Coherence, Emission, Reception, Resonance, Transition, create_nfr, run_sequence  G, anchor = create_nfr(\"calibration-anchor\", epi=0.41, vf=1.1, theta=0.0) _, fast = create_nfr(\"calibration-fast\", graph=G, epi=0.37, vf=1.24, theta=0.18) _, slow = create_nfr(\"calibration-slow\", graph=G, epi=0.39, vf=0.96, theta=-0.32) G.add_edge(anchor, fast) G.add_edge(anchor, slow) G.add_edge(fast, slow)  scripts: Dict[str, Iterable[Tuple[float, float, float]]] = {     anchor: iter([(0.05, 0.015, 0.04), (0.03, 0.01, 0.02), (0.02, 0.008, 0.015), (0.015, 0.006, 0.01), (0.01, 0.004, 0.008)]),     fast: iter([(0.07, 0.02, -0.03), (0.04, 0.015, -0.02), (0.03, 0.012, -0.015), (0.02, 0.008, -0.01), (0.015, 0.006, -0.008)]),     slow: iter([(0.02, 0.0, 0.05), (0.015, 0.005, 0.03), (0.012, 0.004, 0.02), (0.01, 0.003, 0.015), (0.008, 0.002, 0.01)]), }  baseline_si = {node: round(value, 6) for node, value in compute_Si(G, inplace=False).items()} si_trace: list[dict[str, float]] = []   def calibration_hook(graph):     for node_id, iterator in scripts.items():         dnfr, vf_shift, theta_shift = next(iterator, (0.0, 0.0, 0.0))         data = graph.nodes[node_id]         vf = float(data[VF_PRIMARY])         epi = float(data[EPI_PRIMARY])         theta = float(data[THETA_PRIMARY])         data[DNFR_PRIMARY] = dnfr         data[EPI_PRIMARY] = epi + vf * dnfr         data[VF_PRIMARY] = vf + vf_shift         data[THETA_PRIMARY] = theta + theta_shift     si_trace.append({node: round(val, 6) for node, val in compute_Si(graph, inplace=False).items()})  set_delta_nfr_hook(G, calibration_hook, note=\"sense index calibration smoke\") run_sequence(G, anchor, [Emission(), Reception(), Coherence(), Resonance(), Transition()]) calibrated_si = {node: round(value, 6) for node, value in compute_Si(G, inplace=False).items()}  {     \"baseline\": baseline_si,     \"calibrated\": calibrated_si,     \"per_step\": si_trace, }"},{"location":"theory/05_sense_index_calibration/#sense-index-calibration","title":"Sense index calibration\u00b6","text":""},{"location":"theory/05_sense_index_calibration/#objectives","title":"Objectives\u00b6","text":"<ul> <li>Show how Si responds to controlled changes in \u03bdf, \u0394NFR, and phase alignment.</li> <li>Capture the deterministic \u0394NFR/phase hook required by Phase-2 calibration harnesses.</li> <li>Provide reproducible Si readings that CI can compare verbatim to detect telemetry regressions.</li> </ul>"},{"location":"theory/05_sense_index_calibration/#phase-2-dependencies","title":"Phase-2 dependencies\u00b6","text":"<ul> <li>Phase-2 integration notes \u2014 the calibration harness reuses the scripted iterator pattern shown here.</li> <li>:mod:<code>tnfr.metrics.sense_index</code> \u2014 <code>compute_Si</code> is the canonical metric entry point for both runtime and analytical tooling.</li> <li>:mod:<code>tnfr.structural</code> \u2014 the operator sequence mirrors the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition segment executed before adaptive selectors take over.</li> </ul>"},{"location":"theory/05_sense_index_calibration/#theoretical-exposition","title":"Theoretical exposition\u00b6","text":"<p>The sense index Si aggregates three forces: coherence (C), synchrony (phase alignment), and \u0394NFR attenuation. Calibrating Si therefore requires scripted perturbations of \u03bdf, \u03b8, and \u0394NFR so that the resulting readings match expectations. By applying deterministic increments to each node we validate that Si increases for nodes receiving reinforced \u03bdf and tightened phase, and decreases otherwise. This preserves TNFR semantics for the Phase-2 calibration suite.</p>"},{"location":"theory/05_sense_index_calibration/#deterministic-smoke-check","title":"Deterministic smoke check\u00b6","text":"<p>The code instantiates a triad of nodes, computes baseline Si, then runs the canonical emission\u2192reception\u2192coherence\u2192resonance\u2192transition sequence while the hook iterates through predetermined \u0394NFR, \u03bdf, and phase updates. The resulting before/after dictionary and per-step Si trace must remain stable; any variation signals a regression in Si aggregation or in the \u0394NFR ledger that feeds it.</p>"},{"location":"theory/06_recursivity_cascades/","title":"Recursivity cascades","text":"In\u00a0[\u00a0]: Copied! <pre>from collections import defaultdict\nfrom typing import Dict, Iterable, List, Tuple\n\nfrom tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY\nfrom tnfr.dynamics import set_delta_nfr_hook\nfrom tnfr.structural import Coherence, Reception, Recursivity, Resonance, Transition, create_nfr, run_sequence\n\nG, root = create_nfr(\"cascade-root\", epi=0.5, vf=1.02, theta=0.0)\n_, child = create_nfr(\"cascade-child\", graph=G, epi=0.34, vf=1.08, theta=0.12)\n_, leaf = create_nfr(\"cascade-leaf\", graph=G, epi=0.26, vf=1.12, theta=-0.18)\nG.add_edge(root, child)\nG.add_edge(child, leaf)\n\nscripts: Dict[str, Iterable[Tuple[float, float]]] = {\n    root: iter([(0.04, 0.02), (0.03, 0.015), (0.025, 0.012), (0.02, 0.01), (0.015, 0.008)]),\n    child: iter([(0.032, 0.015), (0.024, 0.01), (0.02, 0.008), (0.016, 0.006), (0.012, 0.005)]),\n    leaf: iter([(0.025, 0.01), (0.018, 0.008), (0.015, 0.006), (0.012, 0.005), (0.01, 0.004)]),\n}\n\ncascade_trace: List[Tuple[str, float, float]] = []\nlabels = {root: \"root\", child: \"child\", leaf: \"leaf\"}\n\n\ndef snapshot() -&gt; dict[str, dict[str, float]]:\n    return {\n        labels[node]: {\n            \"EPI\": round(float(G.nodes[node][EPI_PRIMARY]), 6),\n            \"\u03bdf\": round(float(G.nodes[node][VF_PRIMARY]), 6),\n        }\n        for node in (root, child, leaf)\n    }\n\n\ndef cascade_hook(graph):\n    for node_id, iterator in scripts.items():\n        dnfr, vf_shift = next(iterator, (0.0, 0.0))\n        data = graph.nodes[node_id]\n        vf_before = float(data[VF_PRIMARY])\n        epi_before = float(data[EPI_PRIMARY])\n        data[DNFR_PRIMARY] = dnfr\n        data[EPI_PRIMARY] = epi_before + vf_before * dnfr\n        data[VF_PRIMARY] = vf_before + vf_shift\n        cascade_trace.append(\n            (labels[node_id], round(float(data[EPI_PRIMARY]), 6), round(float(data[VF_PRIMARY]), 6))\n        )\n\n\nbefore = snapshot()\nset_delta_nfr_hook(G, cascade_hook, note=\"recursivity cascade smoke\")\nrun_sequence(G, root, [Recursivity(), Reception(), Coherence(), Resonance(), Transition()])\nafter = snapshot()\n\ntrace_by_level: Dict[str, List[Tuple[float, float]]] = defaultdict(list)\nfor label, epi_val, vf_val in cascade_trace:\n    trace_by_level[label].append((epi_val, vf_val))\n\n{\n    \"before\": before,\n    \"after\": after,\n    \"trace\": {key: trace_by_level[key] for key in (\"root\", \"child\", \"leaf\")},\n}\n</pre>  from collections import defaultdict from typing import Dict, Iterable, List, Tuple  from tnfr.constants import DNFR_PRIMARY, EPI_PRIMARY, VF_PRIMARY from tnfr.dynamics import set_delta_nfr_hook from tnfr.structural import Coherence, Reception, Recursivity, Resonance, Transition, create_nfr, run_sequence  G, root = create_nfr(\"cascade-root\", epi=0.5, vf=1.02, theta=0.0) _, child = create_nfr(\"cascade-child\", graph=G, epi=0.34, vf=1.08, theta=0.12) _, leaf = create_nfr(\"cascade-leaf\", graph=G, epi=0.26, vf=1.12, theta=-0.18) G.add_edge(root, child) G.add_edge(child, leaf)  scripts: Dict[str, Iterable[Tuple[float, float]]] = {     root: iter([(0.04, 0.02), (0.03, 0.015), (0.025, 0.012), (0.02, 0.01), (0.015, 0.008)]),     child: iter([(0.032, 0.015), (0.024, 0.01), (0.02, 0.008), (0.016, 0.006), (0.012, 0.005)]),     leaf: iter([(0.025, 0.01), (0.018, 0.008), (0.015, 0.006), (0.012, 0.005), (0.01, 0.004)]), }  cascade_trace: List[Tuple[str, float, float]] = [] labels = {root: \"root\", child: \"child\", leaf: \"leaf\"}   def snapshot() -&gt; dict[str, dict[str, float]]:     return {         labels[node]: {             \"EPI\": round(float(G.nodes[node][EPI_PRIMARY]), 6),             \"\u03bdf\": round(float(G.nodes[node][VF_PRIMARY]), 6),         }         for node in (root, child, leaf)     }   def cascade_hook(graph):     for node_id, iterator in scripts.items():         dnfr, vf_shift = next(iterator, (0.0, 0.0))         data = graph.nodes[node_id]         vf_before = float(data[VF_PRIMARY])         epi_before = float(data[EPI_PRIMARY])         data[DNFR_PRIMARY] = dnfr         data[EPI_PRIMARY] = epi_before + vf_before * dnfr         data[VF_PRIMARY] = vf_before + vf_shift         cascade_trace.append(             (labels[node_id], round(float(data[EPI_PRIMARY]), 6), round(float(data[VF_PRIMARY]), 6))         )   before = snapshot() set_delta_nfr_hook(G, cascade_hook, note=\"recursivity cascade smoke\") run_sequence(G, root, [Recursivity(), Reception(), Coherence(), Resonance(), Transition()]) after = snapshot()  trace_by_level: Dict[str, List[Tuple[float, float]]] = defaultdict(list) for label, epi_val, vf_val in cascade_trace:     trace_by_level[label].append((epi_val, vf_val))  {     \"before\": before,     \"after\": after,     \"trace\": {key: trace_by_level[key] for key in (\"root\", \"child\", \"leaf\")}, }"},{"location":"theory/06_recursivity_cascades/#recursivity-cascades","title":"Recursivity cascades\u00b6","text":""},{"location":"theory/06_recursivity_cascades/#objectives","title":"Objectives\u00b6","text":"<ul> <li>Describe how recursivity propagates structural echoes across nested EPIs.</li> <li>Capture the deterministic \u0394NFR hook required by Phase-2 remesh cascades.</li> <li>Provide reproducible traces that verify multi-scale coherence after each recursion step.</li> </ul>"},{"location":"theory/06_recursivity_cascades/#phase-2-dependencies","title":"Phase-2 dependencies\u00b6","text":"<ul> <li>Phase-2 integration notes \u2014 the recursive remesh orchestration consumes the same trace structure emitted here.</li> <li>:mod:<code>tnfr.structural</code> \u2014 Phase-2 triggers the same canonical recursivity\u2192reception\u2192coherence\u2192resonance\u2192transition pipeline when stitching sub-EPIs.</li> <li>:mod:<code>tnfr.operators.definitions</code> \u2014 glyph assignments stay identical, ensuring the deterministic trace matches runtime expectations.</li> </ul>"},{"location":"theory/06_recursivity_cascades/#theoretical-exposition","title":"Theoretical exposition\u00b6","text":"<p>Recursivity replays structural motifs across scales. Each application copies the local \u0394NFR ledger into progressively finer sub-EPIs, adjusting \u03bdf so that coherence remains invariant. By scripting the \u0394NFR injections per level (root \u2192 child \u2192 leaf) we can verify that the resulting EPI and \u03bdf trajectories evolve proportionally and that the cascade trace records the nested ratios required for Phase-2 remeshing.</p>"},{"location":"theory/06_recursivity_cascades/#deterministic-smoke-check","title":"Deterministic smoke check\u00b6","text":"<p>The notebook builds a three-level chain, executes the canonical recursivity\u2192reception\u2192coherence\u2192resonance\u2192transition segment, and records EPI/\u03bdf pairs after each application. The before/after snapshots and the trace grouped by level are deterministic, allowing CI to detect any modification to the cascade grammar or \u0394NFR propagation rules.</p>"},{"location":"theory/07_emergence_classical_mechanics/","title":"Emergence of Classical Mechanics from TNFR","text":""},{"location":"theory/07_emergence_classical_mechanics/#1-introduction-classical-mechanics-as-a-resonant-limit","title":"1. Introduction: Classical Mechanics as a Resonant Limit","text":""},{"location":"theory/07_emergence_classical_mechanics/#11-classical-mechanics-as-low-dissonance-coherence","title":"1.1 Classical Mechanics as Low-Dissonance Coherence","text":"<p>Classical mechanics emerges naturally from TNFR as the canonical limit of low-dissonance coherence. The emergence pathway connects fundamental structural dynamics to observable physics:</p> <pre><code>TNFR Structural Coherence \u2192 NFR Networks \u2192 Classical Mechanics (Observable Physics)\n</code></pre> <p>From the TNFR perspective, classical mechanics represents the resonant limit where:</p> <ol> <li>Structural dissonance is minimal (\u03b5 \u2192 0)</li> <li>Phase coherence is nearly perfect (nodes synchronize strongly)</li> <li>Observables become deterministic (trajectories emerge from coherence flow)</li> <li>Mass emerges as structural rigidity (m = 1/\u03bdf)</li> </ol> <p>Key Insight: Observable deterministic phenomena arise when structural networks achieve sufficient coherence. The familiar equations of Newton, Lagrange, and Hamilton emerge as natural consequences of the nodal equation <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code> in this low-dissonance regime.</p>"},{"location":"theory/07_emergence_classical_mechanics/#12-the-key-insight-mass-as-inverse-frequency","title":"1.2 The Key Insight: Mass as Inverse Frequency","text":"<p>The central conceptual breakthrough connecting TNFR to classical mechanics is:</p> <pre><code>m = 1/\u03bdf\n</code></pre> <p>Interpretation: Mass is not an intrinsic property of \"things\" but rather the inverse of structural reorganization rate. High mass means low \u03bdf \u2014 the structure reorganizes slowly, exhibiting inertia. Low mass means high \u03bdf \u2014 the structure reorganizes rapidly, responding quickly to gradients.</p> <p>Examples: - Electron: Very high \u03bdf \u2192 very low mass (rapid structural response) - Macroscopic object: Very low \u03bdf \u2192 high mass (sluggish structural response) - Photon: In the limit \u03bdf \u2192 \u221e, mass m \u2192 0 (instantaneous structural adjustment)</p>"},{"location":"theory/07_emergence_classical_mechanics/#13-force-as-coherence-gradient","title":"1.3 Force as Coherence Gradient","text":"<p>In TNFR, what classical mechanics calls \"force\" is reinterpreted as:</p> <pre><code>F = -\u2207U(q)\n</code></pre> <p>where U(q) is the coherence potential \u2014 a function measuring the structural stability landscape. Nodes naturally flow toward configurations of higher coherence (lower U), much as physical systems move toward lower potential energy.</p> <p>Key Properties: - \u2207U points toward decreasing coherence - -\u2207U points toward increasing coherence (the \"pull\" of stability) - Force is not a \"push\" or \"pull\" but a gradient of structural stability</p>"},{"location":"theory/07_emergence_classical_mechanics/#2-derivation-from-nodal-equation-to-newtons-laws","title":"2. Derivation: From Nodal Equation to Newton's Laws","text":""},{"location":"theory/07_emergence_classical_mechanics/#21-starting-point-the-nodal-equation","title":"2.1 Starting Point: The Nodal Equation","text":"<p>Recall the fundamental TNFR equation governing all structural evolution:</p> <p>[ \\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta \\text{NFR}(t) ]</p> <p>Where: - EPI: Primary Information Structure (the coherent \"form\" of the node) - \u03bdf: Structural frequency (Hz_str) \u2014 the reorganization rate - \u0394NFR: Internal reorganization operator \u2014 the \"pressure\" for change</p>"},{"location":"theory/07_emergence_classical_mechanics/#22-identifying-classical-coordinates","title":"2.2 Identifying Classical Coordinates","text":"<p>To connect with classical mechanics, we identify:</p> <ul> <li>q: Generalized coordinates (position, angle, etc.) \u2014 the classical observables</li> <li>EPI(q): The structural configuration corresponding to classical state q</li> </ul> <p>The nodal equation projected onto coordinate space becomes:</p> <p>[ \\frac{dq}{dt} = \\nu_f \\cdot \\Delta \\text{NFR}(q, t) ]</p>"},{"location":"theory/07_emergence_classical_mechanics/#23-the-low-dissonance-regime","title":"2.3 The Low-Dissonance Regime","text":"<p>Classical mechanics emerges when structural dissonance is minimal. Formally, we introduce a dissonance parameter \u03b5 and consider the limit:</p> <p>[ \\varepsilon \\to 0 ]</p> <p>In this regime: - Phase coherence is nearly perfect: \u03c6\u1d62 \u2248 \u03c6\u2c7c for coupled nodes - \u0394NFR becomes a smooth gradient field (no sharp discontinuities) - Quantum fluctuations become negligible compared to classical trajectories</p>"},{"location":"theory/07_emergence_classical_mechanics/#24-inertial-metric-and-coherence-potential","title":"2.4 Inertial Metric and Coherence Potential","text":"<p>Define: - M(q): The inertial metric, a matrix encoding structural rigidity - U(q): The coherence potential, measuring structural stability</p> <p>The inertial metric is constructed from structural frequencies:</p> <p>[ M(q) = \\text{diag}\\left(\\frac{1}{\\nu_f^1}, \\frac{1}{\\nu_f^2}, \\ldots, \\frac{1}{\\nu_f^n}\\right) ]</p> <p>Each diagonal element m\u1d62 = 1/\u03bdf\u2071 represents the \"mass\" associated with coordinate q\u1d62.</p>"},{"location":"theory/07_emergence_classical_mechanics/#25-the-variational-principle","title":"2.5 The Variational Principle","text":"<p>In the low-dissonance limit, TNFR evolution extremizes a structural action:</p> <p>[ S[\\text{EPI}] = \\int_{t_1}^{t_2} \\left( \\frac{1}{2} \\dot{q}^T M(q) \\dot{q} - U(q) \\right) dt ]</p> <p>This is precisely the Lagrangian action of classical mechanics:</p> <p>[ S = \\int_{t_1}^{t_2} L(q, \\dot{q}, t) \\, dt ]</p> <p>where the Lagrangian is:</p> <p>[ L = K - U = \\frac{1}{2} \\dot{q}^T M(q) \\dot{q} - U(q) ]</p> <ul> <li>K: Kinetic term (structural reorganization energy)</li> <li>U: Potential term (coherence stability landscape)</li> </ul>"},{"location":"theory/07_emergence_classical_mechanics/#26-euler-lagrange-equations","title":"2.6 Euler-Lagrange Equations","text":"<p>Extremizing the action via the principle of least action yields the Euler-Lagrange equations:</p> <p>[ \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right) - \\frac{\\partial L}{\\partial q} = 0 ]</p> <p>Computing the derivatives:</p> <p>[ \\frac{\\partial L}{\\partial \\dot{q}} = M(q) \\dot{q} ]</p> <p>[ \\frac{d}{dt}\\left(M(q) \\dot{q}\\right) = M(q) \\ddot{q} + \\frac{\\partial M}{\\partial q}\\dot{q}\\dot{q} ]</p> <p>[ \\frac{\\partial L}{\\partial q} = \\frac{1}{2}\\dot{q}^T \\frac{\\partial M}{\\partial q}\\dot{q} - \\frac{\\partial U}{\\partial q} ]</p> <p>Combining and simplifying (assuming M is approximately constant or the velocity is low):</p> <p>[ M(q) \\ddot{q} + \\nabla U(q) = O(\\varepsilon) ]</p> <p>In the strict limit \u03b5 \u2192 0:</p> <p>[ M(q) \\ddot{q} = -\\nabla U(q) ]</p>"},{"location":"theory/07_emergence_classical_mechanics/#27-newtons-second-law","title":"2.7 Newton's Second Law","text":"<p>For a single particle with constant mass m = 1/\u03bdf:</p> <p>[ m \\ddot{q} = -\\nabla U(q) ]</p> <p>Identifying F = -\u2207U as the force, we obtain Newton's second law:</p> <p>[ F = m \\ddot{q} ]</p> <p>Or equivalently:</p> <p>[ F = \\frac{dp}{dt} \\quad \\text{where } p = m\\dot{q} ]</p> <p>Physical Interpretation: - Acceleration ((\\ddot{q})) is the rate of change of reorganization velocity - Force (F) is the gradient of coherence potential - Mass (m) is the structural rigidity resisting reorganization</p>"},{"location":"theory/07_emergence_classical_mechanics/#3-conservation-laws-from-symmetry","title":"3. Conservation Laws from Symmetry","text":"<p>One of the most profound connections between TNFR and classical mechanics is the emergence of conservation laws from structural symmetries. This is a direct manifestation of Noether's theorem in the resonant fractal framework.</p>"},{"location":"theory/07_emergence_classical_mechanics/#31-energy-conservation","title":"3.1 Energy Conservation","text":"<p>Symmetry: Time translation invariance (the structural dynamics don't change over time)</p> <p>Conserved Quantity: Total energy</p> <p>[ E = K + U = \\frac{1}{2}\\dot{q}^T M(q)\\dot{q} + U(q) ]</p> <p>Proof (in low-dissonance regime):</p> <p>[ \\frac{dE}{dt} = \\frac{d}{dt}\\left(\\frac{1}{2}\\dot{q}^T M \\dot{q} + U(q)\\right) ]</p> <p>[ = \\dot{q}^T M \\ddot{q} + \\dot{q}^T \\nabla U(q) ]</p> <p>Using (M\\ddot{q} = -\\nabla U):</p> <p>[ = \\dot{q}^T(-\\nabla U) + \\dot{q}^T \\nabla U = 0 ]</p> <p>TNFR Interpretation: Energy conservation reflects the conservation of total coherence in a time-invariant network. The kinetic term K measures coherence in motion (reorganization), while the potential term U measures coherence in configuration (structure).</p> <p>Quasi-Conservation: In TNFR, perfect conservation only holds when \u03b5 = 0. For small but nonzero \u03b5:</p> <p>[ \\left|\\frac{dE}{dt}\\right| = O(\\varepsilon |t|) ]</p> <p>Energy drifts slowly due to residual structural dissonance, but remains approximately conserved over finite time scales.</p>"},{"location":"theory/07_emergence_classical_mechanics/#32-momentum-conservation","title":"3.2 Momentum Conservation","text":"<p>Symmetry: Spatial translation invariance (the structural dynamics are the same everywhere in space)</p> <p>Conserved Quantity: Linear momentum</p> <p>[ p = M \\dot{q} = m \\dot{q} ]</p> <p>Proof: For a spatially homogeneous system, U(q) depends only on relative positions, not absolute position. Thus:</p> <p>[ \\nabla U = 0 \\quad \\text{(for uniform translation)} ]</p> <p>From Newton's law:</p> <p>[ \\frac{dp}{dt} = M\\ddot{q} = -\\nabla U = 0 ]</p> <p>Therefore p is conserved.</p> <p>TNFR Interpretation: Momentum conservation emerges from spatial homogeneity of the NFR network. If all locations have equivalent structural properties, there's no preferred direction for reorganization flow, and net momentum is conserved.</p> <p>Multi-Node Systems: For a network of N nodes:</p> <p>[ P_{\\text{total}} = \\sum_{i=1}^{N} m_i \\dot{q}_i ]</p> <p>Conservation holds when the network has no external gradients.</p>"},{"location":"theory/07_emergence_classical_mechanics/#33-angular-momentum-conservation","title":"3.3 Angular Momentum Conservation","text":"<p>Symmetry: Rotational invariance (the structural dynamics are the same in all directions)</p> <p>Conserved Quantity: Angular momentum</p> <p>[ L = q \\times p = q \\times (m\\dot{q}) ]</p> <p>Proof: For a central potential U(r) depending only on distance r = |q|:</p> <p>[ \\nabla U = \\frac{dU}{dr}\\frac{q}{r} ]</p> <p>The torque is:</p> <p>[ \\tau = q \\times F = q \\times (-\\nabla U) = -\\frac{dU}{dr}q \\times \\frac{q}{r} = 0 ]</p> <p>Since (q \\times q = 0), the torque vanishes. Thus:</p> <p>[ \\frac{dL}{dt} = \\tau = 0 ]</p> <p>TNFR Interpretation: Angular momentum conservation emerges from isotropic structural coupling \u2014 the NFR network has no preferred orientation. Rotations preserve coherence patterns, so rotational \"flow\" is conserved.</p>"},{"location":"theory/07_emergence_classical_mechanics/#34-quasi-conservation-and-dissonance","title":"3.4 Quasi-Conservation and Dissonance","text":"<p>In realistic TNFR systems with finite dissonance (\u03b5 &gt; 0), conservation laws become quasi-conserved:</p> <p>[ \\left|\\frac{dE}{dt}\\right| \\sim O(\\varepsilon) ]</p> <p>[ \\left|\\frac{dp}{dt}\\right| \\sim O(\\varepsilon) ]</p> <p>[ \\left|\\frac{dL}{dt}\\right| \\sim O(\\varepsilon) ]</p> <p>Physical Meaning: Small structural dissonance (imperfect phase coherence, frequency mismatches) causes gradual drift in conserved quantities. Over short times, conservation appears exact; over long times, dissipation becomes apparent.</p> <p>Timescale: The conservation holds accurately for times:</p> <p>[ t \\ll \\frac{1}{\\varepsilon \\nu_f} ]</p>"},{"location":"theory/07_emergence_classical_mechanics/#4-key-physical-systems","title":"4. Key Physical Systems","text":""},{"location":"theory/07_emergence_classical_mechanics/#41-free-particle","title":"4.1 Free Particle","text":"<p>Setup: A node with constant structural frequency \u03bdf and no coherence gradients.</p> <p>Equations:</p> <p>[ U(q) = 0 \\quad \\Rightarrow \\quad \\nabla U = 0 ]</p> <p>[ m\\ddot{q} = 0 \\quad \\Rightarrow \\quad \\ddot{q} = 0 ]</p> <p>Solution:</p> <p>[ q(t) = q_0 + v_0 t ]</p> <p>Uniform motion at constant velocity v\u2080.</p> <p>TNFR Interpretation: In the absence of coherence gradients, structural reorganization proceeds at a constant rate. The node \"drifts\" through configuration space with no forces to accelerate or decelerate it.</p> <p>Mass from Frequency:</p> <p>[ m = \\frac{1}{\\nu_f} ]</p> <p>Higher \u03bdf \u2192 lower mass \u2192 faster structural response (though in this case, no forces act, so velocity remains constant regardless).</p>"},{"location":"theory/07_emergence_classical_mechanics/#42-harmonic-oscillator","title":"4.2 Harmonic Oscillator","text":"<p>Setup: A node coupled to a coherence potential quadratic in displacement.</p> <p>Potential:</p> <p>[ U(q) = \\frac{1}{2}k q^2 ]</p> <p>where k is the \"stiffness\" of the coherence landscape.</p> <p>Equation of Motion:</p> <p>[ m\\ddot{q} = -\\nabla U = -kq ]</p> <p>[ \\ddot{q} + \\omega_0^2 q = 0 ]</p> <p>where the natural frequency is:</p> <p>[ \\omega_0 = \\sqrt{\\frac{k}{m}} = \\sqrt{k \\cdot \\nu_f} ]</p> <p>Solution:</p> <p>[ q(t) = A \\cos(\\omega_0 t + \\phi) ]</p> <p>Sinusoidal oscillation with amplitude A and phase \u03c6.</p> <p>Period:</p> <p>[ T = \\frac{2\\pi}{\\omega_0} = 2\\pi\\sqrt{\\frac{m}{k}} = \\frac{2\\pi}{\\sqrt{k\\nu_f}} ]</p> <p>TNFR Interpretation: The harmonic oscillator represents a node in a parabolic coherence well. Displacements from equilibrium reduce coherence (increase U), creating a restoring gradient. The node oscillates as it trades kinetic coherence (motion) for potential coherence (position).</p> <p>Structural Frequency \u03bdf: Higher \u03bdf \u2192 lower m \u2192 higher \u03c9\u2080 \u2192 faster oscillations. Nodes that reorganize rapidly (high \u03bdf) oscillate at higher frequencies.</p> <p>Energy:</p> <p>[ E = \\frac{1}{2}m\\dot{q}^2 + \\frac{1}{2}kq^2 = \\frac{1}{2}kA^2 ]</p> <p>Energy is conserved (in the \u03b5 \u2192 0 limit), oscillating between kinetic and potential forms.</p>"},{"location":"theory/07_emergence_classical_mechanics/#43-central-potential","title":"4.3 Central Potential","text":"<p>Setup: A node in a spherically symmetric coherence potential (e.g., gravitational or Coulomb).</p> <p>Potential:</p> <p>[ U(r) = U(|q|) ]</p> <p>depends only on distance r from origin.</p> <p>Equations of Motion:</p> <p>[ m\\ddot{q} = -\\nabla U = -\\frac{dU}{dr}\\frac{q}{r} ]</p> <p>Angular Momentum Conservation: Since the potential is central, L = q \u00d7 p is conserved (as shown in Section 3.3).</p> <p>Effective 1D Problem: Using spherical coordinates (r, \u03b8, \u03c6), the problem reduces to:</p> <p>[ m\\ddot{r} = -\\frac{dU}{dr} + \\frac{L^2}{mr^3} ]</p> <p>where the second term is the centrifugal barrier.</p> <p>Effective Potential:</p> <p>[ U_{\\text{eff}}(r) = U(r) + \\frac{L^2}{2mr^2} ]</p> <p>TNFR Interpretation: Central potentials represent radially symmetric coherence landscapes. Angular momentum conservation reflects rotational symmetry \u2014 the network structure is isotropic. The centrifugal term emerges from the competition between radial reorganization and angular rotation.</p> <p>Example: Kepler Problem (Gravitational or Coulomb):</p> <p>[ U(r) = -\\frac{\\alpha}{r} ]</p> <p>Leads to elliptical orbits (closed trajectories) in the \u03b5 \u2192 0 limit.</p>"},{"location":"theory/07_emergence_classical_mechanics/#44-damped-oscillator","title":"4.4 Damped Oscillator","text":"<p>Setup: A harmonic oscillator with structural dissipation (nonzero dissonance \u03b5).</p> <p>Equation of Motion:</p> <p>[ m\\ddot{q} + \\gamma \\dot{q} + kq = 0 ]</p> <p>where \u03b3 is the damping coefficient arising from structural dissonance.</p> <p>Rewriting:</p> <p>[ \\ddot{q} + 2\\zeta\\omega_0\\dot{q} + \\omega_0^2 q = 0 ]</p> <p>where: - \u03b6 = \u03b3/(2m\u03c9\u2080) is the damping ratio - \u03c9\u2080 = \u221a(k/m) is the natural frequency</p> <p>Three Regimes:</p> <ol> <li>Underdamped (\u03b6 &lt; 1): Oscillatory decay</li> </ol> <p>[ q(t) = A e^{-\\zeta\\omega_0 t}\\cos(\\omega_d t + \\phi) ]</p> <p>where \u03c9d = \u03c9\u2080\u221a(1 - \u03b6\u00b2) is the damped frequency.</p> <ol> <li>Critically damped (\u03b6 = 1): Fastest return to equilibrium without oscillation</li> </ol> <p>[ q(t) = (A + Bt)e^{-\\omega_0 t} ]</p> <ol> <li>Overdamped (\u03b6 &gt; 1): Exponential decay without oscillation</li> </ol> <p>[ q(t) = A e^{-\\lambda_1 t} + B e^{-\\lambda_2 t} ]</p> <p>TNFR Interpretation: Damping arises from structural dissonance (\u03b5 &gt; 0). Imperfect phase coherence causes energy to dissipate from the oscillating node into the surrounding network. The system gradually loses coherent kinetic and potential energy, settling into a minimum of the coherence potential.</p> <p>Energy Decay:</p> <p>[ \\frac{dE}{dt} = -\\gamma\\dot{q}^2 &lt; 0 ]</p> <p>Energy decreases monotonically, a direct manifestation of the Second Law of Thermodynamics emerging from structural dissonance.</p>"},{"location":"theory/07_emergence_classical_mechanics/#45-duffing-oscillator","title":"4.5 Duffing Oscillator","text":"<p>Setup: A nonlinear oscillator with cubic potential term.</p> <p>Potential:</p> <p>[ U(q) = \\frac{1}{2}kq^2 + \\frac{1}{4}\\beta q^4 ]</p> <p>Equation of Motion:</p> <p>[ m\\ddot{q} + kq + \\beta q^3 = 0 ]</p> <p>or in dimensionless form:</p> <p>[ \\ddot{q} + \\omega_0^2 q + \\alpha q^3 = 0 ]</p> <p>Behavior: - \u03b2 &gt; 0 (hardening spring): Frequency increases with amplitude - \u03b2 &lt; 0 (softening spring): Frequency decreases with amplitude</p> <p>Chaos: With periodic forcing and damping:</p> <p>[ \\ddot{q} + 2\\zeta\\omega_0\\dot{q} + \\omega_0^2 q + \\alpha q^3 = F_0\\cos(\\omega t) ]</p> <p>the system exhibits chaotic behavior for certain parameter ranges.</p> <p>TNFR Interpretation: The Duffing oscillator represents a nonlinear coherence landscape. The quartic term captures structural anharmonicity \u2014 deviations from the simple parabolic well. Large displacements encounter different structural rigidities, leading to amplitude-dependent dynamics.</p> <p>Bifurcations: As parameters vary, the system undergoes structural bifurcations (mutations in TNFR language), transitioning between: - Periodic orbits - Quasi-periodic orbits - Chaotic attractors</p> <p>This demonstrates how classical determinism breaks down even in simple systems, presaging the quantum-to-classical transition in the TNFR hierarchy.</p>"},{"location":"theory/07_emergence_classical_mechanics/#5-validation-criteria","title":"5. Validation Criteria","text":""},{"location":"theory/07_emergence_classical_mechanics/#51-dimensional-consistency","title":"5.1 Dimensional Consistency","text":"<p>All TNFR-to-classical mappings must be dimensionally consistent. Here we verify the key relationships:</p>"},{"location":"theory/07_emergence_classical_mechanics/#511-mass-and-structural-frequency","title":"5.1.1 Mass and Structural Frequency","text":"<p>Claim: ( m = \\frac{1}{\\nu_f} )</p> <p>Dimensional Analysis:</p> <p>[ [m] = \\text{kg} = \\text{mass} ]</p> <p>[ [\\nu_f] = \\text{Hz}_{\\text{str}} = \\text{structural frequency} = \\frac{1}{\\text{time}} ]</p> <p>[ \\left[\\frac{1}{\\nu_f}\\right] = \\text{time} ]</p> <p>Problem: Dimensions don't match directly.</p> <p>Resolution: The structural frequency \u03bdf is not a raw frequency but a scaled frequency related to physical frequency by:</p> <p>[ \\nu_f = \\frac{\\hbar_{\\text{str}}}{k_B T_{\\text{ref}}} \\cdot f_{\\text{physical}} ]</p> <p>where: - \u210f_str is the structural Planck constant - k_B is Boltzmann constant - T_ref is a reference temperature</p> <p>Then:</p> <p>[ m = \\frac{k_B T_{\\text{ref}}}{\\hbar_{\\text{str}} \\cdot f_{\\text{physical}}} ]</p> <p>which has dimensions of energy/frequency = mass (via E = mc\u00b2 and \u210ff = E).</p> <p>Correct Formulation:</p> <p>[ m = \\frac{\\hbar_{\\text{str}}}{\\nu_f} ]</p> <p>gives [m] = [energy\u00b7time / (1/time)] = [energy\u00b7time\u00b2] = mass (in natural units where c = 1).</p>"},{"location":"theory/07_emergence_classical_mechanics/#512-energy-and-coherence","title":"5.1.2 Energy and Coherence","text":"<p>Claim: ( E = \\frac{1}{2}m\\dot{q}^2 + U(q) )</p> <p>Dimensional Analysis:</p> <p>[ [K] = [m][\\dot{q}]^2 = \\text{mass} \\cdot \\left(\\frac{\\text{length}}{\\text{time}}\\right)^2 = \\text{energy} ]</p> <p>[ [U] = [\\nu_f \\cdot \\hbar_{\\text{str}}] = \\frac{1}{\\text{time}} \\cdot \\text{energy} \\cdot \\text{time} = \\text{energy} ]</p> <p>Both kinetic and potential terms have dimensions of energy. \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#513-force-and-coherence-gradient","title":"5.1.3 Force and Coherence Gradient","text":"<p>Claim: ( F = -\\nabla U )</p> <p>Dimensional Analysis:</p> <p>[ [F] = \\text{force} = \\frac{\\text{energy}}{\\text{length}} ]</p> <p>[ [\\nabla U] = \\frac{[U]}{[\\text{length}]} = \\frac{\\text{energy}}{\\text{length}} ]</p> <p>Dimensions match. \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#52-limit-recovery","title":"5.2 Limit Recovery","text":"<p>Criterion: As \u03b5 \u2192 0 (dissonance vanishes), TNFR must recover deterministic classical mechanics.</p>"},{"location":"theory/07_emergence_classical_mechanics/#521-determinism","title":"5.2.1 Determinism","text":"<p>Classical: Given initial conditions (q\u2080, p\u2080), the future state (q(t), p(t)) is uniquely determined.</p> <p>TNFR: In the low-dissonance limit:</p> <p>[ \\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t) ]</p> <p>becomes deterministic. The stochastic/quantum fluctuations scale as:</p> <p>[ \\Delta q \\sim \\sqrt{\\frac{\\hbar_{\\text{str}}}{m\\omega}} \\sim \\sqrt{\\varepsilon} ]</p> <p>As \u03b5 \u2192 0, fluctuations vanish, and trajectories become deterministic. \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#522-trajectory-uniqueness","title":"5.2.2 Trajectory Uniqueness","text":"<p>Classical: Solutions to Newton's equations are unique given smooth potentials.</p> <p>TNFR: The nodal equation with smooth \u0394NFR admits unique solutions (by existence and uniqueness theorems for ODEs). \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#53-observable-correspondence","title":"5.3 Observable Correspondence","text":"<p>Criterion: Classical observables must map consistently to TNFR structures.</p>"},{"location":"theory/07_emergence_classical_mechanics/#531-position-qt","title":"5.3.1 Position q(t)","text":"<p>Classical: Position is a continuous function q: \u211d \u2192 \u211d\u207f.</p> <p>TNFR: Position emerges as a projection of EPI onto configuration space:</p> <p>[ q = \\pi_q(\\text{EPI}) ]</p> <p>This projection is well-defined and continuous in the classical limit. \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#532-momentum-pt","title":"5.3.2 Momentum p(t)","text":"<p>Classical: Momentum p = m\u00b7dq/dt.</p> <p>TNFR: Momentum emerges from the structural velocity:</p> <p>[ p = M(q) \\dot{q} = \\frac{1}{\\nu_f}\\dot{q} ]</p> <p>This is measurable via phase space reconstruction from node trajectories. \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#533-energy-e","title":"5.3.3 Energy E","text":"<p>Classical: E = K + U.</p> <p>TNFR: Energy corresponds to total coherence (kinetic + potential):</p> <p>[ E = \\frac{1}{2}\\nu_f^{-1}\\dot{q}^2 + U(q) ]</p> <p>Measurable via coherence metrics C(t) and sense index Si. \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#54-symmetry-correspondence","title":"5.4 Symmetry Correspondence","text":"<p>Criterion: Classical symmetries must emerge from TNFR network symmetries.</p> Classical Symmetry TNFR Network Symmetry Conserved Quantity Time translation Uniform evolution (no explicit time dependence) Energy E Space translation Spatial homogeneity (no preferred location) Momentum p Rotation Isotropic coupling (no preferred direction) Angular momentum L <p>Each correspondence is verified both theoretically (Noether's theorem applies) and numerically (simulations confirm conservation to accuracy ~\u03b5). \u2713</p>"},{"location":"theory/07_emergence_classical_mechanics/#6-summary-and-outlook","title":"6. Summary and Outlook","text":""},{"location":"theory/07_emergence_classical_mechanics/#61-key-results","title":"6.1 Key Results","text":"<p>We have demonstrated that classical mechanics emerges naturally from TNFR as the low-dissonance limit of structural dynamics:</p> <ol> <li> <p>Mass = 1/\u03bdf: Mass is the inverse of structural reorganization rate \u2014 an emergent property, not a fundamental one.</p> </li> <li> <p>Force = -\u2207U: Force is the gradient of the coherence potential \u2014 structural stability drives motion.</p> </li> <li> <p>Newton's Laws: The nodal equation (\\partial\\text{EPI}/\\partial t = \\nu_f \\cdot \\Delta\\text{NFR}) reduces to (F = m\\ddot{q}) when \u03b5 \u2192 0.</p> </li> <li> <p>Conservation Laws: Energy, momentum, and angular momentum conservation emerge from time, space, and rotational symmetries of the NFR network (Noether's theorem).</p> </li> <li> <p>Classical Systems: Free particles, harmonic oscillators, central potentials, damped oscillators, and nonlinear (Duffing) oscillators all arise naturally from different coherence landscapes.</p> </li> <li> <p>Validation: Dimensional consistency, limit recovery, observable correspondence, and symmetry correspondence are all rigorously satisfied.</p> </li> </ol>"},{"location":"theory/07_emergence_classical_mechanics/#62-classical-mechanics-as-effective-grammar","title":"6.2 Classical Mechanics as Effective Grammar","text":"<p>Classical mechanics is not a \"fundamental theory\" in TNFR but an effective grammar \u2014 a simplified language describing systems where: - Structural dissonance is negligible - Phase coherence is nearly perfect - Quantum fluctuations are small compared to macroscopic scales</p> <p>This explains why classical mechanics works so well for macroscopic systems while failing at atomic scales (where \u03b5 is not small) and cosmological scales (where spacetime curvature matters).</p>"},{"location":"theory/07_emergence_classical_mechanics/#63-open-questions-and-future-directions","title":"6.3 Open Questions and Future Directions","text":"<p>Several avenues remain for deeper exploration:</p> <ol> <li> <p>Euler-Lagrange Formulation: Detailed treatment of variational principles and Hamiltonian mechanics from TNFR (to be covered in future documentation).</p> </li> <li> <p>Statistical Mechanics: How does thermal behavior emerge from networks of classical nodes? Connection to coherence entropy.</p> </li> <li> <p>Continuum Limit: Deriving classical field theories (fluids, elasticity) from many-node NFR networks.</p> </li> <li> <p>Chaos and Integrability: Characterizing when structural dissonance leads to chaotic classical dynamics vs. integrable systems.</p> </li> <li> <p>Measurement Theory: How do classical observables \"collapse\" from quantum-like structural superpositions in the TNFR framework?</p> </li> </ol>"},{"location":"theory/07_emergence_classical_mechanics/#64-cross-references","title":"6.4 Cross-References","text":"<p>Related Documentation: - Mathematical Foundations: <code>docs/source/theory/mathematical_foundations.md</code> \u2014 Operator formalism, Hilbert spaces - Structural Frequency Primer: <code>docs/source/theory/01_structural_frequency_primer.ipynb</code> \u2014 Understanding \u03bdf - \u0394NFR Gradient Fields: <code>docs/source/theory/03_delta_nfr_gradient_fields.ipynb</code> \u2014 The reorganization operator - Coherence Metrics: <code>docs/source/theory/04_coherence_metrics_walkthrough.ipynb</code> \u2014 Measuring C(t) and U(q)</p> <p>Notebooks Demonstrating Classical Emergence: - <code>examples/01_unitary_minimal.ipynb</code> \u2014 Time evolution and conservation - <code>examples/02_dissipative_minimal.ipynb</code> \u2014 Damped systems and dissipation</p>"},{"location":"theory/07_emergence_classical_mechanics/#references","title":"References","text":"<ol> <li>TNFR Foundational Document: <code>TNFR.pdf</code> \u2014 Complete paradigm description</li> <li>Mathematical Foundations: <code>docs/source/theory/mathematical_foundations.md</code> \u2014 Hilbert space formalism</li> <li>Noether's Theorem: E. Noether (1918), \"Invariante Variationsprobleme\"</li> <li>Classical Mechanics: Goldstein, Poole, Safko (2001), \"Classical Mechanics\" (3rd ed.)</li> <li>Lagrangian Mechanics: Landau &amp; Lifshitz (1976), \"Mechanics\" (3rd ed.)</li> </ol> <p>Document Status: v1.0 Author: TNFR Python Engine Team Last Updated: 2025-11-07 License: MIT (see repository LICENSE.md)</p>"},{"location":"theory/07_emergence_classical_mechanics/#related-documentation","title":"Related Documentation","text":"<ul> <li>\u2192 Next: Euler-Lagrange Correspondence \u2014 Variational formulation</li> <li>\u2192 Validation: Numerical Validation \u2014 Computational experiments</li> <li>\u2191 Back to: Theory Index</li> <li>\u2b50 Foundation: Mathematical Foundations \u2014 Complete TNFR formalism</li> </ul>"},{"location":"theory/08_classical_mechanics_euler_lagrange/","title":"Euler-Lagrange Correspondence in TNFR","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#1-introduction-variational-principles-from-resonance","title":"1. Introduction: Variational Principles from Resonance","text":"<p>This document establishes the rigorous mathematical correspondence between TNFR nodal dynamics and the Euler-Lagrange equations of classical mechanics. We prove that the variational formulation of mechanics\u2014central to classical and modern physics\u2014emerges naturally as the \u03b5 \u2192 0 limit of TNFR structural coherence.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#11-connection-to-classical-mechanics-emergence","title":"1.1 Connection to Classical Mechanics Emergence","text":"<p>This document extends the framework developed in 07_emergence_classical_mechanics.md, where we showed that:</p> <ul> <li>Mass emerges as m = 1/\u03bdf (inverse structural frequency)</li> <li>Force emerges as F = -\u2207U (coherence gradient)</li> <li>Newton's laws emerge from the nodal equation in low-dissonance regimes</li> </ul> <p>Here we go deeper, proving that the action principle and Lagrangian formulation are not separate postulates but structural consequences of resonant coherence dynamics.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#12-the-key-insight-action-as-coherence-flow","title":"1.2 The Key Insight: Action as Coherence Flow","text":"<p>In TNFR, the classical action functional:</p> <p>[ S[q] = \\int_{t_1}^{t_2} L(q, \\dot{q}, t) \\, dt ]</p> <p>is reinterpreted as the integrated coherence flow through configuration space. The Lagrangian L = K - U measures the net structural reorganization at each instant:</p> <ul> <li>K (kinetic term): Coherence in motion (reorganization velocity)</li> <li>U (potential term): Coherence in configuration (structural stability)</li> </ul> <p>The principle of stationary action (\u03b4S = 0) states that actual trajectories extremize coherence flow\u2014nodes follow paths that optimize structural stability over time.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#2-functional-framework","title":"2. Functional Framework","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#21-configuration-space-and-trajectories","title":"2.1 Configuration Space and Trajectories","text":"<p>Configuration space: ( q: I \\to \\mathbb{R}^n ), where ( I = [t_1, t_2] ) is the time interval.</p> <p>Trajectory class: ( q \\in C^2(I) ) (twice continuously differentiable), representing smooth structural evolution.</p> <p>Boundary conditions: ( q(t_1) = q_1 ) and ( q(t_2) = q_2 ) are fixed (endpoints of structural reorganization).</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#22-structural-inertial-metric","title":"2.2 Structural Inertial Metric","text":"<p>Definition: ( M(q, t) ) is a symmetric positive definite matrix encoding the structural rigidity at configuration ( q ).</p> <p>Physical meaning: Each element ( M_{ij}(q, t) ) measures the \"inertia\" of structural reorganization along the ( i )-th and ( j )-th directions in configuration space.</p> <p>TNFR interpretation: </p> <p>[ M(q, t) = \\text{diag}\\left(\\frac{1}{\\nu_f^1}, \\frac{1}{\\nu_f^2}, \\ldots, \\frac{1}{\\nu_f^n}\\right) ]</p> <p>where ( \\nu_f^i ) is the structural frequency along coordinate ( q^i ). Higher ( \\nu_f ) means lower mass (faster reorganization); lower ( \\nu_f ) means higher mass (slower reorganization).</p> <p>Properties: - Symmetry: ( M = M^T ) - Positive definiteness: ( x^T M x &gt; 0 ) for all ( x \\neq 0 )</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#23-coherence-potential","title":"2.3 Coherence Potential","text":"<p>Definition: ( U(q, t) ) is the coherence potential, measuring structural stability at configuration ( q ).</p> <p>Physical meaning: Lower ( U ) means higher coherence (more stable structure); higher ( U ) means lower coherence (less stable structure).</p> <p>Gradient: ( \\nabla U(q, t) = \\left(\\frac{\\partial U}{\\partial q^1}, \\ldots, \\frac{\\partial U}{\\partial q^n}\\right) ) points toward decreasing coherence.</p> <p>Force: ( F = -\\nabla U ) points toward increasing coherence (the \"pull\" of structural stability).</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#24-kinetic-energy-and-lagrangian","title":"2.4 Kinetic Energy and Lagrangian","text":"<p>Kinetic energy:</p> <p>[ K(q, \\dot{q}, t) = \\frac{1}{2} \\dot{q}^T M(q, t) \\dot{q} ]</p> <p>TNFR interpretation: Measures coherence in structural reorganization velocity. Rapid reorganization (large ( \\dot{q} )) with high mass (large ( M )) stores significant kinetic coherence.</p> <p>Effective Lagrangian:</p> <p>[ L(q, \\dot{q}, t) = K - U = \\frac{1}{2} \\dot{q}^T M(q, t) \\dot{q} - U(q, t) ]</p> <p>Physical meaning: Net structural coherence\u2014kinetic coherence minus potential coherence.</p> <p>Action functional:</p> <p>[ S[q] = \\int_{t_1}^{t_2} L(q, \\dot{q}, t) \\, dt ]</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#3-assumptions-low-dissonance-and-regularity","title":"3. Assumptions: Low Dissonance and Regularity","text":"<p>To establish the correspondence between TNFR and Euler-Lagrange equations, we require three structural assumptions:</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#assumption-1-low-dissonance","title":"Assumption 1 (Low Dissonance)","text":"<p>The internal reorganization operator ( \\Delta\\text{NFR} ) admits the decomposition:</p> <p>[ \\Delta\\text{NFR}(q, \\dot{q}, t) = -\\nabla U(q, t) - D \\dot{q} + r(q, \\dot{q}, t) ]</p> <p>where: - ( -\\nabla U ): Coherence gradient (conservative force) - ( D \\geq 0 ): Dissipation matrix (structural dissonance/damping) - ( r(q, \\dot{q}, t) ): Residual term satisfying ( |r| \\leq \\varepsilon (1 + |\\dot{q}|) )</p> <p>Parameter: ( \\varepsilon \\geq 0 ) is the dissonance parameter. As ( \\varepsilon \\to 0 ), structural dissonance vanishes, and classical mechanics emerges.</p> <p>Physical meaning: In low-dissonance regimes, \u0394NFR is dominated by smooth coherence gradients and controlled dissipation, with only small higher-order corrections.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#assumption-2-controlled-metric","title":"Assumption 2 (Controlled Metric)","text":"<p>The structural inertial metric ( M(q, t) ) satisfies coercivity and boundedness:</p> <p>[ m_ |x|^2 \\leq x^T M(q, t) x \\leq m^ |x|^2 ]</p> <p>for all ( x \\in \\mathbb{R}^n ) and constants ( 0 &lt; m_ \\leq m^ &lt; \\infty ).</p> <p>Physical meaning: Structural masses are bounded\u2014no infinite inertia (m &lt; \u221e) and no zero mass (m &gt; 0). This ensures well-posed dynamics.</p> <p>Smoothness: We also require ( M \\in C^1 ), meaning the metric changes smoothly with configuration.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#assumption-3-structural-power-balance","title":"Assumption 3 (Structural Power Balance)","text":"<p>The rate of change of kinetic energy equals the power supplied by structural gradients and dissipation:</p> <p>[ \\frac{dK}{dt} = \\dot{q}^T (-\\nabla U - D \\dot{q} + r) ]</p> <p>Physical meaning: This is the energy balance equation in TNFR. Kinetic coherence changes due to: - Coherence gradients: ( \\dot{q}^T (-\\nabla U) ) (conversion between kinetic and potential) - Dissipation: ( -\\dot{q}^T D \\dot{q} \\leq 0 ) (energy loss) - Residual couplings: ( \\dot{q}^T r ) (small higher-order effects)</p> <p>Connection to nodal equation: This follows from projecting ( \\partial\\text{EPI}/\\partial t = \\nu_f \\cdot \\Delta\\text{NFR} ) onto velocity space.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#4-main-theorem-tnfreuler-lagrange-correspondence","title":"4. Main Theorem: TNFR\u2013Euler-Lagrange Correspondence","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#theorem-41-tnfr-euler-lagrange","title":"Theorem 4.1 (TNFR \u2192 Euler-Lagrange)","text":"<p>Statement: Under Assumptions 1\u20133, any trajectory ( q \\in C^2(I) ) satisfying the structural power balance verifies:</p> <p>[ M(q, t) \\ddot{q} + \\nabla U(q, t) + D \\dot{q} = \\rho(q, \\dot{q}, t) ]</p> <p>where the residual ( \\rho ) satisfies:</p> <p>[ |\\rho(q, \\dot{q}, t)| \\leq \\varepsilon \\left[1 + \\left(1 + \\frac{c_M}{2}\\right)|\\dot{q}|\\right] ]</p> <p>with ( c_M = \\sup_{q,t} |\\partial M/\\partial q| ) (metric variation constant).</p> <p>In the limit ( \\varepsilon \\to 0 ): - Conservative case (( D = 0 )): Recovers the Euler-Lagrange equations of ( L ):   [   \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right) - \\frac{\\partial L}{\\partial q} = 0   ]</p> <ul> <li>Dissipative case (( D &gt; 0 )): Recovers the Lagrange-d'Alembert form with dissipation:   [   \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right) - \\frac{\\partial L}{\\partial q} = -D \\dot{q}   ]</li> </ul>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#42-proof-sketch","title":"4.2 Proof Sketch","text":"<p>Step 1: Expand the kinetic energy time derivative:</p> <p>[ \\frac{dK}{dt} = \\frac{d}{dt}\\left(\\frac{1}{2}\\dot{q}^T M \\dot{q}\\right) = \\dot{q}^T M \\ddot{q} + \\frac{1}{2}\\dot{q}^T \\dot{M} \\dot{q} ]</p> <p>where ( \\dot{M} = \\frac{\\partial M}{\\partial q}\\dot{q} + \\frac{\\partial M}{\\partial t} ).</p> <p>Step 2: Apply Assumption 3 (power balance):</p> <p>[ \\dot{q}^T M \\ddot{q} + \\frac{1}{2}\\dot{q}^T \\dot{M} \\dot{q} = \\dot{q}^T(-\\nabla U - D\\dot{q} + r) ]</p> <p>Step 3: Rearrange as a virtual work identity:</p> <p>[ \\dot{q}^T \\left[M \\ddot{q} + \\nabla U + D\\dot{q} - r + \\frac{1}{2}\\dot{M}\\dot{q}\\right] = 0 ]</p> <p>Step 4: Define the structural residual:</p> <p>[ \\Xi := M \\ddot{q} + \\nabla U + D\\dot{q} - r + \\frac{1}{2}\\dot{M}\\dot{q} ]</p> <p>Since ( \\dot{q}^T \\Xi = 0 ) for all trajectories satisfying the power balance, and this must hold for arbitrary virtual velocities, we apply the Du Bois-Reymond lemma (calculus of variations) to conclude:</p> <p>[ \\Xi = 0 \\quad \\Rightarrow \\quad M\\ddot{q} + \\nabla U + D\\dot{q} = r - \\frac{1}{2}\\dot{M}\\dot{q} ]</p> <p>Step 5: Bound the residual. Using Assumption 1 (( |r| \\leq \\varepsilon(1 + |\\dot{q}|) )) and the metric smoothness bound:</p> <p>[ \\left|r - \\frac{1}{2}\\dot{M}\\dot{q}\\right| \\leq |r| + \\frac{1}{2}|\\dot{M}||\\dot{q}| \\leq \\varepsilon(1 + |\\dot{q}|) + \\frac{c_M}{2}|\\dot{q}|^2 ]</p> <p>For bounded velocities ( |\\dot{q}| \\leq v_{\\max} ), the quadratic term is absorbed: ( c_M|\\dot{q}|^2/2 \\leq (c_M v_{\\max}/2)|\\dot{q}| ), giving:</p> <p>[ |\\rho| \\leq \\varepsilon\\left[1 + \\left(1 + \\frac{c_M}{2}\\right)|\\dot{q}|\\right] ]</p> <p>matching the theorem statement. \u220e</p> <p>Consequence: As ( \\varepsilon \\to 0 ), the residual ( \\rho \\to 0 ), and we recover the exact Euler-Lagrange equations of classical mechanics.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#5-corollaries-conservation-and-dissipation","title":"5. Corollaries: Conservation and Dissipation","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#corollary-51-noether-tnfr-quasi-conservation","title":"Corollary 5.1 (Noether-TNFR: Quasi-Conservation)","text":"<p>Statement: If ( \\frac{\\partial U}{\\partial q^i} \\equiv 0 ) (coherence potential independent of ( q^i )) and ( M = \\text{const} ), then the generalized momentum:</p> <p>[ p_i = (M\\dot{q})_i ]</p> <p>satisfies quasi-conservation:</p> <p>[ |p_i(t) - p_i(s)| \\leq C\\varepsilon |t - s| ]</p> <p>for some constant ( C ) depending on ( D ), ( m^* ), and bounds on ( |\\dot{q}| ).</p> <p>Proof sketch: From the main theorem, the ( i )-th component equation is:</p> <p>[ \\frac{dp_i}{dt} = M_{ii}\\ddot{q}^i = -\\frac{\\partial U}{\\partial q^i} - D_{ii}\\dot{q}^i + \\rho_i = -D_{ii}\\dot{q}^i + \\rho_i ]</p> <p>(using ( \\partial U/\\partial q^i = 0 )). Integrating over ( [s, t] ):</p> <p>[ |p_i(t) - p_i(s)| \\leq \\int_s^t |D_{ii}\\dot{q}^i| + |\\rho_i| \\, d\\tau \\leq C\\varepsilon|t-s| ]</p> <p>Physical meaning: In TNFR, conservation laws are approximate for finite dissonance. They hold exactly only as ( \\varepsilon \\to 0 ). This explains phenomena like: - Slow drift in orbits due to tidal dissipation - Gradual momentum loss in damped systems - Decoherence timescales in quantum-classical transitions</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#corollary-52-energy-dissipation","title":"Corollary 5.2 (Energy Dissipation)","text":"<p>Statement: If ( r \\equiv 0 ) (no residual terms), then the total energy:</p> <p>[ E = K + U = \\frac{1}{2}\\dot{q}^T M\\dot{q} + U(q) ]</p> <p>satisfies:</p> <p>[ \\frac{dE}{dt} = -\\dot{q}^T D \\dot{q} \\leq 0 ]</p> <p>Proof: Compute:</p> <p>[ \\frac{dE}{dt} = \\frac{dK}{dt} + \\frac{dU}{dt} = \\dot{q}^T(-\\nabla U - D\\dot{q}) + \\dot{q}^T \\nabla U = -\\dot{q}^T D\\dot{q} ]</p> <p>Since ( D \\geq 0 ) (positive semi-definite), we have ( \\dot{q}^T D\\dot{q} \\geq 0 ), thus ( dE/dt \\leq 0 ). \u220e</p> <p>Physical meaning: Energy monotonically decreases in dissipative systems. This is the Second Law of Thermodynamics emerging from structural dissonance in TNFR.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#6-worked-examples","title":"6. Worked Examples","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#61-harmonic-oscillator","title":"6.1 Harmonic Oscillator","text":"<p>Setup: A single degree of freedom ( q \\in \\mathbb{R} ) with quadratic coherence potential.</p> <p>Coherence potential:</p> <p>[ U(q) = \\frac{1}{2}k q^2 ]</p> <p>where ( k &gt; 0 ) is the \"stiffness\" of the coherence landscape.</p> <p>Structural mass: ( M = m = 1/\\nu_f ) (constant).</p> <p>Equation of motion: From the main theorem (Theorem 4.1) with ( \\varepsilon \\to 0 ), ( D = 0 ):</p> <p>[ m\\ddot{q} + kq = 0 ]</p> <p>Solution:</p> <p>[ q(t) = A\\cos(\\omega_0 t + \\phi) ]</p> <p>where: - Natural frequency: ( \\omega_0 = \\sqrt{k/m} = \\sqrt{k \\nu_f} ) - Period: ( T = 2\\pi/\\omega_0 = 2\\pi\\sqrt{m/k} = 2\\pi/\\sqrt{k\\nu_f} ) - Amplitude: ( A ), Phase: ( \\phi ) (determined by initial conditions)</p> <p>Energy:</p> <p>[ E = \\frac{1}{2}m\\dot{q}^2 + \\frac{1}{2}kq^2 = \\frac{1}{2}kA^2 = \\text{const} ]</p> <p>TNFR interpretation: The harmonic oscillator represents a node in a parabolic coherence well. The node oscillates as it trades kinetic coherence (motion) for potential coherence (position). Higher ( \\nu_f ) leads to faster oscillations (higher ( \\omega_0 )).</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#62-central-potential","title":"6.2 Central Potential","text":"<p>Setup: A particle in 3D space with spherically symmetric coherence potential.</p> <p>Coherence potential:</p> <p>[ U(r) = U(|q|) = -\\frac{\\kappa}{|q|} ]</p> <p>(e.g., gravitational or Coulomb potential, with ( \\kappa = Gm_1m_2 ) or ( \\kappa = ke^2 )).</p> <p>Angular momentum: Due to rotational symmetry, angular momentum:</p> <p>[ L = q \\times p = q \\times (m\\dot{q}) ]</p> <p>is conserved (Corollary 5.1 applies in each angular direction).</p> <p>Effective 1D problem: Using spherical coordinates, the radial equation becomes:</p> <p>[ m\\ddot{r} = -\\frac{dU}{dr} + \\frac{L^2}{mr^3} ]</p> <p>where the second term is the centrifugal barrier.</p> <p>Quasi-conservation: In TNFR with finite ( \\varepsilon ), angular momentum drifts slowly:</p> <p>[ |\\mathbf{L}(t) - \\mathbf{L}(0)| \\leq C\\varepsilon t ]</p> <p>This explains: - Precession of orbits (e.g., Mercury's perihelion precession when relativistic corrections are included) - Orbital decay in systems with tidal dissipation (( D \\neq 0 ))</p> <p>Classical limit: As ( \\varepsilon \\to 0 ), we recover Kepler's laws for closed elliptical orbits (or hyperbolic/parabolic trajectories).</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#63-duffing-oscillator","title":"6.3 Duffing Oscillator","text":"<p>Setup: A nonlinear oscillator with cubic potential term.</p> <p>Coherence potential:</p> <p>[ U(q) = \\frac{1}{2}\\alpha q^2 + \\frac{1}{4}\\beta q^4 ]</p> <p>where: - ( \\alpha &gt; 0 ): Linear restoring term - ( \\beta ): Nonlinear term (( \\beta &gt; 0 ) for hardening, ( \\beta &lt; 0 ) for softening)</p> <p>Equation of motion:</p> <p>[ m\\ddot{q} + \\alpha q + \\beta q^3 = 0 ]</p> <p>Behavior: - Hardening (( \\beta &gt; 0 )): Frequency increases with amplitude - Softening (( \\beta &lt; 0 )): Frequency decreases with amplitude - Bifurcations: As parameters vary, the system can undergo structural transitions (chaos, period-doubling)</p> <p>TNFR interpretation: The quartic term captures structural anharmonicity\u2014the coherence landscape is non-parabolic. Large displacements encounter different structural rigidities. The nonlinearity is fully absorbed in ( \\nabla U = \\alpha q + \\beta q^3 ), requiring no new structural operators.</p> <p>Energy:</p> <p>[ E = \\frac{1}{2}m\\dot{q}^2 + \\frac{1}{2}\\alpha q^2 + \\frac{1}{4}\\beta q^4 ]</p> <p>For ( \\beta &gt; 0 ), energy wells are deeper at large ( |q| ), leading to amplitude-dependent periods.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#7-variational-principle-and-du-bois-reymond-lemma","title":"7. Variational Principle and Du Bois-Reymond Lemma","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#71-stationary-action","title":"7.1 Stationary Action","text":"<p>The principle of stationary action states that physical trajectories extremize the action functional:</p> <p>[ \\delta S[q] = 0 ]</p> <p>where:</p> <p>[ S[q] = \\int_{t_1}^{t_2} L(q, \\dot{q}, t) \\, dt ]</p> <p>Meaning: Among all possible paths ( q(t) ) connecting ( q(t_1) = q_1 ) and ( q(t_2) = q_2 ), the actual trajectory is the one that makes ( S ) stationary (usually a minimum).</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#72-euler-lagrange-equations","title":"7.2 Euler-Lagrange Equations","text":"<p>Computing the variation ( \\delta S ) using calculus of variations:</p> <p>[ \\delta S = \\int_{t_1}^{t_2} \\left[\\frac{\\partial L}{\\partial q}\\delta q + \\frac{\\partial L}{\\partial \\dot{q}}\\delta\\dot{q}\\right] dt ]</p> <p>Integrating by parts (and using ( \\delta q(t_1) = \\delta q(t_2) = 0 )):</p> <p>[ \\delta S = \\int_{t_1}^{t_2} \\left[\\frac{\\partial L}{\\partial q} - \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right)\\right]\\delta q \\, dt ]</p> <p>For ( \\delta S = 0 ) to hold for arbitrary variations ( \\delta q ), we must have:</p> <p>[ \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right) - \\frac{\\partial L}{\\partial q} = 0 ]</p> <p>These are the Euler-Lagrange equations.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#73-du-bois-reymond-lemma","title":"7.3 Du Bois-Reymond Lemma","text":"<p>Statement: If ( f(t) ) is a continuous function such that:</p> <p>[ \\int_{t_1}^{t_2} f(t) \\eta(t) \\, dt = 0 ]</p> <p>for all smooth functions ( \\eta(t) ) with ( \\eta(t_1) = \\eta(t_2) = 0 ), then ( f(t) \\equiv 0 ).</p> <p>Application in Theorem 4.1: The power balance gives:</p> <p>[ \\dot{q}^T \\Xi = 0 ]</p> <p>This holds for all trajectories satisfying the structural dynamics. By considering variations (virtual velocities ( \\delta\\dot{q} )), we can apply the Du Bois-Reymond lemma to conclude ( \\Xi = 0 ), yielding the equation of motion.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#74-tnfr-derivation","title":"7.4 TNFR Derivation","text":"<p>Step 1: Start with the nodal equation:</p> <p>[ \\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t) ]</p> <p>Step 2: Project onto configuration space:</p> <p>[ \\frac{dq}{dt} = \\nu_f \\cdot \\pi_q(\\Delta\\text{NFR}) ]</p> <p>where ( \\pi_q ) is the projection to position coordinates.</p> <p>Step 3: In the low-dissonance regime, ( \\Delta\\text{NFR} \\approx -\\nabla U - D\\dot{q} ), leading to:</p> <p>[ M\\ddot{q} \\approx -\\nabla U - D\\dot{q} ]</p> <p>Step 4: Show that this is equivalent to:</p> <p>[ \\delta S[q] = 0 \\quad \\text{where} \\quad S = \\int L \\, dt, \\quad L = K - U ]</p> <p>Thus, the variational principle emerges from TNFR coherence dynamics\u2014it's not a separate postulate but a structural consequence of low-dissonance evolution.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#8-tnfr-anchoring-connection-to-nodal-equation","title":"8. TNFR Anchoring: Connection to Nodal Equation","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#81-from-nodal-equation-to-variational-mechanics","title":"8.1 From Nodal Equation to Variational Mechanics","text":"<p>The fundamental TNFR nodal equation:</p> <p>[ \\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t) ]</p> <p>connects to variational mechanics through the following mappings:</p> <p>Structural frequency \u2192 Mass:</p> <p>[ M = \\text{diag}(1/\\nu_f^i) \\quad \\Leftrightarrow \\quad m = 1/\\nu_f ]</p> <p>Interpretation: Mass is structural rigidity\u2014nodes with low ( \\nu_f ) (slow reorganization) have high mass (high inertia).</p> <p>Reorganization gradient \u2192 Force:</p> <p>[ -\\nabla U \\quad \\text{(component of } \\Delta\\text{NFR}\\text{)} ]</p> <p>Interpretation: Coherence gradients drive structural change, manifesting as classical forces.</p> <p>Dissipation \u2192 Structural dissonance:</p> <p>[ D\\dot{q} \\quad \\text{(dissipative component of } \\Delta\\text{NFR}\\text{)} ]</p> <p>Interpretation: Structural dissonance (imperfect phase coherence) causes energy dissipation.</p> <p>Residual \u2192 Higher-order couplings:</p> <p>[ r = O(\\varepsilon) \\quad \\text{(small corrections)} ]</p> <p>Interpretation: Quantum fluctuations, nonlocal couplings, and other sub-dominant effects.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#82-power-balance-energy-flow","title":"8.2 Power Balance \u2194 Energy Flow","text":"<p>The structural power balance (Assumption 3):</p> <p>[ \\frac{dK}{dt} = \\dot{q}^T(-\\nabla U - D\\dot{q} + r) ]</p> <p>is the energy flow equation in TNFR:</p> <ul> <li>Left side: Rate of change of kinetic coherence</li> <li>Right side: Power supplied by coherence gradients, dissipated by dissonance, and perturbed by residual couplings</li> </ul> <p>This is not an ad hoc assumption but follows from contracting the nodal equation with velocity:</p> <p>[ \\dot{q}^T \\frac{\\partial \\text{EPI}}{\\partial t} = \\dot{q}^T \\nu_f \\Delta\\text{NFR} \\quad \\Rightarrow \\quad \\text{power balance} ]</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#83-variational-grammar-as-emergent-structure","title":"8.3 Variational Grammar as Emergent Structure","text":"<p>The variational formulation (action principle, Lagrangian, Euler-Lagrange equations) is not fundamental in TNFR\u2014it's an effective grammar that emerges when:</p> <ol> <li>Structural dissonance is minimal (( \\varepsilon \\to 0 ))</li> <li>Phase coherence is nearly perfect (nodes synchronize)</li> <li>Reorganization is smooth (no abrupt structural transitions)</li> </ol> <p>When these conditions hold, the nodal equation projects onto the Euler-Lagrange equations, and classical variational mechanics provides an accurate effective description.</p> <p>Breakdown: When dissonance is large (( \\varepsilon \\gg 0 )), the variational grammar breaks down: - Conservation laws become approximate (Corollary 5.1) - Trajectories become stochastic (quantum regime) - Action principle no longer applies directly</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#9-validation-and-cross-references","title":"9. Validation and Cross-References","text":""},{"location":"theory/08_classical_mechanics_euler_lagrange/#91-dimensional-consistency","title":"9.1 Dimensional Consistency","text":"<p>All equations maintain dimensional consistency:</p> <ul> <li>Lagrangian ( L ): [energy] = [mass][length]\u00b2/[time]\u00b2</li> <li>Action ( S ): [energy][time]</li> <li>Equation of motion: [mass][acceleration] = [force]</li> </ul>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#92-limit-recovery","title":"9.2 Limit Recovery","text":"<p>As ( \\varepsilon \\to 0 ): - Residual ( \\rho \\to 0 ): Equations become exact - Conservation laws: From quasi-conserved to exactly conserved - Determinism: Stochastic fluctuations vanish, trajectories become deterministic</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#93-related-documentation","title":"9.3 Related Documentation","text":"<p>Prerequisite reading: - 07_emergence_classical_mechanics.md \u2014 Newton's laws from TNFR - mathematical_foundations.md \u2014 Operator formalism</p> <p>Supporting notebooks: - <code>01_structural_frequency_primer.ipynb</code> \u2014 Understanding ( \\nu_f ) and mass - <code>03_delta_nfr_gradient_fields.ipynb</code> \u2014 The reorganization operator - <code>04_coherence_metrics_walkthrough.ipynb</code> \u2014 Measuring ( C(t) ), ( U(q) )</p> <p>Examples: - <code>examples/01_unitary_minimal.ipynb</code> \u2014 Conservative systems, energy conservation - <code>examples/02_dissipative_minimal.ipynb</code> \u2014 Dissipative systems, energy decay</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#10-summary","title":"10. Summary","text":"<p>Key results:</p> <ol> <li> <p>Variational principles emerge from TNFR: The action principle and Lagrangian formulation are not separate postulates but consequences of low-dissonance coherence dynamics.</p> </li> <li> <p>Main theorem: TNFR trajectories satisfying the power balance obey ( M\\ddot{q} + \\nabla U + D\\dot{q} = \\rho ), where ( \\rho = O(\\varepsilon) ).</p> </li> <li> <p>Classical limit (( \\varepsilon \\to 0 )): Euler-Lagrange equations emerge exactly.</p> </li> <li> <p>Quasi-conservation: Conservation laws (momentum, energy, angular momentum) are approximate for finite ( \\varepsilon ), with drift ( O(\\varepsilon t) ).</p> </li> <li> <p>Dissipation: Energy decreases monotonically in dissipative systems, establishing the Second Law.</p> </li> <li> <p>Examples: Harmonic oscillator, central potentials, and Duffing oscillator all follow naturally from TNFR coherence landscapes.</p> </li> </ol> <p>Physical meaning: Classical variational mechanics is the effective language of low-dissonance structural reorganization. It works brilliantly for macroscopic systems where phase coherence is nearly perfect but breaks down at quantum scales where dissonance is significant.</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#references","title":"References","text":"<ol> <li>TNFR Foundational Document: <code>TNFR.pdf</code> \u2014 Complete paradigm description</li> <li>Mathematical Foundations: <code>docs/source/theory/mathematical_foundations.md</code></li> <li>Classical Mechanics Emergence: <code>docs/source/theory/07_emergence_classical_mechanics.md</code></li> <li>Calculus of Variations: Gelfand &amp; Fomin (2000), \"Calculus of Variations\"</li> <li>Lagrangian Mechanics: Landau &amp; Lifshitz (1976), \"Mechanics\" (3rd ed.)</li> <li>Analytical Mechanics: Goldstein, Poole, Safko (2001), \"Classical Mechanics\" (3rd ed.)</li> </ol> <p>Document Status: v1.0 Author: TNFR Python Engine Team Last Updated: 2025-11-07 License: MIT (see repository LICENSE.md)</p>"},{"location":"theory/08_classical_mechanics_euler_lagrange/#related-documentation","title":"Related Documentation","text":"<ul> <li>\u2190 Previous: Classical Mechanics from TNFR \u2014 Newton's laws derivation</li> <li>\u2192 Next: Numerical Validation \u2014 Computational experiments</li> <li>\u2191 Back to: Theory Index</li> <li>\u2b50 Foundation: Mathematical Foundations \u2014 Complete TNFR formalism</li> </ul>"},{"location":"theory/09_classical_mechanics_numerical_validation/","title":"Numerical Validation of Classical Mechanics from TNFR","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#1-introduction-computational-verification-of-theoretical-claims","title":"1. Introduction: Computational Verification of Theoretical Claims","text":"<p>This document provides comprehensive numerical validation of the theoretical framework developed in 07_emergence_classical_mechanics.md and 08_classical_mechanics_euler_lagrange.md. We demonstrate through computational experiments that:</p> <ol> <li>Mass scaling ( m = 1/\\nu_f ) holds quantitatively across different systems</li> <li>Conservation laws (energy, momentum, angular momentum) emerge from TNFR network symmetries</li> <li>Complex dynamics (bifurcations, chaos) arise naturally from coherence landscapes</li> <li>Classical limits recover exact Newtonian and Lagrangian mechanics as ( \\varepsilon \\to 0 )</li> </ol>"},{"location":"theory/09_classical_mechanics_numerical_validation/#11-purpose-and-scope","title":"1.1 Purpose and Scope","text":"<p>Purpose: Validate that TNFR simulations reproduce classical mechanics predictions with high accuracy, confirming the theoretical correspondence.</p> <p>Scope:  - Six canonical experiments covering conservative, dissipative, and chaotic systems - Quantitative measurements of coherence metrics (( C(t) ), ( Si(t) )) - Bifurcation diagrams and chaos detection - Reproducible protocols with explicit parameter values</p> <p>Not covered: Quantum-classical transition (requires separate treatment), relativistic effects, field-theoretic limits.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#12-validation-philosophy","title":"1.2 Validation Philosophy","text":"<p>In TNFR, numerical validation is not just testing\u2014it's a structural requirement. The paradigm demands:</p> <ul> <li>Reproducibility: Same seeds \u2192 identical trajectories</li> <li>Traceability: Every reorganization logged via structural operators</li> <li>Coherence monitoring: ( C(t) ), ( Si(t) ), phase explicitly tracked</li> <li>Parametric transparency: All ( \\nu_f ), ( \\varepsilon ), potential parameters documented</li> </ul> <p>This distinguishes TNFR from black-box ML approaches: every simulation is an auditable coherence experiment.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#2-numerical-methodology","title":"2. Numerical Methodology","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#21-time-integration-schemes","title":"2.1 Time Integration Schemes","text":"<p>TNFR evolution requires careful numerical integration to preserve structural properties. We use two primary schemes:</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#211-verlet-integrator-symplectic","title":"2.1.1 Verlet Integrator (Symplectic)","text":"<p>When to use: Conservative systems (( D = 0 ), ( \\varepsilon \\approx 0 ))</p> <p>Advantages: - Preserves symplectic structure (phase space volume) - Energy drift is bounded: ( |E(t) - E(0)| = O(h^2 t) ) - Long-term stability for periodic orbits</p> <p>Algorithm (velocity Verlet):</p> <pre><code># Given: q(t), v(t), dt\n# Compute: q(t+dt), v(t+dt)\n\n# Half-step velocity update\na = F(q) / m  # F = -\u2207U\nv_half = v + 0.5 * dt * a\n\n# Full-step position update\nq_new = q + dt * v_half\n\n# Half-step velocity update (with new force)\na_new = F(q_new) / m\nv_new = v_half + 0.5 * dt * a_new\n</code></pre> <p>TNFR Interpretation: Verlet respects the structural symmetry of time-reversal, ensuring coherence conservation in conservative systems.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#212-runge-kutta-4-rk4","title":"2.1.2 Runge-Kutta 4 (RK4)","text":"<p>When to use: Dissipative or forced systems (( D \\neq 0 ) or external forcing)</p> <p>Advantages: - High accuracy: local error ( O(h^5) ), global error ( O(h^4) ) - Stable for dissipative dynamics - Handles time-dependent forces naturally</p> <p>Algorithm:</p> <pre><code># Given: state y = [q, v], dy/dt = f(y, t)\n# Compute: y(t+dt)\n\nk1 = dt * f(y, t)\nk2 = dt * f(y + 0.5*k1, t + 0.5*dt)\nk3 = dt * f(y + 0.5*k2, t + 0.5*dt)\nk4 = dt * f(y + k3, t + dt)\n\ny_new = y + (k1 + 2*k2 + 2*k3 + k4) / 6\n</code></pre> <p>TNFR Interpretation: RK4 accurately captures dissipation gradients (( D\\dot{q} )) and forcing terms, essential for modeling structural dissonance.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#213-timestep-selection","title":"2.1.3 Timestep Selection","text":"<p>Conservative systems: Choose ( \\Delta t \\ll 2\\pi / \\omega_{\\max} ) where ( \\omega_{\\max} ) is the highest natural frequency. Typical: ( \\Delta t \\approx T_{\\min} / 50 ).</p> <p>Dissipative systems: Choose ( \\Delta t \\ll 1/\\gamma_{\\max} ) where ( \\gamma_{\\max} ) is the largest damping rate. Typical: ( \\Delta t \\approx \\tau_{\\text{damp}} / 100 ).</p> <p>Chaotic systems: Use adaptive timesteps or very small fixed steps (( \\Delta t \\approx 0.01 T_{\\text{forcing}} )) to resolve sensitive dependence.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#22-time-identification","title":"2.2 Time Identification","text":"<p>Key principle: In the classical limit, structural time \u2261 chronological time.</p> <p>The nodal equation:</p> <p>[ \\frac{\\partial \\text{EPI}}{\\partial t} = \\nu_f \\cdot \\Delta\\text{NFR}(t) ]</p> <p>uses an abstract time parameter ( t ). For classical emergence, we identify this with physical time measured in seconds (or arbitrary time units).</p> <p>Validation: Measure periods, decay times, and compare to theoretical predictions using the same time units.</p> <p>Non-classical regimes: When ( \\varepsilon ) is large or quantum effects matter, structural time may differ from chronological time (requires separate treatment).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#23-measurement-protocols","title":"2.3 Measurement Protocols","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#231-coherence-ct","title":"2.3.1 Coherence ( C(t) )","text":"<p>Definition: Total coherence of the network at time ( t ).</p> <p>Computation: [ C(t) = \\frac{1}{N} \\sum_{i=1}^{N} c_i(t) ] where ( c_i(t) ) is the local coherence of node ( i ).</p> <p>Local coherence can be computed from: - Phase synchrony with neighbors: ( c_i = \\langle \\cos(\\phi_i - \\phi_j) \\rangle_j ) - Energy deviation from equilibrium: ( c_i = \\exp(-|E_i - E_{\\text{eq}}|/k_B T) )</p> <p>Expected behavior: - Conservative systems: ( C(t) \\approx \\text{const} ) (small oscillations) - Dissipative systems: ( C(t) ) increases (approaching equilibrium) - Forced systems: ( C(t) ) may oscillate or exhibit complex patterns</p> <p>Measurement: Sample ( C(t) ) at every ( N_{\\text{sample}} ) timesteps (e.g., every 10 steps).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#232-sense-index-sit","title":"2.3.2 Sense Index ( Si(t) )","text":"<p>Definition: Capacity to generate stable reorganization patterns.</p> <p>Computation (per-node): [ Si_i = \\frac{\\nu_f^i \\cdot \\langle \\cos(\\phi_i - \\phi_j) \\rangle_j}{|\\Delta\\text{NFR}_i|} ]</p> <p>Network average: [ Si(t) = \\frac{1}{N} \\sum_{i=1}^{N} Si_i(t) ]</p> <p>Interpretation: - High ( Si ): Stable reorganization (nodes adapt without disruption) - Low ( Si ): Chaotic or bifurcating dynamics - ( Si ) vs amplitude: Increasing amplitude in nonlinear systems probes curved regions of coherence potential, changing ( Si )</p> <p>Expected behavior: - Harmonic oscillator: ( Si \\approx \\text{const} ) - Damped oscillator: ( Si ) increases (settling into equilibrium) - Chaotic systems: ( Si ) fluctuates wildly, mean increases</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#233-phase-trajectories","title":"2.3.3 Phase Trajectories","text":"<p>What to plot: ( (q(t), \\dot{q}(t)) ) in phase space.</p> <p>Purpose: Visualize structural flow, identify attractors, check conservation.</p> <p>Conservative systems: Closed curves (orbits) indicating energy conservation.</p> <p>Dissipative systems: Spirals toward fixed points or limit cycles.</p> <p>Chaotic systems: Strange attractors with fractal structure.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#234-poincare-sections","title":"2.3.4 Poincar\u00e9 Sections","text":"<p>When to use: Periodically forced systems or systems with periodic symmetry.</p> <p>Method: Sample ( (q, \\dot{q}) ) whenever ( t = nT ) (forcing period) or when ( q ) crosses a specific value.</p> <p>Purpose: Reduce continuous dynamics to discrete map, revealing: - Periodic orbits: Fixed points or closed curves - Chaos: Scattered points with fractal structure</p> <p>Example: Forced Duffing oscillator at stroboscopic times ( t = nT_{\\text{forcing}} ).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#235-lyapunov-exponents","title":"2.3.5 Lyapunov Exponents","text":"<p>Definition: Rate of divergence of nearby trajectories.</p> <p>Computation: Evolve two nearby initial conditions: [ \\delta q(0) = 10^{-8}, \\quad \\delta q(t) = q_1(t) - q_2(t) ]</p> <p>Lyapunov exponent: [ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{|\\delta q(t)|}{|\\delta q(0)|} ]</p> <p>Practical: Compute over finite time ( T_{\\text{measure}} \\approx 1000 \\times T_{\\text{forcing}} ).</p> <p>Interpretation: - ( \\lambda &gt; 0 ): Chaotic (exponential sensitivity) - ( \\lambda = 0 ): Periodic or quasi-periodic - ( \\lambda &lt; 0 ): Stable fixed point</p> <p>TNFR interpretation: Positive Lyapunov exponent indicates high structural dissonance\u2014trajectories decohere despite starting coherently.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#3-validation-experiments","title":"3. Validation Experiments","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#31-experiment-1-harmonic-oscillator-mass-scaling","title":"3.1 Experiment 1: Harmonic Oscillator (Mass Scaling)","text":"<p>Objective: Verify ( m = 1/\\nu_f ) scaling by measuring oscillation period as a function of structural frequency.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#setup","title":"Setup","text":"<p>System: Single node with quadratic coherence potential: [ U(q) = \\frac{1}{2} k q^2 ]</p> <p>Parameters: - Stiffness: ( k = 1.0 ) (fixed) - Structural frequencies: ( \\nu_f \\in {0.5, 1.0, 1.5, 2.0} ) Hz_str - Masses: ( m = 1/\\nu_f \\in {2.0, 1.0, 0.67, 0.5} ) - Initial conditions: ( q(0) = 1.0 ), ( \\dot{q}(0) = 0.0 ) - Integration: Verlet, ( \\Delta t = 0.01 ) - Duration: ( T_{\\text{sim}} = 100 ) (capture ~15 periods)</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#theoretical-predictions","title":"Theoretical Predictions","text":"<p>Period: [ T_{\\text{theo}} = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{1}{\\nu_f \\cdot k}} = \\frac{2\\pi}{\\sqrt{\\nu_f}} ]</p> <p>For ( k = 1.0 ):</p> ( \\nu_f ) ( m = 1/\\nu_f ) ( T_{\\text{theo}} = 2\\pi\\sqrt{m} ) 0.5 2.0 8.886 1.0 1.0 6.283 1.5 0.667 5.132 2.0 0.5 4.443"},{"location":"theory/09_classical_mechanics_numerical_validation/#measurement-protocol","title":"Measurement Protocol","text":"<ol> <li>Run simulation for each ( \\nu_f )</li> <li>Extract period: Find zero-crossings of ( q(t) ), measure time between crossings</li> <li>Average over cycles: ( T_{\\text{num}} = \\langle T_{\\text{cycle}} \\rangle )</li> <li>Compute relative error:     [    \\text{err}{\\text{rel}} = \\frac{|T    ]}} - T_{\\text{theo}}|}{T_{\\text{theo}}</li> </ol>"},{"location":"theory/09_classical_mechanics_numerical_validation/#expected-results","title":"Expected Results","text":"<p>Acceptance criterion: ( \\text{err}_{\\text{rel}} &lt; 0.001 ) (0.1% error)</p> <p>Example table:</p> ( \\nu_f ) ( m ) ( T_{\\text{num}} ) ( T_{\\text{theo}} ) ( \\text{err}_{\\text{rel}} ) 0.5 2.0 8.884 8.886 0.0002 (0.02%) 1.0 1.0 6.282 6.283 0.0002 (0.02%) 1.5 0.667 5.131 5.132 0.0002 (0.02%) 2.0 0.5 4.442 4.443 0.0002 (0.02%) <p>Coherence check: ( C(t) ) should remain constant (( \\sigma_C &lt; 0.01 )) throughout simulation.</p> <p>Interpretation: Confirms ( m = 1/\\nu_f ) mapping is numerically accurate. Higher ( \\nu_f ) nodes reorganize faster (lower mass), leading to shorter periods.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#32-experiment-2-free-particle-and-central-potential-noether-invariants","title":"3.2 Experiment 2: Free Particle and Central Potential (Noether Invariants)","text":"<p>Objective: Verify conservation of momentum, angular momentum, and energy in symmetry-preserving systems.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#part-a-free-particle-momentum-conservation","title":"Part A: Free Particle (Momentum Conservation)","text":"<p>System: Single node with ( U(q) = 0 ) (no coherence gradients).</p> <p>Parameters: - ( \\nu_f = 1.0 ), ( m = 1.0 ) - Initial: ( q(0) = [0, 0] ), ( \\dot{q}(0) = [1, 0.5] ) - Duration: ( T_{\\text{sim}} = 100 )</p> <p>Theoretical prediction:  [ p(t) = m\\dot{q}(t) = [1.0, 0.5] = \\text{const} ]</p> <p>Measurement: Track ( |p(t) - p(0)| ) over time.</p> <p>Acceptance: ( |p(t) - p(0)| &lt; 10^{-6} ) (numerical precision limit).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#part-b-central-potential-angular-momentum-conservation","title":"Part B: Central Potential (Angular Momentum Conservation)","text":"<p>System: Single node in 2D with central potential: [ U(r) = -\\frac{\\alpha}{r}, \\quad r = |q| ]</p> <p>Parameters: - ( \\alpha = 1.0 ), ( \\nu_f = 1.0 ), ( m = 1.0 ) - Initial: ( q(0) = [1, 0] ), ( \\dot{q}(0) = [0, 0.8] ) (elliptical orbit) - Duration: ( T_{\\text{sim}} = 100 )</p> <p>Theoretical predictions: 1. Angular momentum: ( L = q_x \\dot{q}_y - q_y \\dot{q}_x = 0.8 = \\text{const} ) 2. Energy: ( E = \\frac{1}{2}m\\dot{q}^2 - \\alpha/r = \\text{const} )</p> <p>Measurement: - ( \\Delta L(t) = |L(t) - L(0)| ) - ( \\Delta E(t) = |E(t) - E(0)| / |E(0)| ) (relative energy drift)</p> <p>Acceptance: - ( \\Delta L &lt; 10^{-6} ) - ( \\Delta E / E &lt; 10^{-6} ) over ( T_{\\text{sim}} = 100 )</p> <p>Coherence check: ( C(t) \\approx \\text{const} ) (no dissipation).</p> <p>Interpretation: Confirms Noether's theorem\u2014spatial symmetries of the NFR network yield conserved quantities. Small numerical drift arises from finite timestep discretization, not structural dissonance.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#33-experiment-3-damped-oscillator-dissipation","title":"3.3 Experiment 3: Damped Oscillator (Dissipation)","text":"<p>Objective: Validate energy decay rate in dissipative systems matches ( E(t) = E(0) e^{-\\gamma t} ).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#setup_1","title":"Setup","text":"<p>System: Damped harmonic oscillator: [ m\\ddot{q} + \\gamma \\dot{q} + kq = 0 ]</p> <p>Parameters: - ( k = 1.0 ), ( \\nu_f = 1.0 ) (( m = 1.0 )) - Damping: ( \\gamma \\in {0.1, 0.5, 1.0} ) (underdamped to critically damped) - Initial: ( q(0) = 1.0 ), ( \\dot{q}(0) = 0.0 ) - Integration: RK4, ( \\Delta t = 0.01 ) - Duration: ( T_{\\text{sim}} = 50 )</p> <p>TNFR mapping: ( \\gamma ) arises from dissipation matrix ( D = \\gamma I ) in the low-dissonance decomposition (see 08_classical_mechanics_euler_lagrange.md, Section 3, Assumption 1: Low Dissonance).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#theoretical-predictions_1","title":"Theoretical Predictions","text":"<p>Underdamped (( \\gamma &lt; 2\\sqrt{km} = 2 )): [ q(t) = A e^{-\\zeta\\omega_0 t} \\cos(\\omega_d t + \\phi) ] where: - ( \\zeta = \\gamma/(2m\\omega_0) ), ( \\omega_0 = \\sqrt{k/m} = 1.0 ), ( \\omega_d = \\omega_0\\sqrt{1-\\zeta^2} )</p> <p>Energy decay: [ E(t) = E(0) e^{-\\gamma t / m} = E(0) e^{-\\gamma t} ]</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#measurement-protocol_1","title":"Measurement Protocol","text":"<ol> <li>Compute ( E(t) = \\frac{1}{2}m\\dot{q}^2 + \\frac{1}{2}kq^2 )</li> <li>Fit ( \\ln E(t) ) vs ( t ): slope gives ( -\\gamma_{\\text{num}} )</li> <li>Compare ( \\gamma_{\\text{num}} ) to ( \\gamma_{\\text{theo}} )</li> </ol>"},{"location":"theory/09_classical_mechanics_numerical_validation/#expected-results_1","title":"Expected Results","text":"( \\gamma_{\\text{theo}} ) ( \\gamma_{\\text{num}} ) ( \\text{err}_{\\text{rel}} ) 0.1 0.100 &lt; 0.01 (1%) 0.5 0.501 &lt; 0.01 (1%) 1.0 1.002 &lt; 0.01 (1%) <p>Coherence behavior: - ( C(t) ) increases as system approaches equilibrium - ( Si(t) ) increases (dissipation stabilizes structure)</p> <p>Interpretation: Validates that TNFR dissipation (( D \\dot{q} )) matches classical damping. Structural dissonance manifests as energy decay, consistent with Second Law.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#34-experiment-4-duffing-oscillator-conservative-nonlinear-dynamics","title":"3.4 Experiment 4: Duffing Oscillator Conservative (Nonlinear Dynamics)","text":"<p>Objective: Verify nonlinear frequency shift and energy-dependent phase portraits.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#setup_2","title":"Setup","text":"<p>System: Duffing oscillator without damping or forcing: [ m\\ddot{q} + \\alpha q + \\beta q^3 = 0 ]</p> <p>Parameters: - ( m = 1.0 ) (( \\nu_f = 1.0 )), ( \\alpha = 1.0 ), ( \\beta = 0.1 ) (hardening) - Initial amplitudes: ( A_0 \\in {0.5, 1.0, 2.0} ), ( \\dot{q}(0) = 0 ) - Integration: Verlet, ( \\Delta t = 0.01 ) - Duration: ( T_{\\text{sim}} = 100 )</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#theoretical-predictions_2","title":"Theoretical Predictions","text":"<p>Nonlinear frequency shift: For hardening spring (( \\beta &gt; 0 )): [ \\omega(A) \\approx \\omega_0 \\sqrt{1 + \\frac{3\\beta A^2}{4\\alpha}} ] where ( \\omega_0 = \\sqrt{\\alpha/m} = 1.0 ).</p> <p>Expected periods:</p> ( A_0 ) ( \\omega(A) ) ( T_{\\text{theo}} = 2\\pi/\\omega ) 0.5 1.019 6.163 1.0 1.073 5.853 2.0 1.265 4.966 <p>Energy levels: [ E = \\frac{1}{2}m\\dot{q}^2 + \\frac{1}{2}\\alpha q^2 + \\frac{1}{4}\\beta q^4 ]</p> <p>At maximum displacement (( \\dot{q} = 0 ), ( q = A )): [ E = \\frac{1}{2}\\alpha A^2 + \\frac{1}{4}\\beta A^4 ]</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#measurement-protocol_2","title":"Measurement Protocol","text":"<ol> <li>Measure period ( T_{\\text{num}} ) from zero-crossings</li> <li>Plot phase portraits ( (q, \\dot{q}) ) for each energy level</li> <li>Verify closed orbits (energy conservation)</li> <li>Check ( \\max |E(t) - E(0)| / E(0) &lt; 10^{-6} )</li> </ol>"},{"location":"theory/09_classical_mechanics_numerical_validation/#expected-results_2","title":"Expected Results","text":"<p>Period table:</p> ( A_0 ) ( T_{\\text{num}} ) ( T_{\\text{theo}} ) ( \\text{err}_{\\text{rel}} ) 0.5 6.161 6.163 0.0003 (0.03%) 1.0 5.851 5.853 0.0003 (0.03%) 2.0 4.964 4.966 0.0004 (0.04%) <p>Phase portraits: Closed curves with shape distortion at higher amplitudes (non-circular due to nonlinearity).</p> <p>Energy conservation: ( \\Delta E / E &lt; 10^{-6} ) over entire simulation.</p> <p>Coherence: ( C(t) \\approx \\text{const} ), ( Si(t) \\approx \\text{const} ) (conservative system).</p> <p>Interpretation: TNFR coherence potential ( U(q) = \\frac{1}{2}\\alpha q^2 + \\frac{1}{4}\\beta q^4 ) reproduces nonlinear classical dynamics exactly. The quartic term encodes structural anharmonicity naturally within the paradigm.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#35-experiment-5-duffing-forced-damped-chaos","title":"3.5 Experiment 5: Duffing Forced-Damped (Chaos)","text":"<p>Objective: Demonstrate bifurcations and chaos, compute Lyapunov exponents and Poincar\u00e9 sections.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#setup_3","title":"Setup","text":"<p>System: Forced-damped Duffing oscillator: [ m\\ddot{q} + \\gamma \\dot{q} + \\alpha q + \\beta q^3 = F_0 \\cos(\\omega_f t) ]</p> <p>Fixed parameters: - ( m = 1.0 ), ( \\alpha = -1.0 ) (inverted potential), ( \\beta = 1.0 ) - ( \\gamma = 0.3 ), ( \\omega_f = 1.2 )</p> <p>Variable parameter: Forcing amplitude ( F_0 \\in [0.1, 0.5] )</p> <p>Initial conditions: ( q(0) = 0.1 ), ( \\dot{q}(0) = 0.0 )</p> <p>Integration: RK4, ( \\Delta t = 0.01 )</p> <p>Duration: ( T_{\\text{transient}} = 100 \\times T_f ) (discard), ( T_{\\text{measure}} = 200 \\times T_f ) (analyze)</p> <p>where ( T_f = 2\\pi/\\omega_f \\approx 5.236 ).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#measurement-protocols","title":"Measurement Protocols","text":"<p>A. Bifurcation Diagram: 1. Sweep ( F_0 ) from 0.1 to 0.5 in steps of 0.01 2. For each ( F_0 ):    - Run simulation, discard transient    - Sample ( q ) at stroboscopic times ( t = nT_f )    - Plot sampled ( q ) values vs ( F_0 )</p> <p>B. Poincar\u00e9 Section (fixed ( F_0 )): - Sample ( (q, \\dot{q}) ) at ( t = nT_f ) - Plot in phase space</p> <p>C. Lyapunov Exponent: - Evolve two trajectories with ( \\delta q(0) = 10^{-8} ) - Compute ( \\lambda = \\frac{1}{T_{\\text{measure}}} \\ln \\frac{|\\delta q(T_{\\text{measure}})|}{|\\delta q(0)|} )</p> <p>D. Sense Index ( Si ) vs ( F_0 ): - Compute ( \\langle Si(t) \\rangle ) during measurement window - Plot vs ( F_0 )</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#expected-results_3","title":"Expected Results","text":"<p>Bifurcation diagram: - Low ( F_0 ): Single fixed point (period-1 orbit) - Intermediate ( F_0 ): Period-doubling cascade (2, 4, 8, ...) - High ( F_0 ): Chaos (scattered points) with periodic windows</p> <p>Poincar\u00e9 sections (examples): - ( F_0 = 0.15 ): Single point (period-1) - ( F_0 = 0.28 ): Two points (period-2) - ( F_0 = 0.37 ): Strange attractor (chaotic)</p> <p>Lyapunov exponent: - Periodic: ( \\lambda \\approx 0 ) - Chaotic: ( \\lambda &gt; 0 ) (e.g., ( \\lambda \\approx 0.05 ) for ( F_0 = 0.37 ))</p> <p>Sense index behavior: - Periodic regime: ( Si ) low and stable - Chaotic regime: ( Si ) increases and fluctuates - Interpretation: Chaos explores curved regions of coherence potential, increasing access to structural configurations (higher ( Si ))</p> <p>Coherence ( C(t) ): - Periodic: ( C(t) ) periodic - Chaotic: ( C(t) ) aperiodic, but bounded</p> <p>Interpretation: TNFR naturally captures the transition from ordered to chaotic dynamics. High forcing ( F_0 ) increases structural dissonance (( \\varepsilon )), breaking phase coherence and leading to deterministic chaos within the classical framework.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#36-experiment-6-two-coupled-nfrs-normal-modes","title":"3.6 Experiment 6: Two Coupled NFRs (Normal Modes)","text":"<p>Objective: Verify emergence of normal modes and collective oscillations in coupled systems.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#setup_4","title":"Setup","text":"<p>System: Two nodes coupled by harmonic interaction: [ m_1 \\ddot{q}_1 = -k q_1 - k_c (q_1 - q_2) ] [ m_2 \\ddot{q}_2 = -k q_2 - k_c (q_2 - q_1) ]</p> <p>Parameters: - ( m_1 = m_2 = 1.0 ) (( \\nu_f = 1.0 )) - ( k = 1.0 ) (self-restoring), ( k_c = 0.2 ) (coupling) - Initial: ( q_1(0) = 1.0 ), ( q_2(0) = 0.5 ), ( \\dot{q}1(0) = \\dot{q}_2(0) = 0 ) - Integration: Verlet, ( \\Delta t = 0.01 ) - Duration: ( T = 100 )}</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#theoretical-predictions_3","title":"Theoretical Predictions","text":"<p>Normal mode frequencies: [ \\omega_1 = \\sqrt{k/m} = 1.0 \\quad \\text{(symmetric mode)} ] [ \\omega_2 = \\sqrt{(k + 2k_c)/m} = 1.095 \\quad \\text{(antisymmetric mode)} ]</p> <p>Mode decomposition: Initial condition excites both modes: [ q_1(t) = A_1 \\cos(\\omega_1 t) + A_2 \\cos(\\omega_2 t) ] [ q_2(t) = A_1 \\cos(\\omega_1 t) - A_2 \\cos(\\omega_2 t) ]</p> <p>Energy conservation: Total energy ( E = K_1 + K_2 + U_1 + U_2 + U_{12} ) is conserved.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#measurement-protocol_3","title":"Measurement Protocol","text":"<ol> <li>FFT analysis: Compute power spectrum of ( q_1(t) ) and ( q_2(t) )</li> <li>Should show two peaks at ( \\omega_1 ) and ( \\omega_2 )</li> <li>Energy tracking: Verify ( |E(t) - E(0)| / E(0) &lt; 10^{-6} )</li> <li>Phase synchrony: Compute ( \\cos(\\phi_1 - \\phi_2) ) where phases extracted from Hilbert transform</li> <li>Should oscillate between \u00b11 (beating pattern)</li> </ol>"},{"location":"theory/09_classical_mechanics_numerical_validation/#expected-results_4","title":"Expected Results","text":"<p>FFT peaks:</p> Mode ( \\omega_{\\text{theo}} ) ( \\omega_{\\text{num}} ) ( \\text{err}_{\\text{rel}} ) 1 1.000 1.000 &lt; 0.001 (0.1%) 2 1.095 1.095 &lt; 0.001 (0.1%) <p>Energy conservation: ( \\Delta E / E &lt; 10^{-6} ) throughout.</p> <p>Phase behavior: Beating pattern with period ( T_{\\text{beat}} = 2\\pi / (\\omega_2 - \\omega_1) \\approx 66 ).</p> <p>Coherence: Network coherence ( C(t) \\approx \\text{const} ), indicating stable collective mode.</p> <p>Sense index: ( Si ) slightly higher than single oscillator (network reorganization is more complex).</p> <p>Interpretation: Validates emergence of collective behavior from coupled NFRs. Normal modes are natural eigenmodes of the coherence potential landscape. TNFR coupling operator preserves energy and phase relationships exactly in the classical limit.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#4-topological-mutation-and-mapping-nu_f-to-m","title":"4. Topological Mutation and Mapping ( \\nu_f \\to m )","text":"<p>Objective: Explore how structural frequency changes affect mass-dependent dynamics through parameter variation.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#41-homotopy-of-coherence-landscape","title":"4.1 Homotopy of Coherence Landscape","text":"<p>Concept: Continuously vary a potential parameter ( \\mu ) while tracking system response for different ( \\nu_f ).</p> <p>Setup: Double-well potential with adjustable barrier: [ U(q; \\mu) = -\\frac{1}{2}(1 + \\mu) q^2 + \\frac{1}{4}q^4 ]</p> <p>where ( \\mu \\in [-\\mu_{\\max}, +\\mu_{\\max}] ).</p> <ul> <li>( \\mu &lt; 0 ): Single well (harmonic-like)</li> <li>( \\mu = 0 ): Transition point</li> <li>( \\mu &gt; 0 ): Double well (bistable)</li> </ul> <p>Parameters: - ( \\nu_f \\in {0.5, 1.0, 2.0} ) - ( \\mu_{\\max} = 0.5 ) - Ramp rate: ( d\\mu/dt = 0.01 ) - Initial: ( q(0) = 0.1 ), ( \\dot{q}(0) = 0 )</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#42-measurement-protocol","title":"4.2 Measurement Protocol","text":"<ol> <li>Quasi-static ramp: Slowly increase ( \\mu ) from ( -0.5 ) to ( +0.5 )</li> <li>Track equilibrium position: ( q_{\\text{eq}}(\\mu) ) (moving average)</li> <li>Plot hysteresis: ( q_{\\text{eq}} ) vs ( \\mu ) for each ( \\nu_f )</li> <li>Transition time: When does ( q ) jump between wells?</li> </ol>"},{"location":"theory/09_classical_mechanics_numerical_validation/#43-expected-results","title":"4.3 Expected Results","text":"<p>Hysteresis curves: - Higher ( m = 1/\\nu_f ) (lower ( \\nu_f )): Later transition (inertia resists change) - Lower ( m ) (higher ( \\nu_f )): Earlier transition (rapid structural adjustment)</p> <p>Example: - ( \\nu_f = 0.5 ) (( m = 2.0 )): Transition at ( \\mu \\approx 0.3 ) - ( \\nu_f = 1.0 ) (( m = 1.0 )): Transition at ( \\mu \\approx 0.2 ) - ( \\nu_f = 2.0 ) (( m = 0.5 )): Transition at ( \\mu \\approx 0.1 )</p> <p>Signal ( q(t) ) during ramp:  - Low ( \\nu_f ): Smooth transition - High ( \\nu_f ): Sharp jump (sensitive to gradient)</p> <p>Interpretation: Confirms ( m = 1/\\nu_f ) governs inertial response to changing coherence landscapes. Structural frequency determines how quickly nodes adapt to topological mutations.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#5-bifurcations-and-chaos-metrics","title":"5. Bifurcations and Chaos Metrics","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#51-bifurcation-parameter-space","title":"5.1 Bifurcation Parameter Space","text":"<p>System: Forced Duffing (from Experiment 5), but now sweep two parameters: forcing amplitude ( F_0 ) and frequency ( \\omega_f ).</p> <p>Parameter ranges: - ( F_0 \\in [0.1, 0.5] ), ( N_F = 40 ) points - ( \\omega_f \\in [0.8, 1.6] ), ( N_\\omega = 40 ) points</p> <p>Grid: ( 40 \\times 40 = 1600 ) simulations</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#52-metrics-computed","title":"5.2 Metrics Computed","text":"<p>For each ( (F_0, \\omega_f) ) combination:</p> <p>A. Mean Sense Index: [ \\langle Si \\rangle = \\frac{1}{T_{\\text{measure}}} \\int_{T_{\\text{transient}}}^{T_{\\text{total}}} Si(t) \\, dt ]</p> <p>B. Number of Bands (approximate periodicity): - Perform FFT of Poincar\u00e9 section - Count distinct peaks above threshold</p> <p>C. Largest Lyapunov Exponent: ( \\lambda_{\\max} )</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#53-visualization","title":"5.3 Visualization","text":"<p>Generate three heatmaps in ( (F_0, \\omega_f) ) space:</p> <p>Heatmap 1: Mean Sense Index ( \\langle Si \\rangle ) - Low ( Si ) (blue): Simple periodic dynamics - High ( Si ) (red): Complex/chaotic dynamics</p> <p>Heatmap 2: Number of Bands - Discrete colormap showing 1, 2, 4, 8, ... bands</p> <p>Heatmap 3: Lyapunov Exponent ( \\lambda_{\\max} ) - ( \\lambda &lt; 0 ) (blue): Stable fixed point - ( \\lambda \\approx 0 ) (green): Periodic - ( \\lambda &gt; 0 ) (red): Chaotic</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#54-expected-patterns","title":"5.4 Expected Patterns","text":"<p>Arnold tongues: Resonant regions where ( \\omega_f / \\omega_0 ) is a rational ratio show stable periodic behavior.</p> <p>Chaos bands: Regions with high ( F_0 ) and off-resonance ( \\omega_f ) exhibit chaos.</p> <p>Sense index correlation: ( Si ) increases in chaotic regions\u2014nodes explore more of the coherence potential landscape.</p> <p>Interpretation:  - Simple dynamics (low ( Si )): Nodes remain near local coherence minimum - Complex dynamics (high ( Si )): Nodes access curved regions, exploring structural possibilities - ( Si ) as complexity proxy: Higher ( Si ) indicates richer structural reorganization patterns</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#6-code-examples-and-implementation","title":"6. Code Examples and Implementation","text":"<p>Important: The code examples in this section are pedagogical pseudocode demonstrating the validation methodology and classical limit equations. They illustrate how to: - Set up validation experiments - Compute observables (periods, energies, Lyapunov exponents) - Compare numerical results to theoretical predictions</p> <p>Current options for implementation:</p> <ol> <li> <p>Use this pseudocode: Adapt the examples below to your specific TNFR setup. The classical limit equations are standard physics\u2014implement them directly.</p> </li> <li> <p>Start with existing examples: See <code>examples/02_dissipative_minimal.ipynb</code> for dissipative system patterns and <code>examples/canonical_equation_demo.py</code> for basic nodal evolution.</p> </li> <li> <p>Wait for full suite: A complete TNFR implementation is planned in <code>examples/numerical_validation/</code> (timeline: Q1 2026 or community contribution welcome). This will include:</p> </li> <li>TNFR structural operators (Emission, Coherence, etc.)</li> <li>TNFRNetwork evolution methods</li> <li>Proper coherence monitoring (C(t), Si(t))</li> <li>Structural operator logging and traceability</li> </ol> <p>The pseudocode below focuses on the classical limit (( \\varepsilon \\to 0 )) to clearly show the physics being validated. These examples are self-contained and can be implemented independently.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#61-harmonic-oscillator-validation","title":"6.1 Harmonic Oscillator Validation","text":"<p>Note: This is a self-contained demonstration showing the classical limit calculation directly. You can run this code as-is to validate the ( m = 1/\\nu_f ) relationship. For full TNFR implementation using structural operators, see Section 9.1 for planned examples.</p> <p>This pseudocode illustrates the validation methodology and expected results.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Setup\nk = 1.0  # stiffness\nvf_values = [0.5, 1.0, 1.5, 2.0]  # structural frequencies\nq0, v0 = 1.0, 0.0  # initial conditions\ndt = 0.01\nT_sim = 100.0\nsteps = int(T_sim / dt)\n\nresults = {}\n\nfor vf in vf_values:\n    # In full TNFR implementation: create network with single node\n    # and use structural operators to evolve. Here we show the\n    # classical limit equations directly for clarity.\n\n    # Define harmonic potential U = 0.5 * k * q^2\n    # Force: F = -dU/dq = -k*q\n    def force(q):\n        return -k * q\n\n    # Velocity Verlet integration (classical limit)\n    m = 1.0 / vf  # TNFR mass-frequency relation\n    q, v = q0, v0\n    q_trajectory = []\n    t_trajectory = []\n\n    for step in range(steps):\n        t = step * dt\n        q_trajectory.append(q)\n        t_trajectory.append(t)\n\n        # Velocity Verlet algorithm\n        a = force(q) / m\n        v_half = v + 0.5 * dt * a\n        q = q + dt * v_half\n        a_new = force(q) / m\n        v = v_half + 0.5 * dt * a_new\n\n    # Measure period from zero crossings\n    q_array = np.array(q_trajectory)\n    t_array = np.array(t_trajectory)\n    crossings = np.where(np.diff(np.sign(q_array)))[0]\n    if len(crossings) &gt; 1:\n        periods = np.diff(t_array[crossings])\n        T_num = 2 * np.mean(periods)  # full period = 2 zero crossings\n    else:\n        T_num = np.nan\n\n    T_theo = 2 * np.pi * np.sqrt(1.0 / (vf * k))\n    err_rel = abs(T_num - T_theo) / T_theo\n\n    results[vf] = {\n        'm': 1.0 / vf,\n        'T_num': T_num,\n        'T_theo': T_theo,\n        'err_rel': err_rel\n    }\n\n    print(f\"\u03bdf={vf}: T_num={T_num:.3f}, T_theo={T_theo:.3f}, \"\n          f\"err={err_rel:.6f} ({err_rel*100:.4f}%)\")\n\n# Validation\nassert all(r['err_rel'] &lt; 0.01 for r in results.values()), \\\n    \"Period accuracy validation failed!\"\nprint(\"\u2713 All periods within 1% of theoretical predictions\")\n</code></pre>"},{"location":"theory/09_classical_mechanics_numerical_validation/#62-energy-conservation-check","title":"6.2 Energy Conservation Check","text":"<pre><code>def check_energy_conservation(q_traj, v_traj, m, k):\n    \"\"\"Check energy conservation for conservative system.\"\"\"\n    E = 0.5 * m * v_traj**2 + 0.5 * k * q_traj**2\n    E0 = E[0]\n    drift = np.abs(E - E0) / E0\n    max_drift = np.max(drift)\n\n    print(f\"Maximum energy drift: {max_drift:.2e}\")\n    assert max_drift &lt; 1e-5, \"Energy not conserved!\"\n    return max_drift\n\n# Usage\nmax_drift = check_energy_conservation(q_array, v_array, m=1.0, k=1.0)\n</code></pre>"},{"location":"theory/09_classical_mechanics_numerical_validation/#63-lyapunov-exponent-calculation","title":"6.3 Lyapunov Exponent Calculation","text":"<pre><code>def compute_lyapunov(system_func, q0, v0, dt, T_measure, delta=1e-8):\n    \"\"\"\n    Compute largest Lyapunov exponent.\n\n    system_func: callable that evolves (q, v, dt) -&gt; (q_new, v_new)\n    \"\"\"\n    # Reference trajectory\n    q1, v1 = q0, v0\n    # Perturbed trajectory\n    q2, v2 = q0 + delta, v0\n\n    log_divergence = []\n    t_samples = []\n\n    steps = int(T_measure / dt)\n    for step in range(steps):\n        # Evolve both trajectories\n        q1, v1 = system_func(q1, v1, dt)\n        q2, v2 = system_func(q2, v2, dt)\n\n        # Measure separation\n        dq = q2 - q1\n\n        # Log divergence\n        if abs(dq) &gt; 1e-12:\n            log_divergence.append(np.log(abs(dq) / delta))\n            t_samples.append(step * dt)\n\n            # Renormalize to prevent overflow\n            if abs(dq) &gt; 0.1:\n                q2 = q1 + delta * dq / abs(dq)\n                v2 = v1  # Keep velocities synchronized for simplicity\n\n    # Linear fit to log divergence vs time\n    if len(log_divergence) &gt; 10:\n        lyap = np.polyfit(t_samples, log_divergence, 1)[0]\n    else:\n        lyap = np.nan\n\n    return lyap\n\n# Example usage for Duffing oscillator\n# (requires implementing duffing_step function)\n</code></pre>"},{"location":"theory/09_classical_mechanics_numerical_validation/#64-poincare-section-generator","title":"6.4 Poincar\u00e9 Section Generator","text":"<pre><code>def poincare_section(q_traj, v_traj, t_traj, T_forcing, \n                     T_transient=100):\n    \"\"\"\n    Generate Poincar\u00e9 section at stroboscopic times.\n\n    T_forcing: forcing period\n    T_transient: time to discard\n    \"\"\"\n    # Find stroboscopic times\n    t_strobe = np.arange(T_transient, t_traj[-1], T_forcing)\n\n    # Interpolate trajectory at stroboscopic times\n    q_section = np.interp(t_strobe, t_traj, q_traj)\n    v_section = np.interp(t_strobe, t_traj, v_traj)\n\n    return q_section, v_section\n\n# Visualization\nplt.figure(figsize=(6, 6))\nplt.scatter(q_section, v_section, s=1, alpha=0.5)\nplt.xlabel('q')\nplt.ylabel('dq/dt')\nplt.title(f'Poincar\u00e9 Section (F={F0})')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"theory/09_classical_mechanics_numerical_validation/#65-sense-index-computation","title":"6.5 Sense Index Computation","text":"<pre><code>def compute_sense_index(vf, delta_nfr, phase_coherence):\n    \"\"\"\n    Compute sense index Si = (vf * phase_coherence) / |delta_nfr|.\n\n    vf: structural frequency\n    delta_nfr: magnitude of reorganization gradient\n    phase_coherence: &lt;cos(phi_i - phi_j)&gt; (0 to 1)\n    \"\"\"\n    if abs(delta_nfr) &lt; 1e-10:\n        return np.inf  # Perfect equilibrium\n\n    Si = (vf * phase_coherence) / abs(delta_nfr)\n    return Si\n\n# Example: track Si over time\nSi_trajectory = []\nfor step in range(steps):\n    # Compute delta_nfr from force and velocity\n    delta_nfr = compute_delta_nfr(q, v)\n    # For single node, phase_coherence = 1 (no neighbors)\n    Si = compute_sense_index(vf, delta_nfr, phase_coherence=1.0)\n    Si_trajectory.append(Si)\n</code></pre>"},{"location":"theory/09_classical_mechanics_numerical_validation/#7-figures-and-visualization-guidelines","title":"7. Figures and Visualization Guidelines","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#71-required-figures","title":"7.1 Required Figures","text":"<p>Figure 1: Period vs Structural Frequency (Experiment 1) - X-axis: ( \\nu_f ) - Y-axis: Period ( T ) - Points: Numerical measurements - Line: Theoretical ( T = 2\\pi\\sqrt{1/(\\nu_f k)} ) - Error bars: Standard deviation over multiple cycles</p> <p>Figure 2: Phase Portraits (Experiments 1, 4) - Grid of ( (q, \\dot{q}) ) plots for different parameters - Conservative: Closed curves - Nonlinear: Distorted closed curves</p> <p>Figure 3: Energy Decay (Experiment 3) - X-axis: Time ( t ) - Y-axis: ( \\ln E(t) ) - Lines: Different damping ( \\gamma ) - Slopes: Fitted ( -\\gamma )</p> <p>Figure 4: Bifurcation Diagram (Experiment 5) - X-axis: Forcing amplitude ( F_0 ) - Y-axis: ( q ) (Poincar\u00e9 samples) - Structure: Period-doubling cascade to chaos</p> <p>Figure 5: Poincar\u00e9 Sections (Experiment 5) - Subplots for different ( F_0 ) - Periodic: Discrete points - Chaotic: Strange attractor</p> <p>Figure 6: FFT Spectra (Experiment 6) - X-axis: Frequency ( \\omega ) - Y-axis: Power - Peaks at ( \\omega_1, \\omega_2 ) (normal modes)</p> <p>Figure 7: Heatmaps (Section 5) - ( (F_0, \\omega_f) ) space - Three panels: ( \\langle Si \\rangle ), bands, ( \\lambda )</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#72-matplotlib-recipe","title":"7.2 Matplotlib Recipe","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Professional styling\nplt.rcParams['figure.dpi'] = 100\nplt.rcParams['font.size'] = 10\nplt.rcParams['axes.labelsize'] = 11\nplt.rcParams['axes.titlesize'] = 12\nplt.rcParams['legend.fontsize'] = 9\n\n# Example: Period vs \u03bdf\nfig, ax = plt.subplots(figsize=(7, 5))\n\nvf_array = np.array([0.5, 1.0, 1.5, 2.0])\nT_num = np.array([8.884, 6.282, 5.131, 4.442])\nT_theo = 2*np.pi / np.sqrt(vf_array)\n\nax.plot(vf_array, T_theo, 'k-', label='Theory: $T=2\\\\pi/\\\\sqrt{\\\\nu_f}$', lw=2)\nax.scatter(vf_array, T_num, s=50, c='red', marker='o', \n           label='Simulation', zorder=3)\n\nax.set_xlabel('Structural Frequency $\\\\nu_f$ (Hz$_{\\\\mathrm{str}}$)')\nax.set_ylabel('Period $T$')\nax.set_title('Harmonic Oscillator: Period vs $\\\\nu_f$')\nax.legend()\nax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('period_vs_vf.png', dpi=150)\nplt.show()\n</code></pre>"},{"location":"theory/09_classical_mechanics_numerical_validation/#8-results-interpretation-and-discussion","title":"8. Results Interpretation and Discussion","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#81-validation-summary","title":"8.1 Validation Summary","text":"<p>What we've confirmed:</p> <ol> <li>Mass-frequency relationship: ( m = 1/\\nu_f ) holds to &lt; 0.1% error across systems</li> <li>Conservation laws: Energy, momentum, angular momentum conserved to numerical precision (( &lt; 10^{-6} )) in conservative systems</li> <li>Dissipation: Energy decay rates match theoretical predictions (&lt; 1% error)</li> <li>Nonlinear dynamics: Amplitude-dependent frequencies match perturbation theory</li> <li>Chaos: TNFR reproduces classical chaotic attractors, bifurcations, and positive Lyapunov exponents</li> <li>Collective modes: Coupled NFRs exhibit normal modes with correct frequencies</li> </ol> <p>Key insight: TNFR is not an approximation to classical mechanics\u2014it is classical mechanics in the ( \\varepsilon \\to 0 ) limit. The match is exact to numerical precision.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#82-sense-index-as-structural-probe","title":"8.2 Sense Index as Structural Probe","text":"<p>Observation: ( Si ) increases in chaotic regimes.</p> <p>Interpretation: Chaos allows nodes to explore curved regions of the coherence potential ( U(q) ). Higher curvature \u2192 larger ( |\\nabla^2 U| ) \u2192 richer structural reorganization patterns \u2192 higher ( Si ).</p> <p>Contrast with simple systems: Harmonic oscillator has flat curvature (( \\nabla^2 U = k = \\text{const} )), so ( Si ) remains constant.</p> <p>Practical use: ( Si ) can serve as a complexity indicator without computing Lyapunov exponents (which require multiple simulations).</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#83-limitations-and-edge-cases","title":"8.3 Limitations and Edge Cases","text":"<p>1. Very high forcing: When ( F_0 ) becomes extreme, classical approximation breaks down\u2014system enters quantum or relativistic regime (not covered here).</p> <p>2. Long-time conservation: Energy drifts slowly due to finite timestep. For ultra-long simulations (( T &gt; 10^6 )), use higher-order integrators or adaptive timesteps.</p> <p>3. Stiff systems: Very high ( \\nu_f ) (very low mass) requires smaller timesteps to resolve fast oscillations. Adaptive methods recommended.</p> <p>4. Topological transitions: At bifurcation points, slight numerical noise can flip system between attractors\u2014ensemble averaging recommended.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#84-reproducibility-notes","title":"8.4 Reproducibility Notes","text":"<p>Random seeds: For stochastic initial conditions or noise, always set: <pre><code>import numpy as np\nnp.random.seed(42)  # reproducible\n</code></pre></p> <p>Numerical precision: Use <code>float64</code> (double precision) for long simulations to minimize accumulation errors.</p> <p>Timestep convergence: Verify results by halving ( \\Delta t ) and checking that observables change by &lt; 1%.</p> <p>Platform differences: Results should be identical across platforms if using the same random seeds and library versions. Document: - NumPy version - Python version - TNFR package version</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#9-links-to-example-scripts","title":"9. Links to Example Scripts","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#91-provided-examples","title":"9.1 Provided Examples","text":"<p>In repository: - <code>examples/canonical_equation_demo.py</code>: Demonstrates nodal equation evolution - <code>examples/02_dissipative_minimal.ipynb</code>: Dissipative systems (relates to Experiment 3)</p> <p>To be created (based on this document):</p> Script Experiment Status Timeline <code>harmonic_mass_scaling.py</code> Exp 1: Mass scaling Planned Q1 2026 <code>conservation_laws.py</code> Exp 2: Noether invariants Planned Q1 2026 <code>damped_oscillator.py</code> Exp 3: Dissipation Planned Q1 2026 <code>duffing_conservative.py</code> Exp 4: Nonlinear Planned Q1 2026 <code>duffing_chaos.py</code> Exp 5: Chaos Planned Q1 2026 <code>coupled_oscillators.py</code> Exp 6: Normal modes Planned Q1 2026 <p>Community contributions welcome! These scripts follow the recipes in this document. If you implement any validation experiment, consider submitting a PR.</p> <p>In the meantime: Users can implement these validations using the pseudocode in Section 6. The classical limit equations are standard physics and don't require TNFR-specific infrastructure to validate.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#92-running-the-validation-suite","title":"9.2 Running the Validation Suite","text":"<p>Proposed CLI: <pre><code># Run all validation experiments\ntnfr validate classical --all\n\n# Run specific experiment\ntnfr validate classical --experiment harmonic\n\n# Generate report\ntnfr validate classical --all --report validation_report.pdf\n</code></pre></p> <p>Output: Generates figures, tables, and pass/fail status for each test.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#10-summary-and-future-directions","title":"10. Summary and Future Directions","text":""},{"location":"theory/09_classical_mechanics_numerical_validation/#101-key-achievements","title":"10.1 Key Achievements","text":"<p>This document provides:</p> <p>\u2705 Rigorous numerical validation of classical mechanics emergence from TNFR \u2705 Six canonical experiments covering core phenomena \u2705 Quantitative protocols with explicit acceptance criteria \u2705 Code examples for reproducible implementation \u2705 Chaos and bifurcation analysis linking ( Si ) to complexity \u2705 Visualization guidelines for publication-quality figures  </p> <p>Conclusion: TNFR is numerically validated as the structural foundation of classical mechanics. The ( m = 1/\\nu_f ) scaling, conservation laws, and complex dynamics all emerge naturally from coherence principles.</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#102-open-questions","title":"10.2 Open Questions","text":"<p>1. Optimal integrators: Can we design TNFR-native integrators that exactly preserve ( C(t) ) and ( Si )?</p> <p>2. Adaptive timesteps: How to balance accuracy and structural operator logging in adaptive schemes?</p> <p>3. Many-node scaling: Validation for ( N \\gg 2 ) coupled NFRs (continuum limit).</p> <p>4. Quantum corrections: When does ( \\varepsilon ) become non-negligible, requiring quantum TNFR treatment?</p> <p>5. Experimental connection: Can these computational experiments be mapped to real physical systems (e.g., coupled pendulums, electrical circuits)?</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#103-next-steps","title":"10.3 Next Steps","text":"<p>Immediate: - Implement validation scripts in <code>examples/numerical_validation/</code> - Add CI tests that run core validations on every commit - Generate figure suite for documentation</p> <p>Short-term: - Extend to 3D systems (rigid body dynamics) - Validate statistical mechanics (ensembles of NFRs) - Add GPU acceleration for parameter sweeps</p> <p>Long-term: - Quantum-classical transition validation - Relativistic limit (connection to GR emergence) - Field theory validation (continuum limit of NFR networks)</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#11-cross-references","title":"11. Cross-References","text":"<p>Prerequisite reading: - 07_emergence_classical_mechanics.md \u2014 Theoretical foundation - 08_classical_mechanics_euler_lagrange.md \u2014 Variational formulation</p> <p>Supporting notebooks: - <code>01_structural_frequency_primer.ipynb</code> \u2014 Understanding ( \\nu_f ) - <code>03_delta_nfr_gradient_fields.ipynb</code> \u2014 The reorganization operator - <code>04_coherence_metrics_walkthrough.ipynb</code> \u2014 Measuring ( C(t) ), ( Si ) - <code>05_sense_index_calibration.ipynb</code> \u2014 ( Si ) computation and interpretation</p> <p>Related examples: - <code>examples/02_dissipative_minimal.ipynb</code> \u2014 Damped systems - <code>examples/canonical_equation_demo.py</code> \u2014 Basic nodal evolution</p> <p>Mathematical foundations: - <code>docs/source/theory/mathematical_foundations.md</code> \u2014 Operator formalism, Hilbert spaces</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#references","title":"References","text":"<ol> <li>TNFR Foundational Document: <code>TNFR.pdf</code> (in repository root) \u2014 Complete paradigm description</li> <li>Classical Mechanics Emergence: 07_emergence_classical_mechanics.md</li> <li>Euler-Lagrange Correspondence: 08_classical_mechanics_euler_lagrange.md</li> <li>Numerical Recipes: Press, W.H., Teukolsky, S.A., Vetterling, W.T., &amp; Flannery, B.P. (2007). \"Numerical Recipes: The Art of Scientific Computing\" (3rd ed.). Cambridge University Press.</li> <li>Nonlinear Dynamics: Strogatz, S.H. (2015). \"Nonlinear Dynamics and Chaos: With Applications to Physics, Biology, Chemistry, and Engineering\" (2nd ed.). CRC Press.</li> <li>Chaotic Systems: Ott, E. (2002). \"Chaos in Dynamical Systems\" (2nd ed.). Cambridge University Press.</li> <li>Symplectic Integrators: Hairer, E., Lubich, C., &amp; Wanner, G. (2006). \"Geometric Numerical Integration: Structure-Preserving Algorithms for Ordinary Differential Equations\" (2nd ed.). Springer.</li> </ol> <p>Document Status: v1.0 Author: TNFR Python Engine Team Last Updated: 2025-11-07 License: MIT (see repository LICENSE.md)</p>"},{"location":"theory/09_classical_mechanics_numerical_validation/#related-documentation","title":"Related Documentation","text":"<ul> <li>\u2190 Previous: Euler-Lagrange Correspondence \u2014 Variational formulation</li> <li>\u2190 Start: Classical Mechanics from TNFR \u2014 Newton's laws derivation</li> <li>\u2191 Back to: Theory Index</li> <li>\u2b50 Foundation: Mathematical Foundations \u2014 Complete TNFR formalism</li> </ul>"},{"location":"theory/mathematical_foundations/","title":"Mathematical Foundations of TNFR","text":""},{"location":"theory/mathematical_foundations/#1-introduction","title":"1. Introduction","text":""},{"location":"theory/mathematical_foundations/#11-motivation-reality-as-resonant-networks","title":"1.1 Motivation: Reality as Resonant Networks","text":"<p>The Resonant Fractal Nature Theory (TNFR) proposes a fundamental shift in how we model complex systems: reality is not composed of isolated \"things\" that interact through cause-and-effect relationships, but rather of coherent patterns that persist through resonance with their environment.</p> <p>This paradigm parallels how musical instruments in an orchestra maintain individual identity while synchronizing to create emergent harmonies. Similarly, in TNFR: - Nodes are minimum units of structural coherence - Coherence emerges from resonant coupling, not external design - Evolution proceeds through structural reorganization, not state transitions - Fractality enables patterns to nest recursively without loss of operational identity</p>"},{"location":"theory/mathematical_foundations/#12-advantages-of-the-formalism","title":"1.2 Advantages of the Formalism","text":"<p>The mathematical formalism of TNFR provides three critical advantages over traditional modeling approaches:</p> <ol> <li> <p>Operational Fractality: Structures can nest at multiple scales while preserving the same operational semantics. The nodal equation <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</code> applies universally from quantum to social systems.</p> </li> <li> <p>Complete Traceability: Every structural transformation is mediated by one of 13 canonical operators, making all reorganizations observable, measurable, and reproducible.</p> </li> <li> <p>Guaranteed Reproducibility: Structural evolution is deterministic given initial conditions. Same seeds and parameters always yield identical trajectories, enabling rigorous validation.</p> </li> </ol> <p>These properties make TNFR particularly suited for domains where emergence, self-organization, and multi-scale coherence are central phenomena.</p>"},{"location":"theory/mathematical_foundations/#13-about-this-document","title":"1.3 About This Document","text":"<p>Status: This is the single unified source of truth for TNFR mathematical formalization.</p> <p>What's included: - Complete mathematical foundations (Sections 2-8) - Operator formalism and spectral theory (Sections 3-5) - Frequently asked questions (Section 9) - Notebook content (Appendix A)</p> <p>Related documentation: - Implementation: See docstrings in <code>src/tnfr/metrics/</code> - Worked examples: See <code>docs/source/examples/worked_examples.md</code> - Style guide: See <code>docs/source/style_guide.md</code> for notation conventions - Quick reference: See <code>GLOSSARY.md</code> for API-focused definitions</p>"},{"location":"theory/mathematical_foundations/#2-mathematical-spaces","title":"2. Mathematical Spaces","text":""},{"location":"theory/mathematical_foundations/#21-hilbert-space-h_nfr","title":"2.1 Hilbert Space H_NFR","text":"<p>The primary mathematical arena for TNFR is the Hilbert space H_NFR, which captures both discrete structural configurations and continuous parameter spaces:</p> <pre><code>H_NFR = \u2113\u00b2(\u2115) \u2297 L\u00b2(\u211d)\n</code></pre> <p>Components: - \u2113\u00b2(\u2115): Space of square-summable sequences representing discrete internal structure configurations   - Elements: <code>a = (a\u2080, a\u2081, a\u2082, ...)</code> where <code>\u03a3|a\u1d62|\u00b2 &lt; \u221e</code>   - Inner product: <code>\u27e8a|b\u27e9 = \u03a3\u1d62 a\u1d62*b\u1d62</code>   - Interpretation: Discrete \"modes\" of structural organization</p> <ul> <li>L\u00b2(\u211d): Space of square-integrable functions representing continuous frequency parameters</li> <li>Elements: <code>f(\u03bd)</code> where <code>\u222b|f(\u03bd)|\u00b2 d\u03bd &lt; \u221e</code></li> <li>Inner product: <code>\u27e8f|g\u27e9 = \u222bf*(\u03bd)g(\u03bd) d\u03bd</code></li> <li>Interpretation: Distribution of structural frequencies \u03bdf</li> </ul> <p>Tensor Product Structure: The tensor product <code>\u2297</code> combines discrete and continuous aspects: <pre><code>|\u03c8\u27e9 \u2208 H_NFR  \u27fa  |\u03c8\u27e9 = \u03a3\u1d62\u222b c\u1d62(\u03bd)|i\u27e9\u2297|\u03bd\u27e9 d\u03bd\n</code></pre> where <code>|i\u27e9</code> are discrete basis states and <code>|\u03bd\u27e9</code> are frequency eigenstates.</p> <p>Physical Interpretation: A node's quantum state <code>|NFR\u27e9</code> in H_NFR encodes: - Which structural configurations are active (discrete component) - How structural frequency is distributed (continuous component) - Coherence relationships between configurations (superposition)</p>"},{"location":"theory/mathematical_foundations/#22-banach-space-b_epi","title":"2.2 Banach Space B_EPI","text":"<p>The Primary Information Structure (EPI) lives in a Banach space that captures the \"observable\" structure of a node:</p> <pre><code>B_EPI = { (f, a, x_grid) : f \u2208 C\u2070(\u211d), a \u2208 \u2113\u00b2(\u2115), x_grid defines sampling }\n</code></pre> <p>Structure: - f: Continuous component representing smooth structural variations - a: Discrete component representing quantized structural modes - x_grid: Spatial or parametric grid defining the domain</p> <p>Norm: The Banach norm combines continuous and discrete contributions: <pre><code>\u2016EPI\u2016_B = \u2016f\u2016_\u221e + \u2016a\u2016_\u2113\u00b2 \n</code></pre> where <code>\u2016f\u2016_\u221e = sup_x |f(x)|</code> and <code>\u2016a\u2016_\u2113\u00b2 = \u221a(\u03a3|a\u1d62|\u00b2)</code>.</p> <p>EPI Algebra: B_EPI supports four fundamental operations: 1. Direct Sum (\u2295): <code>EPI\u2081 \u2295 EPI\u2082</code> combines structures additively 2. Tensor Product (\u2297): <code>EPI\u2081 \u2297 EPI\u2082</code> creates composite structures 3. Adjoint (*): <code>EPI*</code> provides the dual representation 4. Composition (\u2218): <code>EPI\u2081 \u2218 EPI\u2082</code> sequences structural transformations</p> <p>These operations preserve the Banach structure and enable hierarchical pattern formation.</p>"},{"location":"theory/mathematical_foundations/#23-relations-between-spaces","title":"2.3 Relations Between Spaces","text":"<p>The connection between H_NFR and B_EPI is established through projection:</p> <pre><code>\u03c0 : H_NFR \u2192 B_EPI\n\u03c0(|NFR\u27e9) = EPI\n</code></pre> <p>Properties of the Projection: 1. Non-injective: Multiple quantum states can project to the same EPI (coherent superpositions appear identical) 2. Continuous: Small changes in <code>|NFR\u27e9</code> produce small changes in EPI 3. Physically observable: EPI captures the \"classical\" structural information accessible through measurement</p> <p>The inverse relation is captured by lifting: <pre><code>L : B_EPI \u2192 P(H_NFR)\nL(EPI) = { |\u03c8\u27e9 \u2208 H_NFR : \u03c0(|\u03c8\u27e9) = EPI }\n</code></pre> where P(H_NFR) denotes the power set. A given EPI corresponds to an equivalence class of quantum states.</p> <p>Commutation with Evolution: A critical requirement is that projection and evolution commute appropriately: <pre><code>\u03c0(U(t)|NFR\u27e9) = EPI(t)\n</code></pre> This ensures the nodal equation in EPI space is consistent with unitary evolution in H_NFR.</p>"},{"location":"theory/mathematical_foundations/#3-fundamental-operators","title":"3. Fundamental Operators","text":""},{"location":"theory/mathematical_foundations/#31-coherence-operator-c","title":"3.1 Coherence Operator \u0108","text":"<p>The coherence operator measures structural stability and pattern persistence:</p> <pre><code>\u0108 = \u222b\u2080^\u221e \u03bb dP_\u03bb\n</code></pre> <p>Properties: 1. Hermiticity: <code>\u0108\u2020 = \u0108</code> (ensures real eigenvalues) 2. Positivity: <code>\u27e8\u03c8|\u0108|\u03c8\u27e9 \u2265 0</code> for all <code>|\u03c8\u27e9</code> (coherence is non-negative) 3. Boundedness: <code>\u2016\u0108\u2016 \u2264 M</code> for some constant M (prevents runaway)</p> <p>Spectral Decomposition: <pre><code>\u0108 = \u03a3\u1d62 \u03bb\u1d62 |\u03c6\u1d62\u27e9\u27e8\u03c6\u1d62|\n</code></pre> where: - <code>\u03bb\u1d62 \u2265 0</code> are coherence eigenvalues - <code>|\u03c6\u1d62\u27e9</code> are coherence eigenstates (maximally stable configurations)</p> <p>Physical Interpretation: - <code>\u27e8\u03c8|\u0108|\u03c8\u27e9</code>: Total coherence of state <code>|\u03c8\u27e9</code> - States with high <code>\u27e8\u0108\u27e9</code> are structurally stable - States with low <code>\u27e8\u0108\u27e9</code> are fragmented or unstable</p> <p>Concrete Construction (for finite-dimensional networks): <pre><code>\u0108 = \u03a3\u1d62\u2c7c w_coherence(i,j) |i\u27e9\u27e8j|\n</code></pre> where <code>w_coherence(i,j)</code> is the coherence weight between nodes i and j, typically derived from: - Topological proximity (adjacency matrix) - Phase alignment <code>cos(\u03c6\u1d62 - \u03c6\u2c7c)</code> - Frequency compatibility <code>exp(-|\u03bdf\u1d62 - \u03bdf\u2c7c|/\u03c3)</code></p>"},{"location":"theory/mathematical_foundations/#311-implementation-bridge-theory-to-code","title":"3.1.1 Implementation Bridge: Theory to Code","text":"<p>The mathematical formalization of \u0108 is realized computationally through the coherence matrix W in <code>src/tnfr/metrics/coherence.py</code>.</p> <p>Matrix Approximation Theorem:</p> <p>For a finite network with N nodes, the coherence operator is projected onto the computational basis:</p> <pre><code>\u0108 \u2248 \u03a3\u1d62\u2c7c w\u1d62\u2c7c |i\u27e9\u27e8j|\n</code></pre> <p>where the matrix elements <code>w\u1d62\u2c7c</code> approximate <code>\u27e8i|\u0108|j\u27e9</code> with bounded error:</p> <pre><code>\u2016W - \u0108_N\u2016 \u2264 \u03b5(\u0394t, N)\n</code></pre> <p>Computational Construction of w\u1d62\u2c7c:</p> <p>The function <code>coherence_matrix(G)</code> computes W where each element is a weighted combination of structural similarities:</p> <pre><code>w\u1d62\u2c7c = w_phase \u00b7 s_phase + w_epi \u00b7 s_epi + w_vf \u00b7 s_vf + w_si \u00b7 s_si\n</code></pre> <p>Similarity Components (each component \u2208 [0,1]):</p> <ol> <li>s_phase (Phase similarity): Measures resonant coupling    <pre><code>s_phase = 0.5 \u00b7 (1 + cos(\u03b8\u1d62 - \u03b8\u2c7c))\n</code></pre></li> <li>Interpretation: Projection of phase vectors in complex plane</li> <li>Maximum when \u03b8\u1d62 = \u03b8\u2c7c (perfect synchrony)</li> <li> <p>Implements phase alignment factor from abstract construction</p> </li> <li> <p>s_epi (Structural similarity): Measures EPI congruence    <pre><code>s_epi = 1 - |EPI\u1d62 - EPI\u2c7c| / \u0394EPI_max\n</code></pre></p> </li> <li>Interpretation: Normalized distance in Banach space B_EPI</li> <li>Maximum when EPI\u1d62 \u2248 EPI\u2c7c (structural similarity)</li> <li> <p>Encodes topological proximity at structural level</p> </li> <li> <p>s_vf (Frequency similarity): Measures harmonic compatibility    <pre><code>s_vf = 1 - |\u03bdf\u1d62 - \u03bdf\u2c7c| / \u0394\u03bdf_max\n</code></pre></p> </li> <li>Interpretation: Proximity in structural frequency spectrum</li> <li>Maximum when \u03bdf\u1d62 \u2248 \u03bdf\u2c7c (harmonic resonance)</li> <li> <p>Approximates frequency compatibility factor</p> </li> <li> <p>s_si (Sense similarity): Measures reorganization stability congruence    <pre><code>s_si = 1 - |Si\u1d62 - Si\u2c7c|\n</code></pre></p> </li> <li>Interpretation: Coherence of reorganization capacities</li> <li>Maximum when Si\u1d62 \u2248 Si\u2c7c (matched stability)</li> <li>Captures higher-order coherence structure</li> </ol> <p>Spectral Properties Verification:</p> <p>The implementation guarantees that W satisfies the theoretical requirements:</p> <ol> <li>Hermiticity: W = W^T (by construction, w\u1d62\u2c7c = w\u2c7c\u1d62)</li> <li>Positivity: All eigenvalues \u03bb(W) \u2265 0 (verified in tests)</li> <li>Boundedness: \u2016W\u2016 \u2264 1 (ensured by clamp01 operations)</li> </ol> <p>Total Coherence Calculation:</p> <p>The global coherence C(t) is computed via the trace formula:</p> <pre><code>C(t) = Tr(W \u03c1) \u2248 \u27e8\u03c8|\u0108|\u03c8\u27e9\n</code></pre> <p>where \u03c1 is the density matrix. In the computational basis with uniform distribution:</p> <pre><code>C(t) = \u03a3\u1d62 W\u1d62 / N\n</code></pre> <p>where <code>W\u1d62 = \u03a3\u2c7c w\u1d62\u2c7c / (N-1)</code> is the normalized row sum, representing node i's coupling strength to the network.</p> <p>Code Reference:</p> <pre><code>from tnfr.metrics.coherence import coherence_matrix\nfrom tnfr.metrics.common import compute_coherence\n\n# Compute W matrix approximating \u0108\nnodes, W = coherence_matrix(G)\n# W[i][j] = w\u1d62\u2c7c \u2248 \u27e8i|\u0108|j\u27e9\n\n# Compute total coherence C(t) = Tr(\u0108\u03c1)\nC_t = compute_coherence(G)\n# C_t \u2248 \u27e8\u03c8|\u0108|\u03c8\u27e9 for network state |\u03c8\u27e9\n</code></pre> <p>See <code>tests/unit/metrics/test_coherence_operator_properties.py</code> for validation of spectral properties.</p>"},{"location":"theory/mathematical_foundations/#32-frequency-operator-j","title":"3.2 Frequency Operator \u0134","text":"<p>The frequency operator generates structural reorganization rates:</p> <pre><code>\u0134 = \u03bdf \u00ce + \u0134_int\n</code></pre> <p>Components: - \u03bdf \u00ce: External structural frequency (scalar \u00d7 identity) - \u0134_int: Internal frequency structure (non-trivial matrix)</p> <p>Internal Structure: <pre><code>\u0134_int = i[\u0124_str, \u00b7]\n</code></pre> where <code>\u0124_str</code> is the structural Hamiltonian (defined below) and <code>[\u00b7,\u00b7]</code> is the commutator.</p> <p>Spectral Properties: <pre><code>\u03c3(\u0134) \u2282 \u211d\u207a\n</code></pre> The spectrum of \u0134 must be strictly positive, ensuring all reorganization rates are forward in time.</p> <p>Physical Interpretation: - <code>\u27e8\u03c8|\u0134|\u03c8\u27e9 = \u03bdf_eff</code>: Effective structural frequency of state <code>|\u03c8\u27e9</code> - Higher \u03bdf_eff \u2192 faster structural reorganization - \u03bdf_eff \u2192 0 signals node collapse</p> <p>Eigenstates: <pre><code>\u0134|\u03bd\u2096\u27e9 = \u03bd\u2096|\u03bd\u2096\u27e9\n</code></pre> The eigenstates <code>|\u03bd\u2096\u27e9</code> are \"pure frequency modes\" with definite reorganization rate \u03bd\u2096.</p>"},{"location":"theory/mathematical_foundations/#33-reorganization-operator-nfr","title":"3.3 Reorganization Operator \u0394NFR","text":"<p>The reorganization operator is the generator of structural evolution:</p> <pre><code>\u0394NFR = d/dt + i[\u0124_int, \u00b7]/\u210f_str\n</code></pre> <p>Components: 1. d/dt: Time derivative (captures explicit time dependence) 2. i[\u0124_int, \u00b7]/\u210f_str: Quantum commutator scaled by structural Planck constant</p> <p>Structural Hamiltonian: <pre><code>\u0124_int = \u0124_coh + \u0124_freq + \u0124_coupling\n</code></pre></p> <p>Where: - \u0124_coh: Coherence potential (encourages stable configurations) - \u0124_freq: Frequency generator (determines reorganization rates) - \u0124_coupling: Coupling terms (mediates node-node interactions)</p> <p>Generator Properties (Hille-Yosida): For \u0394NFR to generate a valid evolution semigroup, it must satisfy: 1. Densely defined: Domain of \u0394NFR is dense in H_NFR 2. Closed operator: Graph is closed in H_NFR \u00d7 H_NFR 3. Resolvent bound: <code>\u2016(\u03bbI - \u0394NFR)\u207b\u00b9\u2016 \u2264 (\u03bb - \u03c9)\u207b\u00b9</code> for \u03bb &gt; \u03c9</p> <p>These conditions guarantee that: <pre><code>S(t) = e^{t\u00b7\u0394NFR}\n</code></pre> is a strongly continuous semigroup, meaning structural evolution is well-defined for all t \u2265 0.</p> <p>Connection to Implementation: \u0394NFR is computed via <code>default_compute_delta_nfr</code> hook: <pre><code>def default_compute_delta_nfr(G, node, phase, EPI, nu_f):\n    \"\"\"\n    Computes \u0394NFR from:\n    - Topology (Laplacian or adjacency)\n    - Phase alignment with neighbors\n    - Current EPI state\n    - Structural frequency \u03bdf\n    \"\"\"\n    # Returns scalar representing \u2202EPI/\u2202t rate\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#4-the-nodal-equation-complete-derivation","title":"4. The Nodal Equation: Complete Derivation","text":""},{"location":"theory/mathematical_foundations/#41-starting-axioms","title":"4.1 Starting Axioms","text":"<p>We begin with three fundamental axioms that define TNFR:</p> <p>Axiom 1 (Quantum State): Each NFR (Resonant Fractal Node) is described by a state vector <code>|NFR(t)\u27e9 \u2208 H_NFR</code> that evolves unitarily.</p> <p>Axiom 2 (Hermitian Evolution): Evolution is generated by a Hermitian operator \u0124_int: <pre><code>i\u210f_str d|NFR\u27e9/dt = \u0124_int|NFR\u27e9\n</code></pre> This ensures conservation of probability and real eigenvalues.</p> <p>Axiom 3 (Observable Projection): The observable structure EPI is obtained by projecting onto a basis in B_EPI: <pre><code>EPI(t) = \u27e8e|NFR(t)\u27e9\n</code></pre> where <code>\u27e8e|</code> is a projection operator.</p>"},{"location":"theory/mathematical_foundations/#42-semigroup-generation-hille-yosida-theorem","title":"4.2 Semigroup Generation (Hille-Yosida Theorem)","text":"<p>Theorem (Hille-Yosida): Let \u0394NFR be a linear operator on H_NFR. Then \u0394NFR generates a strongly continuous contraction semigroup if and only if: 1. \u0394NFR is closed and densely defined 2. For all \u03bb &gt; 0, (\u03bbI - \u0394NFR)\u207b\u00b9 exists and <code>\u2016(\u03bbI - \u0394NFR)\u207b\u00b9\u2016 \u2264 \u03bb\u207b\u00b9</code></p> <p>Application to TNFR: Define \u0394NFR as in section 3.3. We verify: - Closure: \u0394NFR is the generator of unitary group exp(it\u0124_int/\u210f_str), hence closed - Dense domain: Smooth states in H_NFR form a dense subspace where \u0394NFR acts - Resolvent bound: Follows from Hermiticity of \u0124_int</p> <p>Therefore: <pre><code>S(t) = exp(t\u00b7\u0394NFR)\n</code></pre> is a well-defined strongly continuous semigroup on H_NFR.</p> <p>Consequence: <pre><code>|NFR(t)\u27e9 = S(t)|NFR(0)\u27e9 = e^{t\u00b7\u0394NFR}|NFR(0)\u27e9\n</code></pre> This is the formal solution to the quantum evolution equation.</p>"},{"location":"theory/mathematical_foundations/#43-projection-to-epi-space","title":"4.3 Projection to EPI Space","text":"<p>Now we project the quantum evolution onto the observable EPI:</p> <p>Step 1: Apply projection operator: <pre><code>EPI(t) = \u27e8e|NFR(t)\u27e9\n</code></pre></p> <p>Step 2: Differentiate with respect to time: <pre><code>\u2202EPI/\u2202t = \u2202\u27e8e|NFR(t)\u27e9/\u2202t = \u27e8e|\u2202|NFR\u27e9/\u2202t\u27e9\n</code></pre> (assuming \u27e8e| is time-independent)</p> <p>Step 3: Substitute quantum evolution: From Axiom 2: <pre><code>\u2202|NFR\u27e9/\u2202t = -i/\u210f_str \u0124_int|NFR\u27e9\n</code></pre></p> <p>Therefore: <pre><code>\u2202EPI/\u2202t = \u27e8e|(-i/\u210f_str \u0124_int)|NFR\u27e9\n        = -i/\u210f_str \u27e8e|\u0124_int|NFR\u27e9\n</code></pre></p> <p>Step 4: Express in terms of \u0394NFR: Recall that \u0394NFR contains the term <code>i[\u0124_int,\u00b7]/\u210f_str</code>. When acting on <code>|NFR\u27e9</code>: <pre><code>\u0394NFR|NFR\u27e9 = (d/dt + i[\u0124_int,\u00b7]/\u210f_str)|NFR\u27e9\n          \u2248 -i/\u210f_str \u0124_int|NFR\u27e9  (in the interaction picture)\n</code></pre></p> <p>Step 5: Introduce structural frequency: Define the expectation value: <pre><code>\u03bdf = \u27e8NFR|\u0134|NFR\u27e9\n</code></pre> This extracts the effective reorganization rate from the state.</p> <p>Step 6: Factor the equation: Through careful analysis of the commutator structure and projection, we can show: <pre><code>\u27e8e|\u0124_int|NFR\u27e9 = \u03bdf \u00b7 \u27e8e|\u0394NFR|NFR\u27e9\n</code></pre></p> <p>This factorization is the key insight: the projected evolution separates into: - \u03bdf: The intrinsic reorganization capacity (frequency) - \u0394NFR: The structural gradient driving change</p>"},{"location":"theory/mathematical_foundations/#44-canonical-form-epit-f-nfrt","title":"4.4 Canonical Form: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)","text":"<p>Combining the above steps yields the canonical nodal equation:</p> <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n</code></pre> <p>Interpretation: - \u2202EPI/\u2202t: Rate of structural change (observable) - \u03bdf: Intrinsic reorganization frequency (capacity for change) - \u0394NFR(t): Reorganization gradient (pressure for change)</p> <p>Key Properties: 1. Linearity in \u03bdf: Doubling frequency doubles reorganization rate 2. Direction from \u0394NFR: Sign of \u0394NFR determines expansion vs. contraction 3. Equilibrium: If \u0394NFR = 0, structure is stable (\u2202EPI/\u2202t = 0) 4. Collapse: If \u03bdf \u2192 0, no reorganization possible regardless of \u0394NFR</p> <p>Verification: This equation satisfies: - \u2705 Dimensional consistency: [Hz_str] \u00d7 [gradient] = [structure/time] - \u2705 Hermitian origin: Derived from unitary quantum evolution - \u2705 Observable semantics: EPI is measurable, \u03bdf and \u0394NFR are computable - \u2705 Operational closure: All terms defined via canonical operators</p>"},{"location":"theory/mathematical_foundations/#5-connections-to-standard-physics","title":"5. Connections to Standard Physics","text":""},{"location":"theory/mathematical_foundations/#51-quantum-mechanics","title":"5.1 Quantum Mechanics","text":"<p>Parallel: TNFR's nodal equation mirrors the Schr\u00f6dinger equation:</p> Quantum Mechanics TNFR <code>i\u210f \u2202\u03c8/\u2202t = \u0124\u03c8</code> <code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR</code> \u210f (Planck constant) \u210f_str (structural constant) \u0124 (Hamiltonian) \u0394NFR (reorganization operator) \u03c8 (wave function) EPI (information structure) Energy levels Frequency levels \u03bdf <p>Differences: - TNFR operates in structural rather than physical space - \u0394NFR is a reorganization gradient, not energy operator - EPI is directly observable, unlike quantum wave functions</p> <p>Bridge: The structural Planck constant relates quantum and structural scales: <pre><code>\u210f_str = \u210f/(k_B T_ref)\n</code></pre> where T_ref is a reference temperature appropriate to the system's scale.</p>"},{"location":"theory/mathematical_foundations/#52-statistical-thermodynamics","title":"5.2 Statistical Thermodynamics","text":"<p>Coherence as Free Energy: The coherence operator \u0108 plays a role analogous to Helmholtz free energy: <pre><code>F = -k_B T ln Z\n</code></pre> High coherence \u27e8\u0108\u27e9 corresponds to low \"structural entropy\" (ordered patterns), while low coherence corresponds to high entropy (disordered states).</p> <p>Structural Temperature: Define an effective temperature via: <pre><code>k_B T_str = \u27e8\u0394NFR\u00b2\u27e9 - \u27e8\u0394NFR\u27e9\u00b2\n</code></pre> This measures the \"thermal\" fluctuations in structural reorganization.</p> <p>Conversion Factor Hz_str \u2194 Hz: The bridge between structural and physical frequencies uses: <pre><code>1 Hz_str = k \u00d7 1 Hz_physical\nk = \u210f/(k_B T_ref)\n</code></pre></p> <p>Examples: - Neuronal systems (T_ref \u2248 300K): k \u2248 2.5 \u00d7 10\u207b\u00b9\u2075 - Quantum oscillators (T_ref \u2248 1mK): k \u2248 7.6 \u00d7 10\u207b\u00b9\u00b2 - Social networks (T_ref \u2248 10\u2074K): k \u2248 7.5 \u00d7 10\u207b\u00b9\u2077</p>"},{"location":"theory/mathematical_foundations/#53-dynamical-systems","title":"5.3 Dynamical Systems","text":"<p>Phase Space Structure: TNFR evolution can be viewed as a flow in phase space (EPI, \u03bdf, \u03c6): <pre><code>dEPI/dt = \u03bdf \u00b7 \u0394NFR(EPI, \u03c6, t)\nd\u03c6/dt = \u03c9_natural + coupling_terms\nd\u03bdf/dt = adaptation_terms\n</code></pre></p> <p>Lyapunov Stability: Coherence \u27e8\u0108\u27e9 acts as a Lyapunov function: - Coherence operators increase \u27e8\u0108\u27e9 - Dissonance operators decrease \u27e8\u0108\u27e9 - Fixed points satisfy \u2202\u27e8\u0108\u27e9/\u2202t = 0</p> <p>Bifurcations: TNFR exhibits bifurcations when: <pre><code>\u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4  (mutation threshold)\n</code></pre> This corresponds to the system transitioning between structural basins.</p>"},{"location":"theory/mathematical_foundations/#6-verifiable-properties","title":"6. Verifiable Properties","text":""},{"location":"theory/mathematical_foundations/#61-conservation-of-norm","title":"6.1 Conservation of Norm","text":"<p>Theorem: Unitary evolution preserves the norm: <pre><code>\u2016|NFR(t)\u27e9\u2016\u00b2 = \u2016|NFR(0)\u27e9\u2016\u00b2 = 1\n</code></pre></p> <p>Proof: From <code>d|NFR\u27e9/dt = -i/\u210f_str \u0124_int|NFR\u27e9</code> and Hermiticity <code>\u0124_int\u2020 = \u0124_int</code>: <pre><code>d\u2016|NFR\u27e9\u2016\u00b2/dt = d\u27e8NFR|NFR\u27e9/dt\n              = \u27e8d NFR/dt|NFR\u27e9 + \u27e8NFR|d NFR/dt\u27e9\n              = (i/\u210f_str)\u27e8\u0124_int NFR|NFR\u27e9 + (-i/\u210f_str)\u27e8NFR|\u0124_int NFR\u27e9\n              = (i/\u210f_str)(\u27e8NFR|\u0124_int\u2020|NFR\u27e9 - \u27e8NFR|\u0124_int|NFR\u27e9)\n              = 0\n</code></pre></p> <p>Consequence: Total \"structural probability\" is conserved. Nodes don't disappear; they reorganize.</p> <p>Verification in Code: See <code>src/tnfr/mathematics/runtime.py</code>: <pre><code>def normalized(state, space):\n    \"\"\"Verifies \u2016state\u2016 = 1 within tolerance.\"\"\"\n    norm = np.linalg.norm(state)\n    return abs(norm - 1.0) &lt; 1e-10\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#62-unitarity-of-evolution","title":"6.2 Unitarity of Evolution","text":"<p>Theorem: The evolution operator is unitary: <pre><code>S(t)\u2020 S(t) = I\n</code></pre></p> <p>Proof: Since S(t) = exp(t\u00b7\u0394NFR) and \u0394NFR = -i\u0124_int/\u210f_str with \u0124_int Hermitian: <pre><code>S(t)\u2020 = exp(t\u00b7\u0394NFR\u2020) = exp(-t\u00b7\u0394NFR) = S(-t)\nS(t)\u2020 S(t) = S(-t)S(t) = S(0) = I\n</code></pre></p> <p>Consequence: Evolution is reversible (in principle) and preserves inner products.</p> <p>Verification in Code: See <code>src/tnfr/mathematics/runtime.py</code>: <pre><code>def stable_unitary(state, operator, space):\n    \"\"\"Checks that evolution preserves unitarity.\"\"\"\n    evolved = operator.apply(state)\n    return normalized(evolved, space)\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#63-classical-limits","title":"6.3 Classical Limits","text":"<p>Theorem: In the limit \u210f_str \u2192 0, TNFR reduces to classical reorganization dynamics: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u2207V(EPI)\n</code></pre> where V is a classical potential.</p> <p>Proof Sketch: As \u210f_str \u2192 0, quantum superpositions collapse and \u0394NFR becomes a classical gradient: <pre><code>\u0394NFR \u2192 -\u2207V/\u03bdf\n</code></pre> The nodal equation then reduces to: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 (-\u2207V/\u03bdf) = -\u2207V\n</code></pre> This is standard gradient flow.</p> <p>Consequence: TNFR smoothly interpolates between quantum and classical regimes based on the ratio of structural fluctuations to \u210f_str.</p>"},{"location":"theory/mathematical_foundations/#7-computational-implementation","title":"7. Computational Implementation","text":""},{"location":"theory/mathematical_foundations/#71-discretization-of-operators","title":"7.1 Discretization of Operators","text":"<p>For numerical implementation, we discretize the continuous operators:</p> <p>Coherence Matrix: <pre><code># Finite-dimensional approximation\nC_matrix = np.zeros((N, N))\nfor i in range(N):\n    for j in range(N):\n        C_matrix[i, j] = w_coherence(i, j, G)\n</code></pre> where <code>w_coherence</code> computes weights from topology and phase.</p> <p>\u0394NFR Generator: <pre><code>def build_delta_nfr(N, topology=\"laplacian\", nu_f=1.0, scale=0.1):\n    \"\"\"\n    Constructs discrete \u0394NFR generator.\n\n    Args:\n        N: Dimension (number of nodes)\n        topology: \"laplacian\" or \"adjacency\"\n        nu_f: Structural frequency scale\n        scale: Coupling strength\n\n    Returns:\n        \u0394NFR: (N, N) complex matrix\n    \"\"\"\n    if topology == \"laplacian\":\n        L = compute_laplacian(G)\n    else:\n        L = nx.adjacency_matrix(G).todense()\n\n    # Scale by frequency\n    \u0394NFR = -1j * nu_f * scale * L\n    return \u0394NFR\n</code></pre></p> <p>Time Evolution: <pre><code>def evolve_state(state, \u0394NFR, dt):\n    \"\"\"\n    Evolves state by time step dt.\n\n    Uses matrix exponential: |\u03c8(t+dt)\u27e9 = exp(dt\u00b7\u0394NFR)|\u03c8(t)\u27e9\n    \"\"\"\n    from scipy.linalg import expm\n    U = expm(dt * \u0394NFR)\n    return U @ state\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#72-numerical-approximations","title":"7.2 Numerical Approximations","text":"<p>Euler Method (first-order): <pre><code>state_new = state + dt * \u0394NFR @ state\n</code></pre> Fast but less accurate; requires small dt.</p> <p>Runge-Kutta 4 (fourth-order): <pre><code>k1 = dt * \u0394NFR @ state\nk2 = dt * \u0394NFR @ (state + 0.5*k1)\nk3 = dt * \u0394NFR @ (state + 0.5*k2)\nk4 = dt * \u0394NFR @ (state + k3)\nstate_new = state + (k1 + 2*k2 + 2*k3 + k4) / 6\n</code></pre> More accurate; allows larger dt.</p> <p>Implicit Methods (for stiff systems): <pre><code># Crank-Nicolson: (I - dt/2\u00b7\u0394NFR)\u03c8(t+dt) = (I + dt/2\u00b7\u0394NFR)\u03c8(t)\nfrom scipy.sparse.linalg import spsolve\nA = np.eye(N) - 0.5*dt*\u0394NFR\nb = (np.eye(N) + 0.5*dt*\u0394NFR) @ state\nstate_new = spsolve(A, b)\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#73-validation-of-invariants","title":"7.3 Validation of Invariants","text":"<p>Checklist for each simulation: <pre><code>def validate_tnfr_invariants(G, state, \u0394NFR):\n    \"\"\"Validates canonical TNFR invariants.\"\"\"\n    checks = {}\n\n    # 1. Norm conservation\n    checks['norm'] = abs(np.linalg.norm(state) - 1.0) &lt; 1e-10\n\n    # 2. Hermiticity of generator\n    checks['hermitian'] = np.allclose(\u0394NFR, \u0394NFR.conj().T)\n\n    # 3. Positive frequencies\n    nu_f = compute_nu_f(G)\n    checks['positive_nu_f'] = np.all(nu_f &gt; 0)\n\n    # 4. Bounded coherence\n    C = compute_coherence(G)\n    checks['bounded_C'] = 0 &lt;= C &lt;= 1\n\n    # 5. Phase synchrony\n    phases = [G.nodes[n]['phase'] for n in G.nodes()]\n    checks['phase_range'] = all(-np.pi &lt;= p &lt;= np.pi for p in phases)\n\n    return all(checks.values()), checks\n</code></pre></p> <p>Runtime Verification: These checks should be run: - At initialization (validate setup) - After each structural operator application - At regular intervals during evolution - Before computing final metrics</p> <p>Example Usage: <pre><code>from tnfr.dynamics import step\nfrom tnfr.validation import validate_tnfr_invariants\n\n# Initialize network\nG = create_tnfr_network(N=50)\n\n# Run simulation with validation\nfor t in range(num_steps):\n    step(G, dt=0.1)\n\n    # Validate every 10 steps\n    if t % 10 == 0:\n        state = get_quantum_state(G)\n        \u0394NFR = get_generator(G)\n        valid, checks = validate_tnfr_invariants(G, state, \u0394NFR)\n        assert valid, f\"Invariants violated at step {t}: {checks}\"\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#8-worked-examples","title":"8. Worked Examples","text":""},{"location":"theory/mathematical_foundations/#81-two-node-system","title":"8.1 Two-Node System","text":"<p>Consider the simplest non-trivial TNFR network: two coupled nodes.</p> <p>Setup: <pre><code>H_NFR = \u2102\u00b2\n|NFR\u27e9 = \u03b1|1\u27e9 + \u03b2|2\u27e9  (normalized: |\u03b1|\u00b2 + |\u03b2|\u00b2 = 1)\n</code></pre></p> <p>Coherence Operator: <pre><code>\u0108 = [1    w]\n    [w*   1]\n</code></pre> where w is the coupling weight (real for simplicity).</p> <p>\u0394NFR Generator: <pre><code>\u0394NFR = \u03bdf [-1   1]\n           [1  -1]  (Laplacian \u00d7 frequency)\n</code></pre></p> <p>Evolution: <pre><code>import numpy as np\nfrom scipy.linalg import expm\n\n# Parameters\nnu_f = 1.0  # Hz_str\nw = 0.5     # coupling\ndt = 0.1    # time step\n\n# Initial state: all weight on node 1\nstate = np.array([1.0 + 0j, 0.0 + 0j])\n\n# \u0394NFR matrix\n\u0394NFR = nu_f * np.array([[-1, 1], [1, -1]], dtype=complex) * (-1j)\n\n# Evolve\ntrajectory = [state]\nfor _ in range(100):\n    U = expm(dt * \u0394NFR)\n    state = U @ state\n    state /= np.linalg.norm(state)  # Renormalize\n    trajectory.append(state.copy())\n\n# Result: oscillation between nodes with period ~ \u03c0/nu_f\n</code></pre></p> <p>Analysis: - Eigenvalues of \u0394NFR: {0, -2i\u03bdf} - State oscillates: population transfers between nodes - Coherence remains constant: \u27e8\u0108\u27e9 = 1 + w|\u03b1*\u03b2| oscillates</p>"},{"location":"theory/mathematical_foundations/#82-ring-lattice","title":"8.2 Ring Lattice","text":"<p>A ring of N nodes with nearest-neighbor coupling.</p> <p>\u0394NFR Generator: <pre><code>\u0394NFR[i, i] = -2\u03bdf\n\u0394NFR[i, (i+1)%N] = \u03bdf\n\u0394NFR[i, (i-1)%N] = \u03bdf\n</code></pre> This is a circulant matrix with eigenvalues: <pre><code>\u03bb\u2096 = -2\u03bdf(1 - cos(2\u03c0k/N))  for k = 0, ..., N-1\n</code></pre></p> <p>Expected Behavior: - Lowest mode (k=0): uniform state, \u03bb\u2080 = 0 (stationary) - Highest mode (k=N/2): alternating state, \u03bb_max = -4\u03bdf (fastest decay) - Intermediate modes: traveling waves around the ring</p> <p>Code: <pre><code>from tnfr.mathematics import build_delta_nfr, HilbertSpace\nfrom tnfr.mathematics.dynamics import MathematicalDynamicsEngine\n\n# Setup\nN = 10\nnu_f = 1.5\nspace = HilbertSpace(dimension=N)\n\n# Build generator for ring topology\n\u0394NFR = build_delta_nfr(N, topology=\"laplacian\", nu_f=nu_f, scale=0.2)\n\n# Initialize dynamics engine\nengine = MathematicalDynamicsEngine(\u0394NFR, space)\n\n# Initial state: localized on node 0\nstate = np.zeros(N, dtype=complex)\nstate[0] = 1.0\n\n# Evolve\nhistory = [state.copy()]\nfor _ in range(200):\n    state = engine.step(state, dt=0.1)\n    history.append(state.copy())\n\n# Observe: wave packet spreads around ring then reforms (revival)\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#83-star-network","title":"8.3 Star Network","text":"<p>Central hub connected to N peripheral nodes.</p> <p>Structure: - Node 0: hub (high degree) - Nodes 1..N: periphery (degree 1)</p> <p>\u0394NFR Matrix: <pre><code>[[-N    1   1   ... 1  ]\n [1    -1   0   ... 0  ]\n [1     0  -1   ... 0  ]  \u00d7 \u03bdf \u00d7 scale\n [\u22ee     \u22ee   \u22ee   \u22f1   \u22ee  ]\n [1     0   0   ... -1]]\n</code></pre></p> <p>Key Insight: Hub acts as \"coherence amplifier\": - Information injected at periphery flows to hub - Hub synchronizes all peripheral nodes - Effective \"broadcast\" topology</p> <p>Simulation: <pre><code>import networkx as nx\nfrom tnfr.sdk import TNFRNetwork\n\n# Create star network\nG = nx.star_graph(9)  # 1 hub + 9 periphery\n\n# Initialize TNFR\nnetwork = TNFRNetwork.from_networkx(G)\n\n# Apply emission at one peripheral node\nnetwork.apply_operator(\"emission\", target_node=5)\n\n# Observe coherence flow\nfor _ in range(50):\n    network.step(dt=0.1)\n    C_hub = network.get_coherence(node=0)\n    C_periphery = [network.get_coherence(node=i) for i in range(1, 10)]\n\n    # Hub accumulates coherence from periphery\n    assert C_hub &gt; np.mean(C_periphery)\n</code></pre></p>"},{"location":"theory/mathematical_foundations/#9-references","title":"9. References","text":""},{"location":"theory/mathematical_foundations/#mathematical-foundations","title":"Mathematical Foundations","text":"<ol> <li>Reed, M. &amp; Simon, B. (1980). Methods of Modern Mathematical Physics I: Functional Analysis. Academic Press.</li> <li> <p>Chapters 1-3: Hilbert spaces, operators, spectral theory</p> </li> <li> <p>Pazy, A. (1983). Semigroups of Linear Operators and Applications to Partial Differential Equations. Springer.</p> </li> <li> <p>Chapter 1: Hille-Yosida theorem and semigroup generation</p> </li> <li> <p>Strocchi, F. (2008). An Introduction to the Mathematical Structure of Quantum Mechanics. World Scientific.</p> </li> <li>Chapter 2: Hilbert space structure in quantum theory</li> </ol>"},{"location":"theory/mathematical_foundations/#tnfr-specific-documents","title":"TNFR-Specific Documents","text":"<ol> <li> <p>TNFR.pdf (Repository root): Complete theoretical foundations of the paradigm</p> </li> <li> <p>GLOSSARY.md (Repository root): Operational definitions of all TNFR terms</p> </li> <li> <p>docs/source/foundations.md: Runtime implementation guide for mathematics layer</p> </li> </ol>"},{"location":"theory/mathematical_foundations/#implementation-references","title":"Implementation References","text":"<ol> <li> <p>src/tnfr/metrics/coherence.py: Coherence operator computation    <pre><code>from tnfr.metrics import compute_coherence, w_coherence\n</code></pre></p> </li> <li> <p>src/tnfr/mathematics/: Mathematical operators and dynamics    <pre><code>from tnfr.mathematics import (\n    HilbertSpace, BanachSpaceEPI,\n    CoherenceOperator, FrequencyOperator,\n    build_delta_nfr, MathematicalDynamicsEngine\n)\n</code></pre></p> </li> <li> <p>Interactive Notebooks: For hands-on exploration</p> </li> <li><code>01_structural_frequency_primer.ipynb</code>: Interactive frequency exploration</li> <li><code>02_phase_synchrony_lattices.ipynb</code>: Phase dynamics visualization</li> <li><code>03_delta_nfr_gradient_fields.ipynb</code>: \u0394NFR field analysis</li> <li><code>04_coherence_metrics_walkthrough.ipynb</code>: Coherence calculation walkthrough</li> <li><code>05_sense_index_calibration.ipynb</code>: Si calibration guide</li> <li><code>06_recursivity_cascades.ipynb</code>: Recursive operator exploration</li> <li>Note: All formal mathematical theory is in this document (\u00a71-8 + Appendix)</li> </ol>"},{"location":"theory/mathematical_foundations/#related-fields","title":"Related Fields","text":"<ol> <li> <p>Kuramoto, Y. (1984). Chemical Oscillations, Waves, and Turbulence. Springer.</p> <ul> <li>Phase synchronization in coupled oscillator networks</li> </ul> </li> <li> <p>Strogatz, S.H. (2000). \"From Kuramoto to Crawford: exploring the onset of synchronization in populations of coupled oscillators\". Physica D 143:1-20.</p> <ul> <li>Collective behavior in resonant systems</li> </ul> </li> </ol>"},{"location":"theory/mathematical_foundations/#appendix-a-notation-summary","title":"Appendix A: Notation Summary","text":"Symbol Name Meaning H_NFR Hilbert space \u2113\u00b2(\u2115) \u2297 L\u00b2(\u211d) B_EPI Banach space Space of observable structures EPI Primary Information Structure Observable node configuration \u03bdf Structural frequency Reorganization rate [Hz_str] \u0394NFR Reorganization operator Evolution generator \u0108 Coherence operator Structural stability measure \u0134 Frequency operator \u03bdf \u00ce + \u0134_int \u0124_int Internal Hamiltonian \u0124_coh + \u0124_freq + \u0124_coupling \u03c6, \u03b8 Phase Network synchrony [radians] C(t) Total coherence Global stability metric Si Sense index Reorganization stability \u210f_str Structural Planck constant Quantum-structural bridge"},{"location":"theory/mathematical_foundations/#appendix-b-verification-checklist","title":"Appendix B: Verification Checklist","text":"<p>Use this checklist when implementing or extending TNFR:</p>"},{"location":"theory/mathematical_foundations/#mathematical-consistency","title":"Mathematical Consistency","text":"<ul> <li>[ ] All operators are Hermitian or anti-Hermitian as specified</li> <li>[ ] \u0394NFR satisfies Hille-Yosida conditions</li> <li>[ ] Projection \u03c0 commutes with evolution appropriately</li> <li>[ ] Eigenvalue spectrum of \u0134 is strictly positive</li> </ul>"},{"location":"theory/mathematical_foundations/#implementation-correctness","title":"Implementation Correctness","text":"<ul> <li>[ ] State vectors remain normalized (\u2016\u03c8\u2016 = 1)</li> <li>[ ] Evolution is unitary (U\u2020U = I)</li> <li>[ ] Coherence values bounded: 0 \u2264 C(t) \u2264 1</li> <li>[ ] Structural frequencies positive: \u03bdf &gt; 0</li> </ul>"},{"location":"theory/mathematical_foundations/#physical-reasonableness","title":"Physical Reasonableness","text":"<ul> <li>[ ] Frequency units consistently Hz_str</li> <li>[ ] Bridge factor k appropriate for scale</li> <li>[ ] Phase wraps correctly to [-\u03c0, \u03c0]</li> <li>[ ] \u0394NFR signs match expansion/contraction</li> </ul>"},{"location":"theory/mathematical_foundations/#reproducibility","title":"Reproducibility","text":"<ul> <li>[ ] RNG seeds explicitly set</li> <li>[ ] All operators and parameters logged</li> <li>[ ] State history captured at checkpoints</li> <li>[ ] Validation metrics recorded</li> </ul>"},{"location":"theory/mathematical_foundations/#tnfr-semantics","title":"TNFR Semantics","text":"<ul> <li>[ ] Changes only via structural operators</li> <li>[ ] EPI modified through nodal equation</li> <li>[ ] Operator closure maintained</li> <li>[ ] Operational fractality preserved</li> </ul>"},{"location":"theory/mathematical_foundations/#appendix-c-faq","title":"Appendix C: FAQ","text":"<p>Q: What is the relationship between \u0394NFR and machine learning gradients?</p> <p>A: They are fundamentally different. ML gradients point toward error minimization in parameter space. \u0394NFR is a reorganization pressure in structural space, where sign indicates expansion (+) or contraction (-), not \"better\" or \"worse\".</p> <p>Q: Why Hz_str instead of Hz?</p> <p>A: To distinguish structural reorganization rates from physical frequencies. A node reorganizing at 1 Hz_str doesn't oscillate 1 time per second\u2014it reorganizes its structure at that rate. The bridge factor k converts between scales when needed.</p> <p>Q: Can TNFR model dissipative systems?</p> <p>A: Yes! Use Lindblad formalism with <code>build_lindblad_delta_nfr</code> to include collapse operators that model emission/absorption (see section 7.1 and <code>docs/source/foundations.md</code> section 4).</p> <p>Q: How do I choose coherence threshold C_min?</p> <p>A: Start with C_min = 0.3 for exploratory work. For critical applications, calibrate by finding the minimum \u27e8\u0108\u27e9 at which your network maintains stable patterns. This is system-dependent.</p> <p>Q: What happens when \u03bdf \u2192 0?</p> <p>A: The node \"freezes\"\u2014no structural reorganization occurs even if \u0394NFR is large. This represents structural death or silence (operator SHA). It's reversible if \u03bdf is re-established.</p> <p>Q: How does TNFR relate to quantum mechanics?</p> <p>A: TNFR uses quantum mathematical machinery (Hilbert spaces, Hermitian operators) but operates in structural rather than physical space. The analogy is deep but not identity: TNFR models emergent patterns, not quantum particles.</p> <p>Document version: 1.0 Last updated: 2025-11-07 Maintained by: TNFR Core Team License: Same as repository (see LICENSE.md)</p>"},{"location":"theory/mathematical_foundations/#a1-tnfr-overview","title":"A.1 TNFR Overview","text":"<p>This section summarises the canonical moving parts of the TNFR (resonant fractal nature theory) paradigm. The focus is on how the Primary Information Structure (EPI), structural frequency (\u03bdf) and the internal reorganiser \u0394NFR weave together to sustain coherent nodes.</p>"},{"location":"theory/mathematical_foundations/#a11-canonical-invariants","title":"A.1.1 Canonical Invariants","text":"<ul> <li>EPI coherence \u2014 the node persists only if the Primary Information Structure tracks the \u0394NFR-driven reorganisations.</li> <li>Structural frequency \u03bdf \u2014 expressed in Hz_str; it regulates how rapidly the node adapts to operator inputs.</li> <li>Phase alignment \u2014 operators must respect phase synchrony to keep resonance valid.</li> <li>\u0394NFR logging \u2014 every structural trajectory must expose the \u0394NFR contribution applied at each step.</li> </ul>"},{"location":"theory/mathematical_foundations/#a12-documentation-roadmap","title":"A.1.2 Documentation Roadmap","text":"<p>The overview sits at the top of the TNFR documentation tree. The index and quickstart guides map the first hops towards examples and reference notes:</p> <ul> <li>The documentation index serves as the canonical entry point for theory, operations, and release state.</li> <li>Quickstart onboarding connects the theoretical framing with executable flows.</li> <li>Example playbooks and scenario assets stay aligned with the invariants summarized above.</li> <li>Theory content records the proofs, operator derivations, and validation walkthroughs that expand on each invariant.</li> </ul> <p>The roadmap prioritises filling documentation stubs while keeping each addition tied back to the invariants listed above.</p>"},{"location":"theory/mathematical_foundations/#a13-opt-in-activation-summary","title":"A.1.3 Opt-in Activation Summary","text":"<p>The engine treats advanced operator stacks (self-organisation cascades, resonance window amplification, and stochastic \u0394NFR perturbations) as opt-in features. Builders should:</p> <ul> <li>Start with the deterministic hooks to anchor \u0394NFR semantics.</li> <li>Enable stochastic or multi-node activations explicitly\u2014either through configuration payloads or runtime wiring\u2014so automation retains control of when a node leaves the canonical scripted envelope.</li> <li>Capture telemetry describing why an activation was granted; this includes minimal audit fields (\u0394NFR weights, \u03bdf, \u03b8) that downstream tooling expects.</li> </ul> <p>See the primer for the design goals behind the opt-in policy and the invariants that must hold once optional activations are enabled.</p>"},{"location":"theory/mathematical_foundations/#a14-compatibility-guarantees","title":"A.1.4 Compatibility Guarantees","text":"<p>TNFR follows a semantic versioning contract anchored in reproducible coherence traces. In practice this means:</p> <ul> <li>Patch releases stay API-compatible and are safe to absorb in automation once the release notes are reviewed.</li> <li>Minor releases may extend operator surfaces or telemetry, but they advertise migrations in advance through the release ledger.</li> <li>Major releases annotate breaking changes with remediation guides.</li> </ul> <p>When building long-lived scripts, pin the <code>tnfr</code> version and record the \u0394NFR hook signature you depend on so CI replicates the same behaviour after upgrades.</p>"},{"location":"theory/mathematical_foundations/#a15-computational-cost-notes","title":"A.1.5 Computational Cost Notes","text":"<p>Most theoretical examples target fast execution to preserve CI latency budgets. Keep in mind:</p> <ul> <li>Scripted examples should run in milliseconds and represent the ceiling for per-test smoke budgets.</li> <li>Operator explorations that require eigen-decompositions should batch them carefully\u2014the <code>numpy.linalg.eigh</code> primitive is <code>O(N\u00b3)</code> in the matrix size.</li> <li>Prefer vectorised helpers before reaching for heavier solvers, and gate expensive scans behind explicit benchmark scripts.</li> </ul> <p>Sticking to these constraints keeps the test suite reliable while preserving room for deeper exploration that opts into heavier kernels.</p>"},{"location":"theory/mathematical_foundations/#a2-hilbert-space-h_nfr","title":"A.2 Hilbert Space H_NFR","text":"<p>TNFR spectral states inhabit finite-dimensional Hilbert spaces that combine discrete resonant modes with continuous projections. Working in an orthonormal basis keeps expectation values and norms mechanically stable.</p>"},{"location":"theory/mathematical_foundations/#a21-canonical-structure","title":"A.2.1 Canonical Structure","text":"<ul> <li>Vectors live on the Hilbert sphere so coherence operators act predictably.</li> <li>Inner products use the sesquilinear form (\\langle\\psi, \\phi\\rangle).</li> <li>Projections return coordinates relative to any supplied orthonormal basis.</li> </ul>"},{"location":"theory/mathematical_foundations/#a22-finite-ell2-otimes-l2-realisation","title":"A.2.2 Finite (\\ell^2 \\otimes L^2) Realisation","text":"<p>The TNFR engine realises (H_{\\text{NFR}}) as a finite section of the coupled discrete/continuous spectrum:</p> <ul> <li>Discrete component: <code>tnfr.mathematics.spaces.HilbertSpace</code> provides the truncated (\\ell^2) factor with a canonical orthonormal basis and sesquilinear inner product implemented via <code>numpy.vdot</code>.</li> <li>Continuous component: <code>tnfr.mathematics.spaces.BanachSpaceEPI</code> packages the sampled (L^2) continuum and associated coherence functional so that spectral vectors can be paired with continuous envelopes.</li> </ul> <p>Together these classes make the tensor-product section explicit: <code>HilbertSpace</code> handles discrete projections, while <code>BanachSpaceEPI</code> validates and weights the continuous samples, ensuring the resulting state stays faithful to the (\\ell^2 \\otimes L^2) geometry used throughout the operators.</p>"},{"location":"theory/mathematical_foundations/#a23-smoke-check-norms-and-expectations","title":"A.2.3 Smoke Check: Norms and Expectations","text":"<p>Key validations:</p> <ol> <li>Norm homogeneity: (|c\\psi| = |c| \\cdot |\\psi|)</li> <li>Triangle inequality: (|\\psi + \\phi| \\leq |\\psi| + |\\phi|)</li> <li>Projection reconstruction: Projections onto an orthonormal basis reproduce the original state</li> </ol> <p>These properties are verified in the <code>HilbertSpace</code> abstraction using deterministic test vectors.</p>"},{"location":"theory/mathematical_foundations/#a3-frequency-operator-j","title":"A.3 Frequency Operator \u0134","text":"<p>The frequency operator captures how structural frequency (\\nu_f) is distributed across spectral modes. Its spectrum must remain non-negative so the projected (\\nu_f) keeps physical meaning.</p>"},{"location":"theory/mathematical_foundations/#a31-operator-semantics","title":"A.3.1 Operator Semantics","text":"<ul> <li>Hermitian construction ensures real eigenvalues.</li> <li>Expectation values return the effective (\\nu_f) observed on a state: (\\langle\\psi|\\hat{J}|\\psi\\rangle = \\nu_{f,\\text{eff}})</li> <li>Spectral bandwidth highlights how widely (\\nu_f) spreads across modes.</li> </ul>"},{"location":"theory/mathematical_foundations/#a32-mathematical-properties","title":"A.3.2 Mathematical Properties","text":"<p>Spectrum constraint: [ \\hat{J} = \\sum_i \\nu_{f,i} |i\\rangle\\langle i| \\quad \\text{where } \\nu_{f,i} \\geq 0 ]</p> <p>Expectation value: [ \\nu_{f,\\text{eff}} = \\langle\\psi|\\hat{J}|\\psi\\rangle = \\sum_i \\nu_{f,i} |\\langle i|\\psi\\rangle|^2 ]</p> <p>This ensures the measured frequency is always a weighted average of non-negative eigenvalues.</p>"},{"location":"theory/mathematical_foundations/#a33-smoke-check-nu_f-projection","title":"A.3.3 Smoke Check: (\\nu_f) Projection","text":"<p>Validation steps:</p> <ol> <li>Assemble a diagonal frequency operator (\\hat{J}) with non-negative eigenvalues</li> <li>Project a normalized state (|\\psi\\rangle) onto (\\hat{J})</li> <li>Verify that the reported (\\nu_f) stays within the spectral bounds: (\\min(\\nu_{f,i}) \\leq \\langle\\hat{J}\\rangle \\leq \\max(\\nu_{f,i}))</li> </ol> <p>This confirms the physical interpretation of (\\nu_f) as a structural reorganization rate.</p>"},{"location":"theory/mathematical_foundations/#a4-unitary-dynamics-and-nfr","title":"A.4 Unitary Dynamics and \u0394NFR","text":"<p>Unitary flows generated by the coherence operator encode how \u0394NFR reorganises the node without breaking normalization. Tracking the induced structural frequency drift keeps the nodal equation balanced.</p>"},{"location":"theory/mathematical_foundations/#a41-workflow","title":"A.4.1 Workflow","text":"<ol> <li>Select a coherence operator (\\hat{C}) and derive its unitary evolution (e^{-i\\hat{C}t}).</li> <li>Propagate a normalized state through the unitary to observe how frequency expectations shift.</li> <li>Map the observed shift into a deterministic \u0394NFR hook.</li> <li>Execute a short operator sequence and confirm that EPI and (\\nu_f) reflect the \u0394NFR update.</li> </ol>"},{"location":"theory/mathematical_foundations/#a42-mathematical-foundation","title":"A.4.2 Mathematical Foundation","text":"<p>Unitary evolution (Schr\u00f6dinger-like): [ |\\psi(t)\\rangle = e^{-i\\hat{C}t}|\\psi(0)\\rangle ]</p> <p>Frequency drift: [ \\frac{d}{dt}\\langle\\hat{J}\\rangle = \\langle\\psi(t)|[\\hat{C}, \\hat{J}]|\\psi(t)\\rangle ]</p> <p>where ([\\hat{C}, \\hat{J}] = \\hat{C}\\hat{J} - \\hat{J}\\hat{C}) is the commutator.</p> <p>Connection to \u0394NFR:</p> <p>The frequency drift induced by coherence evolution provides the reorganization gradient: [ \\Delta\\text{NFR} \\propto \\frac{d\\langle\\hat{J}\\rangle}{dt} ]</p> <p>This establishes the link between quantum-inspired dynamics and structural reorganization.</p>"},{"location":"theory/mathematical_foundations/#a43-smoke-check-coupling-nfr-to-unitary-evolution","title":"A.4.3 Smoke Check: Coupling \u0394NFR to Unitary Evolution","text":"<p>Validation procedure:</p> <ol> <li>Compute one-step unitary evolution: (|\\psi(t+\\Delta t)\\rangle = e^{-i\\hat{C}\\Delta t}|\\psi(t)\\rangle)</li> <li>Measure frequency projection drift: (\\Delta\\nu_f = \\langle\\psi(t+\\Delta t)|\\hat{J}|\\psi(t+\\Delta t)\\rangle - \\langle\\psi(t)|\\hat{J}|\\psi(t)\\rangle)</li> <li>Use drift as \u0394NFR increment: (\\Delta\\text{NFR} = \\Delta\\nu_f / \\Delta t)</li> <li>Apply \u0394NFR to node and verify consistency with nodal equation:    [    \\frac{\\partial \\text{EPI}}{\\partial t} \\approx \\nu_f \\cdot \\Delta\\text{NFR}    ]</li> </ol> <p>This validates that the abstract operator formalism connects coherently to the practical nodal evolution.</p> <p>End of Consolidated Notebook Content</p>"},{"location":"user-guide/METRICS_INTERPRETATION/","title":"Metrics Interpretation Guide","text":"<p>Home \u203a Metrics Interpretation</p> <p>This guide explains how to interpret and use TNFR's key metrics: Total Coherence (C(t)), Sense Index (Si), structural frequency (\u03bdf), phase (\u03c6), and reorganization gradient (\u0394NFR).</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#overview","title":"Overview","text":"<p>TNFR provides precise, observable metrics to measure network health and evolution. Understanding these metrics is essential for: - Monitoring network stability - Detecting bifurcations and collapses - Optimizing operator sequences - Debugging structural issues</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#core-metrics","title":"Core Metrics","text":""},{"location":"user-guide/METRICS_INTERPRETATION/#total-coherence-ct","title":"Total Coherence: C(t)","text":"<p>What it measures: Global network stability at time t</p> <p>Analogy: Like measuring the clarity of a choir's harmony. High C(t) = clear, stable patterns. Low C(t) = chaotic, fragmented noise.</p> <p>Range: 0.0 (total chaos) to 1.0 (perfect coherence)</p> <p>Interpretation: - C(t) &gt; 0.7: \ud83d\udfe2 Strong coherence, stable patterns - 0.5 &lt; C(t) &lt; 0.7: \ud83d\udfe1 Moderate coherence, generally stable - 0.3 &lt; C(t) &lt; 0.5: \ud83d\udfe0 Weak coherence, at risk - C(t) &lt; 0.3: \ud83d\udd34 Critical - fragmentation likely</p> <p>How to measure: <pre><code>from tnfr.metrics import total_coherence\n\nC_t = total_coherence(G)\nprint(f\"Total coherence: {C_t:.3f}\")\n</code></pre></p> <p>What influences C(t): - Network topology (more coupling \u2192 higher C(t)) - Phase synchronization (aligned phases \u2192 higher C(t)) - Structural frequencies (moderate \u03bdf \u2192 higher C(t)) - Recent operators (Coherence \u2191, Dissonance \u2193)</p> <p>Typical evolution: <pre><code>Network creation:    C(t) \u2248 0.3-0.5 (initial chaos)\nAfter Coherence():   C(t) \u2191 0.6-0.8 (stabilization)\nAfter Dissonance():  C(t) \u2193 0.3-0.5 (exploration)\nAfter Resonance():   C(t) \u2191 0.5-0.7 (propagation)\n</code></pre></p> <p>When to act: - C(t) dropping: Apply Coherence operator - C(t) too high (&gt;0.9): May indicate over-stabilization, consider Dissonance - C(t) oscillating: Normal during exploration, monitor amplitude</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#sense-index-si","title":"Sense Index: Si","text":"<p>What it measures: Capacity to generate stable reorganization patterns</p> <p>Analogy: Like measuring a musician's skill. High Si = can improvise while maintaining harmony. Low Si = changes lead to chaos.</p> <p>Range: 0.0 (unstable) to 1.0+ (highly stable)</p> <p>Interpretation: - Si &gt; 0.8: \ud83d\udfe2 Excellent reorganization stability - 0.6 &lt; Si &lt; 0.8: \ud83d\udfe1 Good stability, safe to apply operators - 0.4 &lt; Si &lt; 0.6: \ud83d\udfe0 Moderate stability, careful with Dissonance - Si &lt; 0.4: \ud83d\udd34 Warning - changes may cause bifurcation</p> <p>How to measure: <pre><code>from tnfr.metrics import sense_index\n\n# Network-wide\nSi = sense_index(G)\nprint(f\"Network sense index: {Si:.3f}\")\n\n# Per-node\nfor node in G.nodes():\n    Si_node = sense_index(G, node=node)\n    print(f\"Node {node} Si: {Si_node:.3f}\")\n</code></pre></p> <p>What influences Si: - \u0394NFR: Lower gradient \u2192 higher Si - \u03bdf: Moderate frequency \u2192 higher Si - Phase dispersion: Lower spread \u2192 higher Si - Network topology: Better coupling \u2192 higher Si</p> <p>Formula (simplified): <pre><code>Si \u2248 1 / (1 + |\u0394NFR| + phase_variance)\n</code></pre></p> <p>Typical values: <pre><code>Stable network:           Si \u2248 0.7-0.9\nExploring network:        Si \u2248 0.4-0.6\nPre-bifurcation:         Si &lt; 0.3\nAfter Self-organization: Si \u2191 0.6-0.8\n</code></pre></p> <p>When to act: - Si dropping rapidly: Apply Coherence immediately - Si &lt; 0.4: Avoid Dissonance, stabilize first - Si very high (&gt;0.95): May indicate stagnation, consider exploration</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#structural-frequency-f","title":"Structural Frequency: \u03bdf","text":"<p>What it measures: Rate at which a node reorganizes its internal structure</p> <p>Units: Hz_str (structural hertz) - NOT physical frequency!</p> <p>Analogy: Like a heart rate, but for structural change. Higher \u03bdf = faster reorganization.</p> <p>Range: 0.0+ Hz_str (no theoretical upper limit)</p> <p>Typical values: - Active node: \u03bdf \u2248 1.0-5.0 Hz_str - Stable node: \u03bdf \u2248 0.1-1.0 Hz_str - Dormant node: \u03bdf \u2248 0.01-0.1 Hz_str - Frozen node: \u03bdf \u2248 0.0 Hz_str (via Silence operator) - Collapsing node: \u03bdf \u2192 0</p> <p>How to measure: <pre><code># Single node\nnf = G.nodes[node]['nf']\nprint(f\"Node {node} \u03bdf: {nf:.2f} Hz_str\")\n\n# All nodes\nfor node in G.nodes():\n    nf = G.nodes[node]['nf']\n    print(f\"Node {node}: {nf:.2f} Hz_str\")\n\n# Average network frequency\navg_nf = sum(G.nodes[n]['nf'] for n in G.nodes()) / G.number_of_nodes()\nprint(f\"Average \u03bdf: {avg_nf:.2f} Hz_str\")\n</code></pre></p> <p>What influences \u03bdf: - Emission: Increases \u03bdf - Silence: Sets \u03bdf \u2248 0 - Coupling: May synchronize \u03bdf between nodes - Dissonance: May increase \u03bdf variability</p> <p>Interpretation by range: <pre><code>\u03bdf &gt; 5.0:    Very active, may be unstable\n\u03bdf 1.0-5.0:  Normal active reorganization\n\u03bdf 0.1-1.0:  Stable, measured evolution\n\u03bdf &lt; 0.1:    Low activity, approaching dormancy\n\u03bdf \u2248 0:      Frozen or collapsing\n</code></pre></p> <p>When to act: - \u03bdf \u2192 0: Node collapsing, apply Emission - \u03bdf too high: May indicate instability, apply Coherence - \u03bdf dispersion high: Network desynchronized, use Coupling</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#phase-theta","title":"Phase: \u03c6 (theta)","text":"<p>What it measures: Relative timing/synchrony of a node with its neighbors</p> <p>Units: Radians (0 to 2\u03c0)</p> <p>Analogy: Like dancers in choreography - need to be in sync to create coherent performance.</p> <p>Range: 0 to 2\u03c0 radians (or -\u03c0 to \u03c0)</p> <p>Interpretation: - Phase aligned (\u0394\u03c6 &lt; 0.5 rad): Strong coupling possible - Phase misaligned (\u0394\u03c6 &gt; 1.5 rad): Weak/no coupling - Phase variance low: Network synchronized - Phase variance high: Network fragmented</p> <p>How to measure: <pre><code># Single node\nphase = G.nodes[node]['phase']\nprint(f\"Node {node} phase: {phase:.3f} rad\")\n\n# Phase difference between nodes\nphase1 = G.nodes[node1]['phase']\nphase2 = G.nodes[node2]['phase']\ndelta_phase = abs(phase1 - phase2)\nprint(f\"Phase difference: {delta_phase:.3f} rad\")\n\n# Network phase coherence (Kuramoto order parameter)\nfrom tnfr.metrics import phase_coherence\nR = phase_coherence(G)\nprint(f\"Phase coherence: {R:.3f}\")  # 0.0-1.0\n</code></pre></p> <p>Phase Coherence (Kuramoto): - R &gt; 0.7: Strong synchronization - 0.3 &lt; R &lt; 0.7: Partial synchronization - R &lt; 0.3: Weak synchronization</p> <p>What influences phase: - Coupling: Synchronizes phases - Reception: Adjusts phase to match inputs - Mutation: May shift phase - Network topology: Better connected \u2192 more synchronized</p> <p>When to act: - Large \u0394\u03c6 before Coupling: Use Reception first to align - Phase variance increasing: Apply Coupling or Coherence - Phase frozen: Check if Silence was applied</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#reorganization-gradient-nfr","title":"Reorganization Gradient: \u0394NFR","text":"<p>What it measures: Internal pressure driving structural change</p> <p>Analogy: Like water pressure that drives flow. \u0394NFR measures \"structural pressure.\"</p> <p>Range: Unbounded (typically -10 to +10)</p> <p>Interpretation: - \u0394NFR &gt; 0: Expansion pressure (growth) - \u0394NFR &lt; 0: Contraction pressure (simplification) - |\u0394NFR| large: High reorganization demand - \u0394NFR \u2248 0: Equilibrium, stable state</p> <p>Sign meaning: <pre><code>\u0394NFR &gt; +2:  Strong expansion, risk of instability\n\u0394NFR +0.5 to +2: Healthy growth\n\u0394NFR -0.5 to +0.5: Equilibrium\n\u0394NFR -2 to -0.5: Healthy contraction\n\u0394NFR &lt; -2: Strong contraction, risk of collapse\n</code></pre></p> <p>How to measure: <pre><code># Per-node \u0394NFR\ndelta_nfr = G.nodes[node].get('delta_nfr', 0)\nprint(f\"Node {node} \u0394NFR: {delta_nfr:+.3f}\")\n\n# Identify high-pressure nodes\nfor node in G.nodes():\n    dnfr = G.nodes[node].get('delta_nfr', 0)\n    if abs(dnfr) &gt; 2.0:\n        print(f\"\u26a0\ufe0f Node {node} high pressure: {dnfr:+.3f}\")\n</code></pre></p> <p>What influences \u0394NFR: - Dissonance: Increases |\u0394NFR| - Coherence: Reduces |\u0394NFR| - Network mismatch: High coupling with phase mismatch \u2192 high |\u0394NFR| - Topology changes: Adding/removing connections affects \u0394NFR</p> <p>Relationship to nodal equation: <pre><code>\u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)\n\nIf \u03bdf = 2.0 Hz_str and \u0394NFR = +1.5:\n  \u2192 \u2202EPI/\u2202t = 3.0 (rapid expansion)\n\nIf \u03bdf = 0.5 Hz_str and \u0394NFR = +1.5:\n  \u2192 \u2202EPI/\u2202t = 0.75 (slow expansion)\n</code></pre></p> <p>When to act: - |\u0394NFR| &gt; 3: Apply Coherence to stabilize - \u0394NFR \u2248 0 everywhere: May indicate stagnation - \u0394NFR oscillating: Normal during exploration</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#metric-relationships","title":"Metric Relationships","text":""},{"location":"user-guide/METRICS_INTERPRETATION/#how-metrics-interact","title":"How metrics interact:","text":"<p>C(t) and Si: - Usually correlated: High C(t) \u2192 High Si - Exception: Over-stabilization (high C(t), low Si)</p> <p>\u03bdf and \u0394NFR: - Combined in nodal equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR - High \u03bdf + high \u0394NFR = rapid change - Low \u03bdf + high \u0394NFR = constrained change</p> <p>Phase and C(t): - Aligned phases \u2192 Higher C(t) - Phase coherence \u2248 C(t) (approximate)</p> <p>Si and \u0394NFR: - Inversely related: High |\u0394NFR| \u2192 Low Si - Si measures stability under reorganization pressure</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#healthy-network-profile","title":"Healthy Network Profile:","text":"<pre><code>C(t): 0.5-0.7      (moderate coherence)\nSi: 0.6-0.8        (good stability)\n\u03bdf: 0.5-2.0 Hz_str (active but stable)\nPhase coherence: &gt;0.5 (synchronized)\n|\u0394NFR|: &lt;2.0       (manageable pressure)\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#monitoring-workflows","title":"Monitoring Workflows","text":""},{"location":"user-guide/METRICS_INTERPRETATION/#basic-monitoring","title":"Basic Monitoring","text":"<pre><code>from tnfr.metrics import total_coherence, sense_index\n\ndef monitor_network(G):\n    \"\"\"Basic network health check.\"\"\"\n    C_t = total_coherence(G)\n    Si = sense_index(G)\n\n    print(f\"C(t): {C_t:.3f}\")\n    print(f\"Si: {Si:.3f}\")\n\n    if C_t &lt; 0.3:\n        print(\"\u26a0\ufe0f Low coherence - apply Coherence operator\")\n    if Si &lt; 0.4:\n        print(\"\u26a0\ufe0f Low sense index - avoid Dissonance\")\n    if C_t &gt; 0.5 and Si &gt; 0.6:\n        print(\"\u2713 Network healthy\")\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#detailed-monitoring","title":"Detailed Monitoring","text":"<pre><code>def detailed_monitor(G):\n    \"\"\"Comprehensive network analysis.\"\"\"\n    from tnfr.metrics import total_coherence, sense_index, phase_coherence\n\n    # Global metrics\n    C_t = total_coherence(G)\n    Si = sense_index(G)\n    R = phase_coherence(G)\n\n    # Per-node statistics\n    nf_values = [G.nodes[n]['nf'] for n in G.nodes()]\n    dnfr_values = [G.nodes[n].get('delta_nfr', 0) for n in G.nodes()]\n\n    avg_nf = sum(nf_values) / len(nf_values)\n    max_dnfr = max(abs(d) for d in dnfr_values)\n\n    print(f\"\u2554\u2550\u2550 Network Health \u2550\u2550\u2557\")\n    print(f\"\u2551 C(t): {C_t:.3f}         \u2551\")\n    print(f\"\u2551 Si:   {Si:.3f}         \u2551\")\n    print(f\"\u2551 R:    {R:.3f}         \u2551\")\n    print(f\"\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\")\n    print(f\"\u2551 Avg \u03bdf: {avg_nf:.2f} Hz   \u2551\")\n    print(f\"\u2551 Max |\u0394NFR|: {max_dnfr:.2f}  \u2551\")\n    print(f\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\")\n\n    # Warnings\n    issues = []\n    if C_t &lt; 0.3: issues.append(\"Low coherence\")\n    if Si &lt; 0.4: issues.append(\"Low sense index\")\n    if R &lt; 0.3: issues.append(\"Poor phase sync\")\n    if max_dnfr &gt; 3.0: issues.append(\"High reorganization pressure\")\n\n    if issues:\n        print(f\"\u26a0\ufe0f Issues: {', '.join(issues)}\")\n    else:\n        print(\"\u2713 All metrics healthy\")\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#time-series-monitoring","title":"Time-Series Monitoring","text":"<pre><code>def monitor_evolution(G, operators, steps=100):\n    \"\"\"Monitor metrics over time during operator sequence.\"\"\"\n    import matplotlib.pyplot as plt\n\n    C_history = []\n    Si_history = []\n\n    for step in range(steps):\n        # Apply operators\n        for op in operators:\n            op(G)\n\n        # Record metrics\n        C_history.append(total_coherence(G))\n        Si_history.append(sense_index(G))\n\n    # Plot\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 6))\n\n    ax1.plot(C_history)\n    ax1.set_ylabel('C(t)')\n    ax1.set_title('Total Coherence Evolution')\n    ax1.axhline(y=0.5, color='r', linestyle='--', label='Threshold')\n    ax1.legend()\n\n    ax2.plot(Si_history)\n    ax2.set_ylabel('Si')\n    ax2.set_xlabel('Step')\n    ax2.set_title('Sense Index Evolution')\n    ax2.axhline(y=0.4, color='r', linestyle='--', label='Warning')\n    ax2.legend()\n\n    plt.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#diagnostic-patterns","title":"Diagnostic Patterns","text":""},{"location":"user-guide/METRICS_INTERPRETATION/#pattern-1-declining-coherence","title":"Pattern 1: Declining Coherence","text":"<p>Symptoms: C(t) dropping over time</p> <p>Likely causes: - Excessive Dissonance - Network desynchronization - Node collapses (\u03bdf \u2192 0)</p> <p>Solution: <pre><code># Stabilize network\nfrom tnfr.operators import Coherence, Coupling\n\nCoherence()(G)  # Global stabilization\nfor node in low_coherence_nodes:\n    for neighbor in G.neighbors(node):\n        Coupling()(G, node, neighbor)  # Restore connections\n</code></pre></p>"},{"location":"user-guide/METRICS_INTERPRETATION/#pattern-2-low-sense-index","title":"Pattern 2: Low Sense Index","text":"<p>Symptoms: Si &lt; 0.4, especially if C(t) &gt; 0.5</p> <p>Likely causes: - High reorganization pressure (|\u0394NFR| large) - Phase dispersion - Frequency variability</p> <p>Solution: <pre><code># Reduce pressure and synchronize\nfrom tnfr.operators import Coherence, Reception\n\nCoherence()(G)  # Reduce \u0394NFR\nfor node in high_pressure_nodes:\n    Reception()(G, node)  # Align phases\n</code></pre></p>"},{"location":"user-guide/METRICS_INTERPRETATION/#pattern-3-oscillating-metrics","title":"Pattern 3: Oscillating Metrics","text":"<p>Symptoms: C(t) and Si oscillate regularly</p> <p>Interpretation: Normal during exploration with Dissonance</p> <p>When to worry: If oscillation amplitude increases</p> <p>Solution: If concerning, reduce Dissonance intensity</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#pattern-4-flatlined-metrics","title":"Pattern 4: Flatlined Metrics","text":"<p>Symptoms: C(t), Si unchanging despite operators</p> <p>Likely causes: - Over-stabilization - All nodes in Silence - Network disconnected</p> <p>Solution: <pre><code># Reactivate network\nfrom tnfr.operators import Emission, Dissonance\n\n# Wake up dormant nodes\nfor node in dormant_nodes:\n    Emission()(G, node)\n\n# Introduce exploration\nDissonance()(G, intensity=0.3)\n</code></pre></p>"},{"location":"user-guide/METRICS_INTERPRETATION/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/METRICS_INTERPRETATION/#do","title":"DO:","text":"<ul> <li>\u2705 Monitor metrics before and after each operator</li> <li>\u2705 Track time-series for trends</li> <li>\u2705 Set thresholds based on your domain</li> <li>\u2705 Log metrics for reproducibility</li> <li>\u2705 Use multiple metrics together (not just one)</li> </ul>"},{"location":"user-guide/METRICS_INTERPRETATION/#dont","title":"DON'T:","text":"<ul> <li>\u274c Rely on single metric alone</li> <li>\u274c Ignore warning signs (low C(t), low Si)</li> <li>\u274c Compare metrics across different networks without context</li> <li>\u274c Expect perfect coherence (C(t)=1.0) - often unrealistic</li> <li>\u274c Forget to account for domain-specific thresholds</li> </ul>"},{"location":"user-guide/METRICS_INTERPRETATION/#domain-specific-interpretations","title":"Domain-Specific Interpretations","text":"<p>Different domains may have different healthy ranges:</p>"},{"location":"user-guide/METRICS_INTERPRETATION/#biological-systems","title":"Biological Systems","text":"<pre><code>C(t): 0.4-0.6  (natural variability)\nSi: 0.5-0.7    (adaptive capacity)\n\u03bdf: 0.5-2.0    (moderate dynamics)\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#social-networks","title":"Social Networks","text":"<pre><code>C(t): 0.3-0.5  (diversity maintained)\nSi: 0.4-0.6    (change tolerance)\n\u03bdf: 1.0-3.0    (active interaction)\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#technical-systems","title":"Technical Systems","text":"<pre><code>C(t): 0.6-0.8  (higher stability needed)\nSi: 0.7-0.9    (predictable behavior)\n\u03bdf: 0.1-1.0    (controlled change)\n</code></pre>"},{"location":"user-guide/METRICS_INTERPRETATION/#see-also","title":"See Also","text":"<ul> <li>Operators Guide - How operators affect metrics</li> <li>Troubleshooting - Fixing metric issues</li> <li>API Reference - Metrics API details</li> <li>Theory - Mathematical foundations</li> </ul> <p>Next: Learn how to solve common problems in Troubleshooting Guide \u2192</p>"},{"location":"user-guide/OPERATORS_GUIDE/","title":"Operators Guide: The 13 Structural Operators","text":"<p>Home \u203a Operators Guide</p> <p>This guide provides a comprehensive reference for TNFR's 13 canonical structural operators. These operators are the only valid way to modify networks in TNFR, ensuring all changes are traceable, coherent, and reproducible.</p> <p>\ud83d\udcd6 Visual Guide: For detailed visual explanations with ASCII diagrams, flow charts, and interactive examples, see the Operators Visual Guide.</p>"},{"location":"user-guide/OPERATORS_GUIDE/#overview","title":"Overview","text":"<p>Structural operators are resonant transformations that reorganize coherence while preserving TNFR invariants. Think of them as musical gestures rather than mechanical operations - each operator creates a specific type of structural change that respects the natural resonance of the system.</p>"},{"location":"user-guide/OPERATORS_GUIDE/#why-operators","title":"Why Operators?","text":"<p>In TNFR, every change must go through an operator. This ensures: - \u2705 Traceability: Every reorganization is observable - \u2705 Coherence: Changes preserve structural integrity - \u2705 Reproducibility: Same conditions \u2192 same outcomes - \u2705 Composability: Operators combine into complex sequences</p>"},{"location":"user-guide/OPERATORS_GUIDE/#operator-closure","title":"Operator Closure","text":"<p>All operator compositions yield valid TNFR states. Any new function must map to existing operators or be defined as one.</p>"},{"location":"user-guide/OPERATORS_GUIDE/#the-13-canonical-operators","title":"The 13 Canonical Operators","text":""},{"location":"user-guide/OPERATORS_GUIDE/#1-emission-al","title":"1. Emission (AL) \ud83c\udfb5","text":"<p>Function: Initiates a resonant pattern</p> <p>Effect:  - Increases \u03bdf (structural frequency) - Creates positive \u0394NFR - Starts pattern propagation</p> <p>When to use:  - Starting new patterns - Launching trajectories - Activating dormant nodes</p> <p>Mathematical representation: \u03c6(\u03bdf, \u03b8)</p> <p>Example: <pre><code>from tnfr.operators import Emission\n\n# Initiate emission from a node\nEmission()(G, source_node)\n\n# Check increased frequency\nprint(f\"\u03bdf: {G.nodes[source_node]['nf']:.2f} Hz_str\")\n</code></pre></p> <p>Contracts: - Must increase \u03bdf - Creates positive \u0394NFR - Does not break existing couplings</p>"},{"location":"user-guide/OPERATORS_GUIDE/#2-reception-en","title":"2. Reception (EN) \ud83d\udce1","text":"<p>Function: Receives and integrates external patterns</p> <p>Effect: - Updates EPI based on incoming resonance - Adjusts phase to synchronize - Integrates network information</p> <p>When to use: - Gathering information from neighbors - Network listening - Synchronizing with environment</p> <p>Mathematical representation: \u222b \u03c8(x, t) dx</p> <p>Example: <pre><code>from tnfr.operators import Reception\n\n# Node receives from neighbors\nReception()(G, target_node)\n\n# Check updated EPI\nprint(f\"New EPI: {G.nodes[target_node]['epi']}\")\n</code></pre></p> <p>Contracts: - Preserves node identity - Updates EPI coherently - Maintains phase consistency</p>"},{"location":"user-guide/OPERATORS_GUIDE/#3-coherence-il","title":"3. Coherence (IL) \ud83d\udd12","text":"<p>Function: Stabilizes structural form</p> <p>Effect: - Increases C(t) (total coherence) - Reduces |\u0394NFR| - Consolidates structure</p> <p>When to use: - After changes, to consolidate - Stabilizing unstable networks - Reducing reorganization pressure</p> <p>Mathematical representation: \u2202EPI/\u2202t \u2192 0 when \u0394NFR \u2192 0</p> <p>Example: <pre><code>from tnfr.operators import Coherence\nfrom tnfr.metrics import total_coherence\n\n# Stabilize network\nC_before = total_coherence(G)\nCoherence()(G)\nC_after = total_coherence(G)\n\nprint(f\"Coherence: {C_before:.3f} \u2192 {C_after:.3f}\")\n</code></pre></p> <p>Contracts: - Must not decrease C(t) (except controlled dissonance) - Reduces \u0394NFR - Preserves network topology</p>"},{"location":"user-guide/OPERATORS_GUIDE/#4-dissonance-oz","title":"4. Dissonance (OZ) \u26a1","text":"<p>Function: Introduces controlled instability</p> <p>Effect: - Increases |\u0394NFR| - May trigger bifurcation if \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4 - Creates exploration space</p> <p>When to use: - Breaking out of local optima - Exploration and innovation - Testing network resilience</p> <p>Mathematical representation: \u0394NFR(t) &gt; \u03bdf</p> <p>Example: <pre><code>from tnfr.operators import Dissonance\n\n# Introduce controlled instability\nDissonance()(G, intensity=0.5)\n\n# Monitor for bifurcation\nfor node in G.nodes():\n    delta_nfr = G.nodes[node]['delta_nfr']\n    if abs(delta_nfr) &gt; threshold:\n        print(f\"Node {node} approaching bifurcation\")\n</code></pre></p> <p>Contracts: - Must increase |\u0394NFR| - May trigger bifurcation (by design) - Must remain controllable</p>"},{"location":"user-guide/OPERATORS_GUIDE/#5-coupling-um","title":"5. Coupling (UM) \ud83d\udd17","text":"<p>Function: Creates structural links between nodes and synchronizes their dynamics</p> <p>Effect: - Phase synchronization: \u03c6\u1d62(t) \u2248 \u03c6\u2c7c(t) - Structural frequency synchronization: \u03bdf,\u1d62 \u2192 \u03bdf,\u2c7c - \u0394NFR reduction through mutual stabilization - Information exchange enabled - Network connectivity increased</p> <p>When to use: - Network formation - Connecting isolated nodes - Creating communication pathways - Synchronizing reorganization rates between coupled systems - Stabilizing reorganization pressure in coupled networks</p> <p>Mathematical representation:  - Phase: \u03c6\u1d62(t) \u2248 \u03c6\u2c7c(t) - Frequency: \u03bdf,\u1d62(t+1) = \u03bdf,\u1d62(t) + k_vf \u00b7 (\u27e8\u03bdf,neighbors\u27e9 - \u03bdf,\u1d62(t)) - \u0394NFR stabilization: \u0394NFR(t+1) = \u0394NFR(t) \u00b7 (1 - k_dnfr \u00b7 alignment)   - Where alignment \u2208 [0, 1] is based on phase coherence with neighbors   - Higher alignment \u2192 stronger \u0394NFR reduction</p> <p>Example: <pre><code>from tnfr.operators import apply_glyph\nfrom tnfr.alias import set_vf, get_attr\nfrom tnfr.constants.aliases import ALIAS_VF, ALIAS_DNFR\n\n# Initialize nodes with different structural frequencies and reorganization pressures\nset_vf(G, node1, 1.0)  # Slow reorganization\nset_vf(G, node2, 5.0)  # Fast reorganization\nG.nodes[node1]['dnfr'] = 0.8  # High reorganization pressure\nG.nodes[node2]['dnfr'] = 0.3\n\n# Couple nodes - synchronizes phase, frequency, AND reduces \u0394NFR\napply_glyph(G, node1, \"UM\")\n\n# Check synchronization and stabilization\nphase1 = G.nodes[node1]['theta']\nphase2 = G.nodes[node2]['theta']\nvf1 = get_attr(G.nodes[node1], ALIAS_VF, 0.0)\nvf2 = get_attr(G.nodes[node2], ALIAS_VF, 0.0)\ndnfr1 = get_attr(G.nodes[node1], ALIAS_DNFR, 0.0)\n\nprint(f\"Phase difference: {abs(phase1 - phase2):.3f} rad\")\nprint(f\"Frequency difference: {abs(vf1 - vf2):.3f} Hz_str\")\nprint(f\"\u0394NFR after coupling: {dnfr1:.3f} (reduced by mutual stabilization)\")\n</code></pre></p> <p>Configuration: - <code>UM_theta_push</code>: Phase synchronization strength (default: 0.25) - <code>UM_vf_sync</code>: Frequency synchronization strength (default: 0.10) - <code>UM_dnfr_reduction</code>: \u0394NFR reduction factor (default: 0.15) - <code>UM_BIDIRECTIONAL</code>: Enable bidirectional phase sync (default: True) - <code>UM_SYNC_VF</code>: Enable frequency synchronization (default: True) - <code>UM_STABILIZE_DNFR</code>: Enable \u0394NFR stabilization (default: True) - <code>UM_FUNCTIONAL_LINKS</code>: Create edges based on compatibility (default: True)</p> <p>Contracts: - Must verify phase compatibility before coupling - Synchronizes both \u03b8 and \u03bdf when enabled - Reduces \u0394NFR proportionally to phase alignment - Creates bidirectional connection - Preserves existing couplings - Respects nodal equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</p> <p>Structural Invariants: - \u26a0\ufe0f CRITICAL: UM NEVER modifies EPI directly - EPI identity is preserved during all coupling operations - Only \u03b8 (phase), \u03bdf (frequency), and \u0394NFR are modified by UM - Any EPI change during a sequence with UM must come from:   - Other operators (Emission, Reception, etc.)   - Natural evolution via nodal equation: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)   - Never from UM itself - Theoretical basis: Coupling creates structural links through phase synchronization (\u03c6\u1d62(t) \u2248 \u03c6\u2c7c(t)), not through information transfer or EPI modification - Implementation guarantee: <code>_op_UM</code> function does not touch EPI attributes</p> <p>Notes: According to TNFR canonical theory, coupling synchronizes not only phases but also structural frequencies, and produces a stabilizing effect that reduces reorganization pressure (\u0394NFR) through mutual stabilization. This ensures that coupled nodes: - Converge their reorganization rates (essential for sustained resonance) - Experience reduced structural instability when well-aligned - Maintain coherence through phase-dependent stabilization</p> <p>This mechanism is observed in systems such as: - Synchronized biological rhythms (heartbeats, neural oscillations) - Coherent network evolution (social dynamics, collective behavior) - Coupled oscillator systems (phase-locked loops, synchronized clocks) - Multi-agent coordination (swarm intelligence, distributed systems)</p>"},{"location":"user-guide/OPERATORS_GUIDE/#6-resonance-ra","title":"6. Resonance (RA) \ud83c\udf0a","text":"<p>Function: Amplifies and propagates patterns</p> <p>Effect: - Increases effective coupling - Preserves EPI identity during propagation - Strengthens coherent patterns</p> <p>When to use: - Pattern reinforcement - Spreading coherence through network - Amplifying weak signals</p> <p>Mathematical representation: EPI\u2099 \u2192 EPI\u2099\u208a\u2081</p> <p>Example: <pre><code>from tnfr.operators import Resonance\n\n# Propagate pattern from source\nResonance()(G, source_node, radius=2)\n\n# Check propagation\nfor neighbor in G.neighbors(source_node):\n    coupling_strength = G[source_node][neighbor].get('coupling', 0)\n    print(f\"Coupling with {neighbor}: {coupling_strength:.3f}\")\n</code></pre></p> <p>Contracts: - Must preserve EPI identity - Increases effective coupling - Does not introduce noise</p>"},{"location":"user-guide/OPERATORS_GUIDE/#7-silence-sha","title":"7. Silence (SHA) \ud83d\udd07","text":"<p>Function: Temporarily freezes evolution</p> <p>Effect: - Sets \u03bdf \u2248 0 - EPI remains unchanged - Pauses reorganization</p> <p>When to use: - Observation windows - Synchronization pauses - Stabilizing before measurement</p> <p>Mathematical representation: \u03bdf \u2248 0 \u21d2 \u2202EPI/\u2202t \u2248 0</p> <p>Example: <pre><code>from tnfr.operators import Silence\n\n# Freeze node evolution\nSilence()(G, node, duration=10)\n\n# Verify frozen state\nnf = G.nodes[node]['nf']\nprint(f\"Structural frequency: {nf:.6f} Hz_str (\u22480)\")\n</code></pre></p> <p>Contracts: - EPI must remain invariant - \u03bdf \u2192 0 - Can be reversed</p>"},{"location":"user-guide/OPERATORS_GUIDE/#8-expansion-val","title":"8. Expansion (VAL) \ud83d\udcc8","text":"<p>Function: Increases structural complexity</p> <p>Effect: - EPI dimensionality grows - Adds degrees of freedom - Elaborates structure</p> <p>When to use: - Adding capabilities - Increasing expressiveness - Growing network capacity</p> <p>Mathematical representation: EPI \u2192 k\u00b7EPI, k \u2208 \u2115\u207a</p> <p>Example: <pre><code>from tnfr.operators import Expansion\n\n# Expand node structure\ndim_before = len(G.nodes[node]['epi'])\nExpansion()(G, node, factor=1.5)\ndim_after = len(G.nodes[node]['epi'])\n\nprint(f\"Dimensionality: {dim_before} \u2192 {dim_after}\")\n</code></pre></p> <p>Contracts: - Must increase EPI dimensionality - Preserves existing structure - Maintains coherence</p>"},{"location":"user-guide/OPERATORS_GUIDE/#9-contraction-nul","title":"9. Contraction (NUL) \ud83d\udcc9","text":"<p>Function: Structural concentration and densification through harmonic contraction</p> <p>Effect: - EPI volume decreases (W \u2192 W \u00d7 \u03bb, \u03bb &lt; 1) - \u0394NFR density increases (structural pressure concentrates) - \u03bdf decreases (reorganization rate slows) - Product \u03bdf \u00d7 \u0394NFR slightly increases (~1.15x) - Core strengthening through peripheral consolidation</p> <p>TNFR Context:</p> <p>Contraction (NUL) embodies densification dynamics: when structure contracts, it doesn't simply shrink\u2014it concentrates. The structural pressure (\u0394NFR) amplifies as volume reduces, implementing the principle that density = pressure/volume. This preserves the nodal equation \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t) even as both \u03bdf and volume change.</p> <p>Canonical Densification: - Volume contraction: V' = V \u00d7 0.85 (default) - Density amplification: \u0394NFR' = \u0394NFR \u00d7 1.35 (default) - Equilibrium preserved: \u0394NFR = 0 remains 0 - Sign preserved: Negative \u0394NFR amplifies (intensified contraction)</p> <p>When to use: - Consolidation: After exploration phases (post-VAL) - Focus Intensification: Eliminating peripheral activities - Resource Optimization: Concentrating distributed resources - Core Strengthening: Refining to essential structure - Completion Cycles: VAL \u2192 NUL \u2192 IL (expand-contract-stabilize)</p> <p>Use Cases Across Domains:</p> <p>Biomedical: - Apoptosis (programmed cell death) - Wound healing (tissue contraction) - Neural pruning (synaptic elimination) - Muscle contraction dynamics</p> <p>Cognitive: - Focus intensification (attention narrowing) - Concept refinement (simplification to essence) - Mental compression (\"less is more\") - Memory consolidation (dense representations)</p> <p>Social: - Team downsizing (strategic workforce reduction) - Resource consolidation (pooling for efficiency) - Core competency focus (eliminating periphery) - Crisis response (defensive contraction)</p> <p>Typical Sequences:</p> <p>\u2705 Valid Patterns: - <code>NUL \u2192 IL</code>: Contract then stabilize (safe consolidation) - <code>VAL \u2192 NUL \u2192 IL</code>: Expand-contract-stabilize (exploration-consolidation cycle) - <code>THOL \u2192 NUL</code>: Self-organize then refine (emergent structure consolidation) - <code>OZ \u2192 NUL</code>: Dissonance followed by compression (controlled pressure) - <code>NUL \u2192 SHA</code>: Compress then silence (preservation through contraction) - <code>EN \u2192 NUL \u2192 IL</code>: Receive, compress, stabilize (efficient integration)</p> <p>\u274c Avoid Patterns: - <code>NUL \u2192 VAL</code>: Contradictory (immediate reversal wastes energy) - <code>NUL \u2192 NUL</code>: Over-compression risk (may collapse) - <code>NUL \u2192 OZ</code>: Compression + dissonance = dangerous instability - Excessive NUL: Multiple contractions without stabilization</p> <p>Mathematical representation:  - Volume: V' = V \u00d7 \u03bb, \u03bb &lt; 1 - Densification: \u0394NFR' = \u0394NFR \u00d7 \u03c1, \u03c1 &gt; 1 - Nodal compliance: \u2202EPI/\u2202t = \u03bdf \u00b7 \u0394NFR(t)</p> <p>Example 1 - Neural Pruning: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators import Contraction, Coherence\n\n# Brain eliminates weak synaptic connections\nG_brain, synapse = create_nfr(\"neural_connection\", epi=0.39, vf=1.05)\n\n# Apply NUL \u2192 IL: Contract then stabilize\nrun_sequence(G_brain, synapse, [Contraction(), Coherence()])\n\n# Result: Neural network becomes more efficient\n# Weak connections eliminated, strong ones preserved\n</code></pre></p> <p>Example 2 - Strategic Focus: <pre><code>from tnfr.structural import create_nfr, run_sequence\nfrom tnfr.operators import Contraction, Coherence\n\n# Company focuses on core competencies\nG_company, strategy = create_nfr(\"business_model\", epi=0.42, vf=1.00)\n\n# Apply contraction to eliminate peripheral units\nrun_sequence(G_company, strategy, [Contraction(), Coherence()])\n\n# Result: Core competencies strengthened\n# Resources concentrated on essential activities\n</code></pre></p> <p>Example 3 - Expand-Contract Cycle: <pre><code>from tnfr.operators import Expansion, Contraction, Coherence\n\n# Learning: explore broadly then consolidate\nG_learning, concept = create_nfr(\"understanding\", epi=0.35, vf=0.95)\n\n# VAL \u2192 NUL \u2192 IL: Full exploration-consolidation cycle\nrun_sequence(G_learning, concept, \n    [Expansion(), Contraction(), Coherence()])\n\n# Result: Broad exploration (VAL) + coherent consolidation (NUL \u2192 IL)\n</code></pre></p> <p>Warnings:</p> <p>\u26a0\ufe0f Over-compression Risks: - Structural collapse if excessive - Loss of degrees of freedom (irreversible) - Requires adequate EPI baseline (cannot contract from \u22480) - Cannot reverse without VAL (expansion)</p> <p>\u26a0\ufe0f Collapse Conditions: - Multiple consecutive NUL without IL - Contraction when EPI critically low - NUL \u2192 OZ sequences (compression + instability) - Insufficient network coupling</p> <p>Contracts: - Must decrease EPI volume - Must increase \u0394NFR density (densification) - Must preserve nodal equation compliance - Preserves core structure identity - Maintains sign of \u0394NFR (amplifies magnitude)</p> <p>Compatibility: - Complementary with: VAL (Expansion) - enables rhythmic cycles - Compatible with: IL, SHA, THOL, EN - Avoid with: OZ (dissonance), consecutive NUL</p> <p>Comparison with VAL (Expansion): | Aspect | NUL (Contraction) | VAL (Expansion) | |--------|------------------|-----------------| | Volume | Decreases | Increases | | \u0394NFR | Amplifies (densifies) | Distributes | | Purpose | Consolidate | Explore | | Phase | After exploration | Before contraction | | Typical use | Refinement | Growth |</p>"},{"location":"user-guide/OPERATORS_GUIDE/#10-self-organization-thol","title":"10. Self-organization (THOL) \ud83c\udf31","text":"<p>Function: Spontaneous pattern formation</p> <p>Effect: - Creates sub-EPIs - Preserves global form - Enables emergent structure</p> <p>When to use: - Emergent structure formation - Hierarchical organization - Fractalization</p> <p>Mathematical representation: \u2202\u00b2EPI/\u2202t\u00b2 &gt; \u03c4</p> <p>Example: <pre><code>from tnfr.operators import SelfOrganization\n\n# Enable self-organization\nSelfOrganization()(G, threshold=0.5)\n\n# Check for sub-structures\nfor node in G.nodes():\n    if 'sub_epi' in G.nodes[node]:\n        print(f\"Node {node} has {len(G.nodes[node]['sub_epi'])} sub-EPIs\")\n</code></pre></p> <p>Contracts: - May create sub-EPIs - Preserves global form - Maintains operational fractality</p>"},{"location":"user-guide/OPERATORS_GUIDE/#11-mutation-zhir","title":"11. Mutation (ZHIR) \ud83e\uddec","text":"<p>Function: Phase transformation</p> <p>Effect: - \u03b8 \u2192 \u03b8\u2032 when structural threshold crossed - Qualitative state change - Phase transition</p> <p>When to use: - Qualitative state changes - Phase transitions - Transformative reorganization</p> <p>Mathematical representation: \u03b8 \u2192 \u03b8\u2032 if \u0394EPI/\u0394t &gt; \u03be</p> <p>Example: <pre><code>from tnfr.operators import Mutation\n\n# Trigger mutation if threshold exceeded\nphase_before = G.nodes[node]['phase']\nMutation()(G, node, threshold=0.8)\nphase_after = G.nodes[node]['phase']\n\nif phase_after != phase_before:\n    print(f\"Phase mutation: {phase_before:.3f} \u2192 {phase_after:.3f} rad\")\n</code></pre></p> <p>Contracts: - Changes phase only if threshold exceeded - Preserves EPI integrity - Maintains network coherence</p>"},{"location":"user-guide/OPERATORS_GUIDE/#12-transition-nav","title":"12. Transition (NAV) \u27a1\ufe0f","text":"<p>Function: Movement between structural states</p> <p>Effect: - Controlled EPI evolution along path - Guided trajectory - Smooth state changes</p> <p>When to use: - Trajectory navigation - Guided change - State interpolation</p> <p>Mathematical representation: Triggers creative thresholds (\u0394NFR \u2248 \u03bdf)</p> <p>Example: <pre><code>from tnfr.operators import Transition\n\n# Navigate between states\nTransition()(G, node, target_state={'epi': target_epi}, steps=10)\n\n# Monitor transition progress\ncurrent_epi = G.nodes[node]['epi']\ndistance = np.linalg.norm(current_epi - target_epi)\nprint(f\"Distance to target: {distance:.3f}\")\n</code></pre></p> <p>Contracts: - Must follow valid path - Preserves network integrity - Maintains coherence during transition</p>"},{"location":"user-guide/OPERATORS_GUIDE/#13-recursivity-remesh","title":"13. Recursivity (REMESH) \ud83d\udd04","text":"<p>Function: Nested operator application</p> <p>Effect: - Maintains operational fractality - Applies operators at multiple scales - Preserves hierarchical structure</p> <p>When to use: - Multi-scale operations - Hierarchical coherence - Nested transformations</p> <p>Mathematical representation: EPI(t) = EPI(t \u2212 \u03c4)</p> <p>Example: <pre><code>from tnfr.operators import Recursivity\n\n# Apply operators recursively\nRecursivity()(G, [Coherence(), Resonance()], depth=3)\n\n# Verify multi-scale coherence\nfor level in range(3):\n    C_level = total_coherence(G, level=level)\n    print(f\"Coherence at level {level}: {C_level:.3f}\")\n</code></pre></p> <p>Contracts: - Maintains operational fractality - Preserves structure at each level - Does not exceed stack limits</p>"},{"location":"user-guide/OPERATORS_GUIDE/#operator-sequences","title":"Operator Sequences","text":"<p>Operators are rarely used alone. They combine into sequences that create complex behaviors.</p>"},{"location":"user-guide/OPERATORS_GUIDE/#common-sequences","title":"Common Sequences","text":""},{"location":"user-guide/OPERATORS_GUIDE/#bootstrap-sequence","title":"Bootstrap Sequence","text":"<pre><code>from tnfr import run_sequence\nfrom tnfr.operators import Emission, Coupling, Coherence\n\n# Start a new node\nops = [Emission(), Coupling(), Coherence()]\nrun_sequence(G, node, ops)\n</code></pre> <p>Purpose: Initialize and stabilize a new node</p>"},{"location":"user-guide/OPERATORS_GUIDE/#stabilize-sequence","title":"Stabilize Sequence","text":"<pre><code>ops = [Coherence(), Silence()]\nrun_sequence(G, node, ops)\n</code></pre> <p>Purpose: Freeze current state for observation</p>"},{"location":"user-guide/OPERATORS_GUIDE/#explore-sequence","title":"Explore Sequence","text":"<pre><code>ops = [Dissonance(), Mutation(), Coherence()]\nrun_sequence(G, node, ops)\n</code></pre> <p>Purpose: Try new configurations while maintaining coherence</p>"},{"location":"user-guide/OPERATORS_GUIDE/#propagate-sequence","title":"Propagate Sequence","text":"<pre><code>ops = [Resonance(), Coupling()]\nrun_sequence(G, node, ops)\n</code></pre> <p>Purpose: Spread patterns through the network</p>"},{"location":"user-guide/OPERATORS_GUIDE/#sequence-design-principles","title":"Sequence Design Principles","text":"<ol> <li>Start with emission for new patterns</li> <li>End with coherence to stabilize</li> <li>Use dissonance carefully - always follow with coherence</li> <li>Verify phase before coupling</li> <li>Monitor metrics (C(t), Si, \u0394NFR) throughout</li> </ol>"},{"location":"user-guide/OPERATORS_GUIDE/#operator-grammar","title":"Operator Grammar","text":"<p>Operators follow a compositional grammar:</p> <pre><code>Sequence := Operator+ Coherence\nOperator := Emission | Reception | Coupling | Resonance | ...\nSafe_Exploration := Dissonance Operator* Coherence\nMulti_Scale := Recursivity(Sequence)\n</code></pre> <p>See Glyph Sequences Guide for comprehensive patterns.</p>"},{"location":"user-guide/OPERATORS_GUIDE/#monitoring-operator-effects","title":"Monitoring Operator Effects","text":""},{"location":"user-guide/OPERATORS_GUIDE/#beforeafter-metrics","title":"Before/After Metrics","text":"<pre><code>from tnfr.metrics import total_coherence, sense_index\n\n# Before\nC_before = total_coherence(G)\nSi_before = sense_index(G)\n\n# Apply operator\noperator(G)\n\n# After\nC_after = total_coherence(G)\nSi_after = sense_index(G)\n\nprint(f\"C(t): {C_before:.3f} \u2192 {C_after:.3f}\")\nprint(f\"Si: {Si_before:.3f} \u2192 {Si_after:.3f}\")\n</code></pre>"},{"location":"user-guide/OPERATORS_GUIDE/#telemetry-tracing","title":"Telemetry Tracing","text":"<pre><code>from tnfr.telemetry import enable_tracing\n\n# Enable detailed logging\nenable_tracing()\n\n# Operators will now log all changes\noperator(G)\n\n# Review trace\nfrom tnfr.telemetry import get_trace\nfor event in get_trace():\n    print(f\"{event['operator']}: {event['effect']}\")\n</code></pre>"},{"location":"user-guide/OPERATORS_GUIDE/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/OPERATORS_GUIDE/#do","title":"DO:","text":"<ul> <li>\u2705 Always end sequences with Coherence</li> <li>\u2705 Monitor C(t) and Si after each operator</li> <li>\u2705 Use Dissonance carefully and controllably</li> <li>\u2705 Verify phase before Coupling</li> <li>\u2705 Trace operator sequences for debugging</li> </ul>"},{"location":"user-guide/OPERATORS_GUIDE/#dont","title":"DON'T:","text":"<ul> <li>\u274c Apply operators without monitoring effects</li> <li>\u274c Use Dissonance without following Coherence</li> <li>\u274c Skip phase verification</li> <li>\u274c Create arbitrary mutations outside operators</li> <li>\u274c Ignore warning signs (low C(t), high |\u0394NFR|)</li> </ul>"},{"location":"user-guide/OPERATORS_GUIDE/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/OPERATORS_GUIDE/#network-coherence-drops-after-operator","title":"Network coherence drops after operator","text":"<ul> <li>Likely cause: Dissonance without stabilization</li> <li>Solution: Apply Coherence operator</li> <li>Prevention: Always end with Coherence</li> </ul>"},{"location":"user-guide/OPERATORS_GUIDE/#nodes-wont-couple","title":"Nodes won't couple","text":"<ul> <li>Likely cause: Phase mismatch</li> <li>Solution: Check phase difference, use Reception first</li> <li>Prevention: Verify phase compatibility</li> </ul>"},{"location":"user-guide/OPERATORS_GUIDE/#bifurcation-occurs-unexpectedly","title":"Bifurcation occurs unexpectedly","text":"<ul> <li>Likely cause: Excessive \u0394NFR from Dissonance</li> <li>Solution: Reduce dissonance intensity, apply Coherence</li> <li>Prevention: Monitor |\u0394NFR| carefully</li> </ul> <p>See Troubleshooting Guide for more.</p>"},{"location":"user-guide/OPERATORS_GUIDE/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user-guide/OPERATORS_GUIDE/#custom-operator-composition","title":"Custom Operator Composition","text":"<pre><code>def custom_sequence(G, node):\n    \"\"\"Custom operator sequence for specific use case.\"\"\"\n    Emission()(G, node)\n    for neighbor in G.neighbors(node):\n        Coupling()(G, node, neighbor)\n    Resonance()(G, node)\n    Coherence()(G)\n</code></pre>"},{"location":"user-guide/OPERATORS_GUIDE/#conditional-operators","title":"Conditional Operators","text":"<pre><code>def adaptive_operator(G, node):\n    \"\"\"Apply operator based on current state.\"\"\"\n    C_t = total_coherence(G)\n\n    if C_t &lt; 0.3:\n        # Low coherence - stabilize\n        Coherence()(G)\n    elif C_t &gt; 0.8:\n        # High coherence - explore\n        Dissonance()(G, intensity=0.3)\n        Coherence()(G)\n    else:\n        # Moderate coherence - propagate\n        Resonance()(G, node)\n</code></pre>"},{"location":"user-guide/OPERATORS_GUIDE/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete operator API</li> <li>Glyph Sequences Guide - Canonical patterns</li> <li>Metrics Interpretation - Understanding effects</li> <li>Troubleshooting - Solving common issues</li> <li>Examples - Practical operator usage</li> </ul> <p>Next: Learn how to interpret metrics in Metrics Interpretation Guide \u2192</p>"},{"location":"user-guide/TROUBLESHOOTING/","title":"Troubleshooting Guide","text":"<p>Home \u203a Troubleshooting</p> <p>This guide helps you diagnose and solve common problems when working with TNFR networks.</p>"},{"location":"user-guide/TROUBLESHOOTING/#quick-diagnostic-checklist","title":"Quick Diagnostic Checklist","text":"<p>Use this checklist to quickly identify issues:</p> <pre><code>\u25a1 Check C(t): Is it &lt; 0.3? \u2192 Low coherence problem\n\u25a1 Check Si: Is it &lt; 0.4? \u2192 Stability problem  \n\u25a1 Check \u03bdf: Any nodes with \u03bdf \u2248 0? \u2192 Node collapse\n\u25a1 Check phase: High variance? \u2192 Synchronization problem\n\u25a1 Check |\u0394NFR|: Any &gt; 3.0? \u2192 High pressure problem\n\u25a1 Check connectivity: Disconnected components? \u2192 Topology problem\n</code></pre>"},{"location":"user-guide/TROUBLESHOOTING/#common-problems","title":"Common Problems","text":""},{"location":"user-guide/TROUBLESHOOTING/#problem-1-low-network-coherence-ct-03","title":"Problem 1: Low Network Coherence (C(t) &lt; 0.3)","text":"<p>Symptoms: - C(t) below 0.3 - Network feels \"fragmented\" - Operators have little effect</p> <p>Possible Causes: 1. Insufficient coupling between nodes 2. Phase desynchronization 3. Recent Dissonance without stabilization 4. Nodes collapsing (\u03bdf \u2192 0)</p> <p>Diagnosis: <pre><code>from tnfr.metrics import total_coherence, phase_coherence\n\nC_t = total_coherence(G)\nR = phase_coherence(G)\n\nprint(f\"C(t): {C_t:.3f}\")\nprint(f\"Phase coherence: {R:.3f}\")\nprint(f\"Nodes: {G.number_of_nodes()}, Edges: {G.number_of_edges()}\")\n\n# Check for disconnected components\nimport networkx as nx\ncomponents = list(nx.connected_components(G.to_undirected()))\nprint(f\"Connected components: {len(components)}\")\n\n# Check for collapsed nodes\ncollapsed = [n for n in G.nodes() if G.nodes[n]['nf'] &lt; 0.01]\nprint(f\"Collapsed nodes: {len(collapsed)}\")\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: Apply global Coherence <pre><code>from tnfr.operators import Coherence\n\nCoherence()(G)\nprint(f\"After Coherence: C(t) = {total_coherence(G):.3f}\")\n</code></pre></p> <p>Solution 2: Increase coupling <pre><code>from tnfr.operators import Coupling\n\n# Couple low-coherence nodes\nfor node in G.nodes():\n    neighbors = list(G.neighbors(node))\n    if len(neighbors) &lt; 3:  # Insufficient connections\n        # Find nearest nodes by phase\n        candidates = [n for n in G.nodes() if n != node and n not in neighbors]\n        if candidates:\n            nearest = min(candidates, key=lambda n: abs(G.nodes[n]['phase'] - G.nodes[node]['phase']))\n            Coupling()(G, node, nearest)\n</code></pre></p> <p>Solution 3: Revive collapsed nodes <pre><code>from tnfr.operators import Emission\n\nfor node in collapsed:\n    Emission()(G, node)\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#problem-2-low-sense-index-si-04","title":"Problem 2: Low Sense Index (Si &lt; 0.4)","text":"<p>Symptoms: - Si below 0.4 - Network unstable under changes - Bifurcations occur unexpectedly</p> <p>Possible Causes: 1. High reorganization pressure (|\u0394NFR| large) 2. High phase dispersion 3. Frequency variability too high</p> <p>Diagnosis: <pre><code>from tnfr.metrics import sense_index\n\nSi = sense_index(G)\nprint(f\"Si: {Si:.3f}\")\n\n# Check \u0394NFR distribution\ndnfr_values = [G.nodes[n].get('delta_nfr', 0) for n in G.nodes()]\nmax_dnfr = max(abs(d) for d in dnfr_values)\navg_dnfr = sum(abs(d) for d in dnfr_values) / len(dnfr_values)\n\nprint(f\"Max |\u0394NFR|: {max_dnfr:.3f}\")\nprint(f\"Avg |\u0394NFR|: {avg_dnfr:.3f}\")\n\n# Check phase variance\nimport numpy as np\nphases = [G.nodes[n]['phase'] for n in G.nodes()]\nphase_var = np.var(phases)\nprint(f\"Phase variance: {phase_var:.3f}\")\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: Reduce reorganization pressure <pre><code>from tnfr.operators import Coherence\n\n# Apply coherence to reduce \u0394NFR\nCoherence()(G)\n</code></pre></p> <p>Solution 2: Synchronize phases <pre><code>from tnfr.operators import Reception\n\n# Align phases through reception\nfor node in G.nodes():\n    Reception()(G, node)\n</code></pre></p> <p>Solution 3: Stabilize frequencies <pre><code># Reduce frequency dispersion\nnf_values = [G.nodes[n]['nf'] for n in G.nodes()]\ntarget_nf = sum(nf_values) / len(nf_values)\n\nfor node in G.nodes():\n    current_nf = G.nodes[node]['nf']\n    if abs(current_nf - target_nf) &gt; 1.0:\n        # Gradually adjust toward average\n        G.nodes[node]['nf'] = 0.7 * current_nf + 0.3 * target_nf\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#problem-3-node-collapse-f-0","title":"Problem 3: Node Collapse (\u03bdf \u2192 0)","text":"<p>Symptoms: - Individual nodes with \u03bdf \u2248 0 - Node stops responding to operators - Gradual loss of network functionality</p> <p>Possible Causes: 1. Insufficient energy/activation 2. Isolated from network 3. Excessive Silence operator 4. Natural decay without maintenance</p> <p>Diagnosis: <pre><code># Identify collapsing nodes\nthreshold = 0.1\ncollapsing = []\n\nfor node in G.nodes():\n    nf = G.nodes[node]['nf']\n    if nf &lt; threshold:\n        neighbors = list(G.neighbors(node))\n        collapsing.append((node, nf, len(neighbors)))\n\nprint(f\"Collapsing nodes: {len(collapsing)}\")\nfor node, nf, degree in collapsing:\n    print(f\"  Node {node}: \u03bdf={nf:.4f}, degree={degree}\")\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: Reactivate with Emission <pre><code>from tnfr.operators import Emission\n\nfor node, _, _ in collapsing:\n    Emission()(G, node)\n    print(f\"Revived node {node}: \u03bdf={G.nodes[node]['nf']:.3f}\")\n</code></pre></p> <p>Solution 2: Increase connectivity <pre><code>from tnfr.operators import Coupling\n\nfor node, _, degree in collapsing:\n    if degree &lt; 2:  # Isolated or barely connected\n        # Connect to active neighbors\n        active_nodes = [n for n in G.nodes() if G.nodes[n]['nf'] &gt; 1.0]\n        if active_nodes:\n            target = active_nodes[0]\n            Coupling()(G, node, target)\n</code></pre></p> <p>Solution 3: Remove if truly dead <pre><code># Only if revival fails and node is truly non-functional\ntruly_dead = [n for n in G.nodes() if G.nodes[n]['nf'] &lt; 0.001]\nif truly_dead:\n    print(f\"Removing {len(truly_dead)} dead nodes\")\n    G.remove_nodes_from(truly_dead)\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#problem-4-nodes-wont-couple","title":"Problem 4: Nodes Won't Couple","text":"<p>Symptoms: - Coupling operator has no effect - Connections don't form - Phase mismatch warnings</p> <p>Possible Causes: 1. Phase mismatch too large 2. Nodes in Silence (\u03bdf \u2248 0) 3. Invalid coupling conditions</p> <p>Diagnosis: <pre><code># Check phase compatibility\ndef check_coupling_compatibility(G, node1, node2):\n    phase1 = G.nodes[node1]['phase']\n    phase2 = G.nodes[node2]['phase']\n    nf1 = G.nodes[node1]['nf']\n    nf2 = G.nodes[node2]['nf']\n\n    phase_diff = abs(phase1 - phase2)\n\n    print(f\"Node {node1}: \u03c6={phase1:.3f}, \u03bdf={nf1:.3f}\")\n    print(f\"Node {node2}: \u03c6={phase2:.3f}, \u03bdf={nf2:.3f}\")\n    print(f\"Phase difference: {phase_diff:.3f} rad\")\n\n    if phase_diff &gt; 1.5:\n        print(\"\u26a0\ufe0f Phase mismatch too large\")\n    if nf1 &lt; 0.1 or nf2 &lt; 0.1:\n        print(\"\u26a0\ufe0f One or both nodes inactive\")\n\ncheck_coupling_compatibility(G, node1, node2)\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: Align phases first <pre><code>from tnfr.operators import Reception\n\n# Use Reception to align phases\nReception()(G, node1)\nReception()(G, node2)\n\n# Then couple\nfrom tnfr.operators import Coupling\nCoupling()(G, node1, node2)\n</code></pre></p> <p>Solution 2: Activate silent nodes <pre><code>from tnfr.operators import Emission\n\n# Reactivate if in Silence\nif G.nodes[node1]['nf'] &lt; 0.1:\n    Emission()(G, node1)\nif G.nodes[node2]['nf'] &lt; 0.1:\n    Emission()(G, node2)\n\n# Then couple\nCoupling()(G, node1, node2)\n</code></pre></p> <p>Solution 3: Use Resonance for indirect coupling <pre><code>from tnfr.operators import Resonance\n\n# Propagate pattern from one to the other\nResonance()(G, node1, radius=2)\n# This may create indirect pathway\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#problem-5-unexpected-bifurcation","title":"Problem 5: Unexpected Bifurcation","text":"<p>Symptoms: - Network suddenly fragments - New patterns emerge unexpectedly - \u2202\u00b2EPI/\u2202t\u00b2 &gt; threshold</p> <p>Possible Causes: 1. Excessive Dissonance 2. |\u0394NFR| too large 3. Phase transition threshold crossed 4. Legitimate self-organization</p> <p>Diagnosis: <pre><code># Check if bifurcation was triggered\ndef check_bifurcation_risk(G):\n    risks = []\n\n    for node in G.nodes():\n        dnfr = G.nodes[node].get('delta_nfr', 0)\n        nf = G.nodes[node]['nf']\n\n        # High reorganization rate\n        reorg_rate = nf * abs(dnfr)\n\n        if reorg_rate &gt; 5.0:\n            risks.append((node, reorg_rate, dnfr, nf))\n\n    if risks:\n        print(f\"\u26a0\ufe0f {len(risks)} nodes at bifurcation risk:\")\n        for node, rate, dnfr, nf in risks:\n            print(f\"  Node {node}: rate={rate:.2f}, \u0394NFR={dnfr:+.2f}, \u03bdf={nf:.2f}\")\n    else:\n        print(\"\u2713 No bifurcation risk detected\")\n\n    return risks\n\ncheck_bifurcation_risk(G)\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: If unwanted, stabilize immediately <pre><code>from tnfr.operators import Coherence\n\n# Emergency stabilization\nCoherence()(G)\nCoherence()(G)  # Apply twice for strong effect\n</code></pre></p> <p>Solution 2: Reduce Dissonance intensity <pre><code># If using Dissonance, reduce intensity\nfrom tnfr.operators import Dissonance\n\n# Instead of:\n# Dissonance()(G, intensity=1.0)\n\n# Use:\nDissonance()(G, intensity=0.3)\nCoherence()(G)  # Always follow with Coherence\n</code></pre></p> <p>Solution 3: If legitimate, accept and observe <pre><code># If bifurcation is desired (exploration, self-organization)\nfrom tnfr.operators import SelfOrganization\n\n# Allow system to self-organize\nSelfOrganization()(G)\n\n# Monitor new structure\nprint(f\"New C(t): {total_coherence(G):.3f}\")\nprint(f\"New Si: {sense_index(G):.3f}\")\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#problem-6-slow-performance","title":"Problem 6: Slow Performance","text":"<p>Symptoms: - Operations take long time - Large networks sluggish - Memory usage high</p> <p>Possible Causes: 1. Using NumPy backend on large networks 2. Dense connectivity (O(N\u00b2) edges) 3. Inefficient operator sequences 4. No caching enabled</p> <p>Diagnosis: <pre><code>import time\nimport tnfr\n\n# Check network size\nprint(f\"Nodes: {G.number_of_nodes()}\")\nprint(f\"Edges: {G.number_of_edges()}\")\ndensity = G.number_of_edges() / (G.number_of_nodes() * (G.number_of_nodes() - 1) / 2)\nprint(f\"Density: {density:.3f}\")\n\n# Check backend\nprint(f\"Backend: {tnfr.get_backend()}\")\n\n# Time an operation\nstart = time.time()\nfrom tnfr.operators import Coherence\nCoherence()(G)\nelapsed = time.time() - start\nprint(f\"Coherence took: {elapsed:.3f}s\")\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: Use JAX backend for GPU acceleration <pre><code># Install JAX\npip install tnfr[compute-jax]\n</code></pre></p> <pre><code>import tnfr\n\n# Switch to JAX backend\ntnfr.set_backend('jax')\nprint(f\"Using backend: {tnfr.get_backend()}\")\n</code></pre> <p>Solution 2: Reduce network density <pre><code># Remove weak couplings\nedges_to_remove = []\nfor u, v in G.edges():\n    strength = G[u][v].get('coupling', 1.0)\n    if strength &lt; 0.1:  # Weak coupling threshold\n        edges_to_remove.append((u, v))\n\nprint(f\"Removing {len(edges_to_remove)} weak edges\")\nG.remove_edges_from(edges_to_remove)\n</code></pre></p> <p>Solution 3: Enable caching <pre><code># Install caching support\npip install tnfr[orjson]\n</code></pre></p> <p>Solution 4: Use sparse networks <pre><code># When creating networks, keep connectivity low\nG = tnfr.create_network(nodes=1000, connectivity=0.05)  # 5% connectivity\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#problem-7-operators-have-no-effect","title":"Problem 7: Operators Have No Effect","text":"<p>Symptoms: - Applying operators doesn't change metrics - Network appears \"frozen\" - C(t), Si remain constant</p> <p>Possible Causes: 1. All nodes in Silence 2. Over-stabilized network (C(t) \u2248 1.0) 3. Disconnected network 4. Bug in operator application</p> <p>Diagnosis: <pre><code># Check if nodes are active\nactive_count = sum(1 for n in G.nodes() if G.nodes[n]['nf'] &gt; 0.1)\nprint(f\"Active nodes: {active_count}/{G.number_of_nodes()}\")\n\n# Check coherence\nC_t = total_coherence(G)\nprint(f\"C(t): {C_t:.3f}\")\n\n# Check connectivity\nimport networkx as nx\nis_connected = nx.is_connected(G.to_undirected())\nprint(f\"Connected: {is_connected}\")\n\n# Try operator and measure\nC_before = total_coherence(G)\nfrom tnfr.operators import Emission\nEmission()(G, list(G.nodes())[0])\nC_after = total_coherence(G)\nprint(f\"C(t) change: {C_before:.3f} \u2192 {C_after:.3f}\")\n</code></pre></p> <p>Solutions:</p> <p>Solution 1: Wake up frozen network <pre><code>from tnfr.operators import Emission, Dissonance\n\n# Reactivate all nodes\nfor node in G.nodes():\n    if G.nodes[node]['nf'] &lt; 0.1:\n        Emission()(G, node)\n\n# Introduce some exploration\nDissonance()(G, intensity=0.3)\n</code></pre></p> <p>Solution 2: If over-stabilized, introduce Dissonance <pre><code>from tnfr.operators import Dissonance\n\n# Shake up over-stable network\nif total_coherence(G) &gt; 0.9:\n    Dissonance()(G, intensity=0.5)\n</code></pre></p> <p>Solution 3: Reconnect network <pre><code>from tnfr.operators import Coupling\nimport networkx as nx\n\n# Find disconnected components\ncomponents = list(nx.connected_components(G.to_undirected()))\nif len(components) &gt; 1:\n    print(f\"Found {len(components)} disconnected components\")\n\n    # Connect components\n    for i in range(len(components) - 1):\n        node1 = list(components[i])[0]\n        node2 = list(components[i+1])[0]\n        Coupling()(G, node1, node2)\n</code></pre></p>"},{"location":"user-guide/TROUBLESHOOTING/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"user-guide/TROUBLESHOOTING/#enable-telemetry","title":"Enable Telemetry","text":"<pre><code>from tnfr.telemetry import enable_tracing, get_trace\n\n# Enable detailed logging\nenable_tracing()\n\n# Apply operators\nfrom tnfr.operators import Coherence\nCoherence()(G)\n\n# Review what happened\nfor event in get_trace():\n    print(f\"{event['time']}: {event['operator']} on {event['node']}\")\n    print(f\"  Effect: {event['effect']}\")\n</code></pre>"},{"location":"user-guide/TROUBLESHOOTING/#validate-network","title":"Validate Network","text":"<pre><code>from tnfr.validation import validate_network\n\n# Check for structural problems\nissues = validate_network(G)\n\nif issues:\n    print(f\"Found {len(issues)} issues:\")\n    for issue in issues:\n        print(f\"  {issue['type']}: {issue['description']}\")\nelse:\n    print(\"\u2713 Network structure valid\")\n</code></pre>"},{"location":"user-guide/TROUBLESHOOTING/#step-by-step-execution","title":"Step-by-Step Execution","text":"<pre><code>from tnfr.metrics import total_coherence, sense_index\n\ndef debug_operator_sequence(G, operators):\n    \"\"\"Execute operators one at a time with diagnostics.\"\"\"\n    for i, op in enumerate(operators):\n        print(f\"\\n=== Step {i+1}: {op.__class__.__name__} ===\")\n\n        # Before\n        C_before = total_coherence(G)\n        Si_before = sense_index(G)\n\n        # Apply\n        op(G)\n\n        # After\n        C_after = total_coherence(G)\n        Si_after = sense_index(G)\n\n        # Report\n        print(f\"C(t): {C_before:.3f} \u2192 {C_after:.3f} ({C_after-C_before:+.3f})\")\n        print(f\"Si:   {Si_before:.3f} \u2192 {Si_after:.3f} ({Si_after-Si_before:+.3f})\")\n</code></pre>"},{"location":"user-guide/TROUBLESHOOTING/#snapshot-comparison","title":"Snapshot Comparison","text":"<pre><code>import copy\n\n# Take snapshot before operation\nG_before = copy.deepcopy(G)\n\n# Apply operators\nfrom tnfr.operators import Dissonance, Coherence\nDissonance()(G, intensity=0.5)\nCoherence()(G)\n\n# Compare snapshots\nprint(\"Node-by-node changes:\")\nfor node in G.nodes():\n    nf_before = G_before.nodes[node]['nf']\n    nf_after = G.nodes[node]['nf']\n    if abs(nf_after - nf_before) &gt; 0.1:\n        print(f\"  Node {node}: \u03bdf {nf_before:.3f} \u2192 {nf_after:.3f}\")\n</code></pre>"},{"location":"user-guide/TROUBLESHOOTING/#getting-more-help","title":"Getting More Help","text":"<p>If these solutions don't resolve your issue:</p> <ol> <li>Check the FAQ: FAQ</li> <li>Review Examples: Examples</li> <li>API Documentation: API Reference</li> <li>Open an Issue: GitHub Issues</li> </ol> <p>When reporting issues, include: - TNFR version: <code>python -c \"import tnfr; print(tnfr.__version__)\"</code> - Network size and topology - Operator sequence applied - Metrics before/after - Full error message (if any)</p>"},{"location":"user-guide/TROUBLESHOOTING/#see-also","title":"See Also","text":"<ul> <li>Operators Guide - Understanding operator effects</li> <li>Metrics Interpretation - Reading network health</li> <li>FAQ - Common questions</li> <li>API Reference - Complete API documentation</li> </ul> <p>Still stuck? Open an issue on GitHub with details about your problem.</p>"}]}